searchNodes=[{"doc":"Core Erlang abstract syntax trees. This module defines an abstract data type for representing Core Erlang source code as syntax trees. A recommended starting point for the first-time user is the documentation of the function type/1 . NOTES: This module deals with the composition and decomposition of syntactic entities (as opposed to semantic ones); its purpose is to hide all direct references to the data structures used to represent these entities. With few exceptions, the functions in this module perform no semantic interpretation of their inputs, and in general, the user is assumed to pass type-correct arguments - if this is not done, the effects are not defined. Currently, the internal data structure used is the same as the record-based data structures used traditionally in the Beam compiler. The internal representations of abstract syntax trees are subject to change without notice, and should not be documented outside this module. Furthermore, we do not give any guarantees on how an abstract syntax tree may or may not be represented, with the following exceptions : no syntax tree is represented by a single atom, such as none , by a list constructor [X | Y] , or by the empty list [] . This can be relied on when writing functions that operate on syntax trees. DATA TYPES c_alias() = #c_alias{} c_apply() = #c_apply{} c_binary() = #c_binary{} c_bitstr() = #c_bitstr{} c_call() = #c_call{} c_case() = #c_case{} c_catch() = #c_catch{} c_clause() = #c_clause{} c_cons() = #c_cons{} c_fun() = #c_fun{} c_lct() = c_literal() | c_cons() | c_tuple() c_let() = #c_let{} c_letrec() = #c_letrec{} c_literal() = #c_literal{} c_map() = #c_map{} c_map_pair() = #c_map_pair{} c_module() = #c_module{} c_primop() = #c_primop{} c_receive() = #c_receive{} c_seq() = #c_seq{} c_try() = #c_try{} c_tuple() = #c_tuple{} c_values() = #c_values{} c_var() = #c_var{} cerl() = c_alias() | c_apply() | c_binary() | c_bitstr() | c_call() | c_case() | c_catch() | c_clause() | c_cons() | c_fun() | c_let() | c_letrec() | c_literal() | c_map() | c_map_pair() | c_module() | c_primop() | c_receive() | c_seq() | c_try() | c_tuple() | c_values() | c_var() ctype() = alias | apply | binary | bitstr | call | case | catch | clause | cons | fun | let | letrec | literal | map | map_pair | module | primop | receive | seq | try | tuple | values | var dtype() = cons | tuple | {atomic, value() } map_op() = #c_literal{val=assoc} | #c_literal{val=exact} value() = integer() | float() | atom() | [] var_name() = integer() | atom() | {atom(), integer()}","ref":"cerl.html","title":"cerl","type":"module"},{"doc":"Creates a syntax tree corresponding to an Erlang term. Term must be a literal term, i.e., one that can be represented as a source code literal. Thus, it may not contain a process identifier, port, reference, binary or function value as a subterm. Note: This is a constant time operation. See also: ann_abstract/2 , concrete/1 , is_literal/1 , is_literal_term/1 .","ref":"cerl.html#abstract/1","title":"cerl.abstract/1","type":"function"},{"doc":"Appends Annotations to the list of user annotations of Node . Note: this is equivalent to set_ann(Node, Annotations ++ get_ann(Node)) , but potentially more efficient. See also: get_ann/1 , set_ann/2 .","ref":"cerl.html#add_ann/2","title":"cerl.add_ann/2","type":"function"},{"doc":"Returns the pattern subtree of an abstract pattern alias. See also: c_alias/2 .","ref":"cerl.html#alias_pat/1","title":"cerl.alias_pat/1","type":"function"},{"doc":"Returns the variable subtree of an abstract pattern alias. See also: c_alias/2 .","ref":"cerl.html#alias_var/1","title":"cerl.alias_var/1","type":"function"},{"doc":"See also: abstract/1 .","ref":"cerl.html#ann_abstract/2","title":"cerl.ann_abstract/2","type":"function"},{"doc":"See also: c_alias/2 .","ref":"cerl.html#ann_c_alias/3","title":"cerl.ann_c_alias/3","type":"function"},{"doc":"See also: c_apply/2 .","ref":"cerl.html#ann_c_apply/3","title":"cerl.ann_c_apply/3","type":"function"},{"doc":"See also: c_atom/1 .","ref":"cerl.html#ann_c_atom/2","title":"cerl.ann_c_atom/2","type":"function"},{"doc":"See also: c_binary/1 .","ref":"cerl.html#ann_c_binary/2","title":"cerl.ann_c_binary/2","type":"function"},{"doc":"Equivalent to ann_c_bitstr(As, Value, Size, abstract(1), Type, Flags) .","ref":"cerl.html#ann_c_bitstr/5","title":"cerl.ann_c_bitstr/5","type":"function"},{"doc":"See also: ann_c_bitstr/5 , c_bitstr/5 .","ref":"cerl.html#ann_c_bitstr/6","title":"cerl.ann_c_bitstr/6","type":"function"},{"doc":"See also: c_call/3 .","ref":"cerl.html#ann_c_call/4","title":"cerl.ann_c_call/4","type":"function"},{"doc":"See also: c_case/2 .","ref":"cerl.html#ann_c_case/3","title":"cerl.ann_c_case/3","type":"function"},{"doc":"See also: c_catch/1 .","ref":"cerl.html#ann_c_catch/2","title":"cerl.ann_c_catch/2","type":"function"},{"doc":"See also: c_char/1 .","ref":"cerl.html#ann_c_char/2","title":"cerl.ann_c_char/2","type":"function"},{"doc":"Equivalent to ann_c_clause(As, Patterns, c_atom(true), Body) . See also: c_clause/3 .","ref":"cerl.html#ann_c_clause/3","title":"cerl.ann_c_clause/3","type":"function"},{"doc":"See also: ann_c_clause/3 , c_clause/3 .","ref":"cerl.html#ann_c_clause/4","title":"cerl.ann_c_clause/4","type":"function"},{"doc":"See also: c_cons/2 .","ref":"cerl.html#ann_c_cons/3","title":"cerl.ann_c_cons/3","type":"function"},{"doc":"See also: c_cons_skel/2 .","ref":"cerl.html#ann_c_cons_skel/3","title":"cerl.ann_c_cons_skel/3","type":"function"},{"doc":"See also: c_float/1 .","ref":"cerl.html#ann_c_float/2","title":"cerl.ann_c_float/2","type":"function"},{"doc":"Equivalent to ann_c_var(As, {Atom, Arity}) . See also: c_fname/2 .","ref":"cerl.html#ann_c_fname/3","title":"cerl.ann_c_fname/3","type":"function"},{"doc":"See also: c_fun/2 .","ref":"cerl.html#ann_c_fun/3","title":"cerl.ann_c_fun/3","type":"function"},{"doc":"See also: c_int/1 .","ref":"cerl.html#ann_c_int/2","title":"cerl.ann_c_int/2","type":"function"},{"doc":"See also: c_let/3 .","ref":"cerl.html#ann_c_let/4","title":"cerl.ann_c_let/4","type":"function"},{"doc":"See also: c_letrec/2 .","ref":"cerl.html#ann_c_letrec/3","title":"cerl.ann_c_letrec/3","type":"function"},{"doc":"","ref":"cerl.html#ann_c_map/2","title":"cerl.ann_c_map/2","type":"function"},{"doc":"","ref":"cerl.html#ann_c_map/3","title":"cerl.ann_c_map/3","type":"function"},{"doc":"","ref":"cerl.html#ann_c_map_pair/4","title":"cerl.ann_c_map_pair/4","type":"function"},{"doc":"","ref":"cerl.html#ann_c_map_pattern/2","title":"cerl.ann_c_map_pattern/2","type":"function"},{"doc":"See also: ann_c_module/5 , c_module/3 .","ref":"cerl.html#ann_c_module/4","title":"cerl.ann_c_module/4","type":"function"},{"doc":"See also: ann_c_module/4 , c_module/4 .","ref":"cerl.html#ann_c_module/5","title":"cerl.ann_c_module/5","type":"function"},{"doc":"See also: c_nil/0 .","ref":"cerl.html#ann_c_nil/1","title":"cerl.ann_c_nil/1","type":"function"},{"doc":"See also: c_primop/2 .","ref":"cerl.html#ann_c_primop/3","title":"cerl.ann_c_primop/3","type":"function"},{"doc":"Equivalent to ann_c_receive(As, Clauses, c_atom(infinity), c_atom(true)) . See also: c_atom/1 , c_receive/3 .","ref":"cerl.html#ann_c_receive/2","title":"cerl.ann_c_receive/2","type":"function"},{"doc":"See also: ann_c_receive/2 , c_receive/3 .","ref":"cerl.html#ann_c_receive/4","title":"cerl.ann_c_receive/4","type":"function"},{"doc":"See also: c_seq/2 .","ref":"cerl.html#ann_c_seq/3","title":"cerl.ann_c_seq/3","type":"function"},{"doc":"See also: c_string/1 .","ref":"cerl.html#ann_c_string/2","title":"cerl.ann_c_string/2","type":"function"},{"doc":"See also: c_try/5 .","ref":"cerl.html#ann_c_try/6","title":"cerl.ann_c_try/6","type":"function"},{"doc":"See also: c_tuple/1 .","ref":"cerl.html#ann_c_tuple/2","title":"cerl.ann_c_tuple/2","type":"function"},{"doc":"See also: c_tuple_skel/1 .","ref":"cerl.html#ann_c_tuple_skel/2","title":"cerl.ann_c_tuple_skel/2","type":"function"},{"doc":"See also: c_values/1 .","ref":"cerl.html#ann_c_values/2","title":"cerl.ann_c_values/2","type":"function"},{"doc":"See also: c_var/1 .","ref":"cerl.html#ann_c_var/2","title":"cerl.ann_c_var/2","type":"function"},{"doc":"See also: make_data/2 .","ref":"cerl.html#ann_make_data/3","title":"cerl.ann_make_data/3","type":"function"},{"doc":"See also: make_data_skel/2 .","ref":"cerl.html#ann_make_data_skel/3","title":"cerl.ann_make_data_skel/3","type":"function"},{"doc":"Equivalent to ann_make_list(As, List, none) .","ref":"cerl.html#ann_make_list/2","title":"cerl.ann_make_list/2","type":"function"},{"doc":"See also: ann_make_list/2 , make_list/2 .","ref":"cerl.html#ann_make_list/3","title":"cerl.ann_make_list/3","type":"function"},{"doc":"Creates a syntax tree with the given annotations, type and subtrees. See make_tree/2 for details. See also: make_tree/2 .","ref":"cerl.html#ann_make_tree/3","title":"cerl.ann_make_tree/3","type":"function"},{"doc":"Returns the list of argument subtrees of an abstract function application. See also: apply_arity/1 , c_apply/2 .","ref":"cerl.html#apply_args/1","title":"cerl.apply_args/1","type":"function"},{"doc":"Returns the number of argument subtrees of an abstract function application. Note: this is equivalent to length(apply_args(Node)) , but potentially more efficient. See also: apply_args/1 , c_apply/2 .","ref":"cerl.html#apply_arity/1","title":"cerl.apply_arity/1","type":"function"},{"doc":"Returns the operator subtree of an abstract function application. See also: c_apply/2 .","ref":"cerl.html#apply_op/1","title":"cerl.apply_op/1","type":"function"},{"doc":"Returns the literal string represented by an abstract atom. This always includes surrounding single-quote characters. Note that an abstract atom may have several literal representations, and that the representation yielded by this function is not fixed; e.g., atom_lit(c_atom(&quot;a\\012b&quot;)) could yield the string &quot;\\'a\\\\nb\\'&quot; . See also: c_atom/1 .","ref":"cerl.html#atom_lit/1","title":"cerl.atom_lit/1","type":"function"},{"doc":"Returns the printname of an abstract atom. See also: c_atom/1 .","ref":"cerl.html#atom_name/1","title":"cerl.atom_name/1","type":"function"},{"doc":"Returns the value represented by an abstract atom. See also: c_atom/1 .","ref":"cerl.html#atom_val/1","title":"cerl.atom_val/1","type":"function"},{"doc":"Returns the list of segment subtrees of an abstract binary-template. See also: c_binary/1 , c_bitstr/5 .","ref":"cerl.html#binary_segments/1","title":"cerl.binary_segments/1","type":"function"},{"doc":"Returns the total size in bits of an abstract bit-string template. If the size field is an integer literal, the result is the product of the size and unit values; if the size field is the atom literal all , the atom all is returned. If the size is not a literal, the atom any is returned. See also: c_bitstr/5 .","ref":"cerl.html#bitstr_bitsize/1","title":"cerl.bitstr_bitsize/1","type":"function"},{"doc":"Returns the flags subtree of an abstract bit-string template. See also: c_bitstr/5 .","ref":"cerl.html#bitstr_flags/1","title":"cerl.bitstr_flags/1","type":"function"},{"doc":"Returns the size subtree of an abstract bit-string template. See also: c_bitstr/5 .","ref":"cerl.html#bitstr_size/1","title":"cerl.bitstr_size/1","type":"function"},{"doc":"Returns the type subtree of an abstract bit-string template. See also: c_bitstr/5 .","ref":"cerl.html#bitstr_type/1","title":"cerl.bitstr_type/1","type":"function"},{"doc":"Returns the unit subtree of an abstract bit-string template. See also: c_bitstr/5 .","ref":"cerl.html#bitstr_unit/1","title":"cerl.bitstr_unit/1","type":"function"},{"doc":"Returns the value subtree of an abstract bit-string template. See also: c_bitstr/5 .","ref":"cerl.html#bitstr_val/1","title":"cerl.bitstr_val/1","type":"function"},{"doc":"Creates an abstract pattern alias. The result represents &quot; Variable = Pattern &quot;. See also: alias_pat/1 , alias_var/1 , ann_c_alias/3 , c_clause/3 , is_c_alias/1 , update_c_alias/3 .","ref":"cerl.html#c_alias/2","title":"cerl.c_alias/2","type":"function"},{"doc":"Creates an abstract function application. If Arguments is [A1, ..., An] , the result represents &quot; apply Operator(A1, ..., An) &quot;. See also: ann_c_apply/3 , apply_args/1 , apply_arity/1 , apply_op/1 , c_call/3 , c_primop/2 , is_c_apply/1 , update_c_apply/3 .","ref":"cerl.html#c_apply/2","title":"cerl.c_apply/2","type":"function"},{"doc":"Creates an abstract atom literal. The print name of the atom is the character sequence represented by Name . Note: passing a string as argument to this function causes a corresponding atom to be created for the internal representation. See also: ann_c_atom/2 , atom_lit/1 , atom_name/1 , atom_val/1 , is_c_atom/1 .","ref":"cerl.html#c_atom/1","title":"cerl.c_atom/1","type":"function"},{"doc":"Creates an abstract binary-template. A binary object is in this context a sequence of an arbitrary number of bits. (The number of bits used to be evenly divisible by 8, but after the introduction of bit strings in the Erlang language, the choice was made to use the binary template for all bit strings.) It is specified by zero or more bit-string template segments of arbitrary lengths (in number of bits). If Segments is [S1, ..., Sn] , the result represents &quot; \#{S1, ..., Sn}# &quot;. All the Si must have type bitstr . See also: ann_c_binary/2 , binary_segments/1 , c_bitstr/5 , is_c_binary/1 , update_c_binary/2 .","ref":"cerl.html#c_binary/1","title":"cerl.c_binary/1","type":"function"},{"doc":"Equivalent to c_bitstr(Value, abstract(all), abstract(1), Type, Flags) .","ref":"cerl.html#c_bitstr/3","title":"cerl.c_bitstr/3","type":"function"},{"doc":"Equivalent to c_bitstr(Value, Size, abstract(1), Type, Flags) .","ref":"cerl.html#c_bitstr/4","title":"cerl.c_bitstr/4","type":"function"},{"doc":"Creates an abstract bit-string template. These can only occur as components of an abstract binary-template (see c_binary/1 ). The result represents &quot; #&lt;Value&gt;(Size, Unit, Type, Flags) &quot;, where Unit must represent a positive integer constant, Type must represent a constant atom (one of 'integer' , 'float' , or 'binary' ), and Flags must represent a constant list &quot;[F1, ..., Fn]&quot; where all the Fi are atoms. See also: ann_c_bitstr/6 , bitstr_flags/1 , bitstr_size/1 , bitstr_type/1 , bitstr_unit/1 , bitstr_val/1 , c_binary/1 , is_c_bitstr/1 , update_c_bitstr/6 .","ref":"cerl.html#c_bitstr/5","title":"cerl.c_bitstr/5","type":"function"},{"doc":"Creates an abstract inter-module call. If Arguments is [A1, ..., An] , the result represents &quot; call Module:Name(A1, ..., An) &quot;. See also: ann_c_call/4 , c_apply/2 , c_primop/2 , call_args/1 , call_arity/1 , call_module/1 , call_name/1 , is_c_call/1 , update_c_call/4 .","ref":"cerl.html#c_call/3","title":"cerl.c_call/3","type":"function"},{"doc":"Creates an abstract case-expression. If Clauses is [C1, ..., Cn] , the result represents &quot; case Argument of C1 ... Cn end &quot;. Clauses must not be empty. See also: ann_c_case/3 , c_clause/3 , case_arg/1 , case_arity/1 , case_clauses/1 , is_c_case/1 , update_c_case/3 .","ref":"cerl.html#c_case/2","title":"cerl.c_case/2","type":"function"},{"doc":"Creates an abstract catch-expression. The result represents &quot; catch Body &quot;. Note: catch-expressions can be rewritten as try-expressions, and will eventually be removed from Core Erlang. See also: ann_c_catch/2 , c_try/5 , catch_body/1 , is_c_catch/1 , update_c_catch/2 .","ref":"cerl.html#c_catch/1","title":"cerl.c_catch/1","type":"function"},{"doc":"Creates an abstract character literal. If the local implementation of Erlang defines char() as a subset of integer() , this function is equivalent to c_int/1 . Otherwise, if the given value is an integer, it will be converted to the character with the corresponding code. The lexical representation of a character is &quot; $Char &quot;, where Char is a single printing character or an escape sequence. See also: ann_c_char/2 , c_int/1 , c_string/1 , char_lit/1 , char_val/1 , is_c_char/1 , is_print_char/1 .","ref":"cerl.html#c_char/1","title":"cerl.c_char/1","type":"function"},{"doc":"Equivalent to c_clause(Patterns, c_atom(true), Body) . See also: c_atom/1 .","ref":"cerl.html#c_clause/2","title":"cerl.c_clause/2","type":"function"},{"doc":"Creates an an abstract clause. If Patterns is [P1, ..., Pn] , the result represents &quot; &lt;P1, ..., Pn&gt; when Guard -&gt; Body &quot;. See also: ann_c_clause/4 , c_case/2 , c_clause/2 , c_receive/3 , clause_arity/1 , clause_body/1 , clause_guard/1 , clause_pats/1 , clause_vars/1 , is_c_clause/1 , update_c_clause/4 .","ref":"cerl.html#c_clause/3","title":"cerl.c_clause/3","type":"function"},{"doc":"Creates an abstract list constructor. The result represents &quot; [Head | Tail] &quot;. Note that if both Head and Tail have type literal , then the result will also have type literal , and annotations on Head and Tail are lost. Recall that in Erlang, the tail element of a list constructor is not necessarily a list. See also: ann_c_cons/3 , c_cons_skel/2 , c_nil/0 , cons_hd/1 , cons_tl/1 , is_c_cons/1 , is_c_list/1 , list_elements/1 , list_length/1 , make_list/2 , update_c_cons/3 .","ref":"cerl.html#c_cons/2","title":"cerl.c_cons/2","type":"function"},{"doc":"Creates an abstract list constructor skeleton. Does not fold constant literals, i.e., the result always has type cons , representing &quot; [Head | Tail] &quot;. This function is occasionally useful when it is necessary to have annotations on the subnodes of a list constructor node, even when the subnodes are constant literals. Note however that is_literal/1 will yield false and concrete/1 will fail if passed the result from this function. fold_literal/1 can be used to revert a node to the normal-form representation. See also: ann_c_cons_skel/3 , c_cons/2 , c_nil/0 , concrete/1 , fold_literal/1 , is_c_cons/1 , is_c_list/1 , is_literal/1 , update_c_cons_skel/3 .","ref":"cerl.html#c_cons_skel/2","title":"cerl.c_cons_skel/2","type":"function"},{"doc":"Creates an abstract floating-point literal. The lexical representation is the decimal floating-point numeral of Value . See also: ann_c_float/2 , float_lit/1 , float_val/1 , is_c_float/1 .","ref":"cerl.html#c_float/1","title":"cerl.c_float/1","type":"function"},{"doc":"Equivalent to c_var({Name, Arity}) . See also: ann_c_fname/3 , fname_arity/1 , fname_id/1 , is_c_fname/1 , update_c_fname/3 .","ref":"cerl.html#c_fname/2","title":"cerl.c_fname/2","type":"function"},{"doc":"Creates an abstract fun-expression. If Variables is [V1, ..., Vn] , the result represents &quot; fun (V1, ..., Vn) -&gt; Body &quot;. All the Vi must have type var . See also: ann_c_fun/3 , fun_arity/1 , fun_body/1 , fun_vars/1 , is_c_fun/1 , update_c_fun/3 .","ref":"cerl.html#c_fun/2","title":"cerl.c_fun/2","type":"function"},{"doc":"Creates an abstract integer literal. The lexical representation is the canonical decimal numeral of Value . See also: ann_c_int/2 , c_char/1 , int_lit/1 , int_val/1 , is_c_int/1 .","ref":"cerl.html#c_int/1","title":"cerl.c_int/1","type":"function"},{"doc":"Creates an abstract let-expression. If Variables is [V1, ..., Vn] , the result represents &quot; let &lt;V1, ..., Vn&gt; = Argument in Body &quot;. All the Vi must have type var . See also: ann_c_let/4 , is_c_let/1 , let_arg/1 , let_arity/1 , let_body/1 , let_vars/1 , update_c_let/4 .","ref":"cerl.html#c_let/3","title":"cerl.c_let/3","type":"function"},{"doc":"Creates an abstract letrec-expression. If Definitions is [{V1, F1}, ..., {Vn, Fn}] , the result represents &quot; letrec V1 = F1 ... Vn = Fn in Body . All the Vi must have type var and represent function names. All the Fi must have type 'fun' . See also: ann_c_letrec/3 , is_c_letrec/1 , letrec_body/1 , letrec_defs/1 , letrec_vars/1 , update_c_letrec/3 .","ref":"cerl.html#c_letrec/2","title":"cerl.c_letrec/2","type":"function"},{"doc":"","ref":"cerl.html#c_map/1","title":"cerl.c_map/1","type":"function"},{"doc":"","ref":"cerl.html#c_map_pair/2","title":"cerl.c_map_pair/2","type":"function"},{"doc":"","ref":"cerl.html#c_map_pair_exact/2","title":"cerl.c_map_pair_exact/2","type":"function"},{"doc":"","ref":"cerl.html#c_map_pattern/1","title":"cerl.c_map_pattern/1","type":"function"},{"doc":"Equivalent to c_module(Name, Exports, [], Definitions) .","ref":"cerl.html#c_module/3","title":"cerl.c_module/3","type":"function"},{"doc":"Creates an abstract module definition. The result represents module Name [ E1 , . . . , Ek ] attributes [ K1 = T1 , . . . , Km = Tm ] V1 = F1 . . . Vn = Fn end if Exports = [E1, ..., Ek] , Attributes = [{K1, T1}, ..., {Km, Tm}] , and Definitions = [{V1, F1}, ..., {Vn, Fn}] . Name and all the Ki must be atom literals, and all the Ti must be constant literals. All the Vi and Ei must have type var and represent function names. All the Fi must have type 'fun' . See also: ann_c_module/4 , ann_c_module/5 , c_atom/1 , c_fun/2 , c_module/3 , c_var/1 , is_literal/1 , module_attrs/1 , module_defs/1 , module_exports/1 , module_name/1 , module_vars/1 , update_c_module/5 .","ref":"cerl.html#c_module/4","title":"cerl.c_module/4","type":"function"},{"doc":"Creates an abstract empty list. The result represents &quot; [] &quot;. The empty list is traditionally called &quot;nil&quot;. See also: ann_c_nil/1 , c_cons/2 , is_c_list/1 .","ref":"cerl.html#c_nil/0","title":"cerl.c_nil/0","type":"function"},{"doc":"Creates an abstract primitive operation call. If Arguments is [A1, ..., An] , the result represents &quot; primop Name(A1, ..., An) &quot;. Name must be an atom literal. See also: ann_c_primop/3 , c_apply/2 , c_call/3 , is_c_primop/1 , primop_args/1 , primop_arity/1 , primop_name/1 , update_c_primop/3 .","ref":"cerl.html#c_primop/2","title":"cerl.c_primop/2","type":"function"},{"doc":"Equivalent to c_receive(Clauses, c_atom(infinity), c_atom(true)) . See also: c_atom/1 .","ref":"cerl.html#c_receive/1","title":"cerl.c_receive/1","type":"function"},{"doc":"Creates an abstract receive-expression. If Clauses is [C1, ..., Cn] , the result represents &quot; receive C1 ... Cn after Timeout -&gt; Action end &quot;. See also: ann_c_receive/4 , c_receive/1 , is_c_receive/1 , receive_action/1 , receive_clauses/1 , receive_timeout/1 , update_c_receive/4 .","ref":"cerl.html#c_receive/3","title":"cerl.c_receive/3","type":"function"},{"doc":"Creates an abstract sequencing expression. The result represents &quot; do Argument Body &quot;. See also: ann_c_seq/3 , is_c_seq/1 , seq_arg/1 , seq_body/1 , update_c_seq/3 .","ref":"cerl.html#c_seq/2","title":"cerl.c_seq/2","type":"function"},{"doc":"Creates an abstract string literal. Equivalent to creating an abstract list of the corresponding character literals (cf. is_c_string/1 ), but is typically more efficient. The lexical representation of a string is &quot; &quot;Chars&quot; &quot;, where Chars is a sequence of printing characters or spaces. See also: ann_c_string/2 , c_char/1 , is_c_string/1 , is_print_string/1 , string_lit/1 , string_val/1 .","ref":"cerl.html#c_string/1","title":"cerl.c_string/1","type":"function"},{"doc":"Creates an abstract try-expression. If Variables is [V1, ..., Vn] and ExceptionVars is [X1, ..., Xm] , the result represents &quot; try Argument of &lt;V1, ..., Vn&gt; -&gt; Body catch &lt;X1, ..., Xm&gt; -&gt; Handler &quot;. All the Vi and Xi must have type var . See also: ann_c_try/6 , c_catch/1 , is_c_try/1 , try_arg/1 , try_body/1 , try_vars/1 , update_c_try/6 .","ref":"cerl.html#c_try/5","title":"cerl.c_try/5","type":"function"},{"doc":"Creates an abstract tuple. If Elements is [E1, ..., En] , the result represents &quot; {E1, ..., En} &quot;. Note that if all nodes in Elements have type literal , or if Elements is empty, then the result will also have type literal and annotations on nodes in Elements are lost. Recall that Erlang has distinct 1-tuples, i.e., {X} is always distinct from X itself. See also: ann_c_tuple/2 , c_tuple_skel/1 , is_c_tuple/1 , tuple_arity/1 , tuple_es/1 , update_c_tuple/2 .","ref":"cerl.html#c_tuple/1","title":"cerl.c_tuple/1","type":"function"},{"doc":"Creates an abstract tuple skeleton. Does not fold constant literals, i.e., the result always has type tuple , representing &quot; {E1, ..., En} &quot;, if Elements is [E1, ..., En] . This function is occasionally useful when it is necessary to have annotations on the subnodes of a tuple node, even when all the subnodes are constant literals. Note however that is_literal/1 will yield false and concrete/1 will fail if passed the result from this function. fold_literal/1 can be used to revert a node to the normal-form representation. See also: ann_c_tuple_skel/2 , c_tuple/1 , concrete/1 , fold_literal/1 , is_c_tuple/1 , is_literal/1 , tuple_es/1 , update_c_tuple_skel/2 .","ref":"cerl.html#c_tuple_skel/1","title":"cerl.c_tuple_skel/1","type":"function"},{"doc":"Creates an abstract value list. If Elements is [E1, ..., En] , the result represents &quot; &lt;E1, ..., En&gt; &quot;. See also: ann_c_values/2 , is_c_values/1 , update_c_values/2 , values_arity/1 , values_es/1 .","ref":"cerl.html#c_values/1","title":"cerl.c_values/1","type":"function"},{"doc":"Creates an abstract variable. A variable is identified by its name, given by the Name parameter. If a name is given by a single atom, it should either be a &quot;simple&quot; atom which does not need to be single-quoted in Erlang, or otherwise its print name should correspond to a proper Erlang variable, i.e., begin with an uppercase character or an underscore. Names on the form {A, N} represent function name variables &quot; A/N &quot;; these are special variables which may be bound only in the function definitions of a module or a letrec . They may not be bound in let expressions and cannot occur in clause patterns. The atom A in a function name may be any atom; the integer N must be nonnegative. The functions c_fname/2 etc. are utilities for handling function name variables. When printing variable names, they must have the form of proper Core Erlang variables and function names. E.g., a name represented by an integer such as 42 could be formatted as &quot; _42 &quot;, an atom 'Xxx' simply as &quot; Xxx &quot;, and an atom foo as &quot; _foo &quot;. However, one must assure that any two valid distinct names are never mapped to the same strings. Tuples such as {foo, 2} representing function names can simply by formatted as &quot; 'foo'/2 &quot;, with no risk of conflicts. See also: ann_c_var/2 , c_fname/2 , c_letrec/2 , c_module/4 , is_c_var/1 , update_c_var/2 , var_name/1 .","ref":"cerl.html#c_var/1","title":"cerl.c_var/1","type":"function"},{"doc":"Returns the list of argument subtrees of an abstract inter-module call. See also: c_call/3 , call_arity/1 .","ref":"cerl.html#call_args/1","title":"cerl.call_args/1","type":"function"},{"doc":"Returns the number of argument subtrees of an abstract inter-module call. Note: this is equivalent to length(call_args(Node)) , but potentially more efficient. See also: c_call/3 , call_args/1 .","ref":"cerl.html#call_arity/1","title":"cerl.call_arity/1","type":"function"},{"doc":"Returns the module subtree of an abstract inter-module call. See also: c_call/3 .","ref":"cerl.html#call_module/1","title":"cerl.call_module/1","type":"function"},{"doc":"Returns the name subtree of an abstract inter-module call. See also: c_call/3 .","ref":"cerl.html#call_name/1","title":"cerl.call_name/1","type":"function"},{"doc":"Returns the argument subtree of an abstract case-expression. See also: c_case/2 .","ref":"cerl.html#case_arg/1","title":"cerl.case_arg/1","type":"function"},{"doc":"Equivalent to clause_arity(hd(case_clauses(Node))) , but potentially more efficient. See also: c_case/2 , case_clauses/1 , clause_arity/1 .","ref":"cerl.html#case_arity/1","title":"cerl.case_arity/1","type":"function"},{"doc":"Returns the list of clause subtrees of an abstract case-expression. See also: c_case/2 , case_arity/1 .","ref":"cerl.html#case_clauses/1","title":"cerl.case_clauses/1","type":"function"},{"doc":"Returns the body subtree of an abstract catch-expression. See also: c_catch/1 .","ref":"cerl.html#catch_body/1","title":"cerl.catch_body/1","type":"function"},{"doc":"Returns the literal string represented by an abstract character. This includes a leading $ character. Currently, all characters that are not in the set of ISO 8859-1 (Latin-1) &quot;printing&quot; characters will be escaped. See also: c_char/1 .","ref":"cerl.html#char_lit/1","title":"cerl.char_lit/1","type":"function"},{"doc":"Returns the value represented by an abstract character literal. See also: c_char/1 .","ref":"cerl.html#char_val/1","title":"cerl.char_val/1","type":"function"},{"doc":"Returns the number of pattern subtrees of an abstract clause. Note: this is equivalent to length(clause_pats(Node)) , but potentially more efficient. See also: c_clause/3 , clause_pats/1 .","ref":"cerl.html#clause_arity/1","title":"cerl.clause_arity/1","type":"function"},{"doc":"Returns the body subtree of an abstract clause. See also: c_clause/3 .","ref":"cerl.html#clause_body/1","title":"cerl.clause_body/1","type":"function"},{"doc":"Returns the guard subtree of an abstract clause. See also: c_clause/3 .","ref":"cerl.html#clause_guard/1","title":"cerl.clause_guard/1","type":"function"},{"doc":"Returns the list of pattern subtrees of an abstract clause. See also: c_clause/3 , clause_arity/1 .","ref":"cerl.html#clause_pats/1","title":"cerl.clause_pats/1","type":"function"},{"doc":"Returns the list of all abstract variables in the patterns of an abstract clause. The order of listing is not defined. See also: c_clause/3 , pat_list_vars/1 .","ref":"cerl.html#clause_vars/1","title":"cerl.clause_vars/1","type":"function"},{"doc":"Returns the Erlang term represented by a syntax tree. An exception is thrown if Node does not represent a literal term. Note: This is a constant time operation. See also: abstract/1 , is_literal/1 .","ref":"cerl.html#concrete/1","title":"cerl.concrete/1","type":"function"},{"doc":"Returns the head subtree of an abstract list constructor. See also: c_cons/2 .","ref":"cerl.html#cons_hd/1","title":"cerl.cons_hd/1","type":"function"},{"doc":"Returns the tail subtree of an abstract list constructor. Recall that the tail does not necessarily represent a proper list. See also: c_cons/2 .","ref":"cerl.html#cons_tl/1","title":"cerl.cons_tl/1","type":"function"},{"doc":"Copies the list of user annotations from Source to Target . Note: this is equivalent to set_ann(Target, get_ann(Source)) , but potentially more efficient. See also: get_ann/1 , set_ann/2 .","ref":"cerl.html#copy_ann/2","title":"cerl.copy_ann/2","type":"function"},{"doc":"Returns the number of subtrees of a data constructor node. This is equivalent to length(data_es(Node)) , but potentially more efficient. See also: data_es/1 , is_data/1 .","ref":"cerl.html#data_arity/1","title":"cerl.data_arity/1","type":"function"},{"doc":"Returns the list of subtrees of a data constructor node. If the arity of the constructor is zero, the result is the empty list. Note: if data_type(Node) is cons , the number of subtrees is exactly two. If data_type(Node) is {atomic, Value} , the number of subtrees is zero. See also: data_arity/1 , data_type/1 , is_data/1 , make_data/2 .","ref":"cerl.html#data_es/1","title":"cerl.data_es/1","type":"function"},{"doc":"Returns a type descriptor for a data constructor node. (Cf. is_data/1 .) This is mainly useful for comparing types and for constructing new nodes of the same type (cf. make_data/2 ). If Node represents an integer, floating-point number, atom or empty list, the result is {atomic, Value} , where Value is the value of concrete(Node) , otherwise the result is either cons or tuple . Type descriptors can be compared for equality or order (in the Erlang term order), but remember that floating-point values should in general never be tested for equality. See also: concrete/1 , is_data/1 , make_data/2 , type/1 .","ref":"cerl.html#data_type/1","title":"cerl.data_type/1","type":"function"},{"doc":"Returns the numeral string represented by a floating-point literal node. See also: c_float/1 .","ref":"cerl.html#float_lit/1","title":"cerl.float_lit/1","type":"function"},{"doc":"Returns the value represented by a floating-point literal node. See also: c_float/1 .","ref":"cerl.html#float_val/1","title":"cerl.float_val/1","type":"function"},{"doc":"Returns the arity part of an abstract function name variable. See also: c_fname/2 , fname_id/1 .","ref":"cerl.html#fname_arity/1","title":"cerl.fname_arity/1","type":"function"},{"doc":"Returns the identifier part of an abstract function name variable. See also: c_fname/2 , fname_arity/1 .","ref":"cerl.html#fname_id/1","title":"cerl.fname_id/1","type":"function"},{"doc":"Assures that literals have a compact representation. This is occasionally useful if c_cons_skel/2 , c_tuple_skel/1 or unfold_literal/1 were used in the construction of Node , and you want to revert to the normal &quot;folded&quot; representation of literals. If Node represents a tuple or list constructor, its elements are rewritten recursively, and the node is reconstructed using c_cons/2 or c_tuple/1 , respectively; otherwise, Node is not changed. See also: c_cons/2 , c_cons_skel/2 , c_tuple/1 , c_tuple_skel/1 , is_literal/1 , unfold_literal/1 .","ref":"cerl.html#fold_literal/1","title":"cerl.fold_literal/1","type":"function"},{"doc":"Translates an explicit record representation to a corresponding abstract syntax tree. The records are defined in the file &quot; core_parse.hrl &quot;. See also: to_records/1 , type/1 .","ref":"cerl.html#from_records/1","title":"cerl.from_records/1","type":"function"},{"doc":"Returns the number of parameter subtrees of an abstract fun-expression. Note: this is equivalent to length(fun_vars(Node)) , but potentially more efficient. See also: c_fun/2 , fun_vars/1 .","ref":"cerl.html#fun_arity/1","title":"cerl.fun_arity/1","type":"function"},{"doc":"Returns the body subtree of an abstract fun-expression. See also: c_fun/2 .","ref":"cerl.html#fun_body/1","title":"cerl.fun_body/1","type":"function"},{"doc":"Returns the list of parameter subtrees of an abstract fun-expression. See also: c_fun/2 , fun_arity/1 .","ref":"cerl.html#fun_vars/1","title":"cerl.fun_vars/1","type":"function"},{"doc":"Returns the list of user annotations associated with a syntax tree node. For a newly created node, this is the empty list. The annotations may be any terms. See also: set_ann/2 .","ref":"cerl.html#get_ann/1","title":"cerl.get_ann/1","type":"function"},{"doc":"Returns the numeral string represented by an integer literal node. See also: c_int/1 .","ref":"cerl.html#int_lit/1","title":"cerl.int_lit/1","type":"function"},{"doc":"Returns the value represented by an integer literal node. See also: c_int/1 .","ref":"cerl.html#int_val/1","title":"cerl.int_val/1","type":"function"},{"doc":"Returns true if Node is an abstract pattern alias, otherwise false . See also: c_alias/2 .","ref":"cerl.html#is_c_alias/1","title":"cerl.is_c_alias/1","type":"function"},{"doc":"Returns true if Node is an abstract function application, otherwise false . See also: c_apply/2 .","ref":"cerl.html#is_c_apply/1","title":"cerl.is_c_apply/1","type":"function"},{"doc":"Returns true if Node represents an atom literal, otherwise false . See also: c_atom/1 .","ref":"cerl.html#is_c_atom/1","title":"cerl.is_c_atom/1","type":"function"},{"doc":"Returns true if Node is an abstract binary-template; otherwise false . See also: c_binary/1 .","ref":"cerl.html#is_c_binary/1","title":"cerl.is_c_binary/1","type":"function"},{"doc":"Returns true if Node is an abstract bit-string template; otherwise false . See also: c_bitstr/5 .","ref":"cerl.html#is_c_bitstr/1","title":"cerl.is_c_bitstr/1","type":"function"},{"doc":"Returns true if Node is an abstract inter-module call expression; otherwise false . See also: c_call/3 .","ref":"cerl.html#is_c_call/1","title":"cerl.is_c_call/1","type":"function"},{"doc":"Returns true if Node is an abstract case-expression; otherwise false . See also: c_case/2 .","ref":"cerl.html#is_c_case/1","title":"cerl.is_c_case/1","type":"function"},{"doc":"Returns true if Node is an abstract catch-expression, otherwise false . See also: c_catch/1 .","ref":"cerl.html#is_c_catch/1","title":"cerl.is_c_catch/1","type":"function"},{"doc":"Returns true if Node may represent a character literal, otherwise false . If the local implementation of Erlang defines char() as a subset of integer() , then is_c_int(Node) will also yield true . See also: c_char/1 , is_print_char/1 .","ref":"cerl.html#is_c_char/1","title":"cerl.is_c_char/1","type":"function"},{"doc":"Returns true if Node is an abstract clause, otherwise false . See also: c_clause/3 .","ref":"cerl.html#is_c_clause/1","title":"cerl.is_c_clause/1","type":"function"},{"doc":"Returns true if Node is an abstract list constructor, otherwise false .","ref":"cerl.html#is_c_cons/1","title":"cerl.is_c_cons/1","type":"function"},{"doc":"Returns true if Node represents a floating-point literal, otherwise false . See also: c_float/1 .","ref":"cerl.html#is_c_float/1","title":"cerl.is_c_float/1","type":"function"},{"doc":"Returns true if Node is an abstract function name variable, otherwise false . See also: c_fname/2 , c_var/1 , var_name/1 .","ref":"cerl.html#is_c_fname/1","title":"cerl.is_c_fname/1","type":"function"},{"doc":"Returns true if Node is an abstract fun-expression, otherwise false . See also: c_fun/2 .","ref":"cerl.html#is_c_fun/1","title":"cerl.is_c_fun/1","type":"function"},{"doc":"Returns true if Node represents an integer literal, otherwise false . See also: c_int/1 .","ref":"cerl.html#is_c_int/1","title":"cerl.is_c_int/1","type":"function"},{"doc":"Returns true if Node is an abstract let-expression, otherwise false . See also: c_let/3 .","ref":"cerl.html#is_c_let/1","title":"cerl.is_c_let/1","type":"function"},{"doc":"Returns true if Node is an abstract letrec-expression, otherwise false . See also: c_letrec/2 .","ref":"cerl.html#is_c_letrec/1","title":"cerl.is_c_letrec/1","type":"function"},{"doc":"Returns true if Node represents a proper list, otherwise false . A proper list is either the empty list [] , or a cons cell [Head | Tail] , where recursively Tail is a proper list. Note: Because Node is a syntax tree, the actual run-time values corresponding to its subtrees may often be partially or completely unknown. Thus, if Node represents e.g. &quot; [... | Ns] &quot; (where Ns is a variable), then the function will return false , because it is not known whether Ns will be bound to a list at run-time. If Node instead represents e.g. &quot; [1, 2, 3] &quot; or &quot; [A | []] &quot;, then the function will return true . See also: c_cons/2 , c_nil/0 , list_elements/1 , list_length/1 .","ref":"cerl.html#is_c_list/1","title":"cerl.is_c_list/1","type":"function"},{"doc":"Returns true if Node is an abstract map constructor, otherwise false .","ref":"cerl.html#is_c_map/1","title":"cerl.is_c_map/1","type":"function"},{"doc":"","ref":"cerl.html#is_c_map_empty/1","title":"cerl.is_c_map_empty/1","type":"function"},{"doc":"","ref":"cerl.html#is_c_map_pattern/1","title":"cerl.is_c_map_pattern/1","type":"function"},{"doc":"Returns true if Node is an abstract module definition, otherwise false . See also: type/1 .","ref":"cerl.html#is_c_module/1","title":"cerl.is_c_module/1","type":"function"},{"doc":"Returns true if Node is an abstract empty list, otherwise false .","ref":"cerl.html#is_c_nil/1","title":"cerl.is_c_nil/1","type":"function"},{"doc":"Returns true if Node is an abstract primitive operation call, otherwise false . See also: c_primop/2 .","ref":"cerl.html#is_c_primop/1","title":"cerl.is_c_primop/1","type":"function"},{"doc":"Returns true if Node is an abstract receive-expression, otherwise false . See also: c_receive/3 .","ref":"cerl.html#is_c_receive/1","title":"cerl.is_c_receive/1","type":"function"},{"doc":"Returns true if Node is an abstract sequencing expression, otherwise false . See also: c_seq/2 .","ref":"cerl.html#is_c_seq/1","title":"cerl.is_c_seq/1","type":"function"},{"doc":"Returns true if Node may represent a string literal, otherwise false . Strings are defined as lists of characters; see is_c_char/1 for details. See also: c_string/1 , is_c_char/1 , is_print_string/1 .","ref":"cerl.html#is_c_string/1","title":"cerl.is_c_string/1","type":"function"},{"doc":"Returns true if Node is an abstract try-expression, otherwise false . See also: c_try/5 .","ref":"cerl.html#is_c_try/1","title":"cerl.is_c_try/1","type":"function"},{"doc":"Returns true if Node is an abstract tuple, otherwise false . See also: c_tuple/1 .","ref":"cerl.html#is_c_tuple/1","title":"cerl.is_c_tuple/1","type":"function"},{"doc":"Returns true if Node is an abstract value list; otherwise false . See also: c_values/1 .","ref":"cerl.html#is_c_values/1","title":"cerl.is_c_values/1","type":"function"},{"doc":"Returns true if Node is an abstract variable, otherwise false . See also: c_var/1 .","ref":"cerl.html#is_c_var/1","title":"cerl.is_c_var/1","type":"function"},{"doc":"Returns true if Node represents a data constructor, otherwise false . Data constructors are cons cells, tuples, and atomic literals. See also: data_arity/1 , data_es/1 , data_type/1 .","ref":"cerl.html#is_data/1","title":"cerl.is_data/1","type":"function"},{"doc":"Returns true if Node is a leaf node, otherwise false . The current leaf node types are literal and var . Note: all literals (cf. is_literal/1 ) are leaf nodes, even if they represent structured (constant) values such as {foo, [bar, baz]} . Also note that variables are leaf nodes but not literals. See also: is_literal/1 , type/1 .","ref":"cerl.html#is_leaf/1","title":"cerl.is_leaf/1","type":"function"},{"doc":"Returns true if Node represents a literal term, otherwise false . This function returns true if and only if the value of concrete(Node) is defined. Note: This is a constant time operation. See also: abstract/1 , concrete/1 , fold_literal/1 .","ref":"cerl.html#is_literal/1","title":"cerl.is_literal/1","type":"function"},{"doc":"Returns true if Term can be represented as a literal, otherwise false . This function takes time proportional to the size of Term . See also: abstract/1 .","ref":"cerl.html#is_literal_term/1","title":"cerl.is_literal_term/1","type":"function"},{"doc":"Returns true if Node may represent a &quot;printing&quot; character, otherwise false . (Cf. is_c_char/1 .) A &quot;printing&quot; character has either a given graphical representation, or a &quot;named&quot; escape sequence such as &quot; \\n &quot;. Currently, only ISO 8859-1 (Latin-1) character values are recognized. See also: c_char/1 , is_c_char/1 .","ref":"cerl.html#is_print_char/1","title":"cerl.is_print_char/1","type":"function"},{"doc":"Returns true if Node may represent a string literal containing only &quot;printing&quot; characters, otherwise false . See is_c_string/1 and is_print_char/1 for details. Currently, only ISO 8859-1 (Latin-1) character values are recognized. See also: c_string/1 , is_c_string/1 , is_print_char/1 .","ref":"cerl.html#is_print_string/1","title":"cerl.is_print_string/1","type":"function"},{"doc":"Returns the argument subtree of an abstract let-expression. See also: c_let/3 .","ref":"cerl.html#let_arg/1","title":"cerl.let_arg/1","type":"function"},{"doc":"Returns the number of left-hand side variables of an abstract let-expression. Note: this is equivalent to length(let_vars(Node)) , but potentially more efficient. See also: c_let/3 , let_vars/1 .","ref":"cerl.html#let_arity/1","title":"cerl.let_arity/1","type":"function"},{"doc":"Returns the body subtree of an abstract let-expression. See also: c_let/3 .","ref":"cerl.html#let_body/1","title":"cerl.let_body/1","type":"function"},{"doc":"Returns the list of left-hand side variables of an abstract let-expression. See also: c_let/3 , let_arity/1 .","ref":"cerl.html#let_vars/1","title":"cerl.let_vars/1","type":"function"},{"doc":"Returns the body subtree of an abstract letrec-expression. See also: c_letrec/2 .","ref":"cerl.html#letrec_body/1","title":"cerl.letrec_body/1","type":"function"},{"doc":"Returns the list of definitions of an abstract letrec-expression. If Node represents &quot; letrec V1 = F1 ... Vn = Fn in Body &quot;, the returned value is [{V1, F1}, ..., {Vn, Fn}] . See also: c_letrec/2 .","ref":"cerl.html#letrec_defs/1","title":"cerl.letrec_defs/1","type":"function"},{"doc":"Returns the list of left-hand side function variable subtrees of a letrec-expression. If Node represents &quot; letrec V1 = F1 ... Vn = Fn in Body &quot;, the returned value is [V1, ..., Vn] . See also: c_letrec/2 .","ref":"cerl.html#letrec_vars/1","title":"cerl.letrec_vars/1","type":"function"},{"doc":"Returns the list of element subtrees of an abstract list. Node must represent a proper list. E.g., if Node represents &quot; [X1, X2 | [X3, X4 | []] &quot;, then list_elements(Node) yields the list [X1, X2, X3, X4] . See also: c_cons/2 , c_nil/0 , is_c_list/1 , list_length/1 , make_list/2 .","ref":"cerl.html#list_elements/1","title":"cerl.list_elements/1","type":"function"},{"doc":"Returns the number of element subtrees of an abstract list. Node must represent a proper list. E.g., if Node represents &quot; [X1 | [X2, X3 | [X4, X5, X6]]] &quot;, then list_length(Node) returns the integer 6. Note: this is equivalent to length(list_elements(Node)) , but potentially more efficient. See also: c_cons/2 , c_nil/0 , is_c_list/1 , list_elements/1 .","ref":"cerl.html#list_length/1","title":"cerl.list_length/1","type":"function"},{"doc":"Creates a data constructor node with the specified type and subtrees. (Cf. data_type/1 .) An exception is thrown if the length of Elements is invalid for the given Type ; see data_es/1 for arity constraints on constructor types. See also: ann_make_data/3 , data_es/1 , data_type/1 , make_data_skel/2 , update_data/3 .","ref":"cerl.html#make_data/2","title":"cerl.make_data/2","type":"function"},{"doc":"Like make_data/2 , but analogous to c_tuple_skel/1 and c_cons_skel/2 . See also: ann_make_data_skel/3 , c_cons_skel/2 , c_tuple_skel/1 , make_data/2 , update_data_skel/3 .","ref":"cerl.html#make_data_skel/2","title":"cerl.make_data_skel/2","type":"function"},{"doc":"Equivalent to make_list(List, none) .","ref":"cerl.html#make_list/1","title":"cerl.make_list/1","type":"function"},{"doc":"Creates an abstract list from the elements in List and the optional Tail . If Tail is none , the result will represent a nil-terminated list, otherwise it represents &quot; [... | Tail] &quot;. See also: ann_make_list/3 , c_cons/2 , c_nil/0 , list_elements/1 , update_list/3 .","ref":"cerl.html#make_list/2","title":"cerl.make_list/2","type":"function"},{"doc":"Creates a syntax tree with the given type and subtrees. Type must be a node type name (cf. type/1 ) that does not denote a leaf node type (cf. is_leaf/1 ). Groups must be a nonempty list of groups of syntax trees, representing the subtrees of a node of the given type, in left-to-right order as they would occur in the printed program text, grouped by category as done by subtrees/1 . The result of ann_make_tree(get_ann(Node), type(Node), subtrees(Node)) (cf. update_tree/2 ) represents the same source code text as the original Node , assuming that subtrees(Node) yields a nonempty list. However, it does not necessarily have the exact same data representation as Node . See also: ann_make_tree/3 , is_leaf/1 , subtrees/1 , type/1 , update_tree/2 .","ref":"cerl.html#make_tree/2","title":"cerl.make_tree/2","type":"function"},{"doc":"","ref":"cerl.html#map_arg/1","title":"cerl.map_arg/1","type":"function"},{"doc":"","ref":"cerl.html#map_es/1","title":"cerl.map_es/1","type":"function"},{"doc":"","ref":"cerl.html#map_pair_key/1","title":"cerl.map_pair_key/1","type":"function"},{"doc":"","ref":"cerl.html#map_pair_op/1","title":"cerl.map_pair_op/1","type":"function"},{"doc":"","ref":"cerl.html#map_pair_val/1","title":"cerl.map_pair_val/1","type":"function"},{"doc":"Creates a meta-representation of a syntax tree. The result represents an Erlang expression &quot; MetaTree &quot; which, if evaluated, will yield a new syntax tree representing the same source code text as Tree (although the actual data representation may be different). The expression represented by MetaTree is implementation independent with regard to the data structures used by the abstract syntax tree implementation. Any node in Tree whose node type is var (cf. type/1 ), and whose list of annotations (cf. get_ann/1 ) contains the atom meta_var , will remain unchanged in the resulting tree, except that exactly one occurrence of meta_var is removed from its annotation list. The main use of the function meta/1 is to transform a data structure Tree , which represents a piece of program code, into a form that is representation independent when printed . E.g., suppose Tree represents a variable named &quot;V&quot;. Then (assuming a function print/1 for printing syntax trees), evaluating print(abstract(Tree)) - simply using abstract/1 to map the actual data structure onto a syntax tree representation - would output a string that might look something like &quot; {var, ..., 'V'} &quot;, which is obviously dependent on the implementation of the abstract syntax trees. This could e.g. be useful for caching a syntax tree in a file. However, in some situations like in a program generator generator (with two &quot;generator&quot;), it may be unacceptable. Using print(meta(Tree)) instead would output a representation independent syntax tree generating expression; in the above case, something like &quot; cerl:c_var('V') &quot;. The implementation tries to generate compact code with respect to literals and lists. See also: abstract/1 , get_ann/1 , type/1 .","ref":"cerl.html#meta/1","title":"cerl.meta/1","type":"function"},{"doc":"Returns the list of pairs of attribute key/value subtrees of an abstract module definition. See also: c_module/4 .","ref":"cerl.html#module_attrs/1","title":"cerl.module_attrs/1","type":"function"},{"doc":"Returns the list of function definitions of an abstract module definition. See also: c_module/4 .","ref":"cerl.html#module_defs/1","title":"cerl.module_defs/1","type":"function"},{"doc":"Returns the list of exports subtrees of an abstract module definition. See also: c_module/4 .","ref":"cerl.html#module_exports/1","title":"cerl.module_exports/1","type":"function"},{"doc":"Returns the name subtree of an abstract module definition. See also: c_module/4 .","ref":"cerl.html#module_name/1","title":"cerl.module_name/1","type":"function"},{"doc":"Returns the list of left-hand side function variable subtrees of an abstract module definition. See also: c_module/4 .","ref":"cerl.html#module_vars/1","title":"cerl.module_vars/1","type":"function"},{"doc":"Returns the list of all abstract variables in the given patterns. An exception is thrown if some element in Patterns does not represent a well-formed Core Erlang clause pattern. The order of listing is not defined. See also: clause_vars/1 , pat_vars/1 .","ref":"cerl.html#pat_list_vars/1","title":"cerl.pat_list_vars/1","type":"function"},{"doc":"Returns the list of all abstract variables in a pattern. An exception is thrown if Node does not represent a well-formed Core Erlang clause pattern. The order of listing is not defined. See also: clause_vars/1 , pat_list_vars/1 .","ref":"cerl.html#pat_vars/1","title":"cerl.pat_vars/1","type":"function"},{"doc":"Returns the list of argument subtrees of an abstract primitive operation call. See also: c_primop/2 , primop_arity/1 .","ref":"cerl.html#primop_args/1","title":"cerl.primop_args/1","type":"function"},{"doc":"Returns the number of argument subtrees of an abstract primitive operation call. Note: this is equivalent to length(primop_args(Node)) , but potentially more efficient. See also: c_primop/2 , primop_args/1 .","ref":"cerl.html#primop_arity/1","title":"cerl.primop_arity/1","type":"function"},{"doc":"Returns the name subtree of an abstract primitive operation call. See also: c_primop/2 .","ref":"cerl.html#primop_name/1","title":"cerl.primop_name/1","type":"function"},{"doc":"Returns the action subtree of an abstract receive-expression. See also: c_receive/3 .","ref":"cerl.html#receive_action/1","title":"cerl.receive_action/1","type":"function"},{"doc":"Returns the list of clause subtrees of an abstract receive-expression. See also: c_receive/3 .","ref":"cerl.html#receive_clauses/1","title":"cerl.receive_clauses/1","type":"function"},{"doc":"Returns the timeout subtree of an abstract receive-expression. See also: c_receive/3 .","ref":"cerl.html#receive_timeout/1","title":"cerl.receive_timeout/1","type":"function"},{"doc":"Returns the argument subtree of an abstract sequencing expression. See also: c_seq/2 .","ref":"cerl.html#seq_arg/1","title":"cerl.seq_arg/1","type":"function"},{"doc":"Returns the body subtree of an abstract sequencing expression. See also: c_seq/2 .","ref":"cerl.html#seq_body/1","title":"cerl.seq_body/1","type":"function"},{"doc":"Sets the list of user annotations of Node to Annotations . See also: add_ann/2 , copy_ann/2 , get_ann/1 .","ref":"cerl.html#set_ann/2","title":"cerl.set_ann/2","type":"function"},{"doc":"Returns the literal string represented by an abstract string. This includes surrounding double-quote characters &quot;...&quot; . Currently, characters that are not in the set of ISO 8859-1 (Latin-1) &quot;printing&quot; characters will be escaped, except for spaces. See also: c_string/1 .","ref":"cerl.html#string_lit/1","title":"cerl.string_lit/1","type":"function"},{"doc":"Returns the value represented by an abstract string literal. See also: c_string/1 .","ref":"cerl.html#string_val/1","title":"cerl.string_val/1","type":"function"},{"doc":"Returns the grouped list of all subtrees of a node. If Node is a leaf node (cf. is_leaf/1 ), this is the empty list, otherwise the result is always a nonempty list, containing the lists of subtrees of Node , in left-to-right order as they occur in the printed program text, and grouped by category. Often, each group contains only a single subtree. Depending on the type of Node , the size of some groups may be variable (e.g., the group consisting of all the elements of a tuple), while others always contain the same number of elements - usually exactly one (e.g., the group containing the argument expression of a case-expression). Note, however, that the exact structure of the returned list (for a given node type) should in general not be depended upon, since it might be subject to change without notice. The function subtrees/1 and the constructor functions make_tree/2 and update_tree/2 can be a great help if one wants to traverse a syntax tree, visiting all its subtrees, but treat nodes of the tree in a uniform way in most or all cases. Using these functions makes this simple, and also assures that your code is not overly sensitive to extensions of the syntax tree data type, because any node types not explicitly handled by your code can be left to a default case. For example: postorder ( F , Tree ) -&gt; F ( case subtrees ( Tree ) of [ ] -&gt; Tree ; List -&gt; update_tree ( Tree , [ [ postorder ( F , Subtree ) || Subtree &lt;- Group ] || Group &lt;- List ] ) end ) . maps the function F on Tree and all its subtrees, doing a post-order traversal of the syntax tree. (Note the use of update_tree/2 to preserve annotations.) For a simple function like: f ( Node ) -&gt; case type ( Node ) of atom -&gt; atom ( &quot;a_&quot; ++ atom_name ( Node ) ) ; _ -&gt; Node end . the call postorder(fun f/1, Tree) will yield a new representation of Tree in which all atom names have been extended with the prefix &quot;a_&quot;, but nothing else (including annotations) has been changed. See also: is_leaf/1 , make_tree/2 , update_tree/2 .","ref":"cerl.html#subtrees/1","title":"cerl.subtrees/1","type":"function"},{"doc":"Translates an abstract syntax tree to a corresponding explicit record representation. The records are defined in the file &quot; cerl.hrl &quot;. See also: from_records/1 , type/1 .","ref":"cerl.html#to_records/1","title":"cerl.to_records/1","type":"function"},{"doc":"Returns the expression subtree of an abstract try-expression. See also: c_try/5 .","ref":"cerl.html#try_arg/1","title":"cerl.try_arg/1","type":"function"},{"doc":"Returns the success body subtree of an abstract try-expression. See also: c_try/5 .","ref":"cerl.html#try_body/1","title":"cerl.try_body/1","type":"function"},{"doc":"Returns the list of exception variable subtrees of an abstract try-expression. See also: c_try/5 .","ref":"cerl.html#try_evars/1","title":"cerl.try_evars/1","type":"function"},{"doc":"Returns the exception body subtree of an abstract try-expression. See also: c_try/5 .","ref":"cerl.html#try_handler/1","title":"cerl.try_handler/1","type":"function"},{"doc":"Returns the list of success variable subtrees of an abstract try-expression. See also: c_try/5 .","ref":"cerl.html#try_vars/1","title":"cerl.try_vars/1","type":"function"},{"doc":"Returns the number of element subtrees of an abstract tuple. Note: this is equivalent to length(tuple_es(Node)) , but potentially more efficient. See also: c_tuple/1 , tuple_es/1 .","ref":"cerl.html#tuple_arity/1","title":"cerl.tuple_arity/1","type":"function"},{"doc":"Returns the list of element subtrees of an abstract tuple. See also: c_tuple/1 .","ref":"cerl.html#tuple_es/1","title":"cerl.tuple_es/1","type":"function"},{"doc":"Returns the type tag of Node . Current node types are: alias apply binary bitstr call case catch clause cons fun let letrec literal map map_pair module primop receive seq try tuple values var Note: The name of the primary constructor function for a node type is always the name of the type itself, prefixed by &quot; c_ &quot;; recognizer predicates are correspondingly prefixed by &quot; is_c_ &quot;. Furthermore, to simplify preservation of annotations (cf. get_ann/1 ), there are analogous constructor functions prefixed by &quot; ann_c_ &quot; and &quot; update_c_ &quot;, for setting the annotation list of the new node to either a specific value or to the annotations of an existing node, respectively. See also: abstract/1 , c_alias/2 , c_apply/2 , c_binary/1 , c_bitstr/5 , c_call/3 , c_case/2 , c_catch/1 , c_clause/3 , c_cons/2 , c_fun/2 , c_let/3 , c_letrec/2 , c_module/3 , c_primop/2 , c_receive/1 , c_seq/2 , c_try/5 , c_tuple/1 , c_values/1 , c_var/1 , data_type/1 , from_records/1 , get_ann/1 , meta/1 , subtrees/1 , to_records/1 .","ref":"cerl.html#type/1","title":"cerl.type/1","type":"function"},{"doc":"Assures that literals have a fully expanded representation. If Node represents a literal tuple or list constructor, its elements are rewritten recursively, and the node is reconstructed using c_cons_skel/2 or c_tuple_skel/1 , respectively; otherwise, Node is not changed. The fold_literal/1 can be used to revert to the normal compact representation. See also: c_cons/2 , c_cons_skel/2 , c_tuple/1 , c_tuple_skel/1 , fold_literal/1 , is_literal/1 .","ref":"cerl.html#unfold_literal/1","title":"cerl.unfold_literal/1","type":"function"},{"doc":"See also: c_alias/2 .","ref":"cerl.html#update_c_alias/3","title":"cerl.update_c_alias/3","type":"function"},{"doc":"See also: c_apply/2 .","ref":"cerl.html#update_c_apply/3","title":"cerl.update_c_apply/3","type":"function"},{"doc":"See also: c_binary/1 .","ref":"cerl.html#update_c_binary/2","title":"cerl.update_c_binary/2","type":"function"},{"doc":"Equivalent to update_c_bitstr(Node, Value, Size, abstract(1), Type, Flags) .","ref":"cerl.html#update_c_bitstr/5","title":"cerl.update_c_bitstr/5","type":"function"},{"doc":"See also: c_bitstr/5 , update_c_bitstr/5 .","ref":"cerl.html#update_c_bitstr/6","title":"cerl.update_c_bitstr/6","type":"function"},{"doc":"See also: c_call/3 .","ref":"cerl.html#update_c_call/4","title":"cerl.update_c_call/4","type":"function"},{"doc":"See also: c_case/2 .","ref":"cerl.html#update_c_case/3","title":"cerl.update_c_case/3","type":"function"},{"doc":"See also: c_catch/1 .","ref":"cerl.html#update_c_catch/2","title":"cerl.update_c_catch/2","type":"function"},{"doc":"See also: c_clause/3 .","ref":"cerl.html#update_c_clause/4","title":"cerl.update_c_clause/4","type":"function"},{"doc":"See also: c_cons/2 .","ref":"cerl.html#update_c_cons/3","title":"cerl.update_c_cons/3","type":"function"},{"doc":"See also: c_cons_skel/2 .","ref":"cerl.html#update_c_cons_skel/3","title":"cerl.update_c_cons_skel/3","type":"function"},{"doc":"Like update_c_fname/3 , but takes the arity from Node . See also: c_fname/2 , update_c_fname/3 .","ref":"cerl.html#update_c_fname/2","title":"cerl.update_c_fname/2","type":"function"},{"doc":"Equivalent to update_c_var(Old, {Atom, Arity}) . See also: c_fname/2 , update_c_fname/2 .","ref":"cerl.html#update_c_fname/3","title":"cerl.update_c_fname/3","type":"function"},{"doc":"See also: c_fun/2 .","ref":"cerl.html#update_c_fun/3","title":"cerl.update_c_fun/3","type":"function"},{"doc":"See also: c_let/3 .","ref":"cerl.html#update_c_let/4","title":"cerl.update_c_let/4","type":"function"},{"doc":"See also: c_letrec/2 .","ref":"cerl.html#update_c_letrec/3","title":"cerl.update_c_letrec/3","type":"function"},{"doc":"","ref":"cerl.html#update_c_map/3","title":"cerl.update_c_map/3","type":"function"},{"doc":"","ref":"cerl.html#update_c_map_pair/4","title":"cerl.update_c_map_pair/4","type":"function"},{"doc":"See also: c_module/4 .","ref":"cerl.html#update_c_module/5","title":"cerl.update_c_module/5","type":"function"},{"doc":"See also: c_primop/2 .","ref":"cerl.html#update_c_primop/3","title":"cerl.update_c_primop/3","type":"function"},{"doc":"See also: c_receive/3 .","ref":"cerl.html#update_c_receive/4","title":"cerl.update_c_receive/4","type":"function"},{"doc":"See also: c_seq/2 .","ref":"cerl.html#update_c_seq/3","title":"cerl.update_c_seq/3","type":"function"},{"doc":"See also: c_try/5 .","ref":"cerl.html#update_c_try/6","title":"cerl.update_c_try/6","type":"function"},{"doc":"See also: c_tuple/1 .","ref":"cerl.html#update_c_tuple/2","title":"cerl.update_c_tuple/2","type":"function"},{"doc":"See also: c_tuple_skel/1 .","ref":"cerl.html#update_c_tuple_skel/2","title":"cerl.update_c_tuple_skel/2","type":"function"},{"doc":"See also: c_values/1 .","ref":"cerl.html#update_c_values/2","title":"cerl.update_c_values/2","type":"function"},{"doc":"See also: c_var/1 .","ref":"cerl.html#update_c_var/2","title":"cerl.update_c_var/2","type":"function"},{"doc":"See also: make_data/2 .","ref":"cerl.html#update_data/3","title":"cerl.update_data/3","type":"function"},{"doc":"See also: make_data_skel/2 .","ref":"cerl.html#update_data_skel/3","title":"cerl.update_data_skel/3","type":"function"},{"doc":"Equivalent to update_list(Old, List, none) .","ref":"cerl.html#update_list/2","title":"cerl.update_list/2","type":"function"},{"doc":"See also: make_list/2 , update_list/2 .","ref":"cerl.html#update_list/3","title":"cerl.update_list/3","type":"function"},{"doc":"Creates a syntax tree with the given subtrees, and the same type and annotations as the Old node. This is equivalent to ann_make_tree(get_ann(Node), type(Node), Groups) , but potentially more efficient. See also: ann_make_tree/3 , get_ann/1 , type/1 , update_tree/3 .","ref":"cerl.html#update_tree/2","title":"cerl.update_tree/2","type":"function"},{"doc":"Creates a syntax tree with the given type and subtrees, and the same annotations as the Old node. This is equivalent to ann_make_tree(get_ann(Node), Type, Groups) , but potentially more efficient. See also: ann_make_tree/3 , get_ann/1 , update_tree/2 .","ref":"cerl.html#update_tree/3","title":"cerl.update_tree/3","type":"function"},{"doc":"Returns the number of element subtrees of an abstract value list. Note: This is equivalent to length(values_es(Node)) , but potentially more efficient. See also: c_values/1 , values_es/1 .","ref":"cerl.html#values_arity/1","title":"cerl.values_arity/1","type":"function"},{"doc":"Returns the list of element subtrees of an abstract value list. See also: c_values/1 , values_arity/1 .","ref":"cerl.html#values_es/1","title":"cerl.values_es/1","type":"function"},{"doc":"Returns the name of an abstract variable. See also: c_var/1 .","ref":"cerl.html#var_name/1","title":"cerl.var_name/1","type":"function"},{"doc":"Utility functions for Core Erlang case/receive clauses. Syntax trees are defined in the module cerl . DATA TYPES bindings() = [{ cerl:cerl() , cerl:cerl() }] cerl() = cerl:cerl() expr() = any | cerl:cerl() match_ret() = none | {true, bindings() } | {false, bindings() }","ref":"cerl_clauses.html","title":"cerl_clauses","type":"module"},{"doc":"Returns true if any of the abstract clauses in the list is a catch-all, otherwise false . See is_catchall/1 for details. Note: each node in Clauses must have type clause . See also: is_catchall/1 .","ref":"cerl_clauses.html#any_catchall/1","title":"cerl_clauses.any_catchall/1","type":"function"},{"doc":"Tries to reduce a guard expression to a single constant value, if possible. The returned value is {value, Term} if the guard expression Expr always yields the constant value Term , and is otherwise none . Note that although guard expressions should only yield boolean values, this function does not guarantee that Term is either true or false . Also note that only simple constructs like let-expressions are examined recursively; general constant folding is not performed. See also: is_catchall/1 .","ref":"cerl_clauses.html#eval_guard/1","title":"cerl_clauses.eval_guard/1","type":"function"},{"doc":"Returns true if an abstract clause is a catch-all, otherwise false . A clause is a catch-all if all its patterns are variables, and its guard expression always evaluates to true ; cf. eval_guard/1 . Note: Clause must have type clause . See also: any_catchall/1 , eval_guard/1 .","ref":"cerl_clauses.html#is_catchall/1","title":"cerl_clauses.is_catchall/1","type":"function"},{"doc":"Matches a pattern against an expression. The returned value is none if a match is impossible, {true, Bindings} if Pattern definitely matches Expr , and {false, Bindings} if a match is not definite, but cannot be excluded. Bindings is then a list of pairs {Var, SubExpr} , associating each variable in the pattern with either the corresponding subexpression of Expr , or with the atom any if no matching subexpression exists. (Recall that variables may not be repeated in a Core Erlang pattern.) The list of bindings is given in innermost-first order; this should only be of interest if Pattern contains one or more alias patterns. If the returned value is {true, []} , it implies that the pattern and the expression are syntactically identical. Instead of a syntax tree, the atom any can be passed for Expr (or, more generally, be used for any subtree of Expr , in as much the abstract syntax tree implementation allows it); this means that it cannot be decided whether the pattern will match or not, and the corresponding variable bindings will all map to any . The typical use is for producing bindings for receive clauses. Note: Binary-syntax patterns are never structurally matched against binary-syntax expressions by this function. Examples: Matching a pattern &quot; {X, Y} &quot; against the expression &quot; {foo, f(Z)} &quot; yields {true, Bindings} where Bindings associates &quot; X &quot; with the subtree &quot; foo &quot; and &quot; Y &quot; with the subtree &quot; f(Z) &quot;. Matching pattern &quot; {X, {bar, Y}} &quot; against expression &quot; {foo, f(Z)} &quot; yields {false, Bindings} where Bindings associates &quot; X &quot; with the subtree &quot; foo &quot; and &quot; Y &quot; with any (because it is not known if &quot; {foo, Y} &quot; might match the run-time value of &quot; f(Z) &quot; or not). Matching pattern &quot; {foo, bar} &quot; against expression &quot; {foo, f()} &quot; yields {false, []} , telling us that there might be a match, but we cannot deduce any bindings. Matching {foo, X = {bar, Y}} against expression &quot; {foo, {bar, baz}} &quot; yields {true, Bindings} where Bindings associates &quot; Y &quot; with &quot; baz &quot;, and &quot; X &quot; with &quot; {bar, baz} &quot;. Matching a pattern &quot; {X, Y} &quot; against any yields {false, Bindings} where Bindings associates both &quot; X &quot; and &quot; Y &quot; with any .","ref":"cerl_clauses.html#match/2","title":"cerl_clauses.match/2","type":"function"},{"doc":"Like match/2 , but matching a sequence of patterns against a sequence of expressions. Passing an empty list for Exprs is equivalent to passing a list of any atoms of the same length as Patterns . See also: match/2 .","ref":"cerl_clauses.html#match_list/2","title":"cerl_clauses.match_list/2","type":"function"},{"doc":"Equivalent to reduce(Cs, []) .","ref":"cerl_clauses.html#reduce/1","title":"cerl_clauses.reduce/1","type":"function"},{"doc":"Selects a single clause, if possible, or otherwise reduces the list of selectable clauses. The input is a list Clauses of abstract clauses (i.e., syntax trees of type clause ), and a list of switch expressions Exprs . The function tries to uniquely select a single clause or discard unselectable clauses, with respect to the switch expressions. All abstract clauses in the list must have the same number of patterns. If Exprs is not the empty list, it must have the same length as the number of patterns in each clause; see match_list/2 for details. A clause can only be selected if its guard expression always yields the atom true , and a clause whose guard expression always yields the atom false can never be selected. Other guard expressions are considered to have unknown value; cf. eval_guard/1 . If a particular clause can be selected, the function returns {true, {Clause, Bindings}} , where Clause is the selected clause and Bindings is a list of pairs {Var, SubExpr} associating the variables occurring in the patterns of Clause with the corresponding subexpressions in Exprs . The list of bindings is given in innermost-first order; see the match/2 function for details. If no clause could be definitely selected, the function returns {false, NewClauses} , where NewClauses is the list of entries in Clauses that remain after eliminating unselectable clauses, preserving the relative order. See also: eval_guard/1 , match/2 , match_list/2 .","ref":"cerl_clauses.html#reduce/2","title":"cerl_clauses.reduce/2","type":"function"},{"doc":"Basic functions on Core Erlang abstract syntax trees. Syntax trees are defined in the module cerl . DATA TYPES cerl() = cerl:cerl()","ref":"cerl_trees.html","title":"cerl_trees","type":"module"},{"doc":"Returns the length of the longest path in the tree. A leaf node has depth zero, the tree representing &quot; {foo, bar} &quot; has depth one, etc.","ref":"cerl_trees.html#depth/1","title":"cerl_trees.depth/1","type":"function"},{"doc":"Does a fold operation over the nodes of the tree. The result is the value of Function(X1, Function(X2, ... Function(Xn, Unit) ... )) , where X1, ..., Xn are the nodes of Tree in a post-order traversal. See also: mapfold/3 .","ref":"cerl_trees.html#fold/3","title":"cerl_trees.fold/3","type":"function"},{"doc":"Like variables/1 , but only includes variables that are free in the tree. See also: next_free_variable_name/1 , variables/1 .","ref":"cerl_trees.html#free_variables/1","title":"cerl_trees.free_variables/1","type":"function"},{"doc":"","ref":"cerl_trees.html#get_label/1","title":"cerl_trees.get_label/1","type":"function"},{"doc":"Equivalent to label(Tree, 0) .","ref":"cerl_trees.html#label/1","title":"cerl_trees.label/1","type":"function"},{"doc":"Labels each expression in the tree. A term {label, L} is prefixed to the annotation list of each expression node, where L is a unique number for every node, except for variables (and function name variables) which get the same label if they represent the same variable. Constant literal nodes are not labeled. The returned value is a tuple {NewTree, Max} , where NewTree is the labeled tree and Max is 1 plus the largest label value used. All previous annotation terms on the form {label, X} are deleted. The values of L used in the tree is a dense range from N to Max - 1 , where N =&lt; Max =&lt; N + size(Tree) . Note that it is possible that no labels are used at all, i.e., N = Max . Note: All instances of free variables will be given distinct labels. See also: label/1 , size/1 .","ref":"cerl_trees.html#label/2","title":"cerl_trees.label/2","type":"function"},{"doc":"Maps a function onto the nodes of a tree. This replaces each node in the tree by the result of applying the given function on the original node, bottom-up. See also: mapfold/3 .","ref":"cerl_trees.html#map/2","title":"cerl_trees.map/2","type":"function"},{"doc":"Does a combined map/fold operation on the nodes of the tree. This is similar to map/2 , but also propagates a value from each application of Function to the next, starting with the given value Initial , while doing a post-order traversal of the tree, much like fold/3 . This is the same as mapfold/4, with an identity function as the pre-operation. See also: fold/3 , map/2 , mapfold/4 .","ref":"cerl_trees.html#mapfold/3","title":"cerl_trees.mapfold/3","type":"function"},{"doc":"Does a combined map/fold operation on the nodes of the tree. It begins by calling Pre on the tree, using the Initial value. Pre must either return a tree with an updated accumulator or the atom skip . If a tree is returned, this function deconstructs the top node of the returned tree and recurses on the children, using the returned value as the new initial and carrying the returned values from one call to the next. Finally it reassembles the top node from the children, calls Post on it and returns the result. If skip is returned, it returns the tree and accumulator as is.","ref":"cerl_trees.html#mapfold/4","title":"cerl_trees.mapfold/4","type":"function"},{"doc":"Returns a integer variable name higher than any other integer variable name in the syntax tree. An exception is thrown if Tree does not represent a well-formed Core Erlang syntax tree. See also: free_variables/1 , variables/1 .","ref":"cerl_trees.html#next_free_variable_name/1","title":"cerl_trees.next_free_variable_name/1","type":"function"},{"doc":"Returns the number of nodes in Tree .","ref":"cerl_trees.html#size/1","title":"cerl_trees.size/1","type":"function"},{"doc":"Returns an ordered-set list of the names of all variables in the syntax tree. (This includes function name variables.) An exception is thrown if Tree does not represent a well-formed Core Erlang syntax tree. See also: free_variables/1 , next_free_variable_name/1 .","ref":"cerl_trees.html#variables/1","title":"cerl_trees.variables/1","type":"function"},{"doc":"This module provides an interface to the standard Erlang compiler. It can generate either a new file, which contains the object code, or return a binary, which can be loaded directly. Default Compiler Options The (host operating system) environment variable ERL_COMPILER_OPTIONS can be used to give default compiler options. Its value must be a valid Erlang term. If the value is a list, it is used as is. If it is not a list, it is put into a list. The list is appended to any options given to file/2 , forms/2 , and output_generated/2 . Use the alternative functions noenv_file/2 , noenv_forms/2 , or noenv_output_generated/2 if you do not want the environment variable to be consulted, for example, if you are calling the compiler recursively from inside a parse transform. The list can be retrieved with env_compiler_options/0 . Inlining The compiler can do function inlining within an Erlang module. Inlining means that a call to a function is replaced with the function body with the arguments replaced with the actual values. The semantics are preserved, except if exceptions are generated in the inlined code. Exceptions are reported as occurring in the function the body was inlined into. Also, function_clause exceptions are converted to similar case_clause exceptions. When a function is inlined, the original function is kept if it is exported (either by an explicit export or if the option export_all was given) or if not all calls to the function are inlined. Inlining does not necessarily improve running time. For example, inlining can increase Beam stack use, which probably is detrimental to performance for recursive functions. Inlining is never default. It must be explicitly enabled with a compiler option or a -compile() attribute in the source module. To enable inlining, either use the option inline to let the compiler decide which functions to inline, or {inline,[{Name,Arity},...]} to have the compiler inline all calls to the given functions. If the option is given inside a compile directive in an Erlang module, {Name,Arity} can be written as Name/Arity . Example of explicit inlining: - compile ( { inline , [ pi / 0 ] } ) . pi ( ) -&gt; 3.1416 . Example of implicit inlining: - compile ( inline ) . The option {inline_size,Size} controls how large functions that are allowed to be inlined. Default is 24 , which keeps the size of the inlined code roughly the same as the un-inlined version (only relatively small functions are inlined). Example: %% Aggressive inlining - will increase code size. - compile ( inline ) . - compile ( { inline_size , 100 } ) . Inlining of List Functions The compiler can also inline various list manipulation functions from the module list in STDLIB. This feature must be explicitly enabled with a compiler option or a -compile() attribute in the source module. To enable inlining of list functions, use option inline_list_funcs . The following functions are inlined: lists:all/2 lists:any/2 lists:foreach/2 lists:map/2 lists:flatmap/2 lists:filter/2 lists:foldl/3 lists:foldr/3 lists:mapfoldl/3 lists:mapfoldr/3 Parse Transformations Parse transformations are used when a programmer wants to use Erlang syntax but with different semantics. The original Erlang code is then transformed into other Erlang code. See erl_id_trans(3) for an example and an explanation of the function parse_transform_info/0 . Error Information The ErrorInfo mentioned earlier is the standard ErrorInfo structure, which is returned from all I/O modules. It has the following format: { ErrorLocation , Module , ErrorDescriptor } ErrorLocation is the atom none if the error does not correspond to a specific location, for example, if the source file does not exist. A string describing the error is obtained with the following call: Module : format_error ( ErrorDescriptor ) See Also epp(3) , erl_id_trans(3), erl_lint(3) , beam_lib(3)","ref":"compile.html","title":"compile","type":"module"},{"doc":"Return compiler options given via the environment variable ERL_COMPILER_OPTIONS . If the value is a list, it is returned as is. If it is not a list, it is put into a list.","ref":"compile.html#env_compiler_options/0","title":"compile.env_compiler_options/0","type":"function"},{"doc":"Is the same as file(File, [verbose,report_errors,report_warnings]) .","ref":"compile.html#file/1","title":"compile.file/1","type":"function"},{"doc":"CompRet = ModRet | BinRet | ErrRet ModRet = {ok,ModuleName} | {ok,ModuleName,Warnings} BinRet = {ok,ModuleName,Binary} | {ok,ModuleName,Binary,Warnings} ErrRet = error | {error,Errors,Warnings} Compiles the code in the file File , which is an Erlang source code file without the .erl extension. Options determine the behavior of the compiler. Returns {ok,ModuleName} if successful, or error if there are errors. An object code file is created if the compilation succeeds without errors. It is considered to be an error if the module name in the source code is not the same as the basename of the output file. Available options: brief Restricts error and warning messages to a single line of output. As of OTP 24, the compiler will by default also display the part of the source code that the message refers to. basic_validation This option is a fast way to test whether a module will compile successfully. This is useful for code generators that want to verify the code that they emit. No code is generated. If warnings are enabled, warnings generated by the erl_lint module (such as warnings for unused variables and functions) are also returned. Use option strong_validation to generate all warnings that the compiler would generate. strong_validation Similar to option basic_validation . No code is generated, but more compiler passes are run to ensure that warnings generated by the optimization passes are generated (such as clauses that will not match, or expressions that are guaranteed to fail with an exception at runtime). binary The compiler returns the object code in a binary instead of creating an object file. If successful, the compiler returns {ok,ModuleName,Binary} . bin_opt_info The compiler will emit informational warnings about binary matching optimizations (both successful and unsuccessful). For more information, see the section about bin_opt_info in the Efficiency Guide. {compile_info, [{atom(), term()}]} Allows compilers built on top of compile to attach extra compilation metadata to the compile_info chunk in the generated beam file. It is advised for compilers to remove all non-deterministic information if the deterministic option is supported and it was supplied by the user. compressed The compiler will compress the generated object code, which can be useful for embedded systems. debug_info Includes debug information in the form of Erlang Abstract Format in the debug_info chunk of the compiled beam module. Tools such as Debugger, Xref, and Cover require the debug information to be included. Warning : Source code can be reconstructed from the debug information. Use encrypted debug information ( encrypt_debug_info ) to prevent this. For details, see beam_lib(3) . {debug_info, {Backend, Data}} Includes custom debug information in the form of a Backend module with custom Data in the compiled beam module. The given module must implement a debug_info/4 function and is responsible for generating different code representations, as described in the debug_info under beam_lib(3) . Warning : Source code can be reconstructed from the debug information. Use encrypted debug information ( encrypt_debug_info ) to prevent this. {debug_info_key,KeyString} {debug_info_key,{Mode,KeyString}} Includes debug information, but encrypts it so that it cannot be accessed without supplying the key. (To give option debug_info as well is allowed, but not necessary.) Using this option is a good way to always have the debug information available during testing, yet protecting the source code. Mode is the type of crypto algorithm to be used for encrypting the debug information. The default (and currently the only) type is des3_cbc . For details, see beam_lib(3) . encrypt_debug_info Similar to the debug_info_key option, but the key is read from an .erlang.crypt file. For details, see beam_lib(3) . deterministic Omit the options and source tuples in the list returned by Module:module_info(compile) , and reduce the paths in stack traces to the module name alone. This option will make it easier to achieve reproducible builds. makedep Produces a Makefile rule to track headers dependencies. No object file is produced. By default, this rule is written to &lt;File&gt;.Pbeam . However, if option binary is set, nothing is written and the rule is returned in Binary . The output will be encoded in UTF-8. For example, if you have the following module: - module ( module ) . - include_lib ( &quot;eunit/include/eunit.hrl&quot; ) . - include ( &quot;header.hrl&quot; ) . The Makefile rule generated by this option looks as follows: module . beam : module . erl \\ / usr / local / lib / erlang / lib / eunit / include / eunit . hrl \\ header . hrl makedep_side_effect The dependecies are created as a side effect to the normal compilation process. This means that the object file will also be produced. This option override the makedep option. {makedep_output, Output} Writes generated rules to Output instead of the default &lt;File&gt;.Pbeam . Output can be a filename or an io_device() . To write to stdout, use standard_io . However, if binary is set, nothing is written to Output and the result is returned to the caller with {ok, ModuleName, Binary} . {makedep_target, Target} Changes the name of the rule emitted to Target . makedep_quote_target Characters in Target special to make(1) are quoted. makedep_add_missing Considers missing headers as generated files and adds them to the dependencies. makedep_phony Adds a phony target for each dependency. 'P' Produces a listing of the parsed code, after preprocessing and parse transforms, in the file &lt;File&gt;.P . No object file is produced. 'E' Produces a listing of the code, after all source code transformations have been performed, in the file &lt;File&gt;.E . No object file is produced. 'S' Produces a listing of the assembler code in the file &lt;File&gt;.S . No object file is produced. recv_opt_info The compiler will emit informational warnings about selective receive optimizations (both successful and unsuccessful). For more information, see the section about selective receive optimization in the Efficiency Guide. report_errors/report_warnings Causes errors/warnings to be printed as they occur. report A short form for both report_errors and report_warnings . return_errors If this flag is set, {error,ErrorList,WarningList} is returned when there are errors. return_warnings If this flag is set, an extra field, containing WarningList , is added to the tuples returned on success. warnings_as_errors Causes warnings to be treated as errors. This option is supported since R13B04. {error_location,line | column} If the value of this flag is line , the location ErrorLocation of warnings and errors is a line number. If the value is column , ErrorLocation includes both a line number and a column number. Default is column . This option is supported since Erlang/OTP 24.0. If the value of this flag is column , debug information includes column information. return A short form for both return_errors and return_warnings . verbose Causes more verbose information from the compiler, describing what it is doing. {source,FileName} Overrides the source file name as presented in module_info(compile) and stack traces. {outdir,Dir} Sets a new directory for the object code. The current directory is used for output, except when a directory has been specified with this option. export_all Causes all functions in the module to be exported. {i,Dir} Adds Dir to the list of directories to be searched when including a file. When encountering an -include or -include_lib directive, the compiler searches for header files in the following directories: &quot;.&quot; , the current working directory of the file server The base name of the compiled file The directories specified using option i ; the directory specified last is searched first {d,Macro} {d,Macro,Value} Defines a macro Macro to have the value Value . Macro is of type atom, and Value can be any term. The default Value is true . {parse_transform,Module} Causes the parse transformation function Module:parse_transform/2 to be applied to the parsed code before the code is checked for errors. from_abstr The input file is expected to contain Erlang terms representing forms in abstract format (default file suffix &quot;.abstr&quot;). Note that the format of such terms can change between releases. See also the no_lint option. from_asm The input file is expected to be assembler code (default file suffix &quot;.S&quot;). Notice that the format of assembler files is not documented, and can change between releases. from_core The input file is expected to be core code (default file suffix &quot;.core&quot;). Notice that the format of core files is not documented, and can change between releases. no_spawn_compiler_process By default, all code is compiled in a separate process which is terminated at the end of compilation. However, some tools, like Dialyzer or compilers for other BEAM languages, may already manage their own worker processes and spawning an extra process may slow the compilation down. In such scenarios, you can pass this option to stop the compiler from spawning an additional process. no_strict_record_tests This option is not recommended. By default, the generated code for operation Record#record_tag.field verifies that the tuple Record has the correct size for the record, and that the first element is the tag record_tag . Use this option to omit the verification code. no_error_module_mismatch Normally the compiler verifies that the module name given in the source code is the same as the base name of the output file and refuses to generate an output file if there is a mismatch. If you have a good reason (or other reason) for having a module name unrelated to the name of the output file, this option disables that verification (there will not even be a warning if there is a mismatch). {no_auto_import,[{F,A}, ...]} Makes the function F/A no longer being auto-imported from the erlang module, which resolves BIF name clashes. This option must be used to resolve name clashes with BIFs auto-imported before R14A, if it is needed to call the local function with the same name as an auto-imported BIF without module prefix. As from R14A and forward, the compiler resolves calls without module prefix to local or imported functions before trying with auto-imported BIFs. If the BIF is to be called, use the erlang module prefix in the call, not {no_auto_import,[{F,A}, ...]} . If this option is written in the source code, as a -compile directive, the syntax F/A can be used instead of {F,A} , for example: - compile ( { no_auto_import , [ error / 1 ] } ) . no_auto_import Do not auto-import any functions from erlang module. no_line_info Omits line number information to produce a slightly smaller output file. no_lint Skips the pass that checks for errors and warnings. Only applicable together with the from_abstr option. This is mainly for implementations of other languages on top of Erlang, which have already done their own checks to guarantee correctness of the code. Caveat: When this option is used, there are no guarantees that the code output by the compiler is correct and safe to use. The responsibility for correctness lies on the code or person generating the abstract format. If the code contains errors, the compiler may crash or produce unsafe code. {extra_chunks, [{binary(), binary()}]} Pass extra chunks to be stored in the .beam file. The extra chunks must be a list of tuples with a four byte binary as chunk name followed by a binary with the chunk contents. See beam_lib for more information. If warnings are turned on (option report_warnings described earlier), the following options control what type of warnings that are generated. Except from {warn_format,Verbosity} , the following options have two forms: A warn_xxx form, to turn on the warning. A nowarn_xxx form, to turn off the warning. In the descriptions that follow, the form that is used to change the default value are listed. {warn_format, Verbosity} Causes warnings to be emitted for malformed format strings as arguments to io:format and similar functions. Verbosity selects the number of warnings: 0 = No warnings 1 = Warnings for invalid format strings and incorrect number of arguments 2 = Warnings also when the validity cannot be checked, for example, when the format string argument is a variable. The default verbosity is 1 . Verbosity 0 can also be selected by option nowarn_format . nowarn_bif_clash This option is removed, it generates a fatal error if used. As from beginning with R14A, the compiler no longer calls the auto-imported BIF if the name clashes with a local or explicitly imported function, and a call without explicit module name is issued. Instead, the local or imported function is called. Still accepting nowarn_bif_clash would make a module calling functions clashing with auto-imported BIFs compile with both the old and new compilers, but with completely different semantics. This is why the option is removed. The use of this option has always been discouraged. As from R14A, it is an error to use it. To resolve BIF clashes, use explicit module names or the {no_auto_import,[F/A]} compiler directive. {nowarn_bif_clash, FAs} This option is removed, it generates a fatal error if used. The use of this option has always been discouraged. As from R14A, it is an error to use it. To resolve BIF clashes, use explicit module names or the {no_auto_import,[F/A]} compiler directive. nowarn_export_all Turns off warnings for uses of the export_all option. Default is to emit a warning if option export_all is also given. warn_export_vars Emits warnings for all implicitly exported variables referred to after the primitives where they were first defined. By default, the compiler only emits warnings for exported variables referred to in a pattern. nowarn_shadow_vars Turns off warnings for &quot;fresh&quot; variables in functional objects or list comprehensions with the same name as some already defined variable. Default is to emit warnings for such variables. nowarn_unused_function Turns off warnings for unused local functions. Default is to emit warnings for all local functions that are not called directly or indirectly by an exported function. The compiler does not include unused local functions in the generated beam file, but the warning is still useful to keep the source code cleaner. {nowarn_unused_function, FAs} Turns off warnings for unused local functions like nowarn_unused_function does, but only for the mentioned local functions. FAs is a tuple {Name,Arity} or a list of such tuples. nowarn_deprecated_function Turns off warnings for calls to deprecated functions. Default is to emit warnings for every call to a function known by the compiler to be deprecated. Notice that the compiler does not know about attribute -deprecated() , but uses an assembled list of deprecated functions in Erlang/OTP. To do a more general check, the Xref tool can be used. See also xref(3) and the function xref:m/1 , also accessible through the function c:xm/1 . {nowarn_deprecated_function, MFAs} Turns off warnings for calls to deprecated functions like nowarn_deprecated_function does, but only for the mentioned functions. MFAs is a tuple {Module,Name,Arity} or a list of such tuples. nowarn_deprecated_type Turns off warnings for use of deprecated types. Default is to emit warnings for every use of a type known by the compiler to be deprecated. nowarn_removed Turns off warnings for calls to functions that have been removed. Default is to emit warnings for every call to a function known by the compiler to have been recently removed from Erlang/OTP. {nowarn_removed, ModulesOrMFAs} Turns off warnings for calls to modules or functions that have been removed. Default is to emit warnings for every call to a function known by the compiler to have been recently removed from Erlang/OTP. nowarn_obsolete_guard Turns off warnings for calls to old type testing BIFs, such as pid/1 and list/1 . See the Erlang Reference Manual for a complete list of type testing BIFs and their old equivalents. Default is to emit warnings for calls to old type testing BIFs. warn_unused_import Emits warnings for unused imported functions. Default is to emit no warnings for unused imported functions. nowarn_underscore_match By default, warnings are emitted when a variable that begins with an underscore is matched after being bound. Use this option to turn off this kind of warning. nowarn_unused_vars By default, warnings are emitted for unused variables, except for variables beginning with an underscore (&quot;Prolog style warnings&quot;). Use this option to turn off this kind of warning. nowarn_unused_record Turns off warnings for unused record definitions. Default is to emit warnings for unused locally defined records. {nowarn_unused_record, RecordNames} Turns off warnings for unused record definitions. Default is to emit warnings for unused locally defined records. nowarn_unused_type Turns off warnings for unused type declarations. Default is to emit warnings for unused local type declarations. nowarn_nif_inline By default, warnings are emitted when inlining is enabled in a module that may load NIFs, as the compiler may inline NIF fallbacks by accident. Use this option to turn off this kind of warnings. warn_missing_spec By default, warnings are not emitted when a specification (or contract) for an exported function is not given. Use this option to turn on this kind of warning. warn_missing_spec_all By default, warnings are not emitted when a specification (or contract) for an exported or unexported function is not given. Use this option to turn on this kind of warning. Other kinds of warnings are opportunistic warnings . They are generated when the compiler happens to notice potential issues during optimization and code generation. The compiler does not warn for expressions that it does not attempt to optimize. For example, the compiler will emit a warning for 1/0 but not for X/0 , because 1/0 is a constant expression that the compiler will attempt to evaluate. The absence of warnings does not mean that there are no remaining errors in the code. Opportunistic warnings can be disabled using the following options: nowarn_opportunistic Disable all opportunistic warnings. nowarn_failed Disable warnings for expressions that will always fail (such as atom+42 ). nowarn_ignored Disable warnings for expressions whose values are ignored. nowarn_nomatch Disable warnings for patterns that will never match (such as a=b ) and for guards that always evaluate to false . All options, except the include path ( {i,Dir} ), can also be given in the file with attribute -compile([Option,...]) . Attribute -compile() is allowed after the function definitions. Before OTP 22, the option {nowarn_deprecated_function, MFAs} was only recognized when given in the file with attribute -compile() . (The option {nowarn_unused_function,FAs} was incorrectly documented to only work in a file, but it also worked when given in the option list.) Starting from OTP 22, all options that can be given in the file can also be given in the option list. For debugging of the compiler, or for pure curiosity, the intermediate code generated by each compiler pass can be inspected. To print a complete list of the options to produce list files, type compile:options() at the Erlang shell prompt. The options are printed in the order that the passes are executed. If more than one listing option is used, the one representing the earliest pass takes effect. Unrecognized options are ignored. Both WarningList and ErrorList have the following format: [ { FileName , [ ErrorInfo ] } ] . ErrorInfo is described later in this section. The filename is included here, as the compiler uses the Erlang pre-processor epp , which allows the code to be included in other files. It is therefore important to know to which file the location of an error or a warning refers.","ref":"compile.html#file/2","title":"compile.file/2","type":"function"},{"doc":"ErrorDescriptor = errordesc() Uses an ErrorDescriptor and returns a deep list of characters that describes the error. This function is usually called implicitly when an ErrorInfo structure (described in section Error Information ) is processed.","ref":"compile.html#format_error/1","title":"compile.format_error/1","type":"function"},{"doc":"Is the same as forms(Forms, [verbose,report_errors,report_warnings]) .","ref":"compile.html#forms/1","title":"compile.forms/1","type":"function"},{"doc":"Forms = forms() forms() = [ erl_parse:abstract_form ] | cerl:c_module() Options = [ option() ] CompRet = BinRet | ErrRet BinRet = {ok,ModuleName,BinaryOrCode} | {ok,ModuleName,BinaryOrCode,Warnings} ModuleName = module() BinaryOrCode = binary() | term() ErrRet = error | {error,Errors,Warnings} Warnings = Errors = [{ file:filename() , [{ erl_anno:location() | 'none', module(), term()}]}] Analogous to file/1 , but takes a list of forms (in either Erlang abstract or Core Erlang format representation) as first argument. Option binary is implicit, that is, no object code file is produced. For options that normally produce a listing file, such as 'E', the internal format for that compiler pass (an Erlang term, usually not a binary) is returned instead of a binary.","ref":"compile.html#forms/2","title":"compile.forms/2","type":"function"},{"doc":"Works like file/2 , except that the environment variable ERL_COMPILER_OPTIONS is not consulted.","ref":"compile.html#noenv_file/2","title":"compile.noenv_file/2","type":"function"},{"doc":"Works like forms/2 , except that the environment variable ERL_COMPILER_OPTIONS is not consulted.","ref":"compile.html#noenv_forms/2","title":"compile.noenv_forms/2","type":"function"},{"doc":"Options = [term()] Works like output_generated/1 , except that the environment variable ERL_COMPILER_OPTIONS is not consulted.","ref":"compile.html#noenv_output_generated/1","title":"compile.noenv_output_generated/1","type":"function"},{"doc":"Options = [term()] Determines whether the compiler generates a beam file with the given options. true means that a beam file is generated. false means that the compiler generates some listing file, returns a binary, or merely checks the syntax of the source code.","ref":"compile.html#output_generated/1","title":"compile.output_generated/1","type":"function"},{"doc":"List of Erlang abstract or Core Erlang format representations, as used by forms/2","ref":"compile.html#t:forms/0","title":"compile.forms/0","type":"type"},{"doc":"See file/2 for detailed description","ref":"compile.html#t:option/0","title":"compile.option/0","type":"type"}]