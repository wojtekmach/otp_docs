<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.25.1">
    <meta name="project" content="syntax_tools v2.6">

    <title>erl_syntax_lib â€” syntax_tools v2.6</title>
    <link rel="stylesheet" href="dist/erlang-951161c89561e05735a5.css" />

    <script src="dist/sidebar_items-33b0a6fec9.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-f97730d45ef67f3e6188.js"></script>


  </head>
  <body data-type="modules">
    <script>

      try {
        if (localStorage.getItem('night-mode') === 'true') {
          document.body.classList.add('night-mode');
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <span class="icon-search" aria-hidden="true" title="Submit search"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <span class="icon-cross" aria-hidden="true" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="api-reference.html" class="sidebar-projectName">
syntax_tools
      </a>
      <strong class="sidebar-projectVersion">
        v2.6
      </strong>
    </div>

  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list-link" href="#full-list">Pages</a></li>

      <li><a id="modules-list-link" href="#full-list">Modules</a></li>


  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

      <h1>
erl_syntax_lib <small class="app-vsn">(syntax_tools v2.6)</small>

      </h1>


        <section id="moduledoc">
<p>Support library for abstract Erlang syntax trees.</p><p>This module contains utility functions for working with the abstract data type defined in the module <a href="erl_syntax.html">erl_syntax</a>.</p><h2 id="module-data-types" class="section-heading">
  <a href="#module-data-types" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  DATA TYPES
</h2>
<a id="types"></a><dl><dt><a id="type-appFunName"></a>appFunName() = {atom(), arity()} | {atom(), {atom(), arity()}}</dt><dd><p></p></dd><dt><a id="type-field"></a>field() = {atom(), {<a href="#type-field_default">field_default()</a>, <a href="#type-field_type">field_type()</a>}}</dt><dd><p></p></dd><dt><a id="type-field_default"></a>field_default() = none | <a href="erl_syntax.html#type-syntaxTree">erl_syntax:syntaxTree()</a></dt><dd><p></p></dd><dt><a id="type-field_type"></a>field_type() = none | <a href="erl_syntax.html#type-syntaxTree">erl_syntax:syntaxTree()</a></dt><dd><p></p></dd><dt><a id="type-fields"></a>fields() = [<a href="#type-field">field()</a>]</dt><dd><p></p></dd><dt><a id="type-functionN"></a>functionN() = atom() | {atom(), arity()}</dt><dd><p></p></dd><dt><a id="type-functionName"></a>functionName() = <a href="#type-functionN">functionN()</a> | {atom(), <a href="#type-functionN">functionN()</a>}</dt><dd><p></p></dd><dt><a id="type-info"></a>info() = {atom(), [{atom(), <a href="erl_syntax.html#type-syntaxTree">erl_syntax:syntaxTree()</a>}]} | {atom(), atom()} | atom()</dt><dd><p></p></dd><dt><a id="type-info_pair"></a>info_pair() = {<a href="#type-key">key()</a>, term()}</dt><dd><p></p></dd><dt><a id="type-key"></a>key() = attributes | errors | exports | functions | imports | module | records | warnings</dt><dd><p></p></dd><dt><a id="type-name"></a>name() = <a href="#type-shortname">shortname()</a> | {atom(), <a href="#type-shortname">shortname()</a>}</dt><dd><p></p></dd><dt><a id="type-ordset"></a>ordset(T) = <a href="https://wojtekmach.pl/otp_docs/stdlib/ordsets.html#type-ordset">ordsets:ordset(T)</a></dt><dd><p></p></dd><dt><a id="type-set"></a>set(T) = <a href="https://wojtekmach.pl/otp_docs/stdlib/sets.html#type-set">sets:set(T)</a></dt><dd><p></p></dd><dt><a id="type-shortname"></a>shortname() = atom() | {atom(), arity()}</dt><dd><p></p></dd><dt><a id="type-syntaxTree"></a>syntaxTree() = <a href="erl_syntax.html#type-syntaxTree">erl_syntax:syntaxTree()</a></dt><dd><p></p><p>An abstract syntax tree. See the <a href="erl_syntax.html">erl_syntax</a> module for details.</p></dd><dt><a id="type-typeName"></a>typeName() = atom() | {module(), {atom(), arity()}} | {atom(), arity()}</dt><dd><p></p></dd></dl>
        </section>


        <section id="summary" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#summary">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
            Summary
          </h1>

  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_application/1">analyze_application(Node:: erl_syntax:syntaxTree() ) -&gt;  appFunName()  | arity()</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_application-1"></a><p>Returns the name of a called function. The result is a representation of the name of the applied function <code>F/A</code>, if <code>Node</code> represents a function application &quot;<code>&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;X_1&lt;/em&gt;, ..., &lt;em&gt;X_A&lt;/em&gt;)</code>&quot;. If the function is not explicitly named (i.e., <code>F</code> is given by some expression), only the arity <code>A</code> is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_attribute/1">analyze_attribute(Node:: erl_syntax:syntaxTree() ) -&gt; preprocessor | {atom(), term()}</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_attribute-1"></a><p>Analyzes an attribute node. If <code>Node</code> represents a preprocessor directive, the atom <code>preprocessor</code> is returned. Otherwise, if <code>Node</code> represents a module attribute &quot;<code>-&lt;em&gt;Name&lt;/em&gt;...</code>&quot;, a tuple <code>{Name, Info}</code> is returned, where <code>Info</code> depends on <code>Name</code>, as follows</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_export_attribute/1">analyze_export_attribute(Node:: erl_syntax:syntaxTree() ) -&gt; [ functionName() ]</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_export_attribute-1"></a><p>Returns the list of function names declared by an export attribute. We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_file_attribute/1">analyze_file_attribute(Node:: erl_syntax:syntaxTree() ) -&gt; {string(), integer()}</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_file_attribute-1"></a><p>Returns the file name and line number of a <code>file</code> attribute. The result is the pair <code>{File, Line}</code> if <code>Node</code> represents &quot;<code>-file(File, Line).</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_form/1">analyze_form(Node:: erl_syntax:syntaxTree() ) -&gt; {atom(), term()} | atom()</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_form-1"></a><p>Analyzes a &quot;source code form&quot; node. If <code>Node</code> is a &quot;form&quot; type (cf. <code>erl_syntax:is_form/1</code>), the returned value is a tuple <code>{Type, Info}</code> where <code>Type</code> is the node type and <code>Info</code> depends on <code>Type</code>, as follows</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_forms/1">analyze_forms(Forms:: erl_syntax:forms() ) -&gt; [ info_pair() ]</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_forms-1"></a><p>Analyzes a sequence of &quot;program forms&quot;. The given <code>Forms</code> may be a single syntax tree of type <code>form_list</code>, or a list of &quot;program form&quot; syntax trees. The returned value is a list of pairs <code>{Key, Info}</code>, where each value of <code>Key</code> occurs at most once in the list; the absence of a particular key indicates that there is no well-defined value for that key.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_function/1">analyze_function(Node:: erl_syntax:syntaxTree() ) -&gt; {atom(), arity()}</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_function-1"></a><p>Returns the name and arity of a function definition. The result is a pair <code>{Name, A}</code> if <code>Node</code> represents a function definition &quot;<code>Name(&lt;em&gt;P_1&lt;/em&gt;, ..., &lt;em&gt;P_A&lt;/em&gt;) -&gt; ...</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_function_name/1">analyze_function_name(Node:: erl_syntax:syntaxTree() ) -&gt;  functionName()</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_function_name-1"></a><p>Returns the function name represented by a syntax tree. If <code>Node</code> represents a function name, such as &quot;<code>foo/1</code>&quot; or &quot;<code>bloggs:fred/2</code>&quot;, a uniform representation of that name is returned. Different nestings of arity and module name qualifiers in the syntax tree does not affect the result.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_implicit_fun/1">analyze_implicit_fun(Node:: erl_syntax:syntaxTree() ) -&gt;  functionName()</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_implicit_fun-1"></a><p>Returns the name of an implicit fun expression &quot;<code>fun &lt;em&gt;F&lt;/em&gt;</code>&quot;. The result is a representation of the function name <code>F</code>. (Cf. <code>analyze_function_name/1</code>.)</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_import_attribute/1">analyze_import_attribute(Node:: erl_syntax:syntaxTree() ) -&gt; {atom(), [ functionName() ]} | atom()</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_import_attribute-1"></a><p>Returns the module name and (if present) list of function names declared by an import attribute. The returned value is an atom <code>Module</code> or a pair <code>{Module, Names}</code>, where <code>Names</code> is a list of function names declared as imported from the module named by <code>Module</code>. We do not guarantee that each name occurs at most once in <code>Names</code>. The order of listing is not defined.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_module_attribute/1">analyze_module_attribute(Node:: erl_syntax:syntaxTree() ) -&gt; atom() | {atom(), [atom()]}</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_module_attribute-1"></a><p>Returns the module name and possible parameters declared by a module attribute. If the attribute is a plain module declaration such as <code>-module(name)</code>, the result is the module name. If the attribute is a parameterized module declaration, the result is a tuple containing the module name and a list of the parameter variable names.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_record_attribute/1">analyze_record_attribute(Node:: erl_syntax:syntaxTree() ) -&gt; {atom(),  fields() }</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_record_attribute-1"></a><p>Returns the name and the list of fields of a record declaration attribute. The result is a pair <code>{Name, Fields}</code>, if <code>Node</code> represents &quot;<code>-record(Name, {...}).</code>&quot;, where <code>Fields</code> is a list of pairs <code>{Label, {Default, Type}}</code> for each field &quot;<code>Label</code>&quot;, &quot;<code>Label = &lt;em&gt;Default&lt;/em&gt;</code>&quot;, &quot;<code>Label :: &lt;em&gt;Type&lt;/em&gt;</code>&quot;, or &quot;<code>Label = &lt;em&gt;Default&lt;/em&gt; :: &lt;em&gt;Type&lt;/em&gt;</code>&quot; in the declaration, listed in left-to-right order. If the field has no default-value declaration, the value for <code>Default</code> will be the atom <code>none</code>. If the field has no type declaration, the value for <code>Type</code> will be the atom <code>none</code>. We do not guarantee that each label occurs at most once in the list.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_record_expr/1">analyze_record_expr(Node:: erl_syntax:syntaxTree() ) -&gt; {atom(),  info() } | atom()</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_record_expr-1"></a><p>Returns the record name and field name/names of a record expression. If <code>Node</code> has type <code>record_expr</code>, <code>record_index_expr</code> or <code>record_access</code>, a pair <code>{Type, Info}</code> is returned, otherwise an atom <code>Type</code> is returned. <code>Type</code> is the node type of <code>Node</code>, and <code>Info</code> depends on <code>Type</code>, as follows</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_record_field/1">analyze_record_field(Node:: erl_syntax:syntaxTree() ) -&gt;  field()</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_record_field-1"></a><p>Returns the label, value-expression, and type of a record field specifier. The result is a pair <code>{Label, {Default, Type}}</code>, if <code>Node</code> represents &quot;<code>Label</code>&quot;, &quot;<code>Label = &lt;em&gt;Default&lt;/em&gt;</code>&quot;, &quot;<code>Label :: &lt;em&gt;Type&lt;/em&gt;</code>&quot;, or &quot;<code>Label = &lt;em&gt;Default&lt;/em&gt; :: &lt;em&gt;Type&lt;/em&gt;</code>&quot;. If the field has no value-expression, the value for <code>Default</code> will be the atom <code>none</code>. If the field has no type, the value for <code>Type</code> will be the atom <code>none</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_type_application/1">analyze_type_application(Node:: erl_syntax:syntaxTree() ) -&gt;  typeName()</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_type_application-1"></a><p>Returns the name of a used type. The result is a representation of the name of the used pre-defined or local type <code>N/A</code>, if <code>Node</code> represents a local (user) type application &quot;<code>&lt;em&gt;N&lt;/em&gt;(&lt;em&gt;T_1&lt;/em&gt;, ..., &lt;em&gt;T_A&lt;/em&gt;)</code>&quot;, or a representation of the name of the used remote type <code>M:N/A</code> if <code>Node</code> represents a remote user type application &quot;<code>&lt;em&gt;M&lt;/em&gt;:&lt;em&gt;N&lt;/em&gt;(&lt;em&gt;T_1&lt;/em&gt;, ..., &lt;em&gt;T_A&lt;/em&gt;)</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_type_name/1">analyze_type_name(Node:: erl_syntax:syntaxTree() ) -&gt;  typeName()</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_type_name-1"></a><p>Returns the type name represented by a syntax tree. If <code>Node</code> represents a type name, such as &quot;<code>foo/1</code>&quot; or &quot;<code>bloggs:fred/2</code>&quot;, a uniform representation of that name is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#analyze_wild_attribute/1">analyze_wild_attribute(Node:: erl_syntax:syntaxTree() ) -&gt; {atom(), term()}</a>

  </div>

    <div class="summary-synopsis"><a id="analyze_wild_attribute-1"></a><p>Returns the name and value of a &quot;wild&quot; attribute. The result is the pair <code>{Name, Value}</code>, if <code>Node</code> represents &quot;<code>-Name(Value)</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#annotate_bindings/1">annotate_bindings(Tree:: erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="annotate_bindings-1"></a><p>Adds or updates annotations on nodes in a syntax tree. Equivalent to <code>annotate_bindings(Tree, Bindings)</code> where the top-level environment <code>Bindings</code> is taken from the annotation <code>{env, Bindings}</code> on the root node of <code>Tree</code>. An exception is thrown if no such annotation should exist.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#annotate_bindings/2">annotate_bindings(Tree:: erl_syntax:syntaxTree() , Env:: ordsets:ordset(atom()) ) -&gt;  erl_syntax:syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="annotate_bindings-2"></a><p>Adds or updates annotations on nodes in a syntax tree. <code>Bindings</code> specifies the set of bound variables in the environment of the top level node. The following annotations are affected</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#fold/3">fold(F::( erl_syntax:syntaxTree() , term()) -&gt; term(), S::term(), Tree:: erl_syntax:syntaxTree() ) -&gt; term()</a>

  </div>

    <div class="summary-synopsis"><a id="fold-3"></a><p>Folds a function over all nodes of a syntax tree. The result is the value of <code>Function(X1, Function(X2, ... Function(Xn, Start) ... ))</code>, where <code>[X1, X2, ..., Xn]</code> are the nodes of <code>Tree</code> in a post-order traversal.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#fold_subtrees/3">fold_subtrees(F::( erl_syntax:syntaxTree() , term()) -&gt; term(), S::term(), Tree:: erl_syntax:syntaxTree() ) -&gt; term()</a>

  </div>

    <div class="summary-synopsis"><a id="fold_subtrees-3"></a><p>Folds a function over the immediate subtrees of a syntax tree. This is similar to <code>fold/3</code>, but only on the immediate subtrees of <code>Tree</code>, in left-to-right order; it does not include the root node of <code>Tree</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#foldl_listlist/3">foldl_listlist(F::(term(), term()) -&gt; term(), S::term(), Ls::[[term()]]) -&gt; term()</a>

  </div>

    <div class="summary-synopsis"><a id="foldl_listlist-3"></a><p>Like <code>lists:foldl/3</code>, but over a list of lists.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#function_name_expansions/1">function_name_expansions(Fs::[ name() ]) -&gt; [{ shortname() ,  name() }]</a>

  </div>

    <div class="summary-synopsis"><a id="function_name_expansions-1"></a><p>Creates a mapping from corresponding short names to full function names. Names are represented by nested tuples of atoms and integers (cf. <code>analyze_function_name/1</code>). The result is a list containing a pair <code>{ShortName, Name}</code> for each element <code>Name</code> in the given list, where the corresponding <code>ShortName</code> is the rightmost-innermost part of <code>Name</code>. The list thus represents a finite mapping from unqualified names to the corresponding qualified names.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_fail_expr/1">is_fail_expr(E:: erl_syntax:syntaxTree() ) -&gt; boolean()</a>

  </div>

    <div class="summary-synopsis"><a id="is_fail_expr-1"></a><p>Returns <code>true</code> if <code>Tree</code> represents an expression which never terminates normally. Note that the reverse does not apply. Currently, the detected cases are calls to <code>exit/1</code>, <code>throw/1</code>, <code>erlang:error/1</code> and <code>erlang:error/2</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#limit/2">limit(Tree:: erl_syntax:syntaxTree() , Depth::integer()) -&gt;  erl_syntax:syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="limit-2"></a><p>Equivalent to <code>limit(Tree, Depth, Text)</code> using the text <code>&quot;...&quot;</code> as default replacement.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#limit/3">limit(Tree:: erl_syntax:syntaxTree() , Depth::integer(), Node:: erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="limit-3"></a><p>Limits a syntax tree to a specified depth. Replaces all non-leaf subtrees in <code>Tree</code> at the given <code>Depth</code> by <code>Node</code>. If <code>Depth</code> is negative, the result is always <code>Node</code>, even if <code>Tree</code> has no subtrees.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map/2">map(F::( erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree() , Tree:: erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map-2"></a><p>Applies a function to each node of a syntax tree. The result of each application replaces the corresponding original node. The order of traversal is bottom-up.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_subtrees/2">map_subtrees(F::( erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree() , Tree:: erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_subtrees-2"></a><p>Applies a function to each immediate subtree of a syntax tree. The result of each application replaces the corresponding original node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#mapfold/3">mapfold(F::( erl_syntax:syntaxTree() , term()) -&gt; { erl_syntax:syntaxTree() , term()}, S::term(), Tree:: erl_syntax:syntaxTree() ) -&gt; { erl_syntax:syntaxTree() , term()}</a>

  </div>

    <div class="summary-synopsis"><a id="mapfold-3"></a><p>Combines map and fold in a single operation. This is similar to <code>map/2</code>, but also propagates an extra value from each application of the <code>Function</code> to the next, while doing a post-order traversal of the tree like <code>fold/3</code>. The value <code>Start</code> is passed to the first function application, and the final result is the result of the last application.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#mapfold_subtrees/3">mapfold_subtrees(F::( erl_syntax:syntaxTree() , term()) -&gt; { erl_syntax:syntaxTree() , term()}, S::term(), Tree:: erl_syntax:syntaxTree() ) -&gt; { erl_syntax:syntaxTree() , term()}</a>

  </div>

    <div class="summary-synopsis"><a id="mapfold_subtrees-3"></a><p>Does a mapfold operation over the immediate subtrees of a syntax tree. This is similar to <code>mapfold/3</code>, but only on the immediate subtrees of <code>Tree</code>, in left-to-right order; it does not include the root node of <code>Tree</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#mapfoldl_listlist/3">mapfoldl_listlist(F::(term(), term()) -&gt; {term(), term()}, S::term(), Ls::[[term()]]) -&gt; {[[term()]], term()}</a>

  </div>

    <div class="summary-synopsis"><a id="mapfoldl_listlist-3"></a><p>Like <code>lists:mapfoldl/3</code>, but over a list of lists. The list of lists in the result has the same structure as the given list of lists.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#new_variable_name/1">new_variable_name(S:: sets:set(atom()) ) -&gt; atom()</a>

  </div>

    <div class="summary-synopsis"><a id="new_variable_name-1"></a><p>Returns an atom which is not already in the set <code>Used</code>. This is equivalent to <code>new_variable_name(Function, Used)</code>, where <code>Function</code> maps a given integer <code>N</code> to the atom whose name consists of &quot;<code>V</code>&quot; followed by the numeral for <code>N</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#new_variable_name/2">new_variable_name(F::(integer()) -&gt; atom(), S:: sets:set(atom()) ) -&gt; atom()</a>

  </div>

    <div class="summary-synopsis"><a id="new_variable_name-2"></a><p>Returns a user-named atom which is not already in the set <code>Used</code>. The atom is generated by applying the given <code>Function</code> to a generated integer. Integers are generated using an algorithm which tries to keep the names randomly distributed within a reasonably small range relative to the number of elements in the set.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#new_variable_names/2">new_variable_names(N::integer(), S:: sets:set(atom()) ) -&gt; [atom()]</a>

  </div>

    <div class="summary-synopsis"><a id="new_variable_names-2"></a><p>Like <code>new_variable_name/1</code>, but generates a list of <code>N</code> new names.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#new_variable_names/3">new_variable_names(N::integer(), F::(integer()) -&gt; atom(), S:: sets:set(atom()) ) -&gt; [atom()]</a>

  </div>

    <div class="summary-synopsis"><a id="new_variable_names-3"></a><p>Like <code>new_variable_name/2</code>, but generates a list of <code>N</code> new names.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#strip_comments/1">strip_comments(Tree:: erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="strip_comments-1"></a><p>Removes all comments from all nodes of a syntax tree. All other attributes (such as position information) remain unchanged. Standalone comments in form lists are removed; any other standalone comments are changed into null-comments (no text, no indentation).</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#to_comment/1">to_comment(Tree:: erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="to_comment-1"></a><p>Equivalent to <a href="#to_comment/2">to_comment(Tree, &quot;% &quot;)</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#to_comment/2">to_comment(Tree:: erl_syntax:syntaxTree() , Prefix::string()) -&gt;  erl_syntax:syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="to_comment-2"></a><p>Equivalent to <code>to_comment(Tree, Prefix, F)</code> for a default formatting function <code>F</code>. The default <code>F</code> simply calls <code>erl_prettypr:format/1</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#to_comment/3">to_comment(Tree:: erl_syntax:syntaxTree() , Prefix::string(), F::( erl_syntax:syntaxTree() ) -&gt; string()) -&gt;  erl_syntax:syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="to_comment-3"></a><p>Transforms a syntax tree into an abstract comment. The lines of the comment contain the text for <code>Node</code>, as produced by the given <code>Printer</code> function. Each line of the comment is prefixed by the string <code>Prefix</code> (this does not include the initial &quot;<code>%</code>&quot; character of the comment line).</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#variables/1">variables(Tree:: erl_syntax:syntaxTree() ) -&gt;  sets:set(atom())</a>

  </div>

    <div class="summary-synopsis"><a id="variables-1"></a><p>Returns the names of variables occurring in a syntax tree, The result is a set of variable names represented by atoms. Macro names are not included.</p></div>

</div>

  </div>

        </section>


        <section id="functions" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#functions">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Functions
          </h1>
          <div class="functions-list">
<section class="detail" id="analyze_application/1">

  <div class="detail-header">
    <a href="#analyze_application/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_application(Node:: erl_syntax:syntaxTree() ) -&gt;  appFunName()  | arity()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_application(erl_syntax:syntaxTree()) -> <a href="#t:appFunName/0">appFunName</a>() | arity().</pre>

      </div>

<a id="analyze_application-1"></a><p>Returns the name of a called function. The result is a representation of the name of the applied function <code>F/A</code>, if <code>Node</code> represents a function application &quot;<code>&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;X_1&lt;/em&gt;, ..., &lt;em&gt;X_A&lt;/em&gt;)</code>&quot;. If the function is not explicitly named (i.e., <code>F</code> is given by some expression), only the arity <code>A</code> is returned.</p><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed application expression.</p><p><em>See also:</em> <a href="#analyze_function_name/1">analyze_function_name/1</a>.</p>
  </section>
</section>
<section class="detail" id="analyze_attribute/1">

  <div class="detail-header">
    <a href="#analyze_attribute/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_attribute(Node:: erl_syntax:syntaxTree() ) -&gt; preprocessor | {atom(), term()}</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_attribute(erl_syntax:syntaxTree()) -> preprocessor | {atom(), term()}.</pre>

      </div>

<a id="analyze_attribute-1"></a><p>Analyzes an attribute node. If <code>Node</code> represents a preprocessor directive, the atom <code>preprocessor</code> is returned. Otherwise, if <code>Node</code> represents a module attribute &quot;<code>-&lt;em&gt;Name&lt;/em&gt;...</code>&quot;, a tuple <code>{Name, Info}</code> is returned, where <code>Info</code> depends on <code>Name</code>, as follows:</p><dl><dt><code>{module, Info}</code></dt><dd><p>where <code>Info = analyze_module_attribute(Node)</code>.</p></dd><dt><code>{export, Info}</code></dt><dd><p>where <code>Info = analyze_export_attribute(Node)</code>.</p></dd><dt><code>{import, Info}</code></dt><dd><p>where <code>Info = analyze_import_attribute(Node)</code>.</p></dd><dt><code>{file, Info}</code></dt><dd><p>where <code>Info = analyze_file_attribute(Node)</code>.</p></dd><dt><code>{record, Info}</code></dt><dd><p>where <code>Info = analyze_record_attribute(Node)</code>.</p></dd><dt><code>{Name, Info}</code></dt><dd><p>where <code>{Name, Info} = analyze_wild_attribute(Node)</code>.</p></dd></dl><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed module attribute.</p><p><em>See also:</em> <a href="#analyze_export_attribute/1">analyze_export_attribute/1</a>, <a href="#analyze_file_attribute/1">analyze_file_attribute/1</a>, <a href="#analyze_import_attribute/1">analyze_import_attribute/1</a>, <a href="#analyze_module_attribute/1">analyze_module_attribute/1</a>, <a href="#analyze_record_attribute/1">analyze_record_attribute/1</a>, <a href="#analyze_wild_attribute/1">analyze_wild_attribute/1</a>.</p>
  </section>
</section>
<section class="detail" id="analyze_export_attribute/1">

  <div class="detail-header">
    <a href="#analyze_export_attribute/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_export_attribute(Node:: erl_syntax:syntaxTree() ) -&gt; [ functionName() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_export_attribute(erl_syntax:syntaxTree()) -> [<a href="#t:functionName/0">functionName</a>()].</pre>

      </div>

<a id="analyze_export_attribute-1"></a><p>Returns the list of function names declared by an export attribute. We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed export attribute.</p><p><em>See also:</em> <a href="#analyze_attribute/1">analyze_attribute/1</a>.</p>
  </section>
</section>
<section class="detail" id="analyze_file_attribute/1">

  <div class="detail-header">
    <a href="#analyze_file_attribute/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_file_attribute(Node:: erl_syntax:syntaxTree() ) -&gt; {string(), integer()}</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_file_attribute(erl_syntax:syntaxTree()) -> {string(), integer()}.</pre>

      </div>

<a id="analyze_file_attribute-1"></a><p>Returns the file name and line number of a <code>file</code> attribute. The result is the pair <code>{File, Line}</code> if <code>Node</code> represents &quot;<code>-file(File, Line).</code>&quot;.</p><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed <code>file</code> attribute.</p><p><em>See also:</em> <a href="#analyze_attribute/1">analyze_attribute/1</a>.</p>
  </section>
</section>
<section class="detail" id="analyze_form/1">

  <div class="detail-header">
    <a href="#analyze_form/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_form(Node:: erl_syntax:syntaxTree() ) -&gt; {atom(), term()} | atom()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_form(erl_syntax:syntaxTree()) -> {atom(), term()} | atom().</pre>

      </div>

<a id="analyze_form-1"></a><p>Analyzes a &quot;source code form&quot; node. If <code>Node</code> is a &quot;form&quot; type (cf. <code>erl_syntax:is_form/1</code>), the returned value is a tuple <code>{Type, Info}</code> where <code>Type</code> is the node type and <code>Info</code> depends on <code>Type</code>, as follows:</p><dl><dt><code>{attribute, Info}</code></dt><dd><p>where <code>Info = analyze_attribute(Node)</code>.</p></dd><dt><code>{error_marker, Info}</code></dt><dd><p>where <code>Info = erl_syntax:error_marker_info(Node)</code>.</p></dd><dt><code>{function, Info}</code></dt><dd><p>where <code>Info = analyze_function(Node)</code>.</p></dd><dt><code>{warning_marker, Info}</code></dt><dd><p>where <code>Info = erl_syntax:warning_marker_info(Node)</code>.</p></dd></dl><p>For other types of forms, only the node type is returned.</p><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> is not well-formed.</p><p><em>See also:</em> <a href="#analyze_attribute/1">analyze_attribute/1</a>, <a href="#analyze_function/1">analyze_function/1</a>, <a href="erl_syntax.html#error_marker_info/1">erl_syntax:error_marker_info/1</a>, <a href="erl_syntax.html#is_form/1">erl_syntax:is_form/1</a>, <a href="erl_syntax.html#warning_marker_info/1">erl_syntax:warning_marker_info/1</a>.</p>
  </section>
</section>
<section class="detail" id="analyze_forms/1">

  <div class="detail-header">
    <a href="#analyze_forms/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_forms(Forms:: erl_syntax:forms() ) -&gt; [ info_pair() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_forms(erl_syntax:forms()) -> [info_pair()].</pre>

      </div>

<a id="analyze_forms-1"></a><p>Analyzes a sequence of &quot;program forms&quot;. The given <code>Forms</code> may be a single syntax tree of type <code>form_list</code>, or a list of &quot;program form&quot; syntax trees. The returned value is a list of pairs <code>{Key, Info}</code>, where each value of <code>Key</code> occurs at most once in the list; the absence of a particular key indicates that there is no well-defined value for that key.</p><p>Each entry in the resulting list contains the following corresponding information about the program forms:</p><dl><dt><code>{attributes, Attributes}</code></dt><dd><ul><li><p><code>Attributes = [{atom(), term()}]</code></p></li></ul><p><code>Attributes</code> is a list of pairs representing the names and corresponding values of all so-called &quot;wild&quot; attributes (as e.g. &quot;<code>-compile(...)</code>&quot;) occurring in <code>Forms</code> (cf. <code>analyze_wild_attribute/1</code>). We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p></dd><dt><code>{errors, Errors}</code></dt><dd><ul><li><p><code>Errors = [term()]</code></p></li></ul><p><code>Errors</code> is the list of error descriptors of all <code>error_marker</code> nodes that occur in <code>Forms</code>. The order of listing is not defined.</p></dd><dt><code>{exports, Exports}</code></dt><dd><ul><li><p><code>Exports = [FunctionName]</code></p></li><li><p><code>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</code></p></li><li><p><code>ModuleName = atom()</code></p></li></ul><p><code>Exports</code> is a list of representations of those function names that are listed by export declaration attributes in <code>Forms</code> (cf. <code>analyze_export_attribute/1</code>). We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p></dd><dt><code>{functions, Functions}</code></dt><dd><ul><li><p><code>Functions = [{atom(), integer()}]</code></p></li></ul><p><code>Functions</code> is a list of the names of the functions that are defined in <code>Forms</code> (cf. <code>analyze_function/1</code>). We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p></dd><dt><code>{imports, Imports}</code></dt><dd><ul><li><p><code>Imports = [{Module, Names}]</code></p></li><li><p><code>Module = atom()</code></p></li><li><p><code>Names = [FunctionName]</code></p></li><li><p><code>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</code></p></li><li><p><code>ModuleName = atom()</code></p></li></ul><p><code>Imports</code> is a list of pairs representing those module names and corresponding function names that are listed by import declaration attributes in <code>Forms</code> (cf. <code>analyze_import_attribute/1</code>), where each <code>Module</code> occurs at most once in <code>Imports</code>. We do not guarantee that each name occurs at most once in the lists of function names. The order of listing is not defined.</p></dd><dt><code>{module, ModuleName}</code></dt><dd><ul><li><p><code>ModuleName = atom()</code></p></li></ul><p><code>ModuleName</code> is the name declared by a module attribute in <code>Forms</code>. If no module name is defined in <code>Forms</code>, the result will contain no entry for the <code>module</code> key. If multiple module name declarations should occur, all but the first will be ignored.</p></dd><dt><code>{records, Records}</code></dt><dd><ul><li><p><code>Records = [{atom(), Fields}]</code></p></li><li><p><code>Fields = [{atom(), {Default, Type}}]</code></p></li><li><p><code>Default = none | syntaxTree()</code></p></li><li><p><code>Type = none | syntaxTree()</code></p></li></ul><p><code>Records</code> is a list of pairs representing the names and corresponding field declarations of all record declaration attributes occurring in <code>Forms</code>. For fields declared without a default value, the corresponding value for <code>Default</code> is the atom <code>none</code>. Similarly, for fields declared without a type, the corresponding value for <code>Type</code> is the atom <code>none</code> (cf. <code>analyze_record_attribute/1</code>). We do not guarantee that each record name occurs at most once in the list. The order of listing is not defined.</p></dd><dt><code>{warnings, Warnings}</code></dt><dd><ul><li><p><code>Warnings = [term()]</code></p></li></ul><p><code>Warnings</code> is the list of error descriptors of all <code>warning_marker</code> nodes that occur in <code>Forms</code>. The order of listing is not defined.</p></dd></dl><p>The evaluation throws <code>syntax_error</code> if an ill-formed Erlang construct is encountered.</p><p><em>See also:</em> <a href="#analyze_export_attribute/1">analyze_export_attribute/1</a>, <a href="#analyze_function/1">analyze_function/1</a>, <a href="#analyze_import_attribute/1">analyze_import_attribute/1</a>, <a href="#analyze_record_attribute/1">analyze_record_attribute/1</a>, <a href="#analyze_wild_attribute/1">analyze_wild_attribute/1</a>, <a href="erl_syntax.html#error_marker_info/1">erl_syntax:error_marker_info/1</a>, <a href="erl_syntax.html#warning_marker_info/1">erl_syntax:warning_marker_info/1</a>.</p>
  </section>
</section>
<section class="detail" id="analyze_function/1">

  <div class="detail-header">
    <a href="#analyze_function/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_function(Node:: erl_syntax:syntaxTree() ) -&gt; {atom(), arity()}</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_function(erl_syntax:syntaxTree()) -> {atom(), arity()}.</pre>

      </div>

<a id="analyze_function-1"></a><p>Returns the name and arity of a function definition. The result is a pair <code>{Name, A}</code> if <code>Node</code> represents a function definition &quot;<code>Name(&lt;em&gt;P_1&lt;/em&gt;, ..., &lt;em&gt;P_A&lt;/em&gt;) -&gt; ...</code>&quot;.</p><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed function definition.</p>
  </section>
</section>
<section class="detail" id="analyze_function_name/1">

  <div class="detail-header">
    <a href="#analyze_function_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_function_name(Node:: erl_syntax:syntaxTree() ) -&gt;  functionName()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_function_name(erl_syntax:syntaxTree()) -> <a href="#t:functionName/0">functionName</a>().</pre>

      </div>

<a id="analyze_function_name-1"></a><p>Returns the function name represented by a syntax tree. If <code>Node</code> represents a function name, such as &quot;<code>foo/1</code>&quot; or &quot;<code>bloggs:fred/2</code>&quot;, a uniform representation of that name is returned. Different nestings of arity and module name qualifiers in the syntax tree does not affect the result.</p><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed function name.</p>
  </section>
</section>
<section class="detail" id="analyze_implicit_fun/1">

  <div class="detail-header">
    <a href="#analyze_implicit_fun/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_implicit_fun(Node:: erl_syntax:syntaxTree() ) -&gt;  functionName()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_implicit_fun(erl_syntax:syntaxTree()) -> <a href="#t:functionName/0">functionName</a>().</pre>

      </div>

<a id="analyze_implicit_fun-1"></a><p>Returns the name of an implicit fun expression &quot;<code>fun &lt;em&gt;F&lt;/em&gt;</code>&quot;. The result is a representation of the function name <code>F</code>. (Cf. <code>analyze_function_name/1</code>.)</p><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed implicit fun.</p><p><em>See also:</em> <a href="#analyze_function_name/1">analyze_function_name/1</a>.</p>
  </section>
</section>
<section class="detail" id="analyze_import_attribute/1">

  <div class="detail-header">
    <a href="#analyze_import_attribute/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_import_attribute(Node:: erl_syntax:syntaxTree() ) -&gt; {atom(), [ functionName() ]} | atom()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_import_attribute(erl_syntax:syntaxTree()) -> {atom(), [<a href="#t:functionName/0">functionName</a>()]} | atom().</pre>

      </div>

<a id="analyze_import_attribute-1"></a><p>Returns the module name and (if present) list of function names declared by an import attribute. The returned value is an atom <code>Module</code> or a pair <code>{Module, Names}</code>, where <code>Names</code> is a list of function names declared as imported from the module named by <code>Module</code>. We do not guarantee that each name occurs at most once in <code>Names</code>. The order of listing is not defined.</p><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed import attribute.</p><p><em>See also:</em> <a href="#analyze_attribute/1">analyze_attribute/1</a>.</p>
  </section>
</section>
<section class="detail" id="analyze_module_attribute/1">

  <div class="detail-header">
    <a href="#analyze_module_attribute/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_module_attribute(Node:: erl_syntax:syntaxTree() ) -&gt; atom() | {atom(), [atom()]}</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_module_attribute(erl_syntax:syntaxTree()) -> atom() | {atom(), [atom()]}.</pre>

      </div>

<a id="analyze_module_attribute-1"></a><p>Returns the module name and possible parameters declared by a module attribute. If the attribute is a plain module declaration such as <code>-module(name)</code>, the result is the module name. If the attribute is a parameterized module declaration, the result is a tuple containing the module name and a list of the parameter variable names.</p><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed module attribute.</p><p><em>See also:</em> <a href="#analyze_attribute/1">analyze_attribute/1</a>.</p>
  </section>
</section>
<section class="detail" id="analyze_record_attribute/1">

  <div class="detail-header">
    <a href="#analyze_record_attribute/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_record_attribute(Node:: erl_syntax:syntaxTree() ) -&gt; {atom(),  fields() }</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_record_attribute(erl_syntax:syntaxTree()) -> {atom(), <a href="#t:fields/0">fields</a>()}.</pre>

      </div>

<a id="analyze_record_attribute-1"></a><p>Returns the name and the list of fields of a record declaration attribute. The result is a pair <code>{Name, Fields}</code>, if <code>Node</code> represents &quot;<code>-record(Name, {...}).</code>&quot;, where <code>Fields</code> is a list of pairs <code>{Label, {Default, Type}}</code> for each field &quot;<code>Label</code>&quot;, &quot;<code>Label = &lt;em&gt;Default&lt;/em&gt;</code>&quot;, &quot;<code>Label :: &lt;em&gt;Type&lt;/em&gt;</code>&quot;, or &quot;<code>Label = &lt;em&gt;Default&lt;/em&gt; :: &lt;em&gt;Type&lt;/em&gt;</code>&quot; in the declaration, listed in left-to-right order. If the field has no default-value declaration, the value for <code>Default</code> will be the atom <code>none</code>. If the field has no type declaration, the value for <code>Type</code> will be the atom <code>none</code>. We do not guarantee that each label occurs at most once in the list.</p><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed record declaration attribute.</p><p><em>See also:</em> <a href="#analyze_attribute/1">analyze_attribute/1</a>, <a href="#analyze_record_field/1">analyze_record_field/1</a>.</p>
  </section>
</section>
<section class="detail" id="analyze_record_expr/1">

  <div class="detail-header">
    <a href="#analyze_record_expr/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_record_expr(Node:: erl_syntax:syntaxTree() ) -&gt; {atom(),  info() } | atom()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_record_expr(erl_syntax:syntaxTree()) -> {atom(), <a href="#t:info/0">info</a>()} | atom().</pre>

      </div>

<a id="analyze_record_expr-1"></a><p>Returns the record name and field name/names of a record expression. If <code>Node</code> has type <code>record_expr</code>, <code>record_index_expr</code> or <code>record_access</code>, a pair <code>{Type, Info}</code> is returned, otherwise an atom <code>Type</code> is returned. <code>Type</code> is the node type of <code>Node</code>, and <code>Info</code> depends on <code>Type</code>, as follows:</p><dl><dt><code>record_expr</code>:</dt><dd><p><code>{atom(), [{atom(), Value}]}</code></p></dd><dt><code>record_access</code>:</dt><dd><p><code>{atom(), atom()}</code></p></dd><dt><code>record_index_expr</code>:</dt><dd><p><code>{atom(), atom()}</code></p></dd></dl><p></p><p>For a <code>record_expr</code> node, <code>Info</code> represents the record name and the list of descriptors for the involved fields, listed in the order they appear. A field descriptor is a pair <code>{Label, Value}</code>, if <code>Node</code> represents &quot;<code>Label = &lt;em&gt;Value&lt;/em&gt;</code>&quot;. For a <code>record_access</code> node, <code>Info</code> represents the record name and the field name. For a <code>record_index_expr</code> node, <code>Info</code> represents the record name and the name field name.</p><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> represents a record expression that is not well-formed.</p><p><em>See also:</em> <a href="#analyze_record_attribute/1">analyze_record_attribute/1</a>, <a href="#analyze_record_field/1">analyze_record_field/1</a>.</p>
  </section>
</section>
<section class="detail" id="analyze_record_field/1">

  <div class="detail-header">
    <a href="#analyze_record_field/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_record_field(Node:: erl_syntax:syntaxTree() ) -&gt;  field()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_record_field(erl_syntax:syntaxTree()) -> <a href="#t:field/0">field</a>().</pre>

      </div>

<a id="analyze_record_field-1"></a><p>Returns the label, value-expression, and type of a record field specifier. The result is a pair <code>{Label, {Default, Type}}</code>, if <code>Node</code> represents &quot;<code>Label</code>&quot;, &quot;<code>Label = &lt;em&gt;Default&lt;/em&gt;</code>&quot;, &quot;<code>Label :: &lt;em&gt;Type&lt;/em&gt;</code>&quot;, or &quot;<code>Label = &lt;em&gt;Default&lt;/em&gt; :: &lt;em&gt;Type&lt;/em&gt;</code>&quot;. If the field has no value-expression, the value for <code>Default</code> will be the atom <code>none</code>. If the field has no type, the value for <code>Type</code> will be the atom <code>none</code>.</p><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed record field specifier.</p><p><em>See also:</em> <a href="#analyze_record_attribute/1">analyze_record_attribute/1</a>, <a href="#analyze_record_expr/1">analyze_record_expr/1</a>.</p>
  </section>
</section>
<section class="detail" id="analyze_type_application/1">

  <div class="detail-header">
    <a href="#analyze_type_application/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_type_application(Node:: erl_syntax:syntaxTree() ) -&gt;  typeName()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_type_application(erl_syntax:syntaxTree()) -> <a href="#t:typeName/0">typeName</a>().</pre>

      </div>

<a id="analyze_type_application-1"></a><p>Returns the name of a used type. The result is a representation of the name of the used pre-defined or local type <code>N/A</code>, if <code>Node</code> represents a local (user) type application &quot;<code>&lt;em&gt;N&lt;/em&gt;(&lt;em&gt;T_1&lt;/em&gt;, ..., &lt;em&gt;T_A&lt;/em&gt;)</code>&quot;, or a representation of the name of the used remote type <code>M:N/A</code> if <code>Node</code> represents a remote user type application &quot;<code>&lt;em&gt;M&lt;/em&gt;:&lt;em&gt;N&lt;/em&gt;(&lt;em&gt;T_1&lt;/em&gt;, ..., &lt;em&gt;T_A&lt;/em&gt;)</code>&quot;.</p><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed (user) type application expression.</p><p><em>See also:</em> <a href="#analyze_type_name/1">analyze_type_name/1</a>.</p>
  </section>
</section>
<section class="detail" id="analyze_type_name/1">

  <div class="detail-header">
    <a href="#analyze_type_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_type_name(Node:: erl_syntax:syntaxTree() ) -&gt;  typeName()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_type_name(erl_syntax:syntaxTree()) -> <a href="#t:typeName/0">typeName</a>().</pre>

      </div>

<a id="analyze_type_name-1"></a><p>Returns the type name represented by a syntax tree. If <code>Node</code> represents a type name, such as &quot;<code>foo/1</code>&quot; or &quot;<code>bloggs:fred/2</code>&quot;, a uniform representation of that name is returned.</p><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed type name.</p>
  </section>
</section>
<section class="detail" id="analyze_wild_attribute/1">

  <div class="detail-header">
    <a href="#analyze_wild_attribute/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">analyze_wild_attribute(Node:: erl_syntax:syntaxTree() ) -&gt; {atom(), term()}</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>analyze_wild_attribute(erl_syntax:syntaxTree()) -> {atom(), term()}.</pre>

      </div>

<a id="analyze_wild_attribute-1"></a><p>Returns the name and value of a &quot;wild&quot; attribute. The result is the pair <code>{Name, Value}</code>, if <code>Node</code> represents &quot;<code>-Name(Value)</code>&quot;.</p><p>Note that no checking is done whether <code>Name</code> is a reserved attribute name such as <code>module</code> or <code>export</code>: it is assumed that the attribute is &quot;wild&quot;.</p><p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed wild attribute.</p><p><em>See also:</em> <a href="#analyze_attribute/1">analyze_attribute/1</a>.</p>
  </section>
</section>
<section class="detail" id="annotate_bindings/1">

  <div class="detail-header">
    <a href="#annotate_bindings/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">annotate_bindings(Tree:: erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>annotate_bindings(erl_syntax:syntaxTree()) -> erl_syntax:syntaxTree().</pre>

      </div>

<a id="annotate_bindings-1"></a><p>Adds or updates annotations on nodes in a syntax tree. Equivalent to <code>annotate_bindings(Tree, Bindings)</code> where the top-level environment <code>Bindings</code> is taken from the annotation <code>{env, Bindings}</code> on the root node of <code>Tree</code>. An exception is thrown if no such annotation should exist.</p><p><em>See also:</em> <a href="#annotate_bindings/2">annotate_bindings/2</a>.</p>
  </section>
</section>
<section class="detail" id="annotate_bindings/2">

  <div class="detail-header">
    <a href="#annotate_bindings/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">annotate_bindings(Tree:: erl_syntax:syntaxTree() , Env:: ordsets:ordset(atom()) ) -&gt;  erl_syntax:syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>annotate_bindings(erl_syntax:syntaxTree(), <a href="https://wojtekmach.pl/otp_docs/stdlib/ordsets.html#t:ordset/1">ordsets:ordset</a>(atom())) -> erl_syntax:syntaxTree().</pre>

      </div>

<a id="annotate_bindings-2"></a><p>Adds or updates annotations on nodes in a syntax tree. <code>Bindings</code> specifies the set of bound variables in the environment of the top level node. The following annotations are affected:</p><ul><li><p><code>{env, Vars}</code>, representing the input environment of the subtree.</p></li><li><p><code>{bound, Vars}</code>, representing the variables that are bound in the subtree.</p></li><li><p><code>{free, Vars}</code>, representing the free variables in the subtree.</p></li></ul><p><code>Bindings</code> and <code>Vars</code> are ordered-set lists (cf. module <code>ordsets</code>) of atoms representing variable names.</p><p><em>See also:</em> <a href="https://wojtekmach.pl/otp_docs/stdlib/ordsets.html">ordsets(3)</a>, <a href="#annotate_bindings/1">annotate_bindings/1</a>.</p>
  </section>
</section>
<section class="detail" id="fold/3">

  <div class="detail-header">
    <a href="#fold/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">fold(F::( erl_syntax:syntaxTree() , term()) -&gt; term(), S::term(), Tree:: erl_syntax:syntaxTree() ) -&gt; term()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>fold(fun((erl_syntax:syntaxTree(), term()) -> term()), term(), erl_syntax:syntaxTree()) -> term().</pre>

      </div>

<a id="fold-3"></a><p>Folds a function over all nodes of a syntax tree. The result is the value of <code>Function(X1, Function(X2, ... Function(Xn, Start) ... ))</code>, where <code>[X1, X2, ..., Xn]</code> are the nodes of <code>Tree</code> in a post-order traversal.</p><p><em>See also:</em> <a href="#fold_subtrees/3">fold_subtrees/3</a>, <a href="#foldl_listlist/3">foldl_listlist/3</a>.</p>
  </section>
</section>
<section class="detail" id="fold_subtrees/3">

  <div class="detail-header">
    <a href="#fold_subtrees/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">fold_subtrees(F::( erl_syntax:syntaxTree() , term()) -&gt; term(), S::term(), Tree:: erl_syntax:syntaxTree() ) -&gt; term()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>fold_subtrees(fun((erl_syntax:syntaxTree(), term()) -> term()), term(), erl_syntax:syntaxTree()) ->
                 term().</pre>

      </div>

<a id="fold_subtrees-3"></a><p>Folds a function over the immediate subtrees of a syntax tree. This is similar to <code>fold/3</code>, but only on the immediate subtrees of <code>Tree</code>, in left-to-right order; it does not include the root node of <code>Tree</code>.</p><p><em>See also:</em> <a href="#fold/3">fold/3</a>.</p>
  </section>
</section>
<section class="detail" id="foldl_listlist/3">

  <div class="detail-header">
    <a href="#foldl_listlist/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">foldl_listlist(F::(term(), term()) -&gt; term(), S::term(), Ls::[[term()]]) -&gt; term()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>foldl_listlist(fun((term(), term()) -> term()), term(), [[term()]]) -> term().</pre>

      </div>

<a id="foldl_listlist-3"></a><p>Like <code>lists:foldl/3</code>, but over a list of lists.</p><p><em>See also:</em> <a href="https://wojtekmach.pl/otp_docs/stdlib/lists.html#foldl/3">lists:foldl/3</a>, <a href="#fold/3">fold/3</a>.</p>
  </section>
</section>
<section class="detail" id="function_name_expansions/1">

  <div class="detail-header">
    <a href="#function_name_expansions/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">function_name_expansions(Fs::[ name() ]) -&gt; [{ shortname() ,  name() }]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>function_name_expansions([<a href="#t:name/0">name</a>()]) -> [{<a href="#t:shortname/0">shortname</a>(), <a href="#t:name/0">name</a>()}].</pre>

      </div>

<a id="function_name_expansions-1"></a><p>Creates a mapping from corresponding short names to full function names. Names are represented by nested tuples of atoms and integers (cf. <code>analyze_function_name/1</code>). The result is a list containing a pair <code>{ShortName, Name}</code> for each element <code>Name</code> in the given list, where the corresponding <code>ShortName</code> is the rightmost-innermost part of <code>Name</code>. The list thus represents a finite mapping from unqualified names to the corresponding qualified names.</p><p>Note: the resulting list can contain more than one tuple <code>{ShortName, Name}</code> for the same <code>ShortName</code>, possibly with different values for <code>Name</code>, depending on the given list.</p><p><em>See also:</em> <a href="#analyze_function_name/1">analyze_function_name/1</a>.</p>
  </section>
</section>
<section class="detail" id="is_fail_expr/1">

  <div class="detail-header">
    <a href="#is_fail_expr/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">is_fail_expr(E:: erl_syntax:syntaxTree() ) -&gt; boolean()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>is_fail_expr(erl_syntax:syntaxTree()) -> boolean().</pre>

      </div>

<a id="is_fail_expr-1"></a><p>Returns <code>true</code> if <code>Tree</code> represents an expression which never terminates normally. Note that the reverse does not apply. Currently, the detected cases are calls to <code>exit/1</code>, <code>throw/1</code>, <code>erlang:error/1</code> and <code>erlang:error/2</code>.</p><p><em>See also:</em> <a href="https://wojtekmach.pl/otp_docs/erts/erlang.html#error/1">erlang:error/1</a>, <a href="https://wojtekmach.pl/otp_docs/erts/erlang.html#error/2">erlang:error/2</a>, <a href="https://wojtekmach.pl/otp_docs/erts/erlang.html#exit/1">erlang:exit/1</a>, <a href="https://wojtekmach.pl/otp_docs/erts/erlang.html#throw/1">erlang:throw/1</a>.</p>
  </section>
</section>
<section class="detail" id="limit/2">

  <div class="detail-header">
    <a href="#limit/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">limit(Tree:: erl_syntax:syntaxTree() , Depth::integer()) -&gt;  erl_syntax:syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>limit(erl_syntax:syntaxTree(), integer()) -> erl_syntax:syntaxTree().</pre>

      </div>

<a id="limit-2"></a><p>Equivalent to <code>limit(Tree, Depth, Text)</code> using the text <code>&quot;...&quot;</code> as default replacement.</p><p><em>See also:</em> <a href="#limit/3">limit/3</a>, <a href="erl_syntax.html#text/1">erl_syntax:text/1</a>.</p>
  </section>
</section>
<section class="detail" id="limit/3">

  <div class="detail-header">
    <a href="#limit/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">limit(Tree:: erl_syntax:syntaxTree() , Depth::integer(), Node:: erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>limit(erl_syntax:syntaxTree(), integer(), erl_syntax:syntaxTree()) -> erl_syntax:syntaxTree().</pre>

      </div>

<a id="limit-3"></a><p>Limits a syntax tree to a specified depth. Replaces all non-leaf subtrees in <code>Tree</code> at the given <code>Depth</code> by <code>Node</code>. If <code>Depth</code> is negative, the result is always <code>Node</code>, even if <code>Tree</code> has no subtrees.</p><p>When a group of subtrees (as e.g., the argument list of an <code>application</code> node) is at the specified depth, and there are two or more subtrees in the group, these will be collectively replaced by <code>Node</code> even if they are leaf nodes. Groups of subtrees that are above the specified depth will be limited in size, as if each subsequent tree in the group were one level deeper than the previous. E.g., if <code>Tree</code> represents a list of integers &quot;<code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>&quot;, the result of <code>limit(Tree, 5)</code> will represent <code>[1, 2, 3, 4, ...]</code>.</p><p>The resulting syntax tree is typically only useful for pretty-printing or similar visual formatting.</p><p><em>See also:</em> <a href="#limit/2">limit/2</a>.</p>
  </section>
</section>
<section class="detail" id="map/2">

  <div class="detail-header">
    <a href="#map/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map(F::( erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree() , Tree:: erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map(fun((erl_syntax:syntaxTree()) -> erl_syntax:syntaxTree()), erl_syntax:syntaxTree()) ->
       erl_syntax:syntaxTree().</pre>

      </div>

<a id="map-2"></a><p>Applies a function to each node of a syntax tree. The result of each application replaces the corresponding original node. The order of traversal is bottom-up.</p><p><em>See also:</em> <a href="#map_subtrees/2">map_subtrees/2</a>.</p>
  </section>
</section>
<section class="detail" id="map_subtrees/2">

  <div class="detail-header">
    <a href="#map_subtrees/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_subtrees(F::( erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree() , Tree:: erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_subtrees(fun((erl_syntax:syntaxTree()) -> erl_syntax:syntaxTree()), erl_syntax:syntaxTree()) ->
                erl_syntax:syntaxTree().</pre>

      </div>

<a id="map_subtrees-2"></a><p>Applies a function to each immediate subtree of a syntax tree. The result of each application replaces the corresponding original node.</p><p><em>See also:</em> <a href="#map/2">map/2</a>.</p>
  </section>
</section>
<section class="detail" id="mapfold/3">

  <div class="detail-header">
    <a href="#mapfold/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">mapfold(F::( erl_syntax:syntaxTree() , term()) -&gt; { erl_syntax:syntaxTree() , term()}, S::term(), Tree:: erl_syntax:syntaxTree() ) -&gt; { erl_syntax:syntaxTree() , term()}</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>mapfold(fun((erl_syntax:syntaxTree(), term()) -> {erl_syntax:syntaxTree(), term()}),
        term(),
        erl_syntax:syntaxTree()) ->
           {erl_syntax:syntaxTree(), term()}.</pre>

      </div>

<a id="mapfold-3"></a><p>Combines map and fold in a single operation. This is similar to <code>map/2</code>, but also propagates an extra value from each application of the <code>Function</code> to the next, while doing a post-order traversal of the tree like <code>fold/3</code>. The value <code>Start</code> is passed to the first function application, and the final result is the result of the last application.</p><p><em>See also:</em> <a href="#fold/3">fold/3</a>, <a href="#map/2">map/2</a>.</p>
  </section>
</section>
<section class="detail" id="mapfold_subtrees/3">

  <div class="detail-header">
    <a href="#mapfold_subtrees/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">mapfold_subtrees(F::( erl_syntax:syntaxTree() , term()) -&gt; { erl_syntax:syntaxTree() , term()}, S::term(), Tree:: erl_syntax:syntaxTree() ) -&gt; { erl_syntax:syntaxTree() , term()}</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>mapfold_subtrees(fun((erl_syntax:syntaxTree(), term()) -> {erl_syntax:syntaxTree(), term()}),
                 term(),
                 erl_syntax:syntaxTree()) ->
                    {erl_syntax:syntaxTree(), term()}.</pre>

      </div>

<a id="mapfold_subtrees-3"></a><p>Does a mapfold operation over the immediate subtrees of a syntax tree. This is similar to <code>mapfold/3</code>, but only on the immediate subtrees of <code>Tree</code>, in left-to-right order; it does not include the root node of <code>Tree</code>.</p><p><em>See also:</em> <a href="#mapfold/3">mapfold/3</a>.</p>
  </section>
</section>
<section class="detail" id="mapfoldl_listlist/3">

  <div class="detail-header">
    <a href="#mapfoldl_listlist/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">mapfoldl_listlist(F::(term(), term()) -&gt; {term(), term()}, S::term(), Ls::[[term()]]) -&gt; {[[term()]], term()}</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>mapfoldl_listlist(fun((term(), term()) -> {term(), term()}), term(), [[term()]]) ->
                     {[[term()]], term()}.</pre>

      </div>

<a id="mapfoldl_listlist-3"></a><p>Like <code>lists:mapfoldl/3</code>, but over a list of lists. The list of lists in the result has the same structure as the given list of lists.</p>
  </section>
</section>
<section class="detail" id="new_variable_name/1">

  <div class="detail-header">
    <a href="#new_variable_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">new_variable_name(S:: sets:set(atom()) ) -&gt; atom()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>new_variable_name(<a href="https://wojtekmach.pl/otp_docs/stdlib/sets.html#t:set/1">sets:set</a>(atom())) -> atom().</pre>

      </div>

<a id="new_variable_name-1"></a><p>Returns an atom which is not already in the set <code>Used</code>. This is equivalent to <code>new_variable_name(Function, Used)</code>, where <code>Function</code> maps a given integer <code>N</code> to the atom whose name consists of &quot;<code>V</code>&quot; followed by the numeral for <code>N</code>.</p><p><em>See also:</em> <a href="#new_variable_name/2">new_variable_name/2</a>.</p>
  </section>
</section>
<section class="detail" id="new_variable_name/2">

  <div class="detail-header">
    <a href="#new_variable_name/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">new_variable_name(F::(integer()) -&gt; atom(), S:: sets:set(atom()) ) -&gt; atom()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>new_variable_name(fun((integer()) -> atom()), <a href="https://wojtekmach.pl/otp_docs/stdlib/sets.html#t:set/1">sets:set</a>(atom())) -> atom().</pre>

      </div>

<a id="new_variable_name-2"></a><p>Returns a user-named atom which is not already in the set <code>Used</code>. The atom is generated by applying the given <code>Function</code> to a generated integer. Integers are generated using an algorithm which tries to keep the names randomly distributed within a reasonably small range relative to the number of elements in the set.</p><p>This function uses the module <code>rand</code> to generate new keys. The seed it uses may be initialized by calling <code>rand:seed/1</code> or <code>rand:seed/2</code> before this function is first called.</p><p><em>See also:</em> <a href="https://wojtekmach.pl/otp_docs/stdlib/random.html">random(3)</a>, <a href="https://wojtekmach.pl/otp_docs/stdlib/sets.html">sets(3)</a>, <a href="#new_variable_name/1">new_variable_name/1</a>.</p>
  </section>
</section>
<section class="detail" id="new_variable_names/2">

  <div class="detail-header">
    <a href="#new_variable_names/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">new_variable_names(N::integer(), S:: sets:set(atom()) ) -&gt; [atom()]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>new_variable_names(integer(), <a href="https://wojtekmach.pl/otp_docs/stdlib/sets.html#t:set/1">sets:set</a>(atom())) -> [atom()].</pre>

      </div>

<a id="new_variable_names-2"></a><p>Like <code>new_variable_name/1</code>, but generates a list of <code>N</code> new names.</p><p><em>See also:</em> <a href="#new_variable_name/1">new_variable_name/1</a>.</p>
  </section>
</section>
<section class="detail" id="new_variable_names/3">

  <div class="detail-header">
    <a href="#new_variable_names/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">new_variable_names(N::integer(), F::(integer()) -&gt; atom(), S:: sets:set(atom()) ) -&gt; [atom()]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>new_variable_names(integer(), fun((integer()) -> atom()), <a href="https://wojtekmach.pl/otp_docs/stdlib/sets.html#t:set/1">sets:set</a>(atom())) -> [atom()].</pre>

      </div>

<a id="new_variable_names-3"></a><p>Like <code>new_variable_name/2</code>, but generates a list of <code>N</code> new names.</p><p><em>See also:</em> <a href="#new_variable_name/2">new_variable_name/2</a>.</p>
  </section>
</section>
<section class="detail" id="strip_comments/1">

  <div class="detail-header">
    <a href="#strip_comments/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">strip_comments(Tree:: erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>strip_comments(erl_syntax:syntaxTree()) -> erl_syntax:syntaxTree().</pre>

      </div>

<a id="strip_comments-1"></a><p>Removes all comments from all nodes of a syntax tree. All other attributes (such as position information) remain unchanged. Standalone comments in form lists are removed; any other standalone comments are changed into null-comments (no text, no indentation).</p>
  </section>
</section>
<section class="detail" id="to_comment/1">

  <div class="detail-header">
    <a href="#to_comment/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">to_comment(Tree:: erl_syntax:syntaxTree() ) -&gt;  erl_syntax:syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>to_comment(erl_syntax:syntaxTree()) -> erl_syntax:syntaxTree().</pre>

      </div>

<a id="to_comment-1"></a><p>Equivalent to <a href="#to_comment/2">to_comment(Tree, &quot;% &quot;)</a>.</p>
  </section>
</section>
<section class="detail" id="to_comment/2">

  <div class="detail-header">
    <a href="#to_comment/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">to_comment(Tree:: erl_syntax:syntaxTree() , Prefix::string()) -&gt;  erl_syntax:syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>to_comment(erl_syntax:syntaxTree(), string()) -> erl_syntax:syntaxTree().</pre>

      </div>

<a id="to_comment-2"></a><p>Equivalent to <code>to_comment(Tree, Prefix, F)</code> for a default formatting function <code>F</code>. The default <code>F</code> simply calls <code>erl_prettypr:format/1</code>.</p><p><em>See also:</em> <a href="#to_comment/3">to_comment/3</a>, <a href="erl_prettypr.html#format/1">erl_prettypr:format/1</a>.</p>
  </section>
</section>
<section class="detail" id="to_comment/3">

  <div class="detail-header">
    <a href="#to_comment/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">to_comment(Tree:: erl_syntax:syntaxTree() , Prefix::string(), F::( erl_syntax:syntaxTree() ) -&gt; string()) -&gt;  erl_syntax:syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>to_comment(erl_syntax:syntaxTree(), string(), fun((erl_syntax:syntaxTree()) -> string())) ->
              erl_syntax:syntaxTree().</pre>

      </div>

<a id="to_comment-3"></a><p>Transforms a syntax tree into an abstract comment. The lines of the comment contain the text for <code>Node</code>, as produced by the given <code>Printer</code> function. Each line of the comment is prefixed by the string <code>Prefix</code> (this does not include the initial &quot;<code>%</code>&quot; character of the comment line).</p><p>For example, the result of <code>to_comment(erl_syntax:abstract([a,b,c]))</code> represents</p><pre><code class="makeup erlang"><span class="w">          </span><span class="c1">%% [a,b,c]</span></code></pre><p>(cf. <code>to_comment/1</code>).</p><p>Note: the text returned by the formatting function will be split automatically into separate comment lines at each line break. No extra work is needed.</p><p><em>See also:</em> <a href="#to_comment/1">to_comment/1</a>, <a href="#to_comment/2">to_comment/2</a>.</p>
  </section>
</section>
<section class="detail" id="variables/1">

  <div class="detail-header">
    <a href="#variables/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">variables(Tree:: erl_syntax:syntaxTree() ) -&gt;  sets:set(atom())</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>variables(erl_syntax:syntaxTree()) -> <a href="https://wojtekmach.pl/otp_docs/stdlib/sets.html#t:set/1">sets:set</a>(atom()).</pre>

      </div>

<a id="variables-1"></a><p>Returns the names of variables occurring in a syntax tree, The result is a set of variable names represented by atoms. Macro names are not included.</p><p><em>See also:</em> <a href="https://wojtekmach.pl/otp_docs/stdlib/sets.html">sets(3)</a>.</p>
  </section>
</section>

          </div>
        </section>

      <footer class="footer">

        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.25.1) for the
            <a href="https://elixir-lang.org" title="Elixir" target="_blank">Elixir programming language</a>.
          </span>
          <span class="line">
            Designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>

            <a href="api-reference.html" title="API reference" class="line footer-button">API Reference</a>

          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button display-quick-switch">
            Go to a HexDocs package
          </button>
          <button class="line footer-button tooltips-toggle">
            <span class="tooltips-option-disable">Disable tooltips</span>
            <span class="tooltips-option-enable">Enable tooltips</span>
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
