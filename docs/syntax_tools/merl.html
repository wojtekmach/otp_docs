<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.25.1">
    <meta name="project" content="syntax_tools v2.6">

    <title>merl â€” syntax_tools v2.6</title>
    <link rel="stylesheet" href="dist/erlang-951161c89561e05735a5.css" />

    <script src="dist/sidebar_items-33b0a6fec9.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-f97730d45ef67f3e6188.js"></script>


  </head>
  <body data-type="modules">
    <script>

      try {
        if (localStorage.getItem('night-mode') === 'true') {
          document.body.classList.add('night-mode');
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <span class="icon-search" aria-hidden="true" title="Submit search"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <span class="icon-cross" aria-hidden="true" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="api-reference.html" class="sidebar-projectName">
syntax_tools
      </a>
      <strong class="sidebar-projectVersion">
        v2.6
      </strong>
    </div>

  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list-link" href="#full-list">Pages</a></li>

      <li><a id="modules-list-link" href="#full-list">Modules</a></li>


  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

      <h1>
merl <small class="app-vsn">(syntax_tools v2.6)</small>

      </h1>


        <section id="moduledoc">
<p>Metaprogramming in Erlang. Merl is a more user friendly interface to the <code>erl_syntax</code> module, making it easy both to build new ASTs from scratch and to match and decompose existing ASTs. For details that are outside the scope of Merl itself, please see the documentation of <a href="erl_syntax.html">erl_syntax</a>.</p><p><a id="Quick_start"></a><em>Quick start</em></p><p>To enable the full power of Merl, your module needs to include the Merl header file:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="p">-</span><span class="na">include_lib</span><span class="p" data-group-id="2378774363-1">(</span><span class="s">&quot;syntax_tools/include/merl.hrl&quot;</span><span class="p" data-group-id="2378774363-1">)</span><span class="p">.</span></code></pre><p>Then, you can use the <code>?Q(Text)</code> macros in your code to create ASTs or match on existing ASTs. For example:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="n">Tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="4943712635-1">(</span><span class="s">&quot;{foo, 42}&quot;</span><span class="p" data-group-id="4943712635-1">)</span><span class="p">,</span><span class="w">
     </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="4943712635-2">(</span><span class="s">&quot;{foo, _@Number}&quot;</span><span class="p" data-group-id="4943712635-2">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Tuple</span><span class="p">,</span><span class="w">
     </span><span class="n">Call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="4943712635-3">(</span><span class="s">&quot;foo:bar(_@Number)&quot;</span><span class="p" data-group-id="4943712635-3">)</span></code></pre><p>Calling <code>merl:print(Call)</code> will then print the following code:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="nc">foo</span><span class="p">:</span><span class="nf">bar</span><span class="p" data-group-id="2361606020-1">(</span><span class="mi">42</span><span class="p" data-group-id="2361606020-1">)</span></code></pre><p>The <code>?Q</code> macros turn the quoted code fragments into ASTs, and lifts metavariables such as <code>_@Tuple</code> and <code>_@Number</code> to the level of your Erlang code, so you can use the corresponding Erlang variables <code>Tuple</code> and <code>Number</code> directly. This is the most straightforward way to use Merl, and in many cases it's all you need.</p><p>You can even write case switches using <code>?Q</code> macros as patterns. For example:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="k">case</span><span class="w"> </span><span class="n">AST</span><span class="w"> </span><span class="k">of</span><span class="w">
         </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="8655464552-1">(</span><span class="s">&quot;{foo, _@Foo}&quot;</span><span class="p" data-group-id="8655464552-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">handle</span><span class="p" data-group-id="8655464552-2">(</span><span class="n">Foo</span><span class="p" data-group-id="8655464552-2">)</span><span class="p">;</span><span class="w">
         </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="8655464552-3">(</span><span class="s">&quot;{bar, _@Bar}&quot;</span><span class="p" data-group-id="8655464552-3">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="nc">erl_syntax</span><span class="p">:</span><span class="nf">is_integer</span><span class="p" data-group-id="8655464552-4">(</span><span class="n">Bar</span><span class="p" data-group-id="8655464552-4">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">handle</span><span class="p" data-group-id="8655464552-5">(</span><span class="n">Bar</span><span class="p" data-group-id="8655464552-5">)</span><span class="p">;</span><span class="w">
         </span><span class="p">_</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">handle_default</span><span class="p" data-group-id="8655464552-6">(</span><span class="p" data-group-id="8655464552-6">)</span><span class="w">
     </span><span class="k">end</span></code></pre><p>These case switches only allow <code>?Q(...)</code> or <code>_</code> as clause patterns, and the guards may contain any expressions, not just Erlang guard expressions.</p><p>If the macro <code>MERL_NO_TRANSFORM</code> is defined before the <code>merl.hrl</code> header file is included, the parse transform used by Merl will be disabled, and in that case, the match expressions <code>?Q(...) = ...</code>, case switches using <code>?Q(...)</code> patterns, and automatic metavariables like <code>_@Tuple</code> cannot be used in your code, but the Merl macros and functions still work. To do metavariable substitution, you need to use the <code>?Q(Text, Map)</code> macro, e.g.:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="n">Tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="3042648134-1">(</span><span class="s">&quot;{foo, _@bar, _@baz}&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3042648134-2">[</span><span class="p" data-group-id="3042648134-3">{</span><span class="ss">bar</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p" data-group-id="3042648134-3">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3042648134-4">{</span><span class="ss">baz</span><span class="p">,</span><span class="n">Baz</span><span class="p" data-group-id="3042648134-4">}</span><span class="p" data-group-id="3042648134-2">]</span><span class="p" data-group-id="3042648134-1">)</span></code></pre><p>The text given to a <code>?Q(Text)</code> macro can be either a single string, or a list of strings. The latter is useful when you need to split a long expression over multiple lines, e.g.:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="1023635591-1">(</span><span class="p" data-group-id="1023635591-2">[</span><span class="s">&quot;case _@Expr of&quot;</span><span class="p">,</span><span class="w">
         </span><span class="s">&quot;  {foo, X} -&gt; f(X);&quot;</span><span class="p">,</span><span class="w">
         </span><span class="s">&quot;  {bar, X} -&gt; g(X)&quot;</span><span class="p">,</span><span class="w">
         </span><span class="s">&quot;  _ -&gt; h(X)&quot;</span><span class="w">
         </span><span class="s">&quot;end&quot;</span><span class="p" data-group-id="1023635591-2">]</span><span class="p" data-group-id="1023635591-1">)</span></code></pre><p>If there is a syntax error somewhere in the text (like the missing semicolon in the second clause above) this allows Merl to generate an error message pointing to the exact line in your source code. (Just remember to comma-separate the strings in the list, otherwise Erlang will concatenate the string fragments as if they were a single string.)</p><p><a id="Metavariable_syntax"></a><em>Metavariable syntax</em></p><p>There are several ways to write a metavariable in your quoted code:</p><ul><li><p>Atoms starting with <code>@</code>, for example <code>'@foo'</code> or <code>'@Foo'</code></p></li><li><p>Variables starting with <code>_@</code>, for example <code>_@bar</code> or <code>_@Bar</code></p></li><li><p>Strings starting with <code>&quot;'@</code>, for example <code>&quot;'@File&quot;</code></p></li><li><p>Integers starting with 909, for example <code>9091</code> or <code>909123</code></p></li></ul><p>Following the prefix, one or more <code>_</code> or <code>0</code> characters may be used to indicate &quot;lifting&quot; of the variable one or more levels, and after that, a <code>@</code> or <code>9</code> character indicates a glob metavariable (matching zero or more elements in a sequence) rather than a normal metavariable. For example:</p><ul><li><p><code>'@_foo'</code> is lifted one level, and <code>_@__foo</code> is lifted two levels</p></li><li><p><code>_@@bar</code> is a glob variable, and <code>_@_@bar</code> is a lifted glob variable</p></li><li><p><code>90901</code> is a lifted variable,<code>90991</code> is a glob variable, and <code>9090091</code> is a glob variable lifted two levels</p></li></ul><p>(Note that the last character in the name is never considered to be a lift or glob marker, hence, <code>_@__</code> and <code>90900</code> are only lifted one level, not two. Also note that globs only matter for matching; when doing substitutions, a non-glob variable can be used to inject a sequence of elements, and vice versa.)</p><p>If the name after the prefix and any lift and glob markers is <code>_</code> or <code>0</code>, the variable is treated as an anonymous catch-all pattern in matches. For example, <code>_@_</code>, <code>_@@_</code>, <code>_@__</code>, or even <code>_@__@_</code>.</p><p>Finally, if the name without any prefixes or lift/glob markers begins with an uppercase character, as in <code>_@Foo</code> or <code>_@_@Foo</code>, it will become a variable on the Erlang level, and can be used to easily deconstruct and construct syntax trees:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="k">case</span><span class="w"> </span><span class="n">Input</span><span class="w"> </span><span class="k">of</span><span class="w">
         </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="0137907410-1">(</span><span class="s">&quot;{foo, _@Number}&quot;</span><span class="p" data-group-id="0137907410-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="0137907410-2">(</span><span class="s">&quot;foo:bar(_@Number)&quot;</span><span class="p" data-group-id="0137907410-2">)</span><span class="p">;</span><span class="w">
         </span><span class="p">.</span><span class="p">.</span><span class="p">.</span></code></pre><p>We refer to these as &quot;automatic metavariables&quot;. If in addition the name ends with <code>@</code>, as in <code>_@Foo@</code>, the value of the variable as an Erlang term will be automatically converted to the corresponding abstract syntax tree when used to construct a larger tree. For example, in:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="n">Bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4584670144-1">{</span><span class="ss">bar</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p" data-group-id="4584670144-1">}</span><span class="p">,</span><span class="w">
     </span><span class="n">Foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="4584670144-2">(</span><span class="s">&quot;{foo, _@Bar@}&quot;</span><span class="p" data-group-id="4584670144-2">)</span></code></pre><p>(where Bar is just some term, not a syntax tree) the result <code>Foo</code> will be a syntax tree representing <code>{foo, {bar, 42}}</code>. This avoids the need for temporary variables in order to inject data, as in</p><pre><code class="makeup erlang"><span class="w">     </span><span class="n">TmpBar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">erl_syntax</span><span class="p">:</span><span class="nf">abstract</span><span class="p" data-group-id="2211215118-1">(</span><span class="n">Bar</span><span class="p" data-group-id="2211215118-1">)</span><span class="p">,</span><span class="w">
     </span><span class="n">Foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="2211215118-2">(</span><span class="s">&quot;{foo, _@TmpBar}&quot;</span><span class="p" data-group-id="2211215118-2">)</span></code></pre><p>If the context requires an integer rather than a variable, an atom, or a string, you cannot use the uppercase convention to mark an automatic metavariable. Instead, if the integer (without the <code>909</code>-prefix and lift/glob markers) ends in a <code>9</code>, the integer will become an Erlang-level variable prefixed with <code>Q</code>, and if it ends with <code>99</code> it will also be automatically abstracted. For example, the following will increment the arity of the exported function f:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="k">case</span><span class="w"> </span><span class="n">Form</span><span class="w"> </span><span class="k">of</span><span class="w">
         </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="5586904578-1">(</span><span class="s">&quot;-export([f/90919]).&quot;</span><span class="p" data-group-id="5586904578-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
             </span><span class="n">Q2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">erl_syntax</span><span class="p">:</span><span class="nf">concrete</span><span class="p" data-group-id="5586904578-2">(</span><span class="n">Q1</span><span class="p" data-group-id="5586904578-2">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
             </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="5586904578-3">(</span><span class="s">&quot;-export([f/909299]).&quot;</span><span class="p" data-group-id="5586904578-3">)</span><span class="p">;</span><span class="w">
         </span><span class="p">.</span><span class="p">.</span><span class="p">.</span></code></pre><p><a id="When_to_use_the_various_forms_of_metavariables"></a><em>When to use the various forms of metavariables</em></p><p>Merl can only parse a fragment of text if it follows the basic syntactical rules of Erlang. In most places, a normal Erlang variable can be used as metavariable, for example:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="4444867473-1">(</span><span class="s">&quot;f(_@Arg)&quot;</span><span class="p" data-group-id="4444867473-1">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Expr</span></code></pre><p>but if you want to match on something like the name of a function, you have to use an atom as metavariable:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="6543887052-1">(</span><span class="s">&quot;&#39;@Name&#39;() -&gt; _@@_.&quot;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Function</span></code></pre><p>(note the anonymous glob variable <code>_@@_</code> to ignore the function body).</p><p>In some contexts, only a string or an integer is allowed. For example, the directive <code>-file(Name, Line)</code> requires that <code>Name</code> is a string literal and <code>Line</code> an integer literal:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="6119420583-1">(</span><span class="s">&quot;-file(\&quot;&#39;@File\&quot;, 9090).&quot;</span><span class="p" data-group-id="6119420583-1">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="6119420583-2">(</span><span class="s">&quot;-file(\&quot;foo.erl\&quot;, 42).&quot;</span><span class="p" data-group-id="6119420583-2">)</span><span class="p">)</span><span class="p">.</span></code></pre><p>This will extract the string literal <code>&quot;foo.erl&quot;</code> into the variable <code>Foo</code>. Note the use of the anonymous variable <code>9090</code> to ignore the line number. To match and also bind a metavariable that must be an integer literal, we can use the convention of ending the integer with a 9, turning it into a Q-prefixed variable on the Erlang level (see the previous section).</p><p><a id="Globs"></a><em>Globs</em></p><p>Whenever you want to match out a number of elements in a sequence (zero or more) rather than a fixed set of elements, you need to use a glob. For example:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="0064384873-1">(</span><span class="s">&quot;{_@@Elements}&quot;</span><span class="p" data-group-id="0064384873-1">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="0064384873-2">(</span><span class="p" data-group-id="0064384873-3">{</span><span class="ss">a</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="p" data-group-id="0064384873-3">}</span><span class="p" data-group-id="0064384873-2">)</span></code></pre><p>will bind Elements to the list of individual syntax trees representing the atoms <code>a</code>, <code>b</code>, and <code>c</code>. This can also be used with static prefix and suffix elements in the sequence. For example:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="3425264468-1">(</span><span class="s">&quot;{a, b, _@@Elements}&quot;</span><span class="p" data-group-id="3425264468-1">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="3425264468-2">(</span><span class="p" data-group-id="3425264468-3">{</span><span class="ss">a</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="p">,</span><span class="w"> </span><span class="ss">d</span><span class="p" data-group-id="3425264468-3">}</span><span class="p" data-group-id="3425264468-2">)</span></code></pre><p>will bind Elements to the list of the <code>c</code> and <code>d</code> subtrees, and</p><pre><code class="makeup erlang"><span class="w">     </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="7052145933-1">(</span><span class="s">&quot;{_@@Elements, c, d}&quot;</span><span class="p" data-group-id="7052145933-1">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="7052145933-2">(</span><span class="p" data-group-id="7052145933-3">{</span><span class="ss">a</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="p">,</span><span class="w"> </span><span class="ss">d</span><span class="p" data-group-id="7052145933-3">}</span><span class="p" data-group-id="7052145933-2">)</span></code></pre><p>will bind Elements to the list of the <code>a</code> and <code>b</code> subtrees. You can even use plain metavariables in the prefix or suffix:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="6136853761-1">(</span><span class="s">&quot;{_@First, _@@Rest}&quot;</span><span class="p" data-group-id="6136853761-1">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="6136853761-2">(</span><span class="p" data-group-id="6136853761-3">{</span><span class="ss">a</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="p" data-group-id="6136853761-3">}</span><span class="p" data-group-id="6136853761-2">)</span></code></pre><p>or</p><pre><code class="makeup erlang"><span class="w">     </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="9284527858-1">(</span><span class="s">&quot;{_@@_, _@Last}&quot;</span><span class="p" data-group-id="9284527858-1">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="9284527858-2">(</span><span class="p" data-group-id="9284527858-3">{</span><span class="ss">a</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="p" data-group-id="9284527858-3">}</span><span class="p" data-group-id="9284527858-2">)</span></code></pre><p>(ignoring all but the last element). You cannot however have two globs as part of the same sequence.</p><p><a id="Lifted_metavariables"></a><em>Lifted metavariables</em></p><p>In some cases, the Erlang syntax rules make it impossible to place a metavariable directly where you would like it. For example, you cannot write:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="3637650292-1">(</span><span class="s">&quot;-export([_@@Name]).&quot;</span><span class="p" data-group-id="3637650292-1">)</span></code></pre><p>to match out all name/arity pairs in the export list, or to insert a list of exports in a declaration, because the Erlang parser only allows elements on the form <code>A/I</code> (where <code>A</code> is an atom and <code>I</code> an integer) in the export list. A variable like the above is not allowed, but neither is a single atom or integer, so <code>'@@Name'</code> or <code>909919</code> wouldn't work either.</p><p>What you have to do in such cases is to write your metavariable in a syntactically valid position, and use lifting markers to denote where it should really apply, as in:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="9033380976-1">(</span><span class="s">&quot;-export([&#39;@_@Name&#39;/0]).&quot;</span><span class="p" data-group-id="9033380976-1">)</span></code></pre><p>This causes the variable to be lifted (after parsing) to the next higher level in the syntax tree, replacing that entire subtree. In this case, the <code>'@_@Name'/0</code> will be replaced with <code>'@@Name'</code>, and the <code>/0</code> part was just used as dummy notation and will be discarded.</p><p>You may even need to apply lifting more than once. To match the entire export list as a single syntax tree, you can write:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="o">?</span><span class="n">Q</span><span class="p" data-group-id="3463991786-1">(</span><span class="s">&quot;-export([&#39;@__Name&#39;/0]).&quot;</span><span class="p" data-group-id="3463991786-1">)</span></code></pre><p>using two underscores, but with no glob marker this time. This will make the entire <code>['@__Name'/0]</code> part be replaced with <code>'@Name'</code>.</p><p>Sometimes, the tree structure of a code fragment isn't very obvious, and parts of the structure may be invisible when printed as source code. For instance, a simple function definition like the following:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="nf">zero</span><span class="p" data-group-id="4444559634-1">(</span><span class="p" data-group-id="4444559634-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">.</span></code></pre><p>consists of the name (the atom <code>zero</code>), and a list of clauses containing the single clause <code>() -&gt; 0</code>. The clause consists of an argument list (empty), a guard (empty), and a body (which is always a list of expressions) containing the single expression <code>0</code>. This means that to match out the name and the list of clauses of any function, you'll need to use a pattern like <code>?Q(&quot;'@Name'() -&gt; _@_@Body.&quot;)</code>, using a dummy clause whose body is a glob lifted one level.</p><p>To visualize the structure of a syntax tree, you can use the function <code>merl:show(T)</code>, which prints a summary. For example, entering</p><pre><code class="makeup erlang"><span class="w">     </span><span class="nc">merl</span><span class="p">:</span><span class="nf">show</span><span class="p" data-group-id="8259341085-1">(</span><span class="nc">merl</span><span class="p">:</span><span class="nf">quote</span><span class="p" data-group-id="8259341085-2">(</span><span class="s">&quot;inc(X, Y) when Y &gt; 0 -&gt; X + Y.&quot;</span><span class="p" data-group-id="8259341085-2">)</span><span class="p" data-group-id="8259341085-1">)</span></code></pre><p>in the Erlang shell will print the following (where the <code>+</code> signs separate groups of subtrees on the same level):</p><pre><code class="makeup erlang"><span class="w">     </span><span class="nc">function</span><span class="p">:</span><span class="w"> </span><span class="nf">inc</span><span class="p" data-group-id="7379113944-1">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p" data-group-id="7379113944-1">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Y</span><span class="p">.</span><span class="w">
       </span><span class="nc">atom</span><span class="p">:</span><span class="w"> </span><span class="ss">inc</span><span class="w">
       </span><span class="o">+</span><span class="w">
       </span><span class="nc">clause</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7379113944-2">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p" data-group-id="7379113944-2">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Y</span><span class="w">
         </span><span class="nc">variable</span><span class="p">:</span><span class="w"> </span><span class="n">X</span><span class="w">
         </span><span class="nc">variable</span><span class="p">:</span><span class="w"> </span><span class="n">Y</span><span class="w">
         </span><span class="o">+</span><span class="w">
         </span><span class="nc">disjunction</span><span class="p">:</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w">
           </span><span class="nc">conjunction</span><span class="p">:</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w">
             </span><span class="nc">infix_expr</span><span class="p">:</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w">
               </span><span class="nc">variable</span><span class="p">:</span><span class="w"> </span><span class="n">Y</span><span class="w">
               </span><span class="o">+</span><span class="w">
               </span><span class="nc">operator</span><span class="p">:</span><span class="w"> </span><span class="o">&gt;</span><span class="w">
               </span><span class="o">+</span><span class="w">
               </span><span class="nc">integer</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w">
         </span><span class="o">+</span><span class="w">
         </span><span class="nc">infix_expr</span><span class="p">:</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Y</span><span class="w">
           </span><span class="nc">variable</span><span class="p">:</span><span class="w"> </span><span class="n">X</span><span class="w">
           </span><span class="o">+</span><span class="w">
           </span><span class="nc">operator</span><span class="p">:</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="o">+</span><span class="w">
           </span><span class="nc">variable</span><span class="p">:</span><span class="w"> </span><span class="n">Y</span></code></pre><p>This shows another important non-obvious case: a clause guard, even if it's as simple as <code>Y &gt; 0</code>, always consists of a single disjunction of one or more conjunctions of tests, much like a tuple of tuples. Thus:</p><ul><li><p><code>&quot;when _@Guard -&gt;&quot;</code> will only match a guard with exactly one test</p></li><li><p><code>&quot;when _@@Guard -&gt;&quot;</code> will match a guard with one or more comma-separated tests (but no semicolons), binding <code>Guard</code> to the list of tests</p></li><li><p><code>&quot;when _@_Guard -&gt;&quot;</code> will match just like the previous pattern, but binds <code>Guard</code> to the conjunction subtree</p></li><li><p><code>&quot;when _@_@Guard -&gt;&quot;</code> will match an arbitrary nonempty guard, binding <code>Guard</code> to the list of conjunction subtrees</p></li><li><p><code>&quot;when _@__Guard -&gt;&quot;</code> will match like the previous pattern, but binds <code>Guard</code> to the whole disjunction subtree</p></li><li><p>and finally, <code>&quot;when _@__@Guard -&gt;&quot;</code> will match any clause, binding <code>Guard</code> to <code>[]</code> if the guard is empty and to <code>[Disjunction]</code> otherwise</p></li></ul><p>Thus, the following pattern matches all possible clauses:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="s">&quot;(_@Args) when _@__@Guard -&gt; _@Body&quot;</span></code></pre><h2 id="module-data-types" class="section-heading">
  <a href="#module-data-types" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  DATA TYPES
</h2>
<a id="types"></a><dl><dt><a id="type-default_action"></a>default_action() = () -&gt; any()</dt><dd><p></p></dd><dt><a id="type-env"></a>env() = [{Key::<a href="merl.html#content#type-id">id()</a>, <a href="merl.html#content#type-pattern_or_patterns">pattern_or_patterns()</a>}]</dt><dd><p></p></dd><dt><a id="type-guard_test"></a>guard_test() = (<a href="merl.html#content#type-env">env()</a>) -&gt; boolean()</dt><dd><p></p></dd><dt><a id="type-guarded_action"></a>guarded_action() = <a href="merl.html#content#type-switch_action">switch_action()</a> | {<a href="merl.html#content#type-guard_test">guard_test()</a>, <a href="merl.html#content#type-switch_action">switch_action()</a>}</dt><dd><p></p></dd><dt><a id="type-guarded_actions"></a>guarded_actions() = <a href="merl.html#content#type-guarded_action">guarded_action()</a> | [<a href="merl.html#content#type-guarded_action">guarded_action()</a>]</dt><dd><p></p></dd><dt><a id="type-id"></a>id() = atom() | integer()</dt><dd><p></p></dd><dt><a id="type-location"></a>location() = <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_anno.html#type-location">erl_anno:location()</a></dt><dd><p></p></dd><dt><a id="type-pattern"></a>pattern() = <a href="merl.html#content#type-tree">tree()</a> | <a href="merl.html#content#type-template">template()</a></dt><dd><p></p></dd><dt><a id="type-pattern_or_patterns"></a>pattern_or_patterns() = <a href="merl.html#content#type-pattern">pattern()</a> | [<a href="merl.html#content#type-pattern">pattern()</a>]</dt><dd><p></p></dd><dt><a id="type-switch_action"></a>switch_action() = (<a href="merl.html#content#type-env">env()</a>) -&gt; any()</dt><dd><p></p></dd><dt><a id="type-switch_clause"></a>switch_clause() = {<a href="merl.html#content#type-pattern_or_patterns">pattern_or_patterns()</a>, <a href="merl.html#content#type-guarded_actions">guarded_actions()</a>} | {<a href="merl.html#content#type-pattern_or_patterns">pattern_or_patterns()</a>, <a href="merl.html#content#type-guard_test">guard_test()</a>, <a href="merl.html#content#type-switch_action">switch_action()</a>} | <a href="merl.html#content#type-default_action">default_action()</a></dt><dd><p></p></dd><dt><a id="type-template"></a>template() = <a href="merl.html#content#type-tree">tree()</a> | {<a href="merl.html#content#type-id">id()</a>} | {*, <a href="merl.html#content#type-id">id()</a>} | {template, atom(), term(), [[<a href="merl.html#content#type-template">template()</a>]]}</dt><dd><p></p></dd><dt><a id="type-template_or_templates"></a>template_or_templates() = <a href="merl.html#content#type-template">template()</a> | [<a href="merl.html#content#type-template">template()</a>]</dt><dd><p></p></dd><dt><a id="type-text"></a>text() = string() | binary() | [string()] | [binary()]</dt><dd><p></p></dd><dt><a id="type-tree"></a>tree() = <a href="erl_syntax.html#type-syntaxTree">erl_syntax:syntaxTree()</a></dt><dd><p></p></dd><dt><a id="type-tree_or_trees"></a>tree_or_trees() = <a href="merl.html#content#type-tree">tree()</a> | [<a href="merl.html#content#type-tree">tree()</a>]</dt><dd><p></p></dd></dl>
        </section>


        <section id="summary" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#summary">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
            Summary
          </h1>

  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#alpha/2">alpha(Trees:: pattern_or_patterns() , Env::[{ id() ,  id() }]) -&gt;  template_or_templates()</a>

  </div>

    <div class="summary-synopsis"><a id="alpha-2"></a><p>Alpha converts a pattern (renames variables). Similar to tsubst/1, but only renames variables (including globs).</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#compile/1">compile(Code) -&gt; term()
</a>

  </div>

    <div class="summary-synopsis"><a id="compile-1"></a><p>Equivalent to <a href="merl.html#compile/2">compile(Code, [])</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#compile/2">compile(Code, Options) -&gt; term()
</a>

  </div>

    <div class="summary-synopsis"><a id="compile-2"></a><p>Compile a syntax tree or list of syntax trees representing a module into a binary BEAM object.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#compile_and_load/1">compile_and_load(Code) -&gt; term()
</a>

  </div>

    <div class="summary-synopsis"><a id="compile_and_load-1"></a><p>Equivalent to <a href="merl.html#compile_and_load/2">compile_and_load(Code, [])</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#compile_and_load/2">compile_and_load(Code, Options) -&gt; term()
</a>

  </div>

    <div class="summary-synopsis"><a id="compile_and_load-2"></a><p>Compile a syntax tree or list of syntax trees representing a module and load the resulting module into memory.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#match/2">match(Patterns:: pattern_or_patterns() , Trees:: tree_or_trees() ) -&gt; {ok,  env() } | error</a>

  </div>

    <div class="summary-synopsis"><a id="match-2"></a><p>Match a pattern against a syntax tree (or patterns against syntax trees) returning an environment mapping variable names to subtrees; the environment is always sorted on keys. Note that multiple occurrences of metavariables in the pattern is not allowed, but is not checked.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#meta_template/1">meta_template(Templates:: template_or_templates() ) -&gt;  tree_or_trees()</a>

  </div>

    <div class="summary-synopsis"><a id="meta_template-1"></a><p>Turn a template into a syntax tree representing the template. Meta-variables in the template are turned into normal Erlang variables if their names (after the metavariable prefix characters) begin with an uppercase character. E.g., <code>_@Foo</code> in the template becomes the variable <code>Foo</code> in the meta-template. Furthermore, variables ending with <code>@</code> are automatically wrapped in a call to merl:term/1, so e.g. <code>_@Foo@ in the template becomes `merl:term(Foo)</code> in the meta-template.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#print/1">print(Ts) -&gt; term()
</a>

  </div>

    <div class="summary-synopsis"><a id="print-1"></a><p>Pretty-print a syntax tree or template to the standard output. This is a utility function for development and debugging.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#qquote/2">qquote(Text:: text() , Env:: env() ) -&gt;  tree_or_trees()</a>

  </div>

    <div class="summary-synopsis"><a id="qquote-2"></a><p>Parse text and substitute meta-variables.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#qquote/3">qquote(StartPos:: location() , Text:: text() , Env:: env() ) -&gt;  tree_or_trees()</a>

  </div>

    <div class="summary-synopsis"><a id="qquote-3"></a><p>Parse text and substitute meta-variables. Takes an initial scanner starting position as first argument.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#quote/1">quote(Text:: text() ) -&gt;  tree_or_trees()</a>

  </div>

    <div class="summary-synopsis"><a id="quote-1"></a><p>Parse text.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#quote/2">quote(StartPos:: location() , Text:: text() ) -&gt;  tree_or_trees()</a>

  </div>

    <div class="summary-synopsis"><a id="quote-2"></a><p>Parse text. Takes an initial scanner starting position as first argument.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#show/1">show(Ts) -&gt; term()
</a>

  </div>

    <div class="summary-synopsis"><a id="show-1"></a><p>Print the structure of a syntax tree or template to the standard output. This is a utility function for development and debugging.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#subst/2">subst(Trees:: pattern_or_patterns() , Env:: env() ) -&gt;  tree_or_trees()</a>

  </div>

    <div class="summary-synopsis"><a id="subst-2"></a><p>Substitute metavariables in a pattern or list of patterns, yielding a syntax tree or list of trees as result. Both for normal metavariables and glob metavariables, the substituted value may be a single element or a list of elements. For example, if a list representing <code>1, 2, 3</code> is substituted for <code>var</code> in either of <code>[foo, _@var, bar]</code> or <code>[foo, _@var, bar]</code>, the result represents <code>[foo, 1, 2, 3, bar]</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#switch/2">switch(Trees:: tree_or_trees() , Cs::[ switch_clause() ]) -&gt; any()</a>

  </div>

    <div class="summary-synopsis"><a id="switch-2"></a><p>Match against one or more clauses with patterns and optional guards.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#template/1">template(Trees:: pattern_or_patterns() ) -&gt;  template_or_templates()</a>

  </div>

    <div class="summary-synopsis"><a id="template-1"></a><p>Turn a syntax tree or list of trees into a template or templates. Templates can be instantiated or matched against, and reverted back to normal syntax trees using <a href="merl.html#tree/1">tree/1</a>. If the input is already a template, it is not modified further.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#template_vars/1">template_vars(Template:: template_or_templates() ) -&gt; [ id() ]</a>

  </div>

    <div class="summary-synopsis"><a id="template_vars-1"></a><p>Return an ordered list of the metavariables in the template.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#term/1">term(Term::term()) -&gt;  tree()</a>

  </div>

    <div class="summary-synopsis"><a id="term-1"></a><p>Create a syntax tree for a constant term.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#tree/1">tree(Templates:: template_or_templates() ) -&gt;  tree_or_trees()</a>

  </div>

    <div class="summary-synopsis"><a id="tree-1"></a><p>Revert a template to a normal syntax tree. Any remaining metavariables are turned into <code>@</code>-prefixed atoms or <code>909</code>-prefixed integers.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#tsubst/2">tsubst(Trees:: pattern_or_patterns() , Env:: env() ) -&gt;  template_or_templates()</a>

  </div>

    <div class="summary-synopsis"><a id="tsubst-2"></a><p>Like subst/2, but does not convert the result from a template back to a tree. Useful if you want to do multiple separate substitutions.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#var/1">var(Name::atom()) -&gt;  tree()</a>

  </div>

    <div class="summary-synopsis"><a id="var-1"></a><p>Create a variable.</p></div>

</div>

  </div>

        </section>


        <section id="functions" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#functions">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Functions
          </h1>
          <div class="functions-list">
<section class="detail" id="alpha/2">

  <div class="detail-header">
    <a href="#alpha/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">alpha(Trees:: pattern_or_patterns() , Env::[{ id() ,  id() }]) -&gt;  template_or_templates()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>alpha(<a href="#t:pattern_or_patterns/0">pattern_or_patterns</a>(), [{<a href="#t:id/0">id</a>(), <a href="#t:id/0">id</a>()}]) -> <a href="#t:template_or_templates/0">template_or_templates</a>().</pre>

      </div>

<a id="alpha-2"></a><p>Alpha converts a pattern (renames variables). Similar to tsubst/1, but only renames variables (including globs).</p><p><em>See also:</em> <a href="merl.html#tsubst/2">tsubst/2</a>.</p>
  </section>
</section>
<section class="detail" id="compile/1">

  <div class="detail-header">
    <a href="#compile/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">compile(Code) -&gt; term()
</h1>


  </div>

  <section class="docstring">

<a id="compile-1"></a><p>Equivalent to <a href="merl.html#compile/2">compile(Code, [])</a>.</p>
  </section>
</section>
<section class="detail" id="compile/2">

  <div class="detail-header">
    <a href="#compile/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">compile(Code, Options) -&gt; term()
</h1>


  </div>

  <section class="docstring">

<a id="compile-2"></a><p>Compile a syntax tree or list of syntax trees representing a module into a binary BEAM object.</p><p><em>See also:</em> <a href="merl.html#compile/1">compile/1</a>, <a href="merl.html#compile_and_load/2">compile_and_load/2</a>.</p>
  </section>
</section>
<section class="detail" id="compile_and_load/1">

  <div class="detail-header">
    <a href="#compile_and_load/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">compile_and_load(Code) -&gt; term()
</h1>


  </div>

  <section class="docstring">

<a id="compile_and_load-1"></a><p>Equivalent to <a href="merl.html#compile_and_load/2">compile_and_load(Code, [])</a>.</p>
  </section>
</section>
<section class="detail" id="compile_and_load/2">

  <div class="detail-header">
    <a href="#compile_and_load/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">compile_and_load(Code, Options) -&gt; term()
</h1>


  </div>

  <section class="docstring">

<a id="compile_and_load-2"></a><p>Compile a syntax tree or list of syntax trees representing a module and load the resulting module into memory.</p><p><em>See also:</em> <a href="merl.html#compile/2">compile/2</a>, <a href="merl.html#compile_and_load/1">compile_and_load/1</a>.</p>
  </section>
</section>
<section class="detail" id="match/2">

  <div class="detail-header">
    <a href="#match/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">match(Patterns:: pattern_or_patterns() , Trees:: tree_or_trees() ) -&gt; {ok,  env() } | error</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>match(<a href="#t:pattern_or_patterns/0">pattern_or_patterns</a>(), <a href="#t:tree_or_trees/0">tree_or_trees</a>()) -> {ok, <a href="#t:env/0">env</a>()} | error.</pre>

      </div>

<a id="match-2"></a><p>Match a pattern against a syntax tree (or patterns against syntax trees) returning an environment mapping variable names to subtrees; the environment is always sorted on keys. Note that multiple occurrences of metavariables in the pattern is not allowed, but is not checked.</p><p><em>See also:</em> <a href="merl.html#switch/2">switch/2</a>, <a href="merl.html#template/1">template/1</a>.</p>
  </section>
</section>
<section class="detail" id="meta_template/1">

  <div class="detail-header">
    <a href="#meta_template/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">meta_template(Templates:: template_or_templates() ) -&gt;  tree_or_trees()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>meta_template(<a href="#t:template_or_templates/0">template_or_templates</a>()) -> <a href="#t:tree_or_trees/0">tree_or_trees</a>().</pre>

      </div>

<a id="meta_template-1"></a><p>Turn a template into a syntax tree representing the template. Meta-variables in the template are turned into normal Erlang variables if their names (after the metavariable prefix characters) begin with an uppercase character. E.g., <code>_@Foo</code> in the template becomes the variable <code>Foo</code> in the meta-template. Furthermore, variables ending with <code>@</code> are automatically wrapped in a call to merl:term/1, so e.g. <code>_@Foo@ in the template becomes `merl:term(Foo)</code> in the meta-template.</p>
  </section>
</section>
<section class="detail" id="print/1">

  <div class="detail-header">
    <a href="#print/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">print(Ts) -&gt; term()
</h1>


  </div>

  <section class="docstring">

<a id="print-1"></a><p>Pretty-print a syntax tree or template to the standard output. This is a utility function for development and debugging.</p>
  </section>
</section>
<section class="detail" id="qquote/2">

  <div class="detail-header">
    <a href="#qquote/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">qquote(Text:: text() , Env:: env() ) -&gt;  tree_or_trees()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>qquote(Text :: <a href="#t:text/0">text</a>(), Env :: <a href="#t:env/0">env</a>()) -> <a href="#t:tree_or_trees/0">tree_or_trees</a>().</pre>

      </div>

<a id="qquote-2"></a><p>Parse text and substitute meta-variables.</p>
  </section>
</section>
<section class="detail" id="qquote/3">

  <div class="detail-header">
    <a href="#qquote/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">qquote(StartPos:: location() , Text:: text() , Env:: env() ) -&gt;  tree_or_trees()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>qquote(StartPos :: <a href="#t:location/0">location</a>(), Text :: <a href="#t:text/0">text</a>(), Env :: <a href="#t:env/0">env</a>()) -> <a href="#t:tree_or_trees/0">tree_or_trees</a>().</pre>

      </div>

<a id="qquote-3"></a><p>Parse text and substitute meta-variables. Takes an initial scanner starting position as first argument.</p><p>The macro <code>?Q(Text, Env)</code> expands to <code>merl:qquote(?LINE, Text, Env)</code>.</p><p><em>See also:</em> <a href="merl.html#quote/2">quote/2</a>.</p>
  </section>
</section>
<section class="detail" id="quote/1">

  <div class="detail-header">
    <a href="#quote/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">quote(Text:: text() ) -&gt;  tree_or_trees()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>quote(Text :: <a href="#t:text/0">text</a>()) -> <a href="#t:tree_or_trees/0">tree_or_trees</a>().</pre>

      </div>

<a id="quote-1"></a><p>Parse text.</p>
  </section>
</section>
<section class="detail" id="quote/2">

  <div class="detail-header">
    <a href="#quote/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">quote(StartPos:: location() , Text:: text() ) -&gt;  tree_or_trees()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>quote(StartPos :: <a href="#t:location/0">location</a>(), Text :: <a href="#t:text/0">text</a>()) -> <a href="#t:tree_or_trees/0">tree_or_trees</a>().</pre>

      </div>

<a id="quote-2"></a><p>Parse text. Takes an initial scanner starting position as first argument.</p><p>The macro <code>?Q(Text)</code> expands to <code>merl:quote(?LINE, Text, Env)</code>.</p><p><em>See also:</em> <a href="merl.html#quote/1">quote/1</a>.</p>
  </section>
</section>
<section class="detail" id="show/1">

  <div class="detail-header">
    <a href="#show/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">show(Ts) -&gt; term()
</h1>


  </div>

  <section class="docstring">

<a id="show-1"></a><p>Print the structure of a syntax tree or template to the standard output. This is a utility function for development and debugging.</p>
  </section>
</section>
<section class="detail" id="subst/2">

  <div class="detail-header">
    <a href="#subst/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">subst(Trees:: pattern_or_patterns() , Env:: env() ) -&gt;  tree_or_trees()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>subst(<a href="#t:pattern_or_patterns/0">pattern_or_patterns</a>(), <a href="#t:env/0">env</a>()) -> <a href="#t:tree_or_trees/0">tree_or_trees</a>().</pre>

      </div>

<a id="subst-2"></a><p>Substitute metavariables in a pattern or list of patterns, yielding a syntax tree or list of trees as result. Both for normal metavariables and glob metavariables, the substituted value may be a single element or a list of elements. For example, if a list representing <code>1, 2, 3</code> is substituted for <code>var</code> in either of <code>[foo, _@var, bar]</code> or <code>[foo, _@var, bar]</code>, the result represents <code>[foo, 1, 2, 3, bar]</code>.</p>
  </section>
</section>
<section class="detail" id="switch/2">

  <div class="detail-header">
    <a href="#switch/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">switch(Trees:: tree_or_trees() , Cs::[ switch_clause() ]) -&gt; any()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>switch(<a href="#t:tree_or_trees/0">tree_or_trees</a>(), [<a href="#t:switch_clause/0">switch_clause</a>()]) -> any().</pre>

      </div>

<a id="switch-2"></a><p>Match against one or more clauses with patterns and optional guards.</p><p>Note that clauses following a default action will be ignored.</p><p><em>See also:</em> <a href="merl.html#match/2">match/2</a>.</p>
  </section>
</section>
<section class="detail" id="template/1">

  <div class="detail-header">
    <a href="#template/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">template(Trees:: pattern_or_patterns() ) -&gt;  template_or_templates()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>template(<a href="#t:pattern_or_patterns/0">pattern_or_patterns</a>()) -> <a href="#t:template_or_templates/0">template_or_templates</a>().</pre>

      </div>

<a id="template-1"></a><p>Turn a syntax tree or list of trees into a template or templates. Templates can be instantiated or matched against, and reverted back to normal syntax trees using <a href="merl.html#tree/1">tree/1</a>. If the input is already a template, it is not modified further.</p><p><em>See also:</em> <a href="merl.html#match/2">match/2</a>, <a href="merl.html#subst/2">subst/2</a>, <a href="merl.html#tree/1">tree/1</a>.</p>
  </section>
</section>
<section class="detail" id="template_vars/1">

  <div class="detail-header">
    <a href="#template_vars/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">template_vars(Template:: template_or_templates() ) -&gt; [ id() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>template_vars(<a href="#t:template_or_templates/0">template_or_templates</a>()) -> [<a href="#t:id/0">id</a>()].</pre>

      </div>

<a id="template_vars-1"></a><p>Return an ordered list of the metavariables in the template.</p>
  </section>
</section>
<section class="detail" id="term/1">

  <div class="detail-header">
    <a href="#term/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">term(Term::term()) -&gt;  tree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>term()) -> tree().</pre>

      </div>

<a id="term-1"></a><p>Create a syntax tree for a constant term.</p>
  </section>
</section>
<section class="detail" id="tree/1">

  <div class="detail-header">
    <a href="#tree/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">tree(Templates:: template_or_templates() ) -&gt;  tree_or_trees()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>tree(<a href="#t:template_or_templates/0">template_or_templates</a>()) -> <a href="#t:tree_or_trees/0">tree_or_trees</a>().</pre>

      </div>

<a id="tree-1"></a><p>Revert a template to a normal syntax tree. Any remaining metavariables are turned into <code>@</code>-prefixed atoms or <code>909</code>-prefixed integers.</p><p><em>See also:</em> <a href="merl.html#template/1">template/1</a>.</p>
  </section>
</section>
<section class="detail" id="tsubst/2">

  <div class="detail-header">
    <a href="#tsubst/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">tsubst(Trees:: pattern_or_patterns() , Env:: env() ) -&gt;  template_or_templates()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>tsubst(<a href="#t:pattern_or_patterns/0">pattern_or_patterns</a>(), <a href="#t:env/0">env</a>()) -> <a href="#t:template_or_templates/0">template_or_templates</a>().</pre>

      </div>

<a id="tsubst-2"></a><p>Like subst/2, but does not convert the result from a template back to a tree. Useful if you want to do multiple separate substitutions.</p><p><em>See also:</em> <a href="merl.html#subst/2">subst/2</a>, <a href="merl.html#tree/1">tree/1</a>.</p>
  </section>
</section>
<section class="detail" id="var/1">

  <div class="detail-header">
    <a href="#var/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">var(Name::atom()) -&gt;  tree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>var(atom()) -> <a href="#t:tree/0">tree</a>().</pre>

      </div>

<a id="var-1"></a><p>Create a variable.</p>
  </section>
</section>

          </div>
        </section>

      <footer class="footer">

        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.25.1) for the
            <a href="https://elixir-lang.org" title="Elixir" target="_blank">Elixir programming language</a>.
          </span>
          <span class="line">
            Designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>

            <a href="api-reference.html" title="API reference" class="line footer-button">API Reference</a>

          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button display-quick-switch">
            Go to a HexDocs package
          </button>
          <button class="line footer-button tooltips-toggle">
            <span class="tooltips-option-disable">Disable tooltips</span>
            <span class="tooltips-option-enable">Enable tooltips</span>
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
