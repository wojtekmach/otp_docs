<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.25.1">
    <meta name="project" content="syntax_tools v2.6">

    <title>erl_syntax â€” syntax_tools v2.6</title>
    <link rel="stylesheet" href="dist/erlang-951161c89561e05735a5.css" />

    <script src="dist/sidebar_items-33b0a6fec9.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-f97730d45ef67f3e6188.js"></script>


  </head>
  <body data-type="modules">
    <script>

      try {
        if (localStorage.getItem('night-mode') === 'true') {
          document.body.classList.add('night-mode');
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <span class="icon-search" aria-hidden="true" title="Submit search"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <span class="icon-cross" aria-hidden="true" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="api-reference.html" class="sidebar-projectName">
syntax_tools
      </a>
      <strong class="sidebar-projectVersion">
        v2.6
      </strong>
    </div>

  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list-link" href="#full-list">Pages</a></li>

      <li><a id="modules-list-link" href="#full-list">Modules</a></li>


  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

      <h1>
erl_syntax <small class="app-vsn">(syntax_tools v2.6)</small>

      </h1>


        <section id="moduledoc">
<p>Abstract Erlang syntax trees.</p><p>This module defines an abstract data type for representing Erlang source code as syntax trees, in a way that is backwards compatible with the data structures created by the Erlang standard library parser module <code>erl_parse</code> (often referred to as &quot;parse trees&quot;, which is a bit of a misnomer). This means that all <code>erl_parse</code> trees are valid abstract syntax trees, but the reverse is not true: abstract syntax trees can in general not be used as input to functions expecting an <code>erl_parse</code> tree. However, as long as an abstract syntax tree represents a correct Erlang program, the function <a href="erl_syntax.html#revert/1">revert/1</a> should be able to transform it to the corresponding <code>erl_parse</code> representation.</p><p>A recommended starting point for the first-time user is the documentation of the <a href="erl_syntax.html#content#type-syntaxTree">syntaxTree()</a> data type, and the function <a href="erl_syntax.html#type/1">type/1</a>.</p><p><a id="NOTES:"></a><em>NOTES:</em></p><p>This module deals with the composition and decomposition of <em>syntactic</em> entities (as opposed to semantic ones); its purpose is to hide all direct references to the data structures used to represent these entities. With few exceptions, the functions in this module perform no semantic interpretation of their inputs, and in general, the user is assumed to pass type-correct arguments - if this is not done, the effects are not defined.</p><p>With the exception of the <a href="erl_syntax.html#content#type-erl_parse">erl_parse()</a> data structures, the internal representations of abstract syntax trees are subject to change without notice, and should not be documented outside this module. Furthermore, we do not give any guarantees on how an abstract syntax tree may or may not be represented, <em>with the following exceptions</em>: no syntax tree is represented by a single atom, such as <code>none</code>, by a list constructor <code>[X | Y]</code>, or by the empty list <code>[]</code>. This can be relied on when writing functions that operate on syntax trees.</p><h2 id="module-data-types" class="section-heading">
  <a href="#module-data-types" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  DATA TYPES
</h2>
<a id="types"></a><dl><dt><a id="type-annotation_or_location"></a>annotation_or_location() = <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_anno.html#type-anno">erl_anno:anno()</a> | <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_anno.html#type-location">erl_anno:location()</a></dt><dd><p></p></dd><dt><a id="type-encoding"></a>encoding() = utf8 | unicode | latin1</dt><dd><p></p></dd><dt><a id="type-erl_parse"></a>erl_parse() = <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_parse.html#type-abstract_clause">erl_parse:abstract_clause()</a> | <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_parse.html#type-abstract_expr">erl_parse:abstract_expr()</a> | <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_parse.html#type-abstract_form">erl_parse:abstract_form()</a> | <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_parse.html#type-abstract_type">erl_parse:abstract_type()</a> | <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_parse.html#type-form_info">erl_parse:form_info()</a> | <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_parse.html#type-af_binelement">erl_parse:af_binelement(term())</a> | <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_parse.html#type-af_generator">erl_parse:af_generator()</a> | <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_parse.html#type-af_remote_function">erl_parse:af_remote_function()</a></dt><dd><p></p></dd><dt><a id="type-forms"></a>forms() = <a href="erl_syntax.html#content#type-syntaxTree">syntaxTree()</a> | [<a href="erl_syntax.html#content#type-syntaxTree">syntaxTree()</a>]</dt><dd><p></p></dd><dt><a id="type-guard"></a>guard() = none | <a href="erl_syntax.html#content#type-syntaxTree">syntaxTree()</a> | [<a href="erl_syntax.html#content#type-syntaxTree">syntaxTree()</a>] | [[<a href="erl_syntax.html#content#type-syntaxTree">syntaxTree()</a>]]</dt><dd><p></p></dd><dt><a id="type-padding"></a>padding() = none | integer()</dt><dd><p></p></dd><dt><a id="type-syntaxTree"></a>syntaxTree() = <a href="erl_syntax.html#content#type-tree">tree()</a> | <a href="erl_syntax.html#content#type-wrapper">wrapper()</a> | <a href="erl_syntax.html#content#type-erl_parse">erl_parse()</a></dt><dd><p></p></dd><dt><a id="type-syntaxTreeAttributes"></a>syntaxTreeAttributes() = #attr{pos=term(), ann=[term()], com=none | #com{pre=[<a href="erl_syntax.html#content#type-syntaxTree">syntaxTree()</a>], post=[<a href="erl_syntax.html#content#type-syntaxTree">syntaxTree()</a>]}}</dt><dd><p></p></dd><dt><a id="type-tree"></a>tree() = #tree{type=atom(), attr=#attr{pos=term(), ann=[term()], com=none | #com{pre=[<a href="erl_syntax.html#content#type-syntaxTree">syntaxTree()</a>], post=[<a href="erl_syntax.html#content#type-syntaxTree">syntaxTree()</a>]}}, data=term()}</dt><dd><p></p></dd><dt><a id="type-wrapper"></a>wrapper() = #wrapper{type=atom(), attr=#attr{pos=term(), ann=[term()], com=none | #com{pre=[<a href="erl_syntax.html#content#type-syntaxTree">syntaxTree()</a>], post=[<a href="erl_syntax.html#content#type-syntaxTree">syntaxTree()</a>]}}, tree=<a href="erl_syntax.html#content#type-erl_parse">erl_parse()</a>}</dt><dd><p></p></dd></dl>
        </section>


        <section id="summary" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#summary">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
            Summary
          </h1>

  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#abstract/1">abstract(T::term()) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="abstract-1"></a><p>Returns the syntax tree corresponding to an Erlang term. <code>Term</code> must be a literal term, i.e., one that can be represented as a source code literal. Thus, it may not contain a process identifier, port, reference or function value as a subterm. The function recognises printable strings, in order to get a compact and readable representation. Evaluation fails with reason <code>badarg</code> if <code>Term</code> is not a literal term.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#add_ann/2">add_ann(A::term(), Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="add_ann-2"></a><p>Appends the term <code>Annotation</code> to the list of user annotations of <code>Node</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#add_postcomments/2">add_postcomments(Cs::[ syntaxTree() ], Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="add_postcomments-2"></a><p>Appends <code>Comments</code> to the post-comments of <code>Node</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#add_precomments/2">add_precomments(Cs::[ syntaxTree() ], Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="add_precomments-2"></a><p>Appends <code>Comments</code> to the pre-comments of <code>Node</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#annotated_type/2">annotated_type(Name:: syntaxTree() , Type:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="annotated_type-2"></a><p>Creates an abstract annotated type expression. The result represents &quot;<code>Name :: Type</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#annotated_type_body/1">annotated_type_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="annotated_type_body-1"></a><p>Returns the type subtrees of an <code>annotated_type</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#annotated_type_name/1">annotated_type_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="annotated_type_name-1"></a><p>Returns the name subtree of an <code>annotated_type</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#application/2">application(Operator:: syntaxTree() , Arguments::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="application-2"></a><p>Creates an abstract function application expression. If <code>Arguments</code> is <code>[A1, ..., An]</code>, the result represents &quot;<code>Operator(A1, ..., An)</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#application/3">application(Module::none |  syntaxTree() , Name:: syntaxTree() , Arguments::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="application-3"></a><p>Creates an abstract function application expression. If <code>Module</code> is <code>none</code>, this is call is equivalent to <code>application(Function, Arguments)</code>, otherwise it is equivalent to <code>application(module_qualifier(Module, Function), Arguments)</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#application_arguments/1">application_arguments(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="application_arguments-1"></a><p>Returns the list of argument subtrees of an <code>application</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#application_operator/1">application_operator(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="application_operator-1"></a><p>Returns the operator subtree of an <code>application</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#arity_qualifier/2">arity_qualifier(Body:: syntaxTree() , Arity:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="arity_qualifier-2"></a><p>Creates an abstract arity qualifier. The result represents &quot;<code>Body/Arity</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#arity_qualifier_argument/1">arity_qualifier_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="arity_qualifier_argument-1"></a><p>Returns the argument (the arity) subtree of an <code>arity_qualifier</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#arity_qualifier_body/1">arity_qualifier_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="arity_qualifier_body-1"></a><p>Returns the body subtree of an <code>arity_qualifier</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#atom/1">atom(Name::atom() | string()) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="atom-1"></a><p>Creates an abstract atom literal. The print name of the atom is the character sequence represented by <code>Name</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#atom_literal/1">atom_literal(Node:: syntaxTree() ) -&gt; string()</a>

  </div>

    <div class="summary-synopsis"><a id="atom_literal-1"></a><p>Returns the literal string represented by an <code>atom</code> node. This includes surrounding single-quote characters if necessary. Characters beyond 255 will be escaped.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#atom_literal/2">atom_literal(Node, X2) -&gt; term()
</a>

  </div>

    <div class="summary-synopsis"><a id="atom_literal-2"></a><p>Returns the literal string represented by an <code>atom</code> node. This includes surrounding single-quote characters if necessary. Depending on the encoding a character beyond 255 will be escaped (<code>latin1</code>) or copied as is (<code>utf8</code>).</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#atom_name/1">atom_name(Node:: syntaxTree() ) -&gt; string()</a>

  </div>

    <div class="summary-synopsis"><a id="atom_name-1"></a><p>Returns the printname of an <code>atom</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#atom_value/1">atom_value(Node:: syntaxTree() ) -&gt; atom()</a>

  </div>

    <div class="summary-synopsis"><a id="atom_value-1"></a><p>Returns the value represented by an <code>atom</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#attribute/1">attribute(Name:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="attribute-1"></a><p>Equivalent to <a href="erl_syntax.html#attribute/2">attribute(Name, none)</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#attribute/2">attribute(Name:: syntaxTree() , Args::none | [ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="attribute-2"></a><p>Creates an abstract program attribute. If <code>Arguments</code> is <code>[A1, ..., An]</code>, the result represents &quot;<code>-Name(A1, ..., An).</code>&quot;. Otherwise, if <code>Arguments</code> is <code>none</code>, the result represents &quot;<code>-Name.</code>&quot;. The latter form makes it possible to represent preprocessor directives such as &quot;<code>-endif.</code>&quot;. Attributes are source code forms.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#attribute_arguments/1">attribute_arguments(Node:: syntaxTree() ) -&gt; none | [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="attribute_arguments-1"></a><p>Returns the list of argument subtrees of an <code>attribute</code> node, if any. If <code>Node</code> represents &quot;<code>-Name.</code>&quot;, the result is <code>none</code>. Otherwise, if <code>Node</code> represents &quot;<code>-Name(E1, ..., En).</code>&quot;, <code>[E1, ..., E1]</code> is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#attribute_name/1">attribute_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="attribute_name-1"></a><p>Returns the name subtree of an <code>attribute</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binary/1">binary(List::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="binary-1"></a><p>Creates an abstract binary-object template. If <code>Fields</code> is <code>[F1, ..., Fn]</code>, the result represents &quot;<code>&lt;&lt;F1, ..., Fn&gt;&gt;</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binary_comp/2">binary_comp(Template:: syntaxTree() , Body::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="binary_comp-2"></a><p>Creates an abstract binary comprehension. If <code>Body</code> is <code>[E1, ..., En]</code>, the result represents &quot;<code>&lt;&lt;Template || E1, ..., En&gt;&gt;</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binary_comp_body/1">binary_comp_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="binary_comp_body-1"></a><p>Returns the list of body subtrees of a <code>binary_comp</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binary_comp_template/1">binary_comp_template(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="binary_comp_template-1"></a><p>Returns the template subtree of a <code>binary_comp</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binary_field/1">binary_field(Body:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="binary_field-1"></a><p>Equivalent to <a href="erl_syntax.html#binary_field/2">binary_field(Body, [])</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binary_field/2">binary_field(Body:: syntaxTree() , Types::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="binary_field-2"></a><p>Creates an abstract binary template field. If <code>Types</code> is the empty list, the result simply represents &quot;<code>Body</code>&quot;, otherwise, if <code>Types</code> is <code>[T1, ..., Tn]</code>, the result represents &quot;<code>Body/T1-...-Tn</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binary_field/3">binary_field(Body:: syntaxTree() , Size::none |  syntaxTree() , Types::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="binary_field-3"></a><p>Creates an abstract binary template field. If <code>Size</code> is <code>none</code>, this is equivalent to &quot;<code>binary_field(Body, Types)</code>&quot;, otherwise it is equivalent to &quot;<code>binary_field(size_qualifier(Body, Size), Types)</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binary_field_body/1">binary_field_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="binary_field_body-1"></a><p>Returns the body subtree of a <code>binary_field</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binary_field_size/1">binary_field_size(Node:: syntaxTree() ) -&gt; none |  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="binary_field_size-1"></a><p>Returns the size specifier subtree of a <code>binary_field</code> node, if any. If <code>Node</code> represents &quot;<code>Body:Size</code>&quot; or &quot;<code>Body:Size/T1, ..., Tn</code>&quot;, the result is <code>Size</code>, otherwise <code>none</code> is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binary_field_types/1">binary_field_types(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="binary_field_types-1"></a><p>Returns the list of type-specifier subtrees of a <code>binary_field</code> node. If <code>Node</code> represents &quot;<code>.../T1, ..., Tn</code>&quot;, the result is <code>[T1, ..., Tn]</code>, otherwise the result is the empty list.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binary_fields/1">binary_fields(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="binary_fields-1"></a><p>Returns the list of field subtrees of a <code>binary</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binary_generator/2">binary_generator(Pattern:: syntaxTree() , Body:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="binary_generator-2"></a><p>Creates an abstract binary_generator. The result represents &quot;<code>Pattern &lt;- Body</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binary_generator_body/1">binary_generator_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="binary_generator_body-1"></a><p>Returns the body subtree of a <code>generator</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binary_generator_pattern/1">binary_generator_pattern(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="binary_generator_pattern-1"></a><p>Returns the pattern subtree of a <code>generator</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#bitstring_type/2">bitstring_type(M:: syntaxTree() , N:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="bitstring_type-2"></a><p>Creates an abstract bitstring type. The result represents &quot;<code>&lt;&lt;_:M, _:_*N&gt;&gt;</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#bitstring_type_m/1">bitstring_type_m(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="bitstring_type_m-1"></a><p>Returns the number of start bits, <code>M</code>, of a <code>bitstring_type</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#bitstring_type_n/1">bitstring_type_n(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="bitstring_type_n-1"></a><p>Returns the segment size, <code>N</code>, of a <code>bitstring_type</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#block_expr/1">block_expr(Body::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="block_expr-1"></a><p>Creates an abstract block expression. If <code>Body</code> is <code>[B1, ..., Bn]</code>, the result represents &quot;<code>begin B1, ..., Bn end</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#block_expr_body/1">block_expr_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="block_expr_body-1"></a><p>Returns the list of body subtrees of a <code>block_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#case_expr/2">case_expr(Argument:: syntaxTree() , Clauses::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="case_expr-2"></a><p>Creates an abstract case-expression. If <code>Clauses</code> is <code>[C1, ..., Cn]</code>, the result represents &quot;<code>case Argument of C1; ...; Cn end</code>&quot;. More exactly, if each <code>Ci</code> represents &quot;<code>(Pi) Gi -&gt; Bi</code>&quot;, then the result represents &quot;<code>case Argument of P1 G1 -&gt; B1; ...; Pn Gn -&gt; Bn end</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#case_expr_argument/1">case_expr_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="case_expr_argument-1"></a><p>Returns the argument subtree of a <code>case_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#case_expr_clauses/1">case_expr_clauses(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="case_expr_clauses-1"></a><p>Returns the list of clause subtrees of a <code>case_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#catch_expr/1">catch_expr(Expr:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="catch_expr-1"></a><p>Creates an abstract catch-expression. The result represents &quot;<code>catch Expr</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#catch_expr_body/1">catch_expr_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="catch_expr_body-1"></a><p>Returns the body subtree of a <code>catch_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#char/1">char(Char::char()) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="char-1"></a><p>Creates an abstract character literal. The result represents &quot;<code>$Name</code>&quot;, where <code>Name</code> corresponds to <code>Value</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#char_literal/1">char_literal(Node:: syntaxTree() ) -&gt; nonempty_string()</a>

  </div>

    <div class="summary-synopsis"><a id="char_literal-1"></a><p>Returns the literal string represented by a <code>char</code> node. This includes the leading &quot;<code>$</code>&quot; character. Characters beyond 255 will be escaped.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#char_literal/2">char_literal(Node:: syntaxTree() , X2:: encoding() ) -&gt; nonempty_string()</a>

  </div>

    <div class="summary-synopsis"><a id="char_literal-2"></a><p>Returns the literal string represented by a <code>char</code> node. This includes the leading &quot;<code>$</code>&quot; character. Depending on the encoding a character beyond 255 will be escaped (<code>latin1</code>) or copied as is (<code>utf8</code>).</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#char_value/1">char_value(Node:: syntaxTree() ) -&gt; char()</a>

  </div>

    <div class="summary-synopsis"><a id="char_value-1"></a><p>Returns the value represented by a <code>char</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#class_qualifier/2">class_qualifier(Class:: syntaxTree() , Body:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="class_qualifier-2"></a><p>Creates an abstract class qualifier. The result represents &quot;<code>Class:Body</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#class_qualifier/3">class_qualifier(Class:: syntaxTree() , Body:: syntaxTree() , Stacktrace:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="class_qualifier-3"></a><p>Creates an abstract class qualifier. The result represents &quot;<code>Class:Body:Stacktrace</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#class_qualifier_argument/1">class_qualifier_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="class_qualifier_argument-1"></a><p>Returns the argument (the class) subtree of a <code>class_qualifier</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#class_qualifier_body/1">class_qualifier_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="class_qualifier_body-1"></a><p>Returns the body subtree of a <code>class_qualifier</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#class_qualifier_stacktrace/1">class_qualifier_stacktrace(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="class_qualifier_stacktrace-1"></a><p>Returns the stacktrace subtree of a <code>class_qualifier</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#clause/2">clause(Guard:: guard() , Body::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="clause-2"></a><p>Equivalent to <a href="erl_syntax.html#clause/3">clause([], Guard, Body)</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#clause/3">clause(Patterns::[ syntaxTree() ], Guard:: guard() , Body::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="clause-3"></a><p>Creates an abstract clause. If <code>Patterns</code> is <code>[P1, ..., Pn]</code> and <code>Body</code> is <code>[B1, ..., Bm]</code>, then if <code>Guard</code> is <code>none</code>, the result represents &quot;<code>(P1, ..., Pn) -&gt; B1, ..., Bm</code>&quot;, otherwise, unless <code>Guard</code> is a list, the result represents &quot;<code>(P1, ..., Pn) when Guard -&gt; B1, ..., Bm</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#clause_body/1">clause_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="clause_body-1"></a><p>Return the list of body subtrees of a <code>clause</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#clause_guard/1">clause_guard(Node:: syntaxTree() ) -&gt; none |  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="clause_guard-1"></a><p>Returns the guard subtree of a <code>clause</code> node, if any. If <code>Node</code> represents &quot;<code>(P1, ..., Pn) when Guard -&gt; B1, ..., Bm</code>&quot;, <code>Guard</code> is returned. Otherwise, the result is <code>none</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#clause_patterns/1">clause_patterns(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="clause_patterns-1"></a><p>Returns the list of pattern subtrees of a <code>clause</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#comment/1">comment(Strings::[string()]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="comment-1"></a><p>Equivalent to <a href="erl_syntax.html#comment/2">comment(none, Strings)</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#comment/2">comment(Pad:: padding() , Strings::[string()]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="comment-2"></a><p>Creates an abstract comment with the given padding and text. If <code>Strings</code> is a (possibly empty) list <code>[&quot;Txt1&quot;, ..., &quot;TxtN&quot;]</code>, the result represents the source code text</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#comment_padding/1">comment_padding(Node:: syntaxTree() ) -&gt;  padding()</a>

  </div>

    <div class="summary-synopsis"><a id="comment_padding-1"></a><p>Returns the amount of padding before the comment, or <code>none</code>. The latter means that a default padding may be used.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#comment_text/1">comment_text(Node:: syntaxTree() ) -&gt; [string()]</a>

  </div>

    <div class="summary-synopsis"><a id="comment_text-1"></a><p>Returns the lines of text of the abstract comment.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#compact_list/1">compact_list(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="compact_list-1"></a><p>Yields the most compact form for an abstract list skeleton. The result either represents &quot;<code>[E1, ..., En | Tail]</code>&quot;, where <code>Tail</code> is not a list skeleton, or otherwise simply &quot;<code>[E1, ..., En]</code>&quot;. Annotations on subtrees of <code>Node</code> that represent list skeletons may be lost, but comments will be propagated to the result. Returns <code>Node</code> itself if <code>Node</code> does not represent a list skeleton.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#concrete/1">concrete(Node:: syntaxTree() ) -&gt; term()</a>

  </div>

    <div class="summary-synopsis"><a id="concrete-1"></a><p>Returns the Erlang term represented by a syntax tree. Evaluation fails with reason <code>badarg</code> if <code>Node</code> does not represent a literal term.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#conjunction/1">conjunction(Tests::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="conjunction-1"></a><p>Creates an abstract conjunction. If <code>List</code> is <code>[E1, ..., En]</code>, the result represents &quot;<code>E1, ..., En</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#conjunction_body/1">conjunction_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="conjunction_body-1"></a><p>Returns the list of body subtrees of a <code>conjunction</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#cons/2">cons(Head:: syntaxTree() , Tail:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="cons-2"></a><p>&quot;Optimising&quot; list skeleton cons operation. Creates an abstract list skeleton whose first element is <code>Head</code> and whose tail corresponds to <code>Tail</code>. This is similar to <code>list([Head], Tail)</code>, except that <code>Tail</code> may not be <code>none</code>, and that the result does not necessarily represent exactly &quot;<code>[Head | Tail]</code>&quot;, but may depend on the <code>Tail</code> subtree. E.g., if <code>Tail</code> represents <code>[X, Y]</code>, the result may represent &quot;<code>[Head, X, Y]</code>&quot;, rather than &quot;<code>[Head | [X, Y]]</code>&quot;. Annotations on <code>Tail</code> itself may be lost if <code>Tail</code> represents a list skeleton, but comments on <code>Tail</code> are propagated to the result.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#constrained_function_type/2">constrained_function_type(FunctionType:: syntaxTree() , FunctionConstraint::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="constrained_function_type-2"></a><p>Creates an abstract constrained function type. If <code>FunctionConstraint</code> is <code>[C1, ..., Cn]</code>, the result represents &quot;<code>FunctionType when C1, ...Cn</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#constrained_function_type_argument/1">constrained_function_type_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="constrained_function_type_argument-1"></a><p>Returns the function constraint subtree of a <code>constrained_function_type</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#constrained_function_type_body/1">constrained_function_type_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="constrained_function_type_body-1"></a><p>Returns the function type subtree of a <code>constrained_function_type</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#constraint/2">constraint(Name:: syntaxTree() , Types::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="constraint-2"></a><p>Creates an abstract (subtype) constraint. The result represents &quot;<code>Name :: Type</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#constraint_argument/1">constraint_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="constraint_argument-1"></a><p>Returns the name subtree of a <code>constraint</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#constraint_body/1">constraint_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="constraint_body-1"></a><p>Returns the type subtree of a <code>constraint</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#copy_ann/2">copy_ann(Source:: syntaxTree() , Target:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="copy_ann-2"></a><p>Copies the list of user annotations from <code>Source</code> to <code>Target</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#copy_attrs/2">copy_attrs(S:: syntaxTree() , T:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="copy_attrs-2"></a><p>Copies the attributes from <code>Source</code> to <code>Target</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#copy_comments/2">copy_comments(Source:: syntaxTree() , Target:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="copy_comments-2"></a><p>Copies the pre- and postcomments from <code>Source</code> to <code>Target</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#copy_pos/2">copy_pos(Source:: syntaxTree() , Target:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="copy_pos-2"></a><p>Copies the annotation from <code>Source</code> to <code>Target</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#data/1">data(Tree:: syntaxTree() ) -&gt; term()</a>

  </div>

    <div class="summary-synopsis"><a id="data-1"></a><p><em>For special purposes only</em>. Returns the associated data of a syntax tree node. Evaluation fails with reason <code>badarg</code> if <code>is_tree(Node)</code> does not yield <code>true</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#disjunction/1">disjunction(Tests::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="disjunction-1"></a><p>Creates an abstract disjunction. If <code>List</code> is <code>[E1, ..., En]</code>, the result represents &quot;<code>E1; ...; En</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#disjunction_body/1">disjunction_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="disjunction_body-1"></a><p>Returns the list of body subtrees of a <code>disjunction</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#eof_marker/0">eof_marker() -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="eof_marker-0"></a><p>Creates an abstract end-of-file marker. This represents the end of input when reading a sequence of source code forms. An end-of-file marker is itself regarded as a source code form (namely, the last in any sequence in which it occurs). It has no defined lexical form.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#error_marker/1">error_marker(Error::term()) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="error_marker-1"></a><p>Creates an abstract error marker. The result represents an occurrence of an error in the source code, with an associated Erlang I/O ErrorInfo structure given by <code>Error</code> (see module <a href="https://wojtekmach.pl/otp_docs/stdlib/io.html">io(3)</a> for details). Error markers are regarded as source code forms, but have no defined lexical form.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#error_marker_info/1">error_marker_info(Node:: syntaxTree() ) -&gt; term()</a>

  </div>

    <div class="summary-synopsis"><a id="error_marker_info-1"></a><p>Returns the ErrorInfo structure of an <code>error_marker</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#flatten_form_list/1">flatten_form_list(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="flatten_form_list-1"></a><p>Flattens sublists of a <code>form_list</code> node. Returns <code>Node</code> with all subtrees of type <code>form_list</code> recursively expanded, yielding a single &quot;flat&quot; abstract form sequence.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#float/1">float(Value::float()) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="float-1"></a><p>Creates an abstract floating-point literal. The lexical representation is the decimal floating-point numeral of <code>Value</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#float_literal/1">float_literal(Node:: syntaxTree() ) -&gt; string()</a>

  </div>

    <div class="summary-synopsis"><a id="float_literal-1"></a><p>Returns the numeral string represented by a <code>float</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#float_value/1">float_value(Node:: syntaxTree() ) -&gt; float()</a>

  </div>

    <div class="summary-synopsis"><a id="float_value-1"></a><p>Returns the value represented by a <code>float</code> node. Note that floating-point values should usually not be compared for equality.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#form_list/1">form_list(Forms::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="form_list-1"></a><p>Creates an abstract sequence of &quot;source code forms&quot;. If <code>Forms</code> is <code>[F1, ..., Fn]</code>, where each <code>Fi</code> is a form (see <a href="erl_syntax.html#is_form/1">is_form/1</a>, the result represents</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#form_list_elements/1">form_list_elements(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="form_list_elements-1"></a><p>Returns the list of subnodes of a <code>form_list</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#fun_expr/1">fun_expr(Clauses::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="fun_expr-1"></a><p>Creates an abstract fun-expression. If <code>Clauses</code> is <code>[C1, ..., Cn]</code>, the result represents &quot;<code>fun C1; ...; Cn end</code>&quot;. More exactly, if each <code>Ci</code> represents &quot;<code>(Pi1, ..., Pim) Gi -&gt; Bi</code>&quot;, then the result represents &quot;<code>fun (P11, ..., P1m) G1 -&gt; B1; ...; (Pn1, ..., Pnm) Gn -&gt; Bn end</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#fun_expr_arity/1">fun_expr_arity(Node:: syntaxTree() ) -&gt; arity()</a>

  </div>

    <div class="summary-synopsis"><a id="fun_expr_arity-1"></a><p>Returns the arity of a <code>fun_expr</code> node. The result is the number of parameter patterns in the first clause of the fun-expression; subsequent clauses are ignored.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#fun_expr_clauses/1">fun_expr_clauses(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="fun_expr_clauses-1"></a><p>Returns the list of clause subtrees of a <code>fun_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#fun_type/0">fun_type() -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="fun_type-0"></a><p>Creates an abstract fun of any type. The result represents &quot;<code>fun()</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#function/2">function(Name:: syntaxTree() , Clauses::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="function-2"></a><p>Creates an abstract function definition. If <code>Clauses</code> is <code>[C1, ..., Cn]</code>, the result represents &quot;<code>Name C1; ...; Name Cn.</code>&quot;. More exactly, if each <code>Ci</code> represents &quot;<code>(Pi1, ..., Pim) Gi -&gt; Bi</code>&quot;, then the result represents &quot;<code>Name(P11, ..., P1m) G1 -&gt; B1; ...; Name(Pn1, ..., Pnm) Gn -&gt; Bn.</code>&quot;. Function definitions are source code forms.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#function_arity/1">function_arity(Node:: syntaxTree() ) -&gt; arity()</a>

  </div>

    <div class="summary-synopsis"><a id="function_arity-1"></a><p>Returns the arity of a <code>function</code> node. The result is the number of parameter patterns in the first clause of the function; subsequent clauses are ignored.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#function_clauses/1">function_clauses(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="function_clauses-1"></a><p>Returns the list of clause subtrees of a <code>function</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#function_name/1">function_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="function_name-1"></a><p>Returns the name subtree of a <code>function</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#function_type/1">function_type(Type) -&gt; term()
</a>

  </div>

    <div class="summary-synopsis"><a id="function_type-1"></a><p>Equivalent to <a href="erl_syntax.html#function_type/2">function_type(any_arity, Type)</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#function_type/2">function_type(Arguments::any_arity | [ syntaxTree() ], Return:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="function_type-2"></a><p>Creates an abstract function type. If <code>Arguments</code> is <code>[T1, ..., Tn]</code>, then if it occurs within a function specification, the result represents &quot;<code>(T1, ...Tn) -&gt; Return</code>&quot;; otherwise it represents &quot;<code>fun((T1, ...Tn) -&gt; Return)</code>&quot;. If <code>Arguments</code> is <code>any_arity</code>, it represents &quot;<code>fun((...) -&gt; Return)</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#function_type_arguments/1">function_type_arguments(Node:: syntaxTree() ) -&gt; any_arity | [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="function_type_arguments-1"></a><p>Returns the argument types subtrees of a <code>function_type</code> node. If <code>Node</code> represents &quot;<code>fun((...) -&gt; Return)</code>&quot;, <code>any_arity</code> is returned; otherwise, if <code>Node</code> represents &quot;<code>(T1, ...Tn) -&gt; Return</code>&quot; or &quot;<code>fun((T1, ...Tn) -&gt; Return)</code>&quot;, <code>[T1, ..., Tn]</code> is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#function_type_return/1">function_type_return(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="function_type_return-1"></a><p>Returns the return type subtrees of a <code>function_type</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#generator/2">generator(Pattern:: syntaxTree() , Body:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="generator-2"></a><p>Creates an abstract generator. The result represents &quot;<code>Pattern &lt;- Body</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#generator_body/1">generator_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="generator_body-1"></a><p>Returns the body subtree of a <code>generator</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#generator_pattern/1">generator_pattern(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="generator_pattern-1"></a><p>Returns the pattern subtree of a <code>generator</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#get_ann/1">get_ann(Tree:: syntaxTree() ) -&gt; [term()]</a>

  </div>

    <div class="summary-synopsis"><a id="get_ann-1"></a><p>Returns the list of user annotations associated with a syntax tree node. For a newly created node, this is the empty list. The annotations may be any terms.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#get_attrs/1">get_attrs(Tree:: syntaxTree() ) -&gt;  syntaxTreeAttributes()</a>

  </div>

    <div class="summary-synopsis"><a id="get_attrs-1"></a><p>Returns a representation of the attributes associated with a syntax tree node. The attributes are all the extra information that can be attached to a node. Currently, this includes position information, source code comments, and user annotations. The result of this function cannot be inspected directly; only attached to another node (see <a href="erl_syntax.html#set_attrs/2">set_attrs/2</a>).</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#get_pos/1">get_pos(Tree:: syntaxTree() ) -&gt;  annotation_or_location()</a>

  </div>

    <div class="summary-synopsis"><a id="get_pos-1"></a><p>Returns the annotation (see <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_anno.html">erl_anno(3)</a>) associated with <code>Node</code>. By default, all new tree nodes have their associated position information set to the integer zero. Use <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_anno.html#location/1">erl_anno:location/1</a> or <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_anno.html#line/1">erl_anno:line/1</a> to get the position information.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#get_postcomments/1">get_postcomments(Tree:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="get_postcomments-1"></a><p>Returns the associated post-comments of a node. This is a possibly empty list of abstract comments, in top-down textual order. When the code is formatted, post-comments are typically displayed to the right of and/or below the node. For example</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#get_precomments/1">get_precomments(Tree:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="get_precomments-1"></a><p>Returns the associated pre-comments of a node. This is a possibly empty list of abstract comments, in top-down textual order. When the code is formatted, pre-comments are typically displayed directly above the node. For example</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#has_comments/1">has_comments(Tree:: syntaxTree() ) -&gt; boolean()</a>

  </div>

    <div class="summary-synopsis"><a id="has_comments-1"></a><p>Yields <code>false</code> if the node has no associated comments, and <code>true</code> otherwise.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#if_expr/1">if_expr(Clauses::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="if_expr-1"></a><p>Creates an abstract if-expression. If <code>Clauses</code> is <code>[C1, ..., Cn]</code>, the result represents &quot;<code>if C1; ...; Cn end</code>&quot;. More exactly, if each <code>Ci</code> represents &quot;<code>() Gi -&gt; Bi</code>&quot;, then the result represents &quot;<code>if G1 -&gt; B1; ...; Gn -&gt; Bn end</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#if_expr_clauses/1">if_expr_clauses(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="if_expr_clauses-1"></a><p>Returns the list of clause subtrees of an <code>if_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#implicit_fun/1">implicit_fun(Name:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="implicit_fun-1"></a><p>Creates an abstract &quot;implicit fun&quot; expression. The result represents &quot;<code>fun Name</code>&quot;. <code>Name</code> should represent either <code>F/A</code> or <code>M:F/A</code></p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#implicit_fun/2">implicit_fun(Name:: syntaxTree() , Arity::none |  syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="implicit_fun-2"></a><p>Creates an abstract &quot;implicit fun&quot; expression. If <code>Arity</code> is <code>none</code>, this is equivalent to <code>implicit_fun(Name)</code>, otherwise it is equivalent to <code>implicit_fun(arity_qualifier(Name, Arity))</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#implicit_fun/3">implicit_fun(Module::none |  syntaxTree() , Name:: syntaxTree() , Arity:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="implicit_fun-3"></a><p>Creates an abstract module-qualified &quot;implicit fun&quot; expression. If <code>Module</code> is <code>none</code>, this is equivalent to <code>implicit_fun(Name, Arity)</code>, otherwise it is equivalent to <code>implicit_fun(module_qualifier(Module, arity_qualifier(Name, Arity))</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#implicit_fun_name/1">implicit_fun_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="implicit_fun_name-1"></a><p>Returns the name subtree of an <code>implicit_fun</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#infix_expr/3">infix_expr(Left:: syntaxTree() , Operator:: syntaxTree() , Right:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="infix_expr-3"></a><p>Creates an abstract infix operator expression. The result represents &quot;<code>Left Operator Right</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#infix_expr_left/1">infix_expr_left(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="infix_expr_left-1"></a><p>Returns the left argument subtree of an <code>infix_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#infix_expr_operator/1">infix_expr_operator(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="infix_expr_operator-1"></a><p>Returns the operator subtree of an <code>infix_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#infix_expr_right/1">infix_expr_right(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="infix_expr_right-1"></a><p>Returns the right argument subtree of an <code>infix_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#integer/1">integer(Value::integer()) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="integer-1"></a><p>Creates an abstract integer literal. The lexical representation is the canonical decimal numeral of <code>Value</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#integer_literal/1">integer_literal(Node:: syntaxTree() ) -&gt; string()</a>

  </div>

    <div class="summary-synopsis"><a id="integer_literal-1"></a><p>Returns the numeral string represented by an <code>integer</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#integer_range_type/2">integer_range_type(Low:: syntaxTree() , High:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="integer_range_type-2"></a><p>Creates an abstract range type. The result represents &quot;<code>Low .. High</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#integer_range_type_high/1">integer_range_type_high(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="integer_range_type_high-1"></a><p>Returns the high limit of an <code>integer_range_type</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#integer_range_type_low/1">integer_range_type_low(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="integer_range_type_low-1"></a><p>Returns the low limit of an <code>integer_range_type</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#integer_value/1">integer_value(Node:: syntaxTree() ) -&gt; integer()</a>

  </div>

    <div class="summary-synopsis"><a id="integer_value-1"></a><p>Returns the value represented by an <code>integer</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_atom/2">is_atom(Node:: syntaxTree() , Value::atom()) -&gt; boolean()</a>

  </div>

    <div class="summary-synopsis"><a id="is_atom-2"></a><p>Returns <code>true</code> if <code>Node</code> has type <code>atom</code> and represents <code>Value</code>, otherwise <code>false</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_char/2">is_char(Node:: syntaxTree() , Value::char()) -&gt; boolean()</a>

  </div>

    <div class="summary-synopsis"><a id="is_char-2"></a><p>Returns <code>true</code> if <code>Node</code> has type <code>char</code> and represents <code>Value</code>, otherwise <code>false</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_form/1">is_form(Node:: syntaxTree() ) -&gt; boolean()</a>

  </div>

    <div class="summary-synopsis"><a id="is_form-1"></a><p>Returns <code>true</code> if <code>Node</code> is a syntax tree representing a so-called &quot;source code form&quot;, otherwise <code>false</code>. Forms are the Erlang source code units which, placed in sequence, constitute an Erlang program. Current form types are</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_integer/2">is_integer(Node:: syntaxTree() , Value::integer()) -&gt; boolean()</a>

  </div>

    <div class="summary-synopsis"><a id="is_integer-2"></a><p>Returns <code>true</code> if <code>Node</code> has type <code>integer</code> and represents <code>Value</code>, otherwise <code>false</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_leaf/1">is_leaf(Node:: syntaxTree() ) -&gt; boolean()</a>

  </div>

    <div class="summary-synopsis"><a id="is_leaf-1"></a><p>Returns <code>true</code> if <code>Node</code> is a leaf node, otherwise <code>false</code>. The currently recognised leaf node types are</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_list_skeleton/1">is_list_skeleton(Node:: syntaxTree() ) -&gt; boolean()</a>

  </div>

    <div class="summary-synopsis"><a id="is_list_skeleton-1"></a><p>Returns <code>true</code> if <code>Node</code> has type <code>list</code> or <code>nil</code>, otherwise <code>false</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_literal/1">is_literal(T:: syntaxTree() ) -&gt; boolean()</a>

  </div>

    <div class="summary-synopsis"><a id="is_literal-1"></a><p>Returns <code>true</code> if <code>Node</code> represents a literal term, otherwise <code>false</code>. This function returns <code>true</code> if and only if the value of <code>concrete(Node)</code> is defined.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_proper_list/1">is_proper_list(Node:: syntaxTree() ) -&gt; boolean()</a>

  </div>

    <div class="summary-synopsis"><a id="is_proper_list-1"></a><p>Returns <code>true</code> if <code>Node</code> represents a proper list, and <code>false</code> otherwise. A proper list is a list skeleton either on the form &quot;<code>[]</code>&quot; or &quot;<code>[E1, ..., En]</code>&quot;, or &quot;<code>[... | Tail]</code>&quot; where recursively <code>Tail</code> also represents a proper list.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_string/2">is_string(Node:: syntaxTree() , Value::string()) -&gt; boolean()</a>

  </div>

    <div class="summary-synopsis"><a id="is_string-2"></a><p>Returns <code>true</code> if <code>Node</code> has type <code>string</code> and represents <code>Value</code>, otherwise <code>false</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_tree/1">is_tree(Tree:: syntaxTree() ) -&gt; boolean()</a>

  </div>

    <div class="summary-synopsis"><a id="is_tree-1"></a><p><em>For special purposes only</em>. Returns <code>true</code> if <code>Tree</code> is an abstract syntax tree and <code>false</code> otherwise.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#join_comments/2">join_comments(Source:: syntaxTree() , Target:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="join_comments-2"></a><p>Appends the comments of <code>Source</code> to the current comments of <code>Target</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#list/1">list(List::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="list-1"></a><p>Equivalent to <a href="erl_syntax.html#list/2">list(List, none)</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#list/2">list(Elements::[ syntaxTree() ], Tail::none |  syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="list-2"></a><p>Constructs an abstract list skeleton. The result has type <code>list</code> or <code>nil</code>. If <code>List</code> is a nonempty list <code>[E1, ..., En]</code>, the result has type <code>list</code> and represents either &quot;<code>[E1, ..., En]</code>&quot;, if <code>Tail</code> is <code>none</code>, or otherwise &quot;<code>[E1, ..., En | Tail]</code>&quot;. If <code>List</code> is the empty list, <code>Tail</code> <em>must</em> be <code>none</code>, and in that case the result has type <code>nil</code> and represents &quot;<code>[]</code>&quot; (see <a href="erl_syntax.html#/0">nil/0</a>).</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#list_comp/2">list_comp(Template:: syntaxTree() , Body::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="list_comp-2"></a><p>Creates an abstract list comprehension. If <code>Body</code> is <code>[E1, ..., En]</code>, the result represents &quot;<code>[Template || E1, ..., En]</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#list_comp_body/1">list_comp_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="list_comp_body-1"></a><p>Returns the list of body subtrees of a <code>list_comp</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#list_comp_template/1">list_comp_template(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="list_comp_template-1"></a><p>Returns the template subtree of a <code>list_comp</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#list_elements/1">list_elements(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="list_elements-1"></a><p>Returns the list of element subtrees of a list skeleton. <code>Node</code> must represent a proper list. E.g., if <code>Node</code> represents &quot;<code>[X1, X2 | [X3, X4 | []]</code>&quot;, then <code>list_elements(Node)</code> yields the list <code>[X1, X2, X3, X4]</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#list_head/1">list_head(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="list_head-1"></a><p>Returns the head element subtree of a <code>list</code> node. If <code>Node</code> represents &quot;<code>[Head ...]</code>&quot;, the result will represent &quot;<code>Head</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#list_length/1">list_length(Node:: syntaxTree() ) -&gt; non_neg_integer()</a>

  </div>

    <div class="summary-synopsis"><a id="list_length-1"></a><p>Returns the number of element subtrees of a list skeleton. <code>Node</code> must represent a proper list. E.g., if <code>Node</code> represents &quot;<code>[X1 | [X2, X3 | [X4, X5, X6]]]</code>&quot;, then <code>list_length(Node)</code> returns the integer 6.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#list_prefix/1">list_prefix(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="list_prefix-1"></a><p>Returns the prefix element subtrees of a <code>list</code> node. If <code>Node</code> represents &quot;<code>[E1, ..., En]</code>&quot; or &quot;<code>[E1, ..., En | Tail]</code>&quot;, the returned value is <code>[E1, ..., En]</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#list_suffix/1">list_suffix(Node:: syntaxTree() ) -&gt; none |  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="list_suffix-1"></a><p>Returns the suffix subtree of a <code>list</code> node, if one exists. If <code>Node</code> represents &quot;<code>[E1, ..., En | Tail]</code>&quot;, the returned value is <code>Tail</code>, otherwise, i.e., if <code>Node</code> represents &quot;<code>[E1, ..., En]</code>&quot;, <code>none</code> is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#list_tail/1">list_tail(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="list_tail-1"></a><p>Returns the tail of a <code>list</code> node. If <code>Node</code> represents a single-element list &quot;<code>[E]</code>&quot;, then the result has type <code>nil</code>, representing &quot;<code>[]</code>&quot;. If <code>Node</code> represents &quot;<code>[E1, E2 ...]</code>&quot;, the result will represent &quot;<code>[E2 ...]</code>&quot;, and if <code>Node</code> represents &quot;<code>[Head | Tail]</code>&quot;, the result will represent &quot;<code>Tail</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#macro/1">macro(Name:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="macro-1"></a><p>Equivalent to <a href="erl_syntax.html#macro/2">macro(Name, none)</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#macro/2">macro(Name:: syntaxTree() , Arguments::none | [ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="macro-2"></a><p>Creates an abstract macro application. If <code>Arguments</code> is <code>none</code>, the result represents &quot;<code>?Name</code>&quot;, otherwise, if <code>Arguments</code> is <code>[A1, ..., An]</code>, the result represents &quot;<code>?Name(A1, ..., An)</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#macro_arguments/1">macro_arguments(Node:: syntaxTree() ) -&gt; none | [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="macro_arguments-1"></a><p>Returns the list of argument subtrees of a <code>macro</code> node, if any. If <code>Node</code> represents &quot;<code>?Name</code>&quot;, <code>none</code> is returned. Otherwise, if <code>Node</code> represents &quot;<code>?Name(A1, ..., An)</code>&quot;, <code>[A1, ..., An]</code> is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#macro_name/1">macro_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="macro_name-1"></a><p>Returns the name subtree of a <code>macro</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#make_tree/2">make_tree(X1::atom(), X2::[[ syntaxTree() ]]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="make_tree-2"></a><p>Creates a syntax tree with the given type and subtrees. <code>Type</code> must be a node type name (see <a href="erl_syntax.html#type/1">type/1</a>) that does not denote a leaf node type (see <a href="erl_syntax.html#is_leaf/1">is_leaf/1</a>). <code>Groups</code> must be a <em>nonempty</em> list of groups of syntax trees, representing the subtrees of a node of the given type, in left-to-right order as they would occur in the printed program text, grouped by category as done by <a href="erl_syntax.html#subtrees/1">subtrees/1</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_expr/1">map_expr(Fields::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_expr-1"></a><p>Equivalent to <a href="erl_syntax.html#map_expr/2">map_expr(none, Fields)</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_expr/2">map_expr(Argument::none |  syntaxTree() , Fields::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_expr-2"></a><p>Creates an abstract map expression. If <code>Fields</code> is <code>[F1, ..., Fn]</code>, then if <code>Argument</code> is <code>none</code>, the result represents &quot;<code>#{F1, ..., Fn}</code>&quot;, otherwise it represents &quot;<code>Argument#{F1, ..., Fn}</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_expr_argument/1">map_expr_argument(Node:: syntaxTree() ) -&gt; none |  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_expr_argument-1"></a><p>Returns the argument subtree of a <code>map_expr</code> node, if any. If <code>Node</code> represents &quot;<code>#{...}</code>&quot;, <code>none</code> is returned. Otherwise, if <code>Node</code> represents &quot;<code>Argument#{...}</code>&quot;, <code>Argument</code> is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_expr_fields/1">map_expr_fields(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="map_expr_fields-1"></a><p>Returns the list of field subtrees of a <code>map_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_field_assoc/2">map_field_assoc(Name:: syntaxTree() , Value:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_field_assoc-2"></a><p>Creates an abstract map assoc field. The result represents &quot;<code>Name =&gt; Value</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_field_assoc_name/1">map_field_assoc_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_field_assoc_name-1"></a><p>Returns the name subtree of a <code>map_field_assoc</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_field_assoc_value/1">map_field_assoc_value(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_field_assoc_value-1"></a><p>Returns the value subtree of a <code>map_field_assoc</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_field_exact/2">map_field_exact(Name:: syntaxTree() , Value:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_field_exact-2"></a><p>Creates an abstract map exact field. The result represents &quot;<code>Name := Value</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_field_exact_name/1">map_field_exact_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_field_exact_name-1"></a><p>Returns the name subtree of a <code>map_field_exact</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_field_exact_value/1">map_field_exact_value(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_field_exact_value-1"></a><p>Returns the value subtree of a <code>map_field_exact</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_type/0">map_type() -&gt; term()
</a>

  </div>

    <div class="summary-synopsis"><a id="map_type-0"></a><p>Equivalent to <a href="erl_syntax.html#map_type/1">map_type(any_size)</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_type/1">map_type(Fields::any_size | [ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_type-1"></a><p>Creates an abstract type map. If <code>Fields</code> is <code>[F1, ..., Fn]</code>, the result represents &quot;<code>#{F1, ..., Fn}</code>&quot;; otherwise, if <code>Fields</code> is <code>any_size</code>, it represents &quot;<code>map()</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_type_assoc/2">map_type_assoc(Name:: syntaxTree() , Value:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_type_assoc-2"></a><p>Creates an abstract map type assoc field. The result represents &quot;<code>Name =&gt; Value</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_type_assoc_name/1">map_type_assoc_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_type_assoc_name-1"></a><p>Returns the name subtree of a <code>map_type_assoc</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_type_assoc_value/1">map_type_assoc_value(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_type_assoc_value-1"></a><p>Returns the value subtree of a <code>map_type_assoc</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_type_exact/2">map_type_exact(Name:: syntaxTree() , Value:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_type_exact-2"></a><p>Creates an abstract map type exact field. The result represents &quot;<code>Name := Value</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_type_exact_name/1">map_type_exact_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_type_exact_name-1"></a><p>Returns the name subtree of a <code>map_type_exact</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_type_exact_value/1">map_type_exact_value(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="map_type_exact_value-1"></a><p>Returns the value subtree of a <code>map_type_exact</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_type_fields/1">map_type_fields(Node:: syntaxTree() ) -&gt; any_size | [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="map_type_fields-1"></a><p>Returns the list of field subtrees of a <code>map_type</code> node. If <code>Node</code> represents &quot;<code>map()</code>&quot;, <code>any_size</code> is returned; otherwise, if <code>Node</code> represents &quot;<code>#{F1, ..., Fn}</code>&quot;, <code>[F1, ..., Fn]</code> is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#match_expr/2">match_expr(Pattern:: syntaxTree() , Body:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="match_expr-2"></a><p>Creates an abstract match-expression. The result represents &quot;<code>Pattern = Body</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#match_expr_body/1">match_expr_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="match_expr_body-1"></a><p>Returns the body subtree of a <code>match_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#match_expr_pattern/1">match_expr_pattern(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="match_expr_pattern-1"></a><p>Returns the pattern subtree of a <code>match_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#meta/1">meta(T:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="meta-1"></a><p>Creates a meta-representation of a syntax tree. The result represents an Erlang expression &quot;<code>MetaTree</code>&quot; which, if evaluated, will yield a new syntax tree representing the same source code text as <code>Tree</code> (although the actual data representation may be different). The expression represented by <code>MetaTree</code> is <em>implementation independent</em> with regard to the data structures used by the abstract syntax tree implementation. Comments attached to nodes of <code>Tree</code> will be preserved, but other attributes are lost.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#module_qualifier/2">module_qualifier(Module:: syntaxTree() , Body:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="module_qualifier-2"></a><p>Creates an abstract module qualifier. The result represents &quot;<code>Module:Body</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#module_qualifier_argument/1">module_qualifier_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="module_qualifier_argument-1"></a><p>Returns the argument (the module) subtree of a <code>module_qualifier</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#module_qualifier_body/1">module_qualifier_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="module_qualifier_body-1"></a><p>Returns the body subtree of a <code>module_qualifier</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#named_fun_expr/2">named_fun_expr(Name:: syntaxTree() , Clauses::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="named_fun_expr-2"></a><p>Creates an abstract named fun-expression. If <code>Clauses</code> is <code>[C1, ..., Cn]</code>, the result represents &quot;<code>fun Name C1; ...; Name Cn end</code>&quot;. More exactly, if each <code>Ci</code> represents &quot;<code>(Pi1, ..., Pim) Gi -&gt; Bi</code>&quot;, then the result represents &quot;<code>fun Name(P11, ..., P1m) G1 -&gt; B1; ...; Name(Pn1, ..., Pnm) Gn -&gt; Bn end</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#named_fun_expr_arity/1">named_fun_expr_arity(Node:: syntaxTree() ) -&gt; arity()</a>

  </div>

    <div class="summary-synopsis"><a id="named_fun_expr_arity-1"></a><p>Returns the arity of a <code>named_fun_expr</code> node. The result is the number of parameter patterns in the first clause of the named fun-expression; subsequent clauses are ignored.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#named_fun_expr_clauses/1">named_fun_expr_clauses(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="named_fun_expr_clauses-1"></a><p>Returns the list of clause subtrees of a <code>named_fun_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#named_fun_expr_name/1">named_fun_expr_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="named_fun_expr_name-1"></a><p>Returns the name subtree of a <code>named_fun_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#/0">nil() -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="nil-0"></a><p>Creates an abstract empty list. The result represents &quot;<code>[]</code>&quot;. The empty list is traditionally called &quot;nil&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#normalize_list/1">normalize_list(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="normalize_list-1"></a><p>Expands an abstract list skeleton to its most explicit form. If <code>Node</code> represents &quot;<code>[E1, ..., En | Tail]</code>&quot;, the result represents &quot;<code>[E1 | ... [En | Tail1] ... ]</code>&quot;, where <code>Tail1</code> is the result of <code>normalize_list(Tail)</code>. If <code>Node</code> represents &quot;<code>[E1, ..., En]</code>&quot;, the result simply represents &quot;<code>[E1 | ... [En | []] ... ]</code>&quot;. If <code>Node</code> does not represent a list skeleton, <code>Node</code> itself is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#operator/1">operator(Name::atom() | string()) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="operator-1"></a><p>Creates an abstract operator. The name of the operator is the character sequence represented by <code>Name</code>. This is analogous to the print name of an atom, but an operator is never written within single-quotes; e.g., the result of <code>operator('++')</code> represents &quot;<code>++</code>&quot; rather than &quot;<code>'++'</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#operator_literal/1">operator_literal(Node:: syntaxTree() ) -&gt; string()</a>

  </div>

    <div class="summary-synopsis"><a id="operator_literal-1"></a><p>Returns the literal string represented by an <code>operator</code> node. This is simply the operator name as a string.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#operator_name/1">operator_name(Node:: syntaxTree() ) -&gt; atom()</a>

  </div>

    <div class="summary-synopsis"><a id="operator_name-1"></a><p>Returns the name of an <code>operator</code> node. Note that the name is returned as an atom.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#parentheses/1">parentheses(Expr:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="parentheses-1"></a><p>Creates an abstract parenthesised expression. The result represents &quot;<code>(Body)</code>&quot;, independently of the context.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#parentheses_body/1">parentheses_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="parentheses_body-1"></a><p>Returns the body subtree of a <code>parentheses</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#prefix_expr/2">prefix_expr(Operator:: syntaxTree() , Argument:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="prefix_expr-2"></a><p>Creates an abstract prefix operator expression. The result represents &quot;<code>Operator Argument</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#prefix_expr_argument/1">prefix_expr_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="prefix_expr_argument-1"></a><p>Returns the argument subtree of a <code>prefix_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#prefix_expr_operator/1">prefix_expr_operator(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="prefix_expr_operator-1"></a><p>Returns the operator subtree of a <code>prefix_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#receive_expr/1">receive_expr(Clauses::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="receive_expr-1"></a><p>Equivalent to <a href="erl_syntax.html#receive_expr/3">receive_expr(Clauses, none, [])</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#receive_expr/3">receive_expr(Clauses::[ syntaxTree() ], Timeout::none |  syntaxTree() , Action::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="receive_expr-3"></a><p>Creates an abstract receive-expression. If <code>Timeout</code> is <code>none</code>, the result represents &quot;<code>receive C1; ...; Cn end</code>&quot; (the <code>Action</code> argument is ignored). Otherwise, if <code>Clauses</code> is <code>[C1, ..., Cn]</code> and <code>Action</code> is <code>[A1, ..., Am]</code>, the result represents &quot;<code>receive C1; ...; Cn after Timeout -&gt; A1, ..., Am end</code>&quot;. More exactly, if each <code>Ci</code> represents &quot;<code>(Pi) Gi -&gt; Bi</code>&quot;, then the result represents &quot;<code>receive P1 G1 -&gt; B1; ...; Pn Gn -&gt; Bn ... end</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#receive_expr_action/1">receive_expr_action(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="receive_expr_action-1"></a><p>Returns the list of action body subtrees of a <code>receive_expr</code> node. If <code>Node</code> represents &quot;<code>receive C1; ...; Cn end</code>&quot;, this is the empty list.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#receive_expr_clauses/1">receive_expr_clauses(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="receive_expr_clauses-1"></a><p>Returns the list of clause subtrees of a <code>receive_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#receive_expr_timeout/1">receive_expr_timeout(Node:: syntaxTree() ) -&gt; none |  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="receive_expr_timeout-1"></a><p>Returns the timeout subtree of a <code>receive_expr</code> node, if any. If <code>Node</code> represents &quot;<code>receive C1; ...; Cn end</code>&quot;, <code>none</code> is returned. Otherwise, if <code>Node</code> represents &quot;<code>receive C1; ...; Cn after Timeout -&gt; ... end</code>&quot;, <code>Timeout</code> is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_access/3">record_access(Argument:: syntaxTree() , Type:: syntaxTree() , Field:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_access-3"></a><p>Creates an abstract record field access expression. The result represents &quot;<code>Argument#Type.Field</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_access_argument/1">record_access_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_access_argument-1"></a><p>Returns the argument subtree of a <code>record_access</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_access_field/1">record_access_field(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_access_field-1"></a><p>Returns the field subtree of a <code>record_access</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_access_type/1">record_access_type(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_access_type-1"></a><p>Returns the type subtree of a <code>record_access</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_expr/2">record_expr(Type:: syntaxTree() , Fields::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_expr-2"></a><p>Equivalent to <a href="erl_syntax.html#record_expr/3">record_expr(none, Type, Fields)</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_expr/3">record_expr(Argument::none |  syntaxTree() , Type:: syntaxTree() , Fields::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_expr-3"></a><p>Creates an abstract record expression. If <code>Fields</code> is <code>[F1, ..., Fn]</code>, then if <code>Argument</code> is <code>none</code>, the result represents &quot;<code>#Type{F1, ..., Fn}</code>&quot;, otherwise it represents &quot;<code>Argument#Type{F1, ..., Fn}</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_expr_argument/1">record_expr_argument(Node:: syntaxTree() ) -&gt; none |  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_expr_argument-1"></a><p>Returns the argument subtree of a <code>record_expr</code> node, if any. If <code>Node</code> represents &quot;<code>#Type{...}</code>&quot;, <code>none</code> is returned. Otherwise, if <code>Node</code> represents &quot;<code>Argument#Type{...}</code>&quot;, <code>Argument</code> is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_expr_fields/1">record_expr_fields(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="record_expr_fields-1"></a><p>Returns the list of field subtrees of a <code>record_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_expr_type/1">record_expr_type(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_expr_type-1"></a><p>Returns the type subtree of a <code>record_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_field/1">record_field(Name:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_field-1"></a><p>Equivalent to <a href="erl_syntax.html#record_field/2">record_field(Name, none)</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_field/2">record_field(Name:: syntaxTree() , Value::none |  syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_field-2"></a><p>Creates an abstract record field specification. If <code>Value</code> is <code>none</code>, the result represents simply &quot;<code>Name</code>&quot;, otherwise it represents &quot;<code>Name = Value</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_field_name/1">record_field_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_field_name-1"></a><p>Returns the name subtree of a <code>record_field</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_field_value/1">record_field_value(Node:: syntaxTree() ) -&gt; none |  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_field_value-1"></a><p>Returns the value subtree of a <code>record_field</code> node, if any. If <code>Node</code> represents &quot;<code>Name</code>&quot;, <code>none</code> is returned. Otherwise, if <code>Node</code> represents &quot;<code>Name = Value</code>&quot;, <code>Value</code> is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_index_expr/2">record_index_expr(Type:: syntaxTree() , Field:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_index_expr-2"></a><p>Creates an abstract record field index expression. The result represents &quot;<code>#Type.Field</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_index_expr_field/1">record_index_expr_field(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_index_expr_field-1"></a><p>Returns the field subtree of a <code>record_index_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_index_expr_type/1">record_index_expr_type(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_index_expr_type-1"></a><p>Returns the type subtree of a <code>record_index_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_type/2">record_type(Name:: syntaxTree() , Fields::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_type-2"></a><p>Creates an abstract record type. If <code>Fields</code> is <code>[F1, ..., Fn]</code>, the result represents &quot;<code>#Name{F1, ..., Fn}</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_type_field/2">record_type_field(Name:: syntaxTree() , Type:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_type_field-2"></a><p>Creates an abstract record type field. The result represents &quot;<code>Name :: Type</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_type_field_name/1">record_type_field_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_type_field_name-1"></a><p>Returns the name subtree of a <code>record_type_field</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_type_field_type/1">record_type_field_type(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_type_field_type-1"></a><p>Returns the type subtree of a <code>record_type_field</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_type_fields/1">record_type_fields(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="record_type_fields-1"></a><p>Returns the fields subtree of a <code>record_type</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#record_type_name/1">record_type_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="record_type_name-1"></a><p>Returns the name subtree of a <code>record_type</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#remove_comments/1">remove_comments(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="remove_comments-1"></a><p>Clears the associated comments of <code>Node</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#revert/1">revert(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="revert-1"></a><p>Returns an <code>erl_parse</code>-compatible representation of a syntax tree, if possible. If <code>Tree</code> represents a well-formed Erlang program or expression, the conversion should work without problems. Typically, <a href="erl_syntax.html#is_tree/1">is_tree/1</a> yields <code>true</code> if conversion failed (i.e., the result is still an abstract syntax tree), and <code>false</code> otherwise.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#revert_forms/1">revert_forms(Forms:: forms() ) -&gt; [ erl_parse() ]</a>

  </div>

    <div class="summary-synopsis"><a id="revert_forms-1"></a><p>Reverts a sequence of Erlang source code forms. The sequence can be given either as a <code>form_list</code> syntax tree (possibly nested), or as a list of &quot;program form&quot; syntax trees. If successful, the corresponding flat list of <code>erl_parse</code>-compatible syntax trees is returned (see <a href="erl_syntax.html#revert/1">revert/1</a>). If some program form could not be reverted, <code>{error, Form}</code> is thrown. Standalone comments in the form sequence are discarded.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#set_ann/2">set_ann(Node:: syntaxTree() , As::[term()]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="set_ann-2"></a><p>Sets the list of user annotations of <code>Node</code> to <code>Annotations</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#set_attrs/2">set_attrs(Node:: syntaxTree() , Attr:: syntaxTreeAttributes() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="set_attrs-2"></a><p>Sets the attributes of <code>Node</code> to <code>Attributes</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#set_pos/2">set_pos(Node:: syntaxTree() , Pos:: annotation_or_location() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="set_pos-2"></a><p>Sets the position information of <code>Node</code> to <code>Pos</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#set_postcomments/2">set_postcomments(Node:: syntaxTree() , Cs::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="set_postcomments-2"></a><p>Sets the post-comments of <code>Node</code> to <code>Comments</code>. <code>Comments</code> should be a possibly empty list of abstract comments, in top-down textual order</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#set_precomments/2">set_precomments(Node:: syntaxTree() , Cs::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="set_precomments-2"></a><p>Sets the pre-comments of <code>Node</code> to <code>Comments</code>. <code>Comments</code> should be a possibly empty list of abstract comments, in top-down textual order.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#size_qualifier/2">size_qualifier(Body:: syntaxTree() , Size:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="size_qualifier-2"></a><p>Creates an abstract size qualifier. The result represents &quot;<code>Body:Size</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#size_qualifier_argument/1">size_qualifier_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="size_qualifier_argument-1"></a><p>Returns the argument subtree (the size) of a <code>size_qualifier</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#size_qualifier_body/1">size_qualifier_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="size_qualifier_body-1"></a><p>Returns the body subtree of a <code>size_qualifier</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#string/1">string(String::string()) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="string-1"></a><p>Creates an abstract string literal. The result represents <code>&quot;Text&quot;</code> (including the surrounding double-quotes), where <code>Text</code> corresponds to the sequence of characters in <code>Value</code>, but not representing a <em>specific</em> string literal.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#string_literal/1">string_literal(Node:: syntaxTree() ) -&gt; nonempty_string()</a>

  </div>

    <div class="summary-synopsis"><a id="string_literal-1"></a><p>Returns the literal string represented by a <code>string</code> node. This includes surrounding double-quote characters. Characters beyond 255 will be escaped.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#string_literal/2">string_literal(Node:: syntaxTree() , X2:: encoding() ) -&gt; nonempty_string()</a>

  </div>

    <div class="summary-synopsis"><a id="string_literal-2"></a><p>Returns the literal string represented by a <code>string</code> node. This includes surrounding double-quote characters. Depending on the encoding characters beyond 255 will be escaped (<code>latin1</code>) or copied as is (<code>utf8</code>).</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#string_value/1">string_value(Node:: syntaxTree() ) -&gt; string()</a>

  </div>

    <div class="summary-synopsis"><a id="string_value-1"></a><p>Returns the value represented by a <code>string</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#subtrees/1">subtrees(T:: syntaxTree() ) -&gt; [[ syntaxTree() ]]</a>

  </div>

    <div class="summary-synopsis"><a id="subtrees-1"></a><p>Returns the grouped list of all subtrees of a syntax tree. If <code>Node</code> is a leaf node (see <a href="erl_syntax.html#is_leaf/1">is_leaf/1</a>), this is the empty list, otherwise the result is always a nonempty list, containing the lists of subtrees of <code>Node</code>, in left-to-right order as they occur in the printed program text, and grouped by category. Often, each group contains only a single subtree.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#text/1">text(String::string()) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="text-1"></a><p>Creates an abstract piece of source code text. The result represents exactly the sequence of characters in <code>String</code>. This is useful in cases when one wants full control of the resulting output, e.g., for the appearance of floating-point numbers or macro definitions.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#text_string/1">text_string(Node:: syntaxTree() ) -&gt; string()</a>

  </div>

    <div class="summary-synopsis"><a id="text_string-1"></a><p>Returns the character sequence represented by a <code>text</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#tree/1">tree(Type::atom()) -&gt;  tree()</a>

  </div>

    <div class="summary-synopsis"><a id="tree-1"></a><p>Equivalent to <a href="erl_syntax.html#tree/2">tree(Type, [])</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#tree/2">tree(Type::atom(), Data::term()) -&gt;  tree()</a>

  </div>

    <div class="summary-synopsis"><a id="tree-2"></a><p><em>For special purposes only</em>. Creates an abstract syntax tree node with type tag <code>Type</code> and associated data <code>Data</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#try_after_expr/2">try_after_expr(Body::[ syntaxTree() ], After::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="try_after_expr-2"></a><p>Equivalent to <a href="erl_syntax.html#try_expr/4">try_expr(Body, [], [], After)</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#try_expr/2">try_expr(Body::[ syntaxTree() ], Handlers::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="try_expr-2"></a><p>Equivalent to <a href="erl_syntax.html#try_expr/3">try_expr(Body, [], Handlers)</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#try_expr/3">try_expr(Body::[ syntaxTree() ], Clauses::[ syntaxTree() ], Handlers::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="try_expr-3"></a><p>Equivalent to <a href="erl_syntax.html#try_expr/4">try_expr(Body, Clauses, Handlers, [])</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#try_expr/4">try_expr(Body::[ syntaxTree() ], Clauses::[ syntaxTree() ], Handlers::[ syntaxTree() ], After::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="try_expr-4"></a><p>Creates an abstract try-expression. If <code>Body</code> is <code>[B1, ..., Bn]</code>, <code>Clauses</code> is <code>[C1, ..., Cj]</code>, <code>Handlers</code> is <code>[H1, ..., Hk]</code>, and <code>After</code> is <code>[A1, ..., Am]</code>, the result represents &quot;<code>try B1, ..., Bn of C1; ...; Cj catch H1; ...; Hk after A1, ..., Am end</code>&quot;. More exactly, if each <code>Ci</code> represents &quot;<code>(CPi) CGi -&gt; CBi</code>&quot;, and each <code>Hi</code> represents &quot;<code>(HPi) HGi -&gt; HBi</code>&quot;, then the result represents &quot;<code>try B1, ..., Bn of CP1 CG1 -&gt; CB1; ...; CPj CGj -&gt; CBj catch HP1 HG1 -&gt; HB1; ...; HPk HGk -&gt; HBk after A1, ..., Am end</code>&quot;; see <a href="erl_syntax.html#case_expr/2">case_expr/2</a>. If <code>Clauses</code> is the empty list, the <code>of ...</code> section is left out. If <code>After</code> is the empty list, the <code>after ...</code> section is left out. If <code>Handlers</code> is the empty list, and <code>After</code> is nonempty, the <code>catch ...</code> section is left out.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#try_expr_after/1">try_expr_after(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="try_expr_after-1"></a><p>Returns the list of &quot;after&quot; subtrees of a <code>try_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#try_expr_body/1">try_expr_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="try_expr_body-1"></a><p>Returns the list of body subtrees of a <code>try_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#try_expr_clauses/1">try_expr_clauses(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="try_expr_clauses-1"></a><p>Returns the list of case-clause subtrees of a <code>try_expr</code> node. If <code>Node</code> represents &quot;<code>try Body catch H1; ...; Hn end</code>&quot;, the result is the empty list.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#try_expr_handlers/1">try_expr_handlers(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="try_expr_handlers-1"></a><p>Returns the list of handler-clause subtrees of a <code>try_expr</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#tuple/1">tuple(List::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="tuple-1"></a><p>Creates an abstract tuple. If <code>Elements</code> is <code>[X1, ..., Xn]</code>, the result represents &quot;<code>{X1, ..., Xn}</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#tuple_elements/1">tuple_elements(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="tuple_elements-1"></a><p>Returns the list of element subtrees of a <code>tuple</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#tuple_size/1">tuple_size(Node:: syntaxTree() ) -&gt; non_neg_integer()</a>

  </div>

    <div class="summary-synopsis"><a id="tuple_size-1"></a><p>Returns the number of elements of a <code>tuple</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#tuple_type/0">tuple_type() -&gt; term()
</a>

  </div>

    <div class="summary-synopsis"><a id="tuple_type-0"></a><p>Equivalent to <a href="erl_syntax.html#tuple_type/1">tuple_type(any_size)</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#tuple_type/1">tuple_type(Elements::any_size | [ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="tuple_type-1"></a><p>Creates an abstract type tuple. If <code>Elements</code> is <code>[T1, ..., Tn]</code>, the result represents &quot;<code>{T1, ..., Tn}</code>&quot;; otherwise, if <code>Elements</code> is <code>any_size</code>, it represents &quot;<code>tuple()</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#tuple_type_elements/1">tuple_type_elements(Node:: syntaxTree() ) -&gt; any_size | [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="tuple_type_elements-1"></a><p>Returns the list of type element subtrees of a <code>tuple_type</code> node. If <code>Node</code> represents &quot;<code>tuple()</code>&quot;, <code>any_size</code> is returned; otherwise, if <code>Node</code> represents &quot;<code>{T1, ..., Tn}</code>&quot;, <code>[T1, ..., Tn]</code> is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#type/1">type(Tree:: syntaxTree() ) -&gt; atom()</a>

  </div>

    <div class="summary-synopsis"><a id="type-1"></a><p>Returns the type tag of <code>Node</code>. If <code>Node</code> does not represent a syntax tree, evaluation fails with reason <code>badarg</code>. Node types currently defined by this module are</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#type_application/2">type_application(TypeName:: syntaxTree() , Arguments::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="type_application-2"></a><p>Creates an abstract type application expression. If <code>Arguments</code> is <code>[T1, ..., Tn]</code>, the result represents &quot;<code>TypeName(T1, ...Tn)</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#type_application/3">type_application(Module::none |  syntaxTree() , TypeName:: syntaxTree() , Arguments::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="type_application-3"></a><p>Creates an abstract type application expression. If <code>Module</code> is <code>none</code>, this is call is equivalent to <code>type_application(TypeName, Arguments)</code>, otherwise it is equivalent to <code>type_application(module_qualifier(Module, TypeName), Arguments)</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#type_application_arguments/1">type_application_arguments(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="type_application_arguments-1"></a><p>Returns the arguments subtrees of a <code>type_application</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#type_application_name/1">type_application_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="type_application_name-1"></a><p>Returns the type name subtree of a <code>type_application</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#type_union/1">type_union(Types::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="type_union-1"></a><p>Creates an abstract type union. If <code>Types</code> is <code>[T1, ..., Tn]</code>, the result represents &quot;<code>T1 | ... | Tn</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#type_union_types/1">type_union_types(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="type_union_types-1"></a><p>Returns the list of type subtrees of a <code>type_union</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#typed_record_field/2">typed_record_field(Field:: syntaxTree() , Type:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="typed_record_field-2"></a><p>Creates an abstract typed record field specification. The result represents &quot;<code>Field :: Type</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#typed_record_field_body/1">typed_record_field_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="typed_record_field_body-1"></a><p>Returns the field subtree of a <code>typed_record_field</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#typed_record_field_type/1">typed_record_field_type(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="typed_record_field_type-1"></a><p>Returns the type subtree of a <code>typed_record_field</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#underscore/0">underscore() -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="underscore-0"></a><p>Creates an abstract universal pattern (&quot;<code>_</code>&quot;). The lexical representation is a single underscore character. Note that this is <em>not</em> a variable, lexically speaking.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#update_tree/2">update_tree(Node:: syntaxTree() , Groups::[[ syntaxTree() ]]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="update_tree-2"></a><p>Creates a syntax tree with the same type and attributes as the given tree. This is equivalent to <code>copy_attrs(Node, make_tree(type(Node), Groups))</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#user_type_application/2">user_type_application(TypeName:: syntaxTree() , Arguments::[ syntaxTree() ]) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="user_type_application-2"></a><p>Creates an abstract user type. If <code>Arguments</code> is <code>[T1, ..., Tn]</code>, the result represents &quot;<code>TypeName(T1, ...Tn)</code>&quot;.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#user_type_application_arguments/1">user_type_application_arguments(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</a>

  </div>

    <div class="summary-synopsis"><a id="user_type_application_arguments-1"></a><p>Returns the arguments subtrees of a <code>user_type_application</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#user_type_application_name/1">user_type_application_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="user_type_application_name-1"></a><p>Returns the type name subtree of a <code>user_type_application</code> node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#variable/1">variable(Name::atom() | string()) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="variable-1"></a><p>Creates an abstract variable with the given name. <code>Name</code> may be any atom or string that represents a lexically valid variable name, but <em>not</em> a single underscore character; see <a href="erl_syntax.html#underscore/0">underscore/0</a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#variable_literal/1">variable_literal(Node:: syntaxTree() ) -&gt; string()</a>

  </div>

    <div class="summary-synopsis"><a id="variable_literal-1"></a><p>Returns the name of a <code>variable</code> node as a string.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#variable_name/1">variable_name(Node:: syntaxTree() ) -&gt; atom()</a>

  </div>

    <div class="summary-synopsis"><a id="variable_name-1"></a><p>Returns the name of a <code>variable</code> node as an atom.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#warning_marker/1">warning_marker(Warning::term()) -&gt;  syntaxTree()</a>

  </div>

    <div class="summary-synopsis"><a id="warning_marker-1"></a><p>Creates an abstract warning marker. The result represents an occurrence of a possible problem in the source code, with an associated Erlang I/O ErrorInfo structure given by <code>Error</code> (see module <a href="https://wojtekmach.pl/otp_docs/stdlib/io.html">io(3)</a> for details). Warning markers are regarded as source code forms, but have no defined lexical form.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#warning_marker_info/1">warning_marker_info(Node:: syntaxTree() ) -&gt; term()</a>

  </div>

    <div class="summary-synopsis"><a id="warning_marker_info-1"></a><p>Returns the ErrorInfo structure of a <code>warning_marker</code> node.</p></div>

</div>

  </div>

        </section>


        <section id="functions" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#functions">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Functions
          </h1>
          <div class="functions-list">
<section class="detail" id="abstract/1">

  <div class="detail-header">
    <a href="#abstract/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">abstract(T::term()) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>abstract(term()) -> syntaxTree().</pre>

      </div>

<a id="abstract-1"></a><p>Returns the syntax tree corresponding to an Erlang term. <code>Term</code> must be a literal term, i.e., one that can be represented as a source code literal. Thus, it may not contain a process identifier, port, reference or function value as a subterm. The function recognises printable strings, in order to get a compact and readable representation. Evaluation fails with reason <code>badarg</code> if <code>Term</code> is not a literal term.</p><p><em>See also:</em> <a href="erl_syntax.html#concrete/1">concrete/1</a>, <a href="erl_syntax.html#is_literal/1">is_literal/1</a>.</p>
  </section>
</section>
<section class="detail" id="add_ann/2">

  <div class="detail-header">
    <a href="#add_ann/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">add_ann(A::term(), Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>add_ann(term(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="add_ann-2"></a><p>Appends the term <code>Annotation</code> to the list of user annotations of <code>Node</code>.</p><p>Note: this is equivalent to <code>set_ann(Node, [Annotation | get_ann(Node)])</code>, but potentially more efficient.</p><p><em>See also:</em> <a href="erl_syntax.html#get_ann/1">get_ann/1</a>, <a href="erl_syntax.html#set_ann/2">set_ann/2</a>.</p>
  </section>
</section>
<section class="detail" id="add_postcomments/2">

  <div class="detail-header">
    <a href="#add_postcomments/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">add_postcomments(Cs::[ syntaxTree() ], Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>add_postcomments([syntaxTree()], syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="add_postcomments-2"></a><p>Appends <code>Comments</code> to the post-comments of <code>Node</code>.</p><p>Note: This is equivalent to <code>set_postcomments(Node, get_postcomments(Node) ++ Comments)</code>, but potentially more efficient.</p><p><em>See also:</em> <a href="erl_syntax.html#add_precomments/2">add_precomments/2</a>, <a href="erl_syntax.html#comment/2">comment/2</a>, <a href="erl_syntax.html#get_postcomments/1">get_postcomments/1</a>, <a href="erl_syntax.html#join_comments/2">join_comments/2</a>, <a href="erl_syntax.html#set_postcomments/2">set_postcomments/2</a>.</p>
  </section>
</section>
<section class="detail" id="add_precomments/2">

  <div class="detail-header">
    <a href="#add_precomments/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">add_precomments(Cs::[ syntaxTree() ], Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>add_precomments([syntaxTree()], syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="add_precomments-2"></a><p>Appends <code>Comments</code> to the pre-comments of <code>Node</code>.</p><p>Note: This is equivalent to <code>set_precomments(Node, get_precomments(Node) ++ Comments)</code>, but potentially more efficient.</p><p><em>See also:</em> <a href="erl_syntax.html#add_postcomments/2">add_postcomments/2</a>, <a href="erl_syntax.html#comment/2">comment/2</a>, <a href="erl_syntax.html#get_precomments/1">get_precomments/1</a>, <a href="erl_syntax.html#join_comments/2">join_comments/2</a>, <a href="erl_syntax.html#set_precomments/2">set_precomments/2</a>.</p>
  </section>
</section>
<section class="detail" id="annotated_type/2">

  <div class="detail-header">
    <a href="#annotated_type/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">annotated_type(Name:: syntaxTree() , Type:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>annotated_type(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="annotated_type-2"></a><p>Creates an abstract annotated type expression. The result represents &quot;<code>Name :: Type</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#annotated_type_body/1">annotated_type_body/1</a>, <a href="erl_syntax.html#annotated_type_name/1">annotated_type_name/1</a>.</p>
  </section>
</section>
<section class="detail" id="annotated_type_body/1">

  <div class="detail-header">
    <a href="#annotated_type_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">annotated_type_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>annotated_type_body(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="annotated_type_body-1"></a><p>Returns the type subtrees of an <code>annotated_type</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#annotated_type/2">annotated_type/2</a>.</p>
  </section>
</section>
<section class="detail" id="annotated_type_name/1">

  <div class="detail-header">
    <a href="#annotated_type_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">annotated_type_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>annotated_type_name(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="annotated_type_name-1"></a><p>Returns the name subtree of an <code>annotated_type</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#annotated_type/2">annotated_type/2</a>.</p>
  </section>
</section>
<section class="detail" id="application/2">

  <div class="detail-header">
    <a href="#application/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">application(Operator:: syntaxTree() , Arguments::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>application(syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="application-2"></a><p>Creates an abstract function application expression. If <code>Arguments</code> is <code>[A1, ..., An]</code>, the result represents &quot;<code>Operator(A1, ..., An)</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#application/3">application/3</a>, <a href="erl_syntax.html#application_arguments/1">application_arguments/1</a>, <a href="erl_syntax.html#application_operator/1">application_operator/1</a>.</p>
  </section>
</section>
<section class="detail" id="application/3">

  <div class="detail-header">
    <a href="#application/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">application(Module::none |  syntaxTree() , Name:: syntaxTree() , Arguments::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>application(none | syntaxTree(), syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="application-3"></a><p>Creates an abstract function application expression. If <code>Module</code> is <code>none</code>, this is call is equivalent to <code>application(Function, Arguments)</code>, otherwise it is equivalent to <code>application(module_qualifier(Module, Function), Arguments)</code>.</p><p>(This is a utility function.)</p><p><em>See also:</em> <a href="erl_syntax.html#application/2">application/2</a>, <a href="erl_syntax.html#module_qualifier/2">module_qualifier/2</a>.</p>
  </section>
</section>
<section class="detail" id="application_arguments/1">

  <div class="detail-header">
    <a href="#application_arguments/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">application_arguments(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>application_arguments(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="application_arguments-1"></a><p>Returns the list of argument subtrees of an <code>application</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#application/2">application/2</a>.</p>
  </section>
</section>
<section class="detail" id="application_operator/1">

  <div class="detail-header">
    <a href="#application_operator/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">application_operator(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>application_operator(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="application_operator-1"></a><p>Returns the operator subtree of an <code>application</code> node.</p><p>Note: if <code>Node</code> represents &quot;<code>M:F(...)</code>&quot;, then the result is the subtree representing &quot;<code>M:F</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#application/2">application/2</a>, <a href="erl_syntax.html#module_qualifier/2">module_qualifier/2</a>.</p>
  </section>
</section>
<section class="detail" id="arity_qualifier/2">

  <div class="detail-header">
    <a href="#arity_qualifier/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">arity_qualifier(Body:: syntaxTree() , Arity:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>arity_qualifier(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="arity_qualifier-2"></a><p>Creates an abstract arity qualifier. The result represents &quot;<code>Body/Arity</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#arity_qualifier_argument/1">arity_qualifier_argument/1</a>, <a href="erl_syntax.html#arity_qualifier_body/1">arity_qualifier_body/1</a>.</p>
  </section>
</section>
<section class="detail" id="arity_qualifier_argument/1">

  <div class="detail-header">
    <a href="#arity_qualifier_argument/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">arity_qualifier_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>arity_qualifier_argument(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="arity_qualifier_argument-1"></a><p>Returns the argument (the arity) subtree of an <code>arity_qualifier</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#arity_qualifier/2">arity_qualifier/2</a>.</p>
  </section>
</section>
<section class="detail" id="arity_qualifier_body/1">

  <div class="detail-header">
    <a href="#arity_qualifier_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">arity_qualifier_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>arity_qualifier_body(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="arity_qualifier_body-1"></a><p>Returns the body subtree of an <code>arity_qualifier</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#arity_qualifier/2">arity_qualifier/2</a>.</p>
  </section>
</section>
<section class="detail" id="atom/1">

  <div class="detail-header">
    <a href="#atom/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">atom(Name::atom() | string()) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>atom() | string()) -> syntaxTree().</pre>

      </div>

<a id="atom-1"></a><p>Creates an abstract atom literal. The print name of the atom is the character sequence represented by <code>Name</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#atom_literal/1">atom_literal/1</a>, <a href="erl_syntax.html#atom_literal/2">atom_literal/2</a>, <a href="erl_syntax.html#atom_name/1">atom_name/1</a>, <a href="erl_syntax.html#atom_value/1">atom_value/1</a>, <a href="erl_syntax.html#is_atom/2">is_atom/2</a>.</p>
  </section>
</section>
<section class="detail" id="atom_literal/1">

  <div class="detail-header">
    <a href="#atom_literal/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">atom_literal(Node:: syntaxTree() ) -&gt; string()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>atom_literal(syntaxTree()) -> string().</pre>

      </div>

<a id="atom_literal-1"></a><p>Returns the literal string represented by an <code>atom</code> node. This includes surrounding single-quote characters if necessary. Characters beyond 255 will be escaped.</p><p>Note that e.g. the result of <code>atom(&quot;x\ny&quot;)</code> represents any and all of `x\ny'', `x\12y'', `x\012y'' and `x\^Jy\''; see <a href="erl_syntax.html#string/1">string/1</a>.</p><p><em>See also:</em> <a href="erl_syntax.html#atom/1">atom/1</a>, <a href="erl_syntax.html#string/1">string/1</a>.</p>
  </section>
</section>
<section class="detail" id="atom_literal/2">

  <div class="detail-header">
    <a href="#atom_literal/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">atom_literal(Node, X2) -&gt; term()
</h1>


  </div>

  <section class="docstring">

<a id="atom_literal-2"></a><p>Returns the literal string represented by an <code>atom</code> node. This includes surrounding single-quote characters if necessary. Depending on the encoding a character beyond 255 will be escaped (<code>latin1</code>) or copied as is (<code>utf8</code>).</p><p><em>See also:</em> <a href="erl_syntax.html#atom/1">atom/1</a>, <a href="erl_syntax.html#atom_literal/1">atom_literal/1</a>, <a href="erl_syntax.html#string/1">string/1</a>.</p>
  </section>
</section>
<section class="detail" id="atom_name/1">

  <div class="detail-header">
    <a href="#atom_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">atom_name(Node:: syntaxTree() ) -&gt; string()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>atom_name(syntaxTree()) -> string().</pre>

      </div>

<a id="atom_name-1"></a><p>Returns the printname of an <code>atom</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#atom/1">atom/1</a>.</p>
  </section>
</section>
<section class="detail" id="atom_value/1">

  <div class="detail-header">
    <a href="#atom_value/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">atom_value(Node:: syntaxTree() ) -&gt; atom()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>atom_value(syntaxTree()) -> atom().</pre>

      </div>

<a id="atom_value-1"></a><p>Returns the value represented by an <code>atom</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#atom/1">atom/1</a>.</p>
  </section>
</section>
<section class="detail" id="attribute/1">

  <div class="detail-header">
    <a href="#attribute/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">attribute(Name:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>attribute(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="attribute-1"></a><p>Equivalent to <a href="erl_syntax.html#attribute/2">attribute(Name, none)</a>.</p>
  </section>
</section>
<section class="detail" id="attribute/2">

  <div class="detail-header">
    <a href="#attribute/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">attribute(Name:: syntaxTree() , Args::none | [ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>attribute(syntaxTree(), none | [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="attribute-2"></a><p>Creates an abstract program attribute. If <code>Arguments</code> is <code>[A1, ..., An]</code>, the result represents &quot;<code>-Name(A1, ..., An).</code>&quot;. Otherwise, if <code>Arguments</code> is <code>none</code>, the result represents &quot;<code>-Name.</code>&quot;. The latter form makes it possible to represent preprocessor directives such as &quot;<code>-endif.</code>&quot;. Attributes are source code forms.</p><p>Note: The preprocessor macro definition directive &quot;<code>-define(Name, Body).</code>&quot; has relatively few requirements on the syntactical form of <code>Body</code> (viewed as a sequence of tokens). The <code>text</code> node type can be used for a <code>Body</code> that is not a normal Erlang construct.</p><p><em>See also:</em> <a href="erl_syntax.html#attribute/1">attribute/1</a>, <a href="erl_syntax.html#attribute_arguments/1">attribute_arguments/1</a>, <a href="erl_syntax.html#attribute_name/1">attribute_name/1</a>, <a href="erl_syntax.html#is_form/1">is_form/1</a>, <a href="erl_syntax.html#text/1">text/1</a>.</p>
  </section>
</section>
<section class="detail" id="attribute_arguments/1">

  <div class="detail-header">
    <a href="#attribute_arguments/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">attribute_arguments(Node:: syntaxTree() ) -&gt; none | [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>attribute_arguments(syntaxTree()) -> none | [syntaxTree()].</pre>

      </div>

<a id="attribute_arguments-1"></a><p>Returns the list of argument subtrees of an <code>attribute</code> node, if any. If <code>Node</code> represents &quot;<code>-Name.</code>&quot;, the result is <code>none</code>. Otherwise, if <code>Node</code> represents &quot;<code>-Name(E1, ..., En).</code>&quot;, <code>[E1, ..., E1]</code> is returned.</p><p><em>See also:</em> <a href="erl_syntax.html#attribute/1">attribute/1</a>.</p>
  </section>
</section>
<section class="detail" id="attribute_name/1">

  <div class="detail-header">
    <a href="#attribute_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">attribute_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>attribute_name(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="attribute_name-1"></a><p>Returns the name subtree of an <code>attribute</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#attribute/1">attribute/1</a>.</p>
  </section>
</section>
<section class="detail" id="binary/1">

  <div class="detail-header">
    <a href="#binary/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">binary(List::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>binary([syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="binary-1"></a><p>Creates an abstract binary-object template. If <code>Fields</code> is <code>[F1, ..., Fn]</code>, the result represents &quot;<code>&lt;&lt;F1, ..., Fn&gt;&gt;</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#binary_field/2">binary_field/2</a>, <a href="erl_syntax.html#binary_fields/1">binary_fields/1</a>.</p>
  </section>
</section>
<section class="detail" id="binary_comp/2">

  <div class="detail-header">
    <a href="#binary_comp/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">binary_comp(Template:: syntaxTree() , Body::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>binary_comp(syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="binary_comp-2"></a><p>Creates an abstract binary comprehension. If <code>Body</code> is <code>[E1, ..., En]</code>, the result represents &quot;<code>&lt;&lt;Template || E1, ..., En&gt;&gt;</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#binary_comp_body/1">binary_comp_body/1</a>, <a href="erl_syntax.html#binary_comp_template/1">binary_comp_template/1</a>, <a href="erl_syntax.html#generator/2">generator/2</a>.</p>
  </section>
</section>
<section class="detail" id="binary_comp_body/1">

  <div class="detail-header">
    <a href="#binary_comp_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">binary_comp_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>binary_comp_body(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="binary_comp_body-1"></a><p>Returns the list of body subtrees of a <code>binary_comp</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#binary_comp/2">binary_comp/2</a>.</p>
  </section>
</section>
<section class="detail" id="binary_comp_template/1">

  <div class="detail-header">
    <a href="#binary_comp_template/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">binary_comp_template(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>binary_comp_template(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="binary_comp_template-1"></a><p>Returns the template subtree of a <code>binary_comp</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#binary_comp/2">binary_comp/2</a>.</p>
  </section>
</section>
<section class="detail" id="binary_field/1">

  <div class="detail-header">
    <a href="#binary_field/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">binary_field(Body:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>binary_field(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="binary_field-1"></a><p>Equivalent to <a href="erl_syntax.html#binary_field/2">binary_field(Body, [])</a>.</p>
  </section>
</section>
<section class="detail" id="binary_field/2">

  <div class="detail-header">
    <a href="#binary_field/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">binary_field(Body:: syntaxTree() , Types::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>binary_field(syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="binary_field-2"></a><p>Creates an abstract binary template field. If <code>Types</code> is the empty list, the result simply represents &quot;<code>Body</code>&quot;, otherwise, if <code>Types</code> is <code>[T1, ..., Tn]</code>, the result represents &quot;<code>Body/T1-...-Tn</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#binary/1">binary/1</a>, <a href="erl_syntax.html#binary_field/1">binary_field/1</a>, <a href="erl_syntax.html#binary_field/3">binary_field/3</a>, <a href="erl_syntax.html#binary_field_body/1">binary_field_body/1</a>, <a href="erl_syntax.html#binary_field_size/1">binary_field_size/1</a>, <a href="erl_syntax.html#binary_field_types/1">binary_field_types/1</a>.</p>
  </section>
</section>
<section class="detail" id="binary_field/3">

  <div class="detail-header">
    <a href="#binary_field/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">binary_field(Body:: syntaxTree() , Size::none |  syntaxTree() , Types::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>binary_field(syntaxTree(), none | syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="binary_field-3"></a><p>Creates an abstract binary template field. If <code>Size</code> is <code>none</code>, this is equivalent to &quot;<code>binary_field(Body, Types)</code>&quot;, otherwise it is equivalent to &quot;<code>binary_field(size_qualifier(Body, Size), Types)</code>&quot;.</p><p>(This is a utility function.)</p><p><em>See also:</em> <a href="erl_syntax.html#binary/1">binary/1</a>, <a href="erl_syntax.html#binary_field/2">binary_field/2</a>, <a href="erl_syntax.html#size_qualifier/2">size_qualifier/2</a>.</p>
  </section>
</section>
<section class="detail" id="binary_field_body/1">

  <div class="detail-header">
    <a href="#binary_field_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">binary_field_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>binary_field_body(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="binary_field_body-1"></a><p>Returns the body subtree of a <code>binary_field</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#binary_field/2">binary_field/2</a>.</p>
  </section>
</section>
<section class="detail" id="binary_field_size/1">

  <div class="detail-header">
    <a href="#binary_field_size/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">binary_field_size(Node:: syntaxTree() ) -&gt; none |  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>binary_field_size(syntaxTree()) -> none | syntaxTree().</pre>

      </div>

<a id="binary_field_size-1"></a><p>Returns the size specifier subtree of a <code>binary_field</code> node, if any. If <code>Node</code> represents &quot;<code>Body:Size</code>&quot; or &quot;<code>Body:Size/T1, ..., Tn</code>&quot;, the result is <code>Size</code>, otherwise <code>none</code> is returned.</p><p>(This is a utility function.)</p><p><em>See also:</em> <a href="erl_syntax.html#binary_field/2">binary_field/2</a>, <a href="erl_syntax.html#binary_field/3">binary_field/3</a>.</p>
  </section>
</section>
<section class="detail" id="binary_field_types/1">

  <div class="detail-header">
    <a href="#binary_field_types/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">binary_field_types(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>binary_field_types(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="binary_field_types-1"></a><p>Returns the list of type-specifier subtrees of a <code>binary_field</code> node. If <code>Node</code> represents &quot;<code>.../T1, ..., Tn</code>&quot;, the result is <code>[T1, ..., Tn]</code>, otherwise the result is the empty list.</p><p><em>See also:</em> <a href="erl_syntax.html#binary_field/2">binary_field/2</a>.</p>
  </section>
</section>
<section class="detail" id="binary_fields/1">

  <div class="detail-header">
    <a href="#binary_fields/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">binary_fields(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>binary_fields(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="binary_fields-1"></a><p>Returns the list of field subtrees of a <code>binary</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#binary/1">binary/1</a>, <a href="erl_syntax.html#binary_field/2">binary_field/2</a>.</p>
  </section>
</section>
<section class="detail" id="binary_generator/2">

  <div class="detail-header">
    <a href="#binary_generator/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">binary_generator(Pattern:: syntaxTree() , Body:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>binary_generator(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="binary_generator-2"></a><p>Creates an abstract binary_generator. The result represents &quot;<code>Pattern &lt;- Body</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#binary_comp/2">binary_comp/2</a>, <a href="erl_syntax.html#binary_generator_body/1">binary_generator_body/1</a>, <a href="erl_syntax.html#binary_generator_pattern/1">binary_generator_pattern/1</a>, <a href="erl_syntax.html#list_comp/2">list_comp/2</a>.</p>
  </section>
</section>
<section class="detail" id="binary_generator_body/1">

  <div class="detail-header">
    <a href="#binary_generator_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">binary_generator_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>binary_generator_body(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="binary_generator_body-1"></a><p>Returns the body subtree of a <code>generator</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#binary_generator/2">binary_generator/2</a>.</p>
  </section>
</section>
<section class="detail" id="binary_generator_pattern/1">

  <div class="detail-header">
    <a href="#binary_generator_pattern/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">binary_generator_pattern(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>binary_generator_pattern(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="binary_generator_pattern-1"></a><p>Returns the pattern subtree of a <code>generator</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#binary_generator/2">binary_generator/2</a>.</p>
  </section>
</section>
<section class="detail" id="bitstring_type/2">

  <div class="detail-header">
    <a href="#bitstring_type/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">bitstring_type(M:: syntaxTree() , N:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>bitstring_type(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="bitstring_type-2"></a><p>Creates an abstract bitstring type. The result represents &quot;<code>&lt;&lt;_:M, _:_*N&gt;&gt;</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#bitstring_type_m/1">bitstring_type_m/1</a>, <a href="erl_syntax.html#bitstring_type_n/1">bitstring_type_n/1</a>.</p>
  </section>
</section>
<section class="detail" id="bitstring_type_m/1">

  <div class="detail-header">
    <a href="#bitstring_type_m/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">bitstring_type_m(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>bitstring_type_m(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="bitstring_type_m-1"></a><p>Returns the number of start bits, <code>M</code>, of a <code>bitstring_type</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#bitstring_type/2">bitstring_type/2</a>.</p>
  </section>
</section>
<section class="detail" id="bitstring_type_n/1">

  <div class="detail-header">
    <a href="#bitstring_type_n/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">bitstring_type_n(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>bitstring_type_n(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="bitstring_type_n-1"></a><p>Returns the segment size, <code>N</code>, of a <code>bitstring_type</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#bitstring_type/2">bitstring_type/2</a>.</p>
  </section>
</section>
<section class="detail" id="block_expr/1">

  <div class="detail-header">
    <a href="#block_expr/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">block_expr(Body::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>block_expr([syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="block_expr-1"></a><p>Creates an abstract block expression. If <code>Body</code> is <code>[B1, ..., Bn]</code>, the result represents &quot;<code>begin B1, ..., Bn end</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#block_expr_body/1">block_expr_body/1</a>.</p>
  </section>
</section>
<section class="detail" id="block_expr_body/1">

  <div class="detail-header">
    <a href="#block_expr_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">block_expr_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>block_expr_body(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="block_expr_body-1"></a><p>Returns the list of body subtrees of a <code>block_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#block_expr/1">block_expr/1</a>.</p>
  </section>
</section>
<section class="detail" id="case_expr/2">

  <div class="detail-header">
    <a href="#case_expr/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">case_expr(Argument:: syntaxTree() , Clauses::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>case_expr(syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="case_expr-2"></a><p>Creates an abstract case-expression. If <code>Clauses</code> is <code>[C1, ..., Cn]</code>, the result represents &quot;<code>case Argument of C1; ...; Cn end</code>&quot;. More exactly, if each <code>Ci</code> represents &quot;<code>(Pi) Gi -&gt; Bi</code>&quot;, then the result represents &quot;<code>case Argument of P1 G1 -&gt; B1; ...; Pn Gn -&gt; Bn end</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#case_expr_argument/1">case_expr_argument/1</a>, <a href="erl_syntax.html#case_expr_clauses/1">case_expr_clauses/1</a>, <a href="erl_syntax.html#clause/3">clause/3</a>, <a href="erl_syntax.html#if_expr/1">if_expr/1</a>.</p>
  </section>
</section>
<section class="detail" id="case_expr_argument/1">

  <div class="detail-header">
    <a href="#case_expr_argument/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">case_expr_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>case_expr_argument(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="case_expr_argument-1"></a><p>Returns the argument subtree of a <code>case_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#case_expr/2">case_expr/2</a>.</p>
  </section>
</section>
<section class="detail" id="case_expr_clauses/1">

  <div class="detail-header">
    <a href="#case_expr_clauses/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">case_expr_clauses(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>case_expr_clauses(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="case_expr_clauses-1"></a><p>Returns the list of clause subtrees of a <code>case_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#case_expr/2">case_expr/2</a>.</p>
  </section>
</section>
<section class="detail" id="catch_expr/1">

  <div class="detail-header">
    <a href="#catch_expr/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">catch_expr(Expr:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>catch_expr(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="catch_expr-1"></a><p>Creates an abstract catch-expression. The result represents &quot;<code>catch Expr</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#catch_expr_body/1">catch_expr_body/1</a>.</p>
  </section>
</section>
<section class="detail" id="catch_expr_body/1">

  <div class="detail-header">
    <a href="#catch_expr_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">catch_expr_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>catch_expr_body(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="catch_expr_body-1"></a><p>Returns the body subtree of a <code>catch_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#catch_expr/1">catch_expr/1</a>.</p>
  </section>
</section>
<section class="detail" id="char/1">

  <div class="detail-header">
    <a href="#char/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">char(Char::char()) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>char()) -> syntaxTree().</pre>

      </div>

<a id="char-1"></a><p>Creates an abstract character literal. The result represents &quot;<code>$Name</code>&quot;, where <code>Name</code> corresponds to <code>Value</code>.</p><p>Note: the literal corresponding to a particular character value is not uniquely defined. E.g., the character &quot;<code>a</code>&quot; can be written both as &quot;<code>$a</code>&quot; and &quot;<code>$\141</code>&quot;, and a Tab character can be written as &quot;<code>$\11</code>&quot;, &quot;<code>$\011</code>&quot; or &quot;<code>$\t</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#char_literal/1">char_literal/1</a>, <a href="erl_syntax.html#char_literal/2">char_literal/2</a>, <a href="erl_syntax.html#char_value/1">char_value/1</a>, <a href="erl_syntax.html#is_char/2">is_char/2</a>.</p>
  </section>
</section>
<section class="detail" id="char_literal/1">

  <div class="detail-header">
    <a href="#char_literal/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">char_literal(Node:: syntaxTree() ) -&gt; nonempty_string()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>char_literal(syntaxTree()) -> nonempty_string().</pre>

      </div>

<a id="char_literal-1"></a><p>Returns the literal string represented by a <code>char</code> node. This includes the leading &quot;<code>$</code>&quot; character. Characters beyond 255 will be escaped.</p><p><em>See also:</em> <a href="erl_syntax.html#char/1">char/1</a>.</p>
  </section>
</section>
<section class="detail" id="char_literal/2">

  <div class="detail-header">
    <a href="#char_literal/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">char_literal(Node:: syntaxTree() , X2:: encoding() ) -&gt; nonempty_string()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>char_literal(syntaxTree(), <a href="#t:encoding/0">encoding</a>()) -> nonempty_string().</pre>

      </div>

<a id="char_literal-2"></a><p>Returns the literal string represented by a <code>char</code> node. This includes the leading &quot;<code>$</code>&quot; character. Depending on the encoding a character beyond 255 will be escaped (<code>latin1</code>) or copied as is (<code>utf8</code>).</p><p><em>See also:</em> <a href="erl_syntax.html#char/1">char/1</a>.</p>
  </section>
</section>
<section class="detail" id="char_value/1">

  <div class="detail-header">
    <a href="#char_value/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">char_value(Node:: syntaxTree() ) -&gt; char()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>char_value(syntaxTree()) -> char().</pre>

      </div>

<a id="char_value-1"></a><p>Returns the value represented by a <code>char</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#char/1">char/1</a>.</p>
  </section>
</section>
<section class="detail" id="class_qualifier/2">

  <div class="detail-header">
    <a href="#class_qualifier/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">class_qualifier(Class:: syntaxTree() , Body:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>class_qualifier(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="class_qualifier-2"></a><p>Creates an abstract class qualifier. The result represents &quot;<code>Class:Body</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#class_qualifier_argument/1">class_qualifier_argument/1</a>, <a href="erl_syntax.html#class_qualifier_body/1">class_qualifier_body/1</a>, <a href="erl_syntax.html#class_qualifier_stacktrace/1">class_qualifier_stacktrace/1</a>, <a href="erl_syntax.html#try_expr/4">try_expr/4</a>.</p>
  </section>
</section>
<section class="detail" id="class_qualifier/3">

  <div class="detail-header">
    <a href="#class_qualifier/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">class_qualifier(Class:: syntaxTree() , Body:: syntaxTree() , Stacktrace:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>class_qualifier(syntaxTree(), syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="class_qualifier-3"></a><p>Creates an abstract class qualifier. The result represents &quot;<code>Class:Body:Stacktrace</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#class_qualifier_argument/1">class_qualifier_argument/1</a>, <a href="erl_syntax.html#class_qualifier_body/1">class_qualifier_body/1</a>, <a href="erl_syntax.html#try_expr/4">try_expr/4</a>.</p>
  </section>
</section>
<section class="detail" id="class_qualifier_argument/1">

  <div class="detail-header">
    <a href="#class_qualifier_argument/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">class_qualifier_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>class_qualifier_argument(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="class_qualifier_argument-1"></a><p>Returns the argument (the class) subtree of a <code>class_qualifier</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#class_qualifier/2">class_qualifier/2</a>.</p>
  </section>
</section>
<section class="detail" id="class_qualifier_body/1">

  <div class="detail-header">
    <a href="#class_qualifier_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">class_qualifier_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>class_qualifier_body(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="class_qualifier_body-1"></a><p>Returns the body subtree of a <code>class_qualifier</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#class_qualifier/2">class_qualifier/2</a>.</p>
  </section>
</section>
<section class="detail" id="class_qualifier_stacktrace/1">

  <div class="detail-header">
    <a href="#class_qualifier_stacktrace/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">class_qualifier_stacktrace(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>class_qualifier_stacktrace(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="class_qualifier_stacktrace-1"></a><p>Returns the stacktrace subtree of a <code>class_qualifier</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#class_qualifier/2">class_qualifier/2</a>.</p>
  </section>
</section>
<section class="detail" id="clause/2">

  <div class="detail-header">
    <a href="#clause/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">clause(Guard:: guard() , Body::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>clause(<a href="#t:guard/0">guard</a>(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="clause-2"></a><p>Equivalent to <a href="erl_syntax.html#clause/3">clause([], Guard, Body)</a>.</p>
  </section>
</section>
<section class="detail" id="clause/3">

  <div class="detail-header">
    <a href="#clause/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">clause(Patterns::[ syntaxTree() ], Guard:: guard() , Body::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>clause([syntaxTree()], <a href="#t:guard/0">guard</a>(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="clause-3"></a><p>Creates an abstract clause. If <code>Patterns</code> is <code>[P1, ..., Pn]</code> and <code>Body</code> is <code>[B1, ..., Bm]</code>, then if <code>Guard</code> is <code>none</code>, the result represents &quot;<code>(P1, ..., Pn) -&gt; B1, ..., Bm</code>&quot;, otherwise, unless <code>Guard</code> is a list, the result represents &quot;<code>(P1, ..., Pn) when Guard -&gt; B1, ..., Bm</code>&quot;.</p><p>For simplicity, the <code>Guard</code> argument may also be any of the following:</p><ul><li><p>An empty list <code>[]</code>. This is equivalent to passing <code>none</code>.</p></li><li><p>A nonempty list <code>[E1, ..., Ej]</code> of syntax trees. This is equivalent to passing <code>conjunction([E1, ..., Ej])</code>.</p></li><li><p>A nonempty list of lists of syntax trees <code>[[E1_1, ..., E1_k1], ..., [Ej_1, ..., Ej_kj]]</code>, which is equivalent to passing <code>disjunction([conjunction([E1_1, ..., E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])</code>.</p></li></ul><p></p><p><em>See also:</em> <a href="erl_syntax.html#clause/2">clause/2</a>, <a href="erl_syntax.html#clause_body/1">clause_body/1</a>, <a href="erl_syntax.html#clause_guard/1">clause_guard/1</a>, <a href="erl_syntax.html#clause_patterns/1">clause_patterns/1</a>.</p>
  </section>
</section>
<section class="detail" id="clause_body/1">

  <div class="detail-header">
    <a href="#clause_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">clause_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>clause_body(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="clause_body-1"></a><p>Return the list of body subtrees of a <code>clause</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#clause/3">clause/3</a>.</p>
  </section>
</section>
<section class="detail" id="clause_guard/1">

  <div class="detail-header">
    <a href="#clause_guard/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">clause_guard(Node:: syntaxTree() ) -&gt; none |  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>clause_guard(syntaxTree()) -> none | syntaxTree().</pre>

      </div>

<a id="clause_guard-1"></a><p>Returns the guard subtree of a <code>clause</code> node, if any. If <code>Node</code> represents &quot;<code>(P1, ..., Pn) when Guard -&gt; B1, ..., Bm</code>&quot;, <code>Guard</code> is returned. Otherwise, the result is <code>none</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#clause/3">clause/3</a>.</p>
  </section>
</section>
<section class="detail" id="clause_patterns/1">

  <div class="detail-header">
    <a href="#clause_patterns/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">clause_patterns(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>clause_patterns(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="clause_patterns-1"></a><p>Returns the list of pattern subtrees of a <code>clause</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#clause/3">clause/3</a>.</p>
  </section>
</section>
<section class="detail" id="comment/1">

  <div class="detail-header">
    <a href="#comment/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">comment(Strings::[string()]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>comment([string()]) -> syntaxTree().</pre>

      </div>

<a id="comment-1"></a><p>Equivalent to <a href="erl_syntax.html#comment/2">comment(none, Strings)</a>.</p>
  </section>
</section>
<section class="detail" id="comment/2">

  <div class="detail-header">
    <a href="#comment/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">comment(Pad:: padding() , Strings::[string()]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>comment(padding(), [string()]) -> syntaxTree().</pre>

      </div>

<a id="comment-2"></a><p>Creates an abstract comment with the given padding and text. If <code>Strings</code> is a (possibly empty) list <code>[&quot;Txt1&quot;, ..., &quot;TxtN&quot;]</code>, the result represents the source code text</p><pre><code class="makeup erlang"><span class="w">     </span><span class="c1">%Txt1</span><span class="w">
     </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w">
     </span><span class="c1">%TxtN</span></code></pre><p><code>Padding</code> states the number of empty character positions to the left of the comment separating it horizontally from source code on the same line (if any). If <code>Padding</code> is <code>none</code>, a default positive number is used. If <code>Padding</code> is an integer less than 1, there should be no separating space. Comments are in themselves regarded as source program forms.</p><p><em>See also:</em> <a href="erl_syntax.html#comment/1">comment/1</a>, <a href="erl_syntax.html#is_form/1">is_form/1</a>.</p>
  </section>
</section>
<section class="detail" id="comment_padding/1">

  <div class="detail-header">
    <a href="#comment_padding/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">comment_padding(Node:: syntaxTree() ) -&gt;  padding()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>comment_padding(syntaxTree()) -> padding().</pre>

      </div>

<a id="comment_padding-1"></a><p>Returns the amount of padding before the comment, or <code>none</code>. The latter means that a default padding may be used.</p><p><em>See also:</em> <a href="erl_syntax.html#comment/2">comment/2</a>.</p>
  </section>
</section>
<section class="detail" id="comment_text/1">

  <div class="detail-header">
    <a href="#comment_text/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">comment_text(Node:: syntaxTree() ) -&gt; [string()]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>comment_text(syntaxTree()) -> [string()].</pre>

      </div>

<a id="comment_text-1"></a><p>Returns the lines of text of the abstract comment.</p><p><em>See also:</em> <a href="erl_syntax.html#comment/2">comment/2</a>.</p>
  </section>
</section>
<section class="detail" id="compact_list/1">

  <div class="detail-header">
    <a href="#compact_list/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">compact_list(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>compact_list(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="compact_list-1"></a><p>Yields the most compact form for an abstract list skeleton. The result either represents &quot;<code>[E1, ..., En | Tail]</code>&quot;, where <code>Tail</code> is not a list skeleton, or otherwise simply &quot;<code>[E1, ..., En]</code>&quot;. Annotations on subtrees of <code>Node</code> that represent list skeletons may be lost, but comments will be propagated to the result. Returns <code>Node</code> itself if <code>Node</code> does not represent a list skeleton.</p><p><em>See also:</em> <a href="erl_syntax.html#list/2">list/2</a>, <a href="erl_syntax.html#normalize_list/1">normalize_list/1</a>.</p>
  </section>
</section>
<section class="detail" id="concrete/1">

  <div class="detail-header">
    <a href="#concrete/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">concrete(Node:: syntaxTree() ) -&gt; term()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>concrete(syntaxTree()) -> term().</pre>

      </div>

<a id="concrete-1"></a><p>Returns the Erlang term represented by a syntax tree. Evaluation fails with reason <code>badarg</code> if <code>Node</code> does not represent a literal term.</p><p>Note: Currently, the set of syntax trees which have a concrete representation is larger than the set of trees which can be built using the function <a href="erl_syntax.html#abstract/1">abstract/1</a>. An abstract character will be concretised as an integer, while <a href="erl_syntax.html#abstract/1">abstract/1</a> does not at present yield an abstract character for any input. (Use the <a href="erl_syntax.html#char/1">char/1</a> function to explicitly create an abstract character.)</p><p>Note: <code>arity_qualifier</code> nodes are recognized. This is to follow The Erlang Parser when it comes to wild attributes: both {F, A} and F/A are recognized, which makes it possible to turn wild attributes into recognized attributes without at the same time making it impossible to compile files using the new syntax with the old version of the Erlang Compiler.</p><p><em>See also:</em> <a href="erl_syntax.html#abstract/1">abstract/1</a>, <a href="erl_syntax.html#char/1">char/1</a>, <a href="erl_syntax.html#is_literal/1">is_literal/1</a>.</p>
  </section>
</section>
<section class="detail" id="conjunction/1">

  <div class="detail-header">
    <a href="#conjunction/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">conjunction(Tests::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>conjunction([syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="conjunction-1"></a><p>Creates an abstract conjunction. If <code>List</code> is <code>[E1, ..., En]</code>, the result represents &quot;<code>E1, ..., En</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#conjunction_body/1">conjunction_body/1</a>, <a href="erl_syntax.html#disjunction/1">disjunction/1</a>.</p>
  </section>
</section>
<section class="detail" id="conjunction_body/1">

  <div class="detail-header">
    <a href="#conjunction_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">conjunction_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>conjunction_body(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="conjunction_body-1"></a><p>Returns the list of body subtrees of a <code>conjunction</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#conjunction/1">conjunction/1</a>.</p>
  </section>
</section>
<section class="detail" id="cons/2">

  <div class="detail-header">
    <a href="#cons/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">cons(Head:: syntaxTree() , Tail:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>cons(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="cons-2"></a><p>&quot;Optimising&quot; list skeleton cons operation. Creates an abstract list skeleton whose first element is <code>Head</code> and whose tail corresponds to <code>Tail</code>. This is similar to <code>list([Head], Tail)</code>, except that <code>Tail</code> may not be <code>none</code>, and that the result does not necessarily represent exactly &quot;<code>[Head | Tail]</code>&quot;, but may depend on the <code>Tail</code> subtree. E.g., if <code>Tail</code> represents <code>[X, Y]</code>, the result may represent &quot;<code>[Head, X, Y]</code>&quot;, rather than &quot;<code>[Head | [X, Y]]</code>&quot;. Annotations on <code>Tail</code> itself may be lost if <code>Tail</code> represents a list skeleton, but comments on <code>Tail</code> are propagated to the result.</p><p><em>See also:</em> <a href="erl_syntax.html#list/2">list/2</a>, <a href="erl_syntax.html#list_head/1">list_head/1</a>, <a href="erl_syntax.html#list_tail/1">list_tail/1</a>.</p>
  </section>
</section>
<section class="detail" id="constrained_function_type/2">

  <div class="detail-header">
    <a href="#constrained_function_type/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">constrained_function_type(FunctionType:: syntaxTree() , FunctionConstraint::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>constrained_function_type(syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="constrained_function_type-2"></a><p>Creates an abstract constrained function type. If <code>FunctionConstraint</code> is <code>[C1, ..., Cn]</code>, the result represents &quot;<code>FunctionType when C1, ...Cn</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#constrained_function_type_argument/1">constrained_function_type_argument/1</a>, <a href="erl_syntax.html#constrained_function_type_body/1">constrained_function_type_body/1</a>.</p>
  </section>
</section>
<section class="detail" id="constrained_function_type_argument/1">

  <div class="detail-header">
    <a href="#constrained_function_type_argument/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">constrained_function_type_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>constrained_function_type_argument(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="constrained_function_type_argument-1"></a><p>Returns the function constraint subtree of a <code>constrained_function_type</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#constrained_function_type/2">constrained_function_type/2</a>.</p>
  </section>
</section>
<section class="detail" id="constrained_function_type_body/1">

  <div class="detail-header">
    <a href="#constrained_function_type_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">constrained_function_type_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>constrained_function_type_body(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="constrained_function_type_body-1"></a><p>Returns the function type subtree of a <code>constrained_function_type</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#constrained_function_type/2">constrained_function_type/2</a>.</p>
  </section>
</section>
<section class="detail" id="constraint/2">

  <div class="detail-header">
    <a href="#constraint/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">constraint(Name:: syntaxTree() , Types::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>constraint(syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="constraint-2"></a><p>Creates an abstract (subtype) constraint. The result represents &quot;<code>Name :: Type</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#constraint_argument/1">constraint_argument/1</a>, <a href="erl_syntax.html#constraint_body/1">constraint_body/1</a>.</p>
  </section>
</section>
<section class="detail" id="constraint_argument/1">

  <div class="detail-header">
    <a href="#constraint_argument/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">constraint_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>constraint_argument(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="constraint_argument-1"></a><p>Returns the name subtree of a <code>constraint</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#constraint/2">constraint/2</a>.</p>
  </section>
</section>
<section class="detail" id="constraint_body/1">

  <div class="detail-header">
    <a href="#constraint_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">constraint_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>constraint_body(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="constraint_body-1"></a><p>Returns the type subtree of a <code>constraint</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#constraint/2">constraint/2</a>.</p>
  </section>
</section>
<section class="detail" id="copy_ann/2">

  <div class="detail-header">
    <a href="#copy_ann/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">copy_ann(Source:: syntaxTree() , Target:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>copy_ann(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="copy_ann-2"></a><p>Copies the list of user annotations from <code>Source</code> to <code>Target</code>.</p><p>Note: this is equivalent to <code>set_ann(Target, get_ann(Source))</code>, but potentially more efficient.</p><p><em>See also:</em> <a href="erl_syntax.html#get_ann/1">get_ann/1</a>, <a href="erl_syntax.html#set_ann/2">set_ann/2</a>.</p>
  </section>
</section>
<section class="detail" id="copy_attrs/2">

  <div class="detail-header">
    <a href="#copy_attrs/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">copy_attrs(S:: syntaxTree() , T:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>copy_attrs(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="copy_attrs-2"></a><p>Copies the attributes from <code>Source</code> to <code>Target</code>.</p><p>Note: this is equivalent to <code>set_attrs(Target, get_attrs(Source))</code>, but potentially more efficient.</p><p><em>See also:</em> <a href="erl_syntax.html#get_attrs/1">get_attrs/1</a>, <a href="erl_syntax.html#set_attrs/2">set_attrs/2</a>.</p>
  </section>
</section>
<section class="detail" id="copy_comments/2">

  <div class="detail-header">
    <a href="#copy_comments/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">copy_comments(Source:: syntaxTree() , Target:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>copy_comments(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="copy_comments-2"></a><p>Copies the pre- and postcomments from <code>Source</code> to <code>Target</code>.</p><p>Note: This is equivalent to <code>set_postcomments(set_precomments(Target, get_precomments(Source)), get_postcomments(Source))</code>, but potentially more efficient.</p><p><em>See also:</em> <a href="erl_syntax.html#comment/2">comment/2</a>, <a href="erl_syntax.html#get_postcomments/1">get_postcomments/1</a>, <a href="erl_syntax.html#get_precomments/1">get_precomments/1</a>, <a href="erl_syntax.html#set_postcomments/2">set_postcomments/2</a>, <a href="erl_syntax.html#set_precomments/2">set_precomments/2</a>.</p>
  </section>
</section>
<section class="detail" id="copy_pos/2">

  <div class="detail-header">
    <a href="#copy_pos/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">copy_pos(Source:: syntaxTree() , Target:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>copy_pos(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="copy_pos-2"></a><p>Copies the annotation from <code>Source</code> to <code>Target</code>.</p><p>This is equivalent to <code>set_pos(Target, get_pos(Source))</code>, but potentially more efficient.</p><p><em>See also:</em> <a href="erl_syntax.html#get_pos/1">get_pos/1</a>, <a href="erl_syntax.html#set_pos/2">set_pos/2</a>.</p>
  </section>
</section>
<section class="detail" id="data/1">

  <div class="detail-header">
    <a href="#data/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">data(Tree:: syntaxTree() ) -&gt; term()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>data(syntaxTree()) -> term().</pre>

      </div>

<a id="data-1"></a><p><em>For special purposes only</em>. Returns the associated data of a syntax tree node. Evaluation fails with reason <code>badarg</code> if <code>is_tree(Node)</code> does not yield <code>true</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#tree/2">tree/2</a>.</p>
  </section>
</section>
<section class="detail" id="disjunction/1">

  <div class="detail-header">
    <a href="#disjunction/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">disjunction(Tests::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>disjunction([syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="disjunction-1"></a><p>Creates an abstract disjunction. If <code>List</code> is <code>[E1, ..., En]</code>, the result represents &quot;<code>E1; ...; En</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#conjunction/1">conjunction/1</a>, <a href="erl_syntax.html#disjunction_body/1">disjunction_body/1</a>.</p>
  </section>
</section>
<section class="detail" id="disjunction_body/1">

  <div class="detail-header">
    <a href="#disjunction_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">disjunction_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>disjunction_body(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="disjunction_body-1"></a><p>Returns the list of body subtrees of a <code>disjunction</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#disjunction/1">disjunction/1</a>.</p>
  </section>
</section>
<section class="detail" id="eof_marker/0">

  <div class="detail-header">
    <a href="#eof_marker/0" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">eof_marker() -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>eof_marker() -> syntaxTree().</pre>

      </div>

<a id="eof_marker-0"></a><p>Creates an abstract end-of-file marker. This represents the end of input when reading a sequence of source code forms. An end-of-file marker is itself regarded as a source code form (namely, the last in any sequence in which it occurs). It has no defined lexical form.</p><p>Note: this is retained only for backwards compatibility with existing parsers and tools.</p><p><em>See also:</em> <a href="erl_syntax.html#error_marker/1">error_marker/1</a>, <a href="erl_syntax.html#is_form/1">is_form/1</a>, <a href="erl_syntax.html#warning_marker/1">warning_marker/1</a>.</p>
  </section>
</section>
<section class="detail" id="error_marker/1">

  <div class="detail-header">
    <a href="#error_marker/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">error_marker(Error::term()) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>error_marker(term()) -> syntaxTree().</pre>

      </div>

<a id="error_marker-1"></a><p>Creates an abstract error marker. The result represents an occurrence of an error in the source code, with an associated Erlang I/O ErrorInfo structure given by <code>Error</code> (see module <a href="https://wojtekmach.pl/otp_docs/stdlib/io.html">io(3)</a> for details). Error markers are regarded as source code forms, but have no defined lexical form.</p><p>Note: this is supported only for backwards compatibility with existing parsers and tools.</p><p><em>See also:</em> <a href="erl_syntax.html#eof_marker/0">eof_marker/0</a>, <a href="erl_syntax.html#error_marker_info/1">error_marker_info/1</a>, <a href="erl_syntax.html#is_form/1">is_form/1</a>, <a href="erl_syntax.html#warning_marker/1">warning_marker/1</a>.</p>
  </section>
</section>
<section class="detail" id="error_marker_info/1">

  <div class="detail-header">
    <a href="#error_marker_info/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">error_marker_info(Node:: syntaxTree() ) -&gt; term()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>error_marker_info(syntaxTree()) -> term().</pre>

      </div>

<a id="error_marker_info-1"></a><p>Returns the ErrorInfo structure of an <code>error_marker</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#error_marker/1">error_marker/1</a>.</p>
  </section>
</section>
<section class="detail" id="flatten_form_list/1">

  <div class="detail-header">
    <a href="#flatten_form_list/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">flatten_form_list(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>flatten_form_list(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="flatten_form_list-1"></a><p>Flattens sublists of a <code>form_list</code> node. Returns <code>Node</code> with all subtrees of type <code>form_list</code> recursively expanded, yielding a single &quot;flat&quot; abstract form sequence.</p><p><em>See also:</em> <a href="erl_syntax.html#form_list/1">form_list/1</a>.</p>
  </section>
</section>
<section class="detail" id="float/1">

  <div class="detail-header">
    <a href="#float/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">float(Value::float()) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>float()) -> syntaxTree().</pre>

      </div>

<a id="float-1"></a><p>Creates an abstract floating-point literal. The lexical representation is the decimal floating-point numeral of <code>Value</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#float_literal/1">float_literal/1</a>, <a href="erl_syntax.html#float_value/1">float_value/1</a>.</p>
  </section>
</section>
<section class="detail" id="float_literal/1">

  <div class="detail-header">
    <a href="#float_literal/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">float_literal(Node:: syntaxTree() ) -&gt; string()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>float_literal(syntaxTree()) -> string().</pre>

      </div>

<a id="float_literal-1"></a><p>Returns the numeral string represented by a <code>float</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#float/1">float/1</a>.</p>
  </section>
</section>
<section class="detail" id="float_value/1">

  <div class="detail-header">
    <a href="#float_value/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">float_value(Node:: syntaxTree() ) -&gt; float()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>float_value(syntaxTree()) -> float().</pre>

      </div>

<a id="float_value-1"></a><p>Returns the value represented by a <code>float</code> node. Note that floating-point values should usually not be compared for equality.</p><p><em>See also:</em> <a href="erl_syntax.html#float/1">float/1</a>.</p>
  </section>
</section>
<section class="detail" id="form_list/1">

  <div class="detail-header">
    <a href="#form_list/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">form_list(Forms::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>form_list([syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="form_list-1"></a><p>Creates an abstract sequence of &quot;source code forms&quot;. If <code>Forms</code> is <code>[F1, ..., Fn]</code>, where each <code>Fi</code> is a form (see <a href="erl_syntax.html#is_form/1">is_form/1</a>, the result represents</p><pre><code class="makeup erlang"><span class="w">     </span><span class="n">F1</span><span class="w">
     </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w">
     </span><span class="n">Fn</span></code></pre><p>where the <code>Fi</code> are separated by one or more line breaks. A node of type <code>form_list</code> is itself regarded as a source code form; see <a href="erl_syntax.html#flatten_form_list/1">flatten_form_list/1</a>.</p><p>Note: this is simply a way of grouping source code forms as a single syntax tree, usually in order to form an Erlang module definition.</p><p><em>See also:</em> <a href="erl_syntax.html#flatten_form_list/1">flatten_form_list/1</a>, <a href="erl_syntax.html#form_list_elements/1">form_list_elements/1</a>, <a href="erl_syntax.html#is_form/1">is_form/1</a>.</p>
  </section>
</section>
<section class="detail" id="form_list_elements/1">

  <div class="detail-header">
    <a href="#form_list_elements/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">form_list_elements(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>form_list_elements(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="form_list_elements-1"></a><p>Returns the list of subnodes of a <code>form_list</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#form_list/1">form_list/1</a>.</p>
  </section>
</section>
<section class="detail" id="fun_expr/1">

  <div class="detail-header">
    <a href="#fun_expr/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">fun_expr(Clauses::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>fun_expr([syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="fun_expr-1"></a><p>Creates an abstract fun-expression. If <code>Clauses</code> is <code>[C1, ..., Cn]</code>, the result represents &quot;<code>fun C1; ...; Cn end</code>&quot;. More exactly, if each <code>Ci</code> represents &quot;<code>(Pi1, ..., Pim) Gi -&gt; Bi</code>&quot;, then the result represents &quot;<code>fun (P11, ..., P1m) G1 -&gt; B1; ...; (Pn1, ..., Pnm) Gn -&gt; Bn end</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#fun_expr_arity/1">fun_expr_arity/1</a>, <a href="erl_syntax.html#fun_expr_clauses/1">fun_expr_clauses/1</a>.</p>
  </section>
</section>
<section class="detail" id="fun_expr_arity/1">

  <div class="detail-header">
    <a href="#fun_expr_arity/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">fun_expr_arity(Node:: syntaxTree() ) -&gt; arity()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>fun_expr_arity(syntaxTree()) -> arity().</pre>

      </div>

<a id="fun_expr_arity-1"></a><p>Returns the arity of a <code>fun_expr</code> node. The result is the number of parameter patterns in the first clause of the fun-expression; subsequent clauses are ignored.</p><p>An exception is thrown if <code>fun_expr_clauses(Node)</code> returns an empty list, or if the first element of that list is not a syntax tree <code>C</code> of type <code>clause</code> such that <code>clause_patterns(C)</code> is a nonempty list.</p><p><em>See also:</em> <a href="erl_syntax.html#clause/3">clause/3</a>, <a href="erl_syntax.html#clause_patterns/1">clause_patterns/1</a>, <a href="erl_syntax.html#fun_expr/1">fun_expr/1</a>, <a href="erl_syntax.html#fun_expr_clauses/1">fun_expr_clauses/1</a>.</p>
  </section>
</section>
<section class="detail" id="fun_expr_clauses/1">

  <div class="detail-header">
    <a href="#fun_expr_clauses/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">fun_expr_clauses(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>fun_expr_clauses(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="fun_expr_clauses-1"></a><p>Returns the list of clause subtrees of a <code>fun_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#fun_expr/1">fun_expr/1</a>.</p>
  </section>
</section>
<section class="detail" id="fun_type/0">

  <div class="detail-header">
    <a href="#fun_type/0" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">fun_type() -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>fun_type() -> syntaxTree().</pre>

      </div>

<a id="fun_type-0"></a><p>Creates an abstract fun of any type. The result represents &quot;<code>fun()</code>&quot;.</p>
  </section>
</section>
<section class="detail" id="function/2">

  <div class="detail-header">
    <a href="#function/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">function(Name:: syntaxTree() , Clauses::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>function(syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="function-2"></a><p>Creates an abstract function definition. If <code>Clauses</code> is <code>[C1, ..., Cn]</code>, the result represents &quot;<code>Name C1; ...; Name Cn.</code>&quot;. More exactly, if each <code>Ci</code> represents &quot;<code>(Pi1, ..., Pim) Gi -&gt; Bi</code>&quot;, then the result represents &quot;<code>Name(P11, ..., P1m) G1 -&gt; B1; ...; Name(Pn1, ..., Pnm) Gn -&gt; Bn.</code>&quot;. Function definitions are source code forms.</p><p><em>See also:</em> <a href="erl_syntax.html#function_arity/1">function_arity/1</a>, <a href="erl_syntax.html#function_clauses/1">function_clauses/1</a>, <a href="erl_syntax.html#function_name/1">function_name/1</a>, <a href="erl_syntax.html#is_form/1">is_form/1</a>.</p>
  </section>
</section>
<section class="detail" id="function_arity/1">

  <div class="detail-header">
    <a href="#function_arity/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">function_arity(Node:: syntaxTree() ) -&gt; arity()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>function_arity(syntaxTree()) -> arity().</pre>

      </div>

<a id="function_arity-1"></a><p>Returns the arity of a <code>function</code> node. The result is the number of parameter patterns in the first clause of the function; subsequent clauses are ignored.</p><p>An exception is thrown if <code>function_clauses(Node)</code> returns an empty list, or if the first element of that list is not a syntax tree <code>C</code> of type <code>clause</code> such that <code>clause_patterns(C)</code> is a nonempty list.</p><p><em>See also:</em> <a href="erl_syntax.html#clause/3">clause/3</a>, <a href="erl_syntax.html#clause_patterns/1">clause_patterns/1</a>, <a href="erl_syntax.html#function/2">function/2</a>, <a href="erl_syntax.html#function_clauses/1">function_clauses/1</a>.</p>
  </section>
</section>
<section class="detail" id="function_clauses/1">

  <div class="detail-header">
    <a href="#function_clauses/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">function_clauses(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>function_clauses(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="function_clauses-1"></a><p>Returns the list of clause subtrees of a <code>function</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#function/2">function/2</a>.</p>
  </section>
</section>
<section class="detail" id="function_name/1">

  <div class="detail-header">
    <a href="#function_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">function_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>function_name(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="function_name-1"></a><p>Returns the name subtree of a <code>function</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#function/2">function/2</a>.</p>
  </section>
</section>
<section class="detail" id="function_type/1">

  <div class="detail-header">
    <a href="#function_type/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">function_type(Type) -&gt; term()
</h1>


  </div>

  <section class="docstring">

<a id="function_type-1"></a><p>Equivalent to <a href="erl_syntax.html#function_type/2">function_type(any_arity, Type)</a>.</p>
  </section>
</section>
<section class="detail" id="function_type/2">

  <div class="detail-header">
    <a href="#function_type/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">function_type(Arguments::any_arity | [ syntaxTree() ], Return:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>function_type(any_arity | [syntaxTree()], syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="function_type-2"></a><p>Creates an abstract function type. If <code>Arguments</code> is <code>[T1, ..., Tn]</code>, then if it occurs within a function specification, the result represents &quot;<code>(T1, ...Tn) -&gt; Return</code>&quot;; otherwise it represents &quot;<code>fun((T1, ...Tn) -&gt; Return)</code>&quot;. If <code>Arguments</code> is <code>any_arity</code>, it represents &quot;<code>fun((...) -&gt; Return)</code>&quot;.</p><p>Note that the <code>erl_parse</code> representation is identical for &quot;<code>FunctionType</code>&quot; and &quot;<code>fun(FunctionType)</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#function_type_arguments/1">function_type_arguments/1</a>, <a href="erl_syntax.html#function_type_return/1">function_type_return/1</a>.</p>
  </section>
</section>
<section class="detail" id="function_type_arguments/1">

  <div class="detail-header">
    <a href="#function_type_arguments/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">function_type_arguments(Node:: syntaxTree() ) -&gt; any_arity | [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>function_type_arguments(syntaxTree()) -> any_arity | [syntaxTree()].</pre>

      </div>

<a id="function_type_arguments-1"></a><p>Returns the argument types subtrees of a <code>function_type</code> node. If <code>Node</code> represents &quot;<code>fun((...) -&gt; Return)</code>&quot;, <code>any_arity</code> is returned; otherwise, if <code>Node</code> represents &quot;<code>(T1, ...Tn) -&gt; Return</code>&quot; or &quot;<code>fun((T1, ...Tn) -&gt; Return)</code>&quot;, <code>[T1, ..., Tn]</code> is returned.</p><p><em>See also:</em> <a href="erl_syntax.html#function_type/1">function_type/1</a>, <a href="erl_syntax.html#function_type/2">function_type/2</a>.</p>
  </section>
</section>
<section class="detail" id="function_type_return/1">

  <div class="detail-header">
    <a href="#function_type_return/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">function_type_return(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>function_type_return(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="function_type_return-1"></a><p>Returns the return type subtrees of a <code>function_type</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#function_type/1">function_type/1</a>, <a href="erl_syntax.html#function_type/2">function_type/2</a>.</p>
  </section>
</section>
<section class="detail" id="generator/2">

  <div class="detail-header">
    <a href="#generator/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">generator(Pattern:: syntaxTree() , Body:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>generator(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="generator-2"></a><p>Creates an abstract generator. The result represents &quot;<code>Pattern &lt;- Body</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#binary_comp/2">binary_comp/2</a>, <a href="erl_syntax.html#generator_body/1">generator_body/1</a>, <a href="erl_syntax.html#generator_pattern/1">generator_pattern/1</a>, <a href="erl_syntax.html#list_comp/2">list_comp/2</a>.</p>
  </section>
</section>
<section class="detail" id="generator_body/1">

  <div class="detail-header">
    <a href="#generator_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">generator_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>generator_body(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="generator_body-1"></a><p>Returns the body subtree of a <code>generator</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#generator/2">generator/2</a>.</p>
  </section>
</section>
<section class="detail" id="generator_pattern/1">

  <div class="detail-header">
    <a href="#generator_pattern/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">generator_pattern(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>generator_pattern(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="generator_pattern-1"></a><p>Returns the pattern subtree of a <code>generator</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#generator/2">generator/2</a>.</p>
  </section>
</section>
<section class="detail" id="get_ann/1">

  <div class="detail-header">
    <a href="#get_ann/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">get_ann(Tree:: syntaxTree() ) -&gt; [term()]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>get_ann(syntaxTree()) -> [term()].</pre>

      </div>

<a id="get_ann-1"></a><p>Returns the list of user annotations associated with a syntax tree node. For a newly created node, this is the empty list. The annotations may be any terms.</p><p><em>See also:</em> <a href="erl_syntax.html#get_attrs/1">get_attrs/1</a>, <a href="erl_syntax.html#set_ann/2">set_ann/2</a>.</p>
  </section>
</section>
<section class="detail" id="get_attrs/1">

  <div class="detail-header">
    <a href="#get_attrs/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">get_attrs(Tree:: syntaxTree() ) -&gt;  syntaxTreeAttributes()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>get_attrs(syntaxTree()) -> syntaxTreeAttributes().</pre>

      </div>

<a id="get_attrs-1"></a><p>Returns a representation of the attributes associated with a syntax tree node. The attributes are all the extra information that can be attached to a node. Currently, this includes position information, source code comments, and user annotations. The result of this function cannot be inspected directly; only attached to another node (see <a href="erl_syntax.html#set_attrs/2">set_attrs/2</a>).</p><p>For accessing individual attributes, see <a href="erl_syntax.html#get_pos/1">get_pos/1</a>, <a href="erl_syntax.html#get_ann/1">get_ann/1</a>, <a href="erl_syntax.html#get_precomments/1">get_precomments/1</a> and <a href="erl_syntax.html#get_postcomments/1">get_postcomments/1</a>.</p><p><em>See also:</em> <a href="erl_syntax.html#get_ann/1">get_ann/1</a>, <a href="erl_syntax.html#get_pos/1">get_pos/1</a>, <a href="erl_syntax.html#get_postcomments/1">get_postcomments/1</a>, <a href="erl_syntax.html#get_precomments/1">get_precomments/1</a>, <a href="erl_syntax.html#set_attrs/2">set_attrs/2</a>.</p>
  </section>
</section>
<section class="detail" id="get_pos/1">

  <div class="detail-header">
    <a href="#get_pos/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">get_pos(Tree:: syntaxTree() ) -&gt;  annotation_or_location()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>get_pos(syntaxTree()) -> <a href="#t:annotation_or_location/0">annotation_or_location</a>().</pre>

      </div>

<a id="get_pos-1"></a><p>Returns the annotation (see <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_anno.html">erl_anno(3)</a>) associated with <code>Node</code>. By default, all new tree nodes have their associated position information set to the integer zero. Use <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_anno.html#location/1">erl_anno:location/1</a> or <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_anno.html#line/1">erl_anno:line/1</a> to get the position information.</p><p><em>See also:</em> <a href="erl_syntax.html#get_attrs/1">get_attrs/1</a>, <a href="erl_syntax.html#set_pos/2">set_pos/2</a>.</p>
  </section>
</section>
<section class="detail" id="get_postcomments/1">

  <div class="detail-header">
    <a href="#get_postcomments/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">get_postcomments(Tree:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>get_postcomments(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="get_postcomments-1"></a><p>Returns the associated post-comments of a node. This is a possibly empty list of abstract comments, in top-down textual order. When the code is formatted, post-comments are typically displayed to the right of and/or below the node. For example:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="p" data-group-id="1203837525-1">{</span><span class="ss">foo</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p" data-group-id="1203837525-1">}</span><span class="w">     </span><span class="c1">% Post-comment of tuple</span></code></pre><p>If possible, the comment should be moved past any following separator characters on the same line, rather than placing the separators on the following line. E.g.:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="nf">foo</span><span class="p" data-group-id="6328238658-1">(</span><span class="p" data-group-id="6328238658-2">[</span><span class="n">X</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="n">Xs</span><span class="p" data-group-id="6328238658-2">]</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p" data-group-id="6328238658-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
         </span><span class="nf">foo</span><span class="p" data-group-id="6328238658-3">(</span><span class="n">Xs</span><span class="p">,</span><span class="w"> </span><span class="nf">bar</span><span class="p" data-group-id="6328238658-4">(</span><span class="n">X</span><span class="p" data-group-id="6328238658-4">)</span><span class="p" data-group-id="6328238658-3">)</span><span class="p">;</span><span class="w">     </span><span class="c1">% Post-comment of &#39;bar(X)&#39; node</span><span class="w">
      </span><span class="p">.</span><span class="p">.</span><span class="p">.</span></code></pre><p>(where the comment is moved past the rightmost &quot;<code>)</code>&quot; and the &quot;<code>;</code>&quot;).</p><p><em>See also:</em> <a href="erl_syntax.html#comment/2">comment/2</a>, <a href="erl_syntax.html#get_attrs/1">get_attrs/1</a>, <a href="erl_syntax.html#get_precomments/1">get_precomments/1</a>, <a href="erl_syntax.html#set_postcomments/2">set_postcomments/2</a>.</p>
  </section>
</section>
<section class="detail" id="get_precomments/1">

  <div class="detail-header">
    <a href="#get_precomments/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">get_precomments(Tree:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>get_precomments(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="get_precomments-1"></a><p>Returns the associated pre-comments of a node. This is a possibly empty list of abstract comments, in top-down textual order. When the code is formatted, pre-comments are typically displayed directly above the node. For example:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="c1">% Pre-comment of function</span><span class="w">
     </span><span class="nf">foo</span><span class="p" data-group-id="1034572509-1">(</span><span class="n">X</span><span class="p" data-group-id="1034572509-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="1034572509-2">{</span><span class="ss">bar</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p" data-group-id="1034572509-2">}</span><span class="p">.</span></code></pre><p>If possible, the comment should be moved before any preceding separator characters on the same line. E.g.:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="nf">foo</span><span class="p" data-group-id="5053318474-1">(</span><span class="p" data-group-id="5053318474-2">[</span><span class="n">X</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="n">Xs</span><span class="p" data-group-id="5053318474-2">]</span><span class="p" data-group-id="5053318474-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
         </span><span class="c1">% Pre-comment of &#39;bar(X)&#39; node</span><span class="w">
         </span><span class="p" data-group-id="5053318474-3">[</span><span class="nf">bar</span><span class="p" data-group-id="5053318474-4">(</span><span class="n">X</span><span class="p" data-group-id="5053318474-4">)</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="nf">foo</span><span class="p" data-group-id="5053318474-5">(</span><span class="n">Xs</span><span class="p" data-group-id="5053318474-5">)</span><span class="p" data-group-id="5053318474-3">]</span><span class="p">;</span><span class="w">
     </span><span class="p">.</span><span class="p">.</span><span class="p">.</span></code></pre><p>(where the comment is moved before the &quot;<code>[</code>&quot;).</p><p><em>See also:</em> <a href="erl_syntax.html#comment/2">comment/2</a>, <a href="erl_syntax.html#get_attrs/1">get_attrs/1</a>, <a href="erl_syntax.html#get_postcomments/1">get_postcomments/1</a>, <a href="erl_syntax.html#set_precomments/2">set_precomments/2</a>.</p>
  </section>
</section>
<section class="detail" id="has_comments/1">

  <div class="detail-header">
    <a href="#has_comments/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">has_comments(Tree:: syntaxTree() ) -&gt; boolean()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>has_comments(syntaxTree()) -> boolean().</pre>

      </div>

<a id="has_comments-1"></a><p>Yields <code>false</code> if the node has no associated comments, and <code>true</code> otherwise.</p><p>Note: This is equivalent to <code>(get_precomments(Node) == []) and (get_postcomments(Node) == [])</code>, but potentially more efficient.</p><p><em>See also:</em> <a href="erl_syntax.html#get_postcomments/1">get_postcomments/1</a>, <a href="erl_syntax.html#get_precomments/1">get_precomments/1</a>, <a href="erl_syntax.html#remove_comments/1">remove_comments/1</a>.</p>
  </section>
</section>
<section class="detail" id="if_expr/1">

  <div class="detail-header">
    <a href="#if_expr/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">if_expr(Clauses::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>if_expr([syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="if_expr-1"></a><p>Creates an abstract if-expression. If <code>Clauses</code> is <code>[C1, ..., Cn]</code>, the result represents &quot;<code>if C1; ...; Cn end</code>&quot;. More exactly, if each <code>Ci</code> represents &quot;<code>() Gi -&gt; Bi</code>&quot;, then the result represents &quot;<code>if G1 -&gt; B1; ...; Gn -&gt; Bn end</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#case_expr/2">case_expr/2</a>, <a href="erl_syntax.html#clause/3">clause/3</a>, <a href="erl_syntax.html#if_expr_clauses/1">if_expr_clauses/1</a>.</p>
  </section>
</section>
<section class="detail" id="if_expr_clauses/1">

  <div class="detail-header">
    <a href="#if_expr_clauses/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">if_expr_clauses(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>if_expr_clauses(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="if_expr_clauses-1"></a><p>Returns the list of clause subtrees of an <code>if_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#if_expr/1">if_expr/1</a>.</p>
  </section>
</section>
<section class="detail" id="implicit_fun/1">

  <div class="detail-header">
    <a href="#implicit_fun/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">implicit_fun(Name:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>implicit_fun(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="implicit_fun-1"></a><p>Creates an abstract &quot;implicit fun&quot; expression. The result represents &quot;<code>fun Name</code>&quot;. <code>Name</code> should represent either <code>F/A</code> or <code>M:F/A</code></p><p><em>See also:</em> <a href="erl_syntax.html#arity_qualifier/2">arity_qualifier/2</a>, <a href="erl_syntax.html#implicit_fun/2">implicit_fun/2</a>, <a href="erl_syntax.html#implicit_fun/3">implicit_fun/3</a>, <a href="erl_syntax.html#implicit_fun_name/1">implicit_fun_name/1</a>, <a href="erl_syntax.html#module_qualifier/2">module_qualifier/2</a>.</p>
  </section>
</section>
<section class="detail" id="implicit_fun/2">

  <div class="detail-header">
    <a href="#implicit_fun/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">implicit_fun(Name:: syntaxTree() , Arity::none |  syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>implicit_fun(syntaxTree(), none | syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="implicit_fun-2"></a><p>Creates an abstract &quot;implicit fun&quot; expression. If <code>Arity</code> is <code>none</code>, this is equivalent to <code>implicit_fun(Name)</code>, otherwise it is equivalent to <code>implicit_fun(arity_qualifier(Name, Arity))</code>.</p><p>(This is a utility function.)</p><p><em>See also:</em> <a href="erl_syntax.html#implicit_fun/1">implicit_fun/1</a>, <a href="erl_syntax.html#implicit_fun/3">implicit_fun/3</a>.</p>
  </section>
</section>
<section class="detail" id="implicit_fun/3">

  <div class="detail-header">
    <a href="#implicit_fun/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">implicit_fun(Module::none |  syntaxTree() , Name:: syntaxTree() , Arity:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>implicit_fun(none | syntaxTree(), syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="implicit_fun-3"></a><p>Creates an abstract module-qualified &quot;implicit fun&quot; expression. If <code>Module</code> is <code>none</code>, this is equivalent to <code>implicit_fun(Name, Arity)</code>, otherwise it is equivalent to <code>implicit_fun(module_qualifier(Module, arity_qualifier(Name, Arity))</code>.</p><p>(This is a utility function.)</p><p><em>See also:</em> <a href="erl_syntax.html#implicit_fun/1">implicit_fun/1</a>, <a href="erl_syntax.html#implicit_fun/2">implicit_fun/2</a>.</p>
  </section>
</section>
<section class="detail" id="implicit_fun_name/1">

  <div class="detail-header">
    <a href="#implicit_fun_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">implicit_fun_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>implicit_fun_name(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="implicit_fun_name-1"></a><p>Returns the name subtree of an <code>implicit_fun</code> node.</p><p>Note: if <code>Node</code> represents &quot;<code>fun N/A</code>&quot; or &quot;<code>fun M:N/A</code>&quot;, then the result is the subtree representing &quot;<code>N/A</code>&quot; or &quot;<code>M:N/A</code>&quot;, respectively.</p><p><em>See also:</em> <a href="erl_syntax.html#arity_qualifier/2">arity_qualifier/2</a>, <a href="erl_syntax.html#implicit_fun/1">implicit_fun/1</a>, <a href="erl_syntax.html#module_qualifier/2">module_qualifier/2</a>.</p>
  </section>
</section>
<section class="detail" id="infix_expr/3">

  <div class="detail-header">
    <a href="#infix_expr/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">infix_expr(Left:: syntaxTree() , Operator:: syntaxTree() , Right:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>infix_expr(syntaxTree(), syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="infix_expr-3"></a><p>Creates an abstract infix operator expression. The result represents &quot;<code>Left Operator Right</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#infix_expr_left/1">infix_expr_left/1</a>, <a href="erl_syntax.html#infix_expr_operator/1">infix_expr_operator/1</a>, <a href="erl_syntax.html#infix_expr_right/1">infix_expr_right/1</a>, <a href="erl_syntax.html#prefix_expr/2">prefix_expr/2</a>.</p>
  </section>
</section>
<section class="detail" id="infix_expr_left/1">

  <div class="detail-header">
    <a href="#infix_expr_left/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">infix_expr_left(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>infix_expr_left(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="infix_expr_left-1"></a><p>Returns the left argument subtree of an <code>infix_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#infix_expr/3">infix_expr/3</a>.</p>
  </section>
</section>
<section class="detail" id="infix_expr_operator/1">

  <div class="detail-header">
    <a href="#infix_expr_operator/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">infix_expr_operator(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>infix_expr_operator(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="infix_expr_operator-1"></a><p>Returns the operator subtree of an <code>infix_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#infix_expr/3">infix_expr/3</a>.</p>
  </section>
</section>
<section class="detail" id="infix_expr_right/1">

  <div class="detail-header">
    <a href="#infix_expr_right/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">infix_expr_right(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>infix_expr_right(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="infix_expr_right-1"></a><p>Returns the right argument subtree of an <code>infix_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#infix_expr/3">infix_expr/3</a>.</p>
  </section>
</section>
<section class="detail" id="integer/1">

  <div class="detail-header">
    <a href="#integer/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">integer(Value::integer()) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>integer()) -> syntaxTree().</pre>

      </div>

<a id="integer-1"></a><p>Creates an abstract integer literal. The lexical representation is the canonical decimal numeral of <code>Value</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#integer_literal/1">integer_literal/1</a>, <a href="erl_syntax.html#integer_value/1">integer_value/1</a>, <a href="erl_syntax.html#is_integer/2">is_integer/2</a>.</p>
  </section>
</section>
<section class="detail" id="integer_literal/1">

  <div class="detail-header">
    <a href="#integer_literal/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">integer_literal(Node:: syntaxTree() ) -&gt; string()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>integer_literal(syntaxTree()) -> string().</pre>

      </div>

<a id="integer_literal-1"></a><p>Returns the numeral string represented by an <code>integer</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#integer/1">integer/1</a>.</p>
  </section>
</section>
<section class="detail" id="integer_range_type/2">

  <div class="detail-header">
    <a href="#integer_range_type/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">integer_range_type(Low:: syntaxTree() , High:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>integer_range_type(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="integer_range_type-2"></a><p>Creates an abstract range type. The result represents &quot;<code>Low .. High</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#integer_range_type_high/1">integer_range_type_high/1</a>, <a href="erl_syntax.html#integer_range_type_low/1">integer_range_type_low/1</a>.</p>
  </section>
</section>
<section class="detail" id="integer_range_type_high/1">

  <div class="detail-header">
    <a href="#integer_range_type_high/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">integer_range_type_high(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>integer_range_type_high(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="integer_range_type_high-1"></a><p>Returns the high limit of an <code>integer_range_type</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#integer_range_type/2">integer_range_type/2</a>.</p>
  </section>
</section>
<section class="detail" id="integer_range_type_low/1">

  <div class="detail-header">
    <a href="#integer_range_type_low/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">integer_range_type_low(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>integer_range_type_low(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="integer_range_type_low-1"></a><p>Returns the low limit of an <code>integer_range_type</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#integer_range_type/2">integer_range_type/2</a>.</p>
  </section>
</section>
<section class="detail" id="integer_value/1">

  <div class="detail-header">
    <a href="#integer_value/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">integer_value(Node:: syntaxTree() ) -&gt; integer()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>integer_value(syntaxTree()) -> integer().</pre>

      </div>

<a id="integer_value-1"></a><p>Returns the value represented by an <code>integer</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#integer/1">integer/1</a>.</p>
  </section>
</section>
<section class="detail" id="is_atom/2">

  <div class="detail-header">
    <a href="#is_atom/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">is_atom(Node:: syntaxTree() , Value::atom()) -&gt; boolean()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>is_atom(syntaxTree(), atom()) -> boolean().</pre>

      </div>

<a id="is_atom-2"></a><p>Returns <code>true</code> if <code>Node</code> has type <code>atom</code> and represents <code>Value</code>, otherwise <code>false</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#atom/1">atom/1</a>.</p>
  </section>
</section>
<section class="detail" id="is_char/2">

  <div class="detail-header">
    <a href="#is_char/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">is_char(Node:: syntaxTree() , Value::char()) -&gt; boolean()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>is_char(syntaxTree(), char()) -> boolean().</pre>

      </div>

<a id="is_char-2"></a><p>Returns <code>true</code> if <code>Node</code> has type <code>char</code> and represents <code>Value</code>, otherwise <code>false</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#char/1">char/1</a>.</p>
  </section>
</section>
<section class="detail" id="is_form/1">

  <div class="detail-header">
    <a href="#is_form/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">is_form(Node:: syntaxTree() ) -&gt; boolean()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>is_form(syntaxTree()) -> boolean().</pre>

      </div>

<a id="is_form-1"></a><p>Returns <code>true</code> if <code>Node</code> is a syntax tree representing a so-called &quot;source code form&quot;, otherwise <code>false</code>. Forms are the Erlang source code units which, placed in sequence, constitute an Erlang program. Current form types are:</p><p><code>attribute</code> <code>comment</code> <code>error_marker</code> <code>eof_marker</code><br/><code>form_list</code> <code>function</code> <code>warning_marker</code> <code>text</code><br/></p><p><em>See also:</em> <a href="erl_syntax.html#attribute/2">attribute/2</a>, <a href="erl_syntax.html#comment/2">comment/2</a>, <a href="erl_syntax.html#eof_marker/0">eof_marker/0</a>, <a href="erl_syntax.html#error_marker/1">error_marker/1</a>, <a href="erl_syntax.html#form_list/1">form_list/1</a>, <a href="erl_syntax.html#function/2">function/2</a>, <a href="erl_syntax.html#type/1">type/1</a>, <a href="erl_syntax.html#warning_marker/1">warning_marker/1</a>.</p>
  </section>
</section>
<section class="detail" id="is_integer/2">

  <div class="detail-header">
    <a href="#is_integer/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">is_integer(Node:: syntaxTree() , Value::integer()) -&gt; boolean()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>is_integer(syntaxTree(), integer()) -> boolean().</pre>

      </div>

<a id="is_integer-2"></a><p>Returns <code>true</code> if <code>Node</code> has type <code>integer</code> and represents <code>Value</code>, otherwise <code>false</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#integer/1">integer/1</a>.</p>
  </section>
</section>
<section class="detail" id="is_leaf/1">

  <div class="detail-header">
    <a href="#is_leaf/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">is_leaf(Node:: syntaxTree() ) -&gt; boolean()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>is_leaf(syntaxTree()) -> boolean().</pre>

      </div>

<a id="is_leaf-1"></a><p>Returns <code>true</code> if <code>Node</code> is a leaf node, otherwise <code>false</code>. The currently recognised leaf node types are:</p><p><code>atom</code> <code>char</code> <code>comment</code> <code>eof_marker</code> <code>error_marker</code><br/><code>float</code> <code>fun_type</code> <code>integer</code> <code>nil</code> <code>operator</code> <code>string</code><br/><code>text</code> <code>underscore</code> <code>variable</code> <code>warning_marker</code><br/></p><p>A node of type <code>map_expr</code> is a leaf node if and only if it has no argument and no fields. A node of type <code>map_type</code> is a leaf node if and only if it has no fields (<code>any_size</code>). A node of type <code>tuple</code> is a leaf node if and only if its arity is zero. A node of type <code>tuple_type</code> is a leaf node if and only if it has no elements (<code>any_size</code>).</p><p>Note: not all literals are leaf nodes, and vice versa. E.g., tuples with nonzero arity and nonempty lists may be literals, but are not leaf nodes. Variables, on the other hand, are leaf nodes but not literals.</p><p><em>See also:</em> <a href="erl_syntax.html#is_literal/1">is_literal/1</a>, <a href="erl_syntax.html#type/1">type/1</a>.</p>
  </section>
</section>
<section class="detail" id="is_list_skeleton/1">

  <div class="detail-header">
    <a href="#is_list_skeleton/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">is_list_skeleton(Node:: syntaxTree() ) -&gt; boolean()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>is_list_skeleton(syntaxTree()) -> boolean().</pre>

      </div>

<a id="is_list_skeleton-1"></a><p>Returns <code>true</code> if <code>Node</code> has type <code>list</code> or <code>nil</code>, otherwise <code>false</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#list/2">list/2</a>, <a href="erl_syntax.html#/0">nil/0</a>.</p>
  </section>
</section>
<section class="detail" id="is_literal/1">

  <div class="detail-header">
    <a href="#is_literal/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">is_literal(T:: syntaxTree() ) -&gt; boolean()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>is_literal(syntaxTree()) -> boolean().</pre>

      </div>

<a id="is_literal-1"></a><p>Returns <code>true</code> if <code>Node</code> represents a literal term, otherwise <code>false</code>. This function returns <code>true</code> if and only if the value of <code>concrete(Node)</code> is defined.</p><p><em>See also:</em> <a href="erl_syntax.html#abstract/1">abstract/1</a>, <a href="erl_syntax.html#concrete/1">concrete/1</a>.</p>
  </section>
</section>
<section class="detail" id="is_proper_list/1">

  <div class="detail-header">
    <a href="#is_proper_list/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">is_proper_list(Node:: syntaxTree() ) -&gt; boolean()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>is_proper_list(syntaxTree()) -> boolean().</pre>

      </div>

<a id="is_proper_list-1"></a><p>Returns <code>true</code> if <code>Node</code> represents a proper list, and <code>false</code> otherwise. A proper list is a list skeleton either on the form &quot;<code>[]</code>&quot; or &quot;<code>[E1, ..., En]</code>&quot;, or &quot;<code>[... | Tail]</code>&quot; where recursively <code>Tail</code> also represents a proper list.</p><p>Note: Since <code>Node</code> is a syntax tree, the actual run-time values corresponding to its subtrees may often be partially or completely unknown. Thus, if <code>Node</code> represents e.g. &quot;<code>[... | Ns]</code>&quot; (where <code>Ns</code> is a variable), then the function will return <code>false</code>, because it is not known whether <code>Ns</code> will be bound to a list at run-time. If <code>Node</code> instead represents e.g. &quot;<code>[1, 2, 3]</code>&quot; or &quot;<code>[A | []]</code>&quot;, then the function will return <code>true</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#list/2">list/2</a>.</p>
  </section>
</section>
<section class="detail" id="is_string/2">

  <div class="detail-header">
    <a href="#is_string/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">is_string(Node:: syntaxTree() , Value::string()) -&gt; boolean()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>is_string(syntaxTree(), string()) -> boolean().</pre>

      </div>

<a id="is_string-2"></a><p>Returns <code>true</code> if <code>Node</code> has type <code>string</code> and represents <code>Value</code>, otherwise <code>false</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#string/1">string/1</a>.</p>
  </section>
</section>
<section class="detail" id="is_tree/1">

  <div class="detail-header">
    <a href="#is_tree/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">is_tree(Tree:: syntaxTree() ) -&gt; boolean()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>is_tree(syntaxTree()) -> boolean().</pre>

      </div>

<a id="is_tree-1"></a><p><em>For special purposes only</em>. Returns <code>true</code> if <code>Tree</code> is an abstract syntax tree and <code>false</code> otherwise.</p><p><em>Note</em>: this function yields <code>false</code> for all &quot;old-style&quot; <code>erl_parse</code>-compatible &quot;parse trees&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#tree/2">tree/2</a>.</p>
  </section>
</section>
<section class="detail" id="join_comments/2">

  <div class="detail-header">
    <a href="#join_comments/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">join_comments(Source:: syntaxTree() , Target:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>join_comments(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="join_comments-2"></a><p>Appends the comments of <code>Source</code> to the current comments of <code>Target</code>.</p><p>Note: This is equivalent to <code>add_postcomments(get_postcomments(Source), add_precomments(get_precomments(Source), Target))</code>, but potentially more efficient.</p><p><em>See also:</em> <a href="erl_syntax.html#add_postcomments/2">add_postcomments/2</a>, <a href="erl_syntax.html#add_precomments/2">add_precomments/2</a>, <a href="erl_syntax.html#comment/2">comment/2</a>, <a href="erl_syntax.html#get_postcomments/1">get_postcomments/1</a>, <a href="erl_syntax.html#get_precomments/1">get_precomments/1</a>.</p>
  </section>
</section>
<section class="detail" id="list/1">

  <div class="detail-header">
    <a href="#list/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">list(List::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>list([syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="list-1"></a><p>Equivalent to <a href="erl_syntax.html#list/2">list(List, none)</a>.</p>
  </section>
</section>
<section class="detail" id="list/2">

  <div class="detail-header">
    <a href="#list/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">list(Elements::[ syntaxTree() ], Tail::none |  syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>list([syntaxTree()], none | syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="list-2"></a><p>Constructs an abstract list skeleton. The result has type <code>list</code> or <code>nil</code>. If <code>List</code> is a nonempty list <code>[E1, ..., En]</code>, the result has type <code>list</code> and represents either &quot;<code>[E1, ..., En]</code>&quot;, if <code>Tail</code> is <code>none</code>, or otherwise &quot;<code>[E1, ..., En | Tail]</code>&quot;. If <code>List</code> is the empty list, <code>Tail</code> <em>must</em> be <code>none</code>, and in that case the result has type <code>nil</code> and represents &quot;<code>[]</code>&quot; (see <a href="erl_syntax.html#/0">nil/0</a>).</p><p>The difference between lists as semantic objects (built up of individual &quot;cons&quot; and &quot;nil&quot; terms) and the various syntactic forms for denoting lists may be bewildering at first. This module provides functions both for exact control of the syntactic representation as well as for the simple composition and deconstruction in terms of cons and head/tail operations.</p><p>Note: in <code>list(Elements, none)</code>, the &quot;nil&quot; list terminator is implicit and has no associated information (see <a href="erl_syntax.html#get_attrs/1">get_attrs/1</a>), while in the seemingly equivalent <code>list(Elements, Tail)</code> when <code>Tail</code> has type <code>nil</code>, the list terminator subtree <code>Tail</code> may have attached attributes such as position, comments, and annotations, which will be preserved in the result.</p><p><em>See also:</em> <a href="erl_syntax.html#compact_list/1">compact_list/1</a>, <a href="erl_syntax.html#cons/2">cons/2</a>, <a href="erl_syntax.html#get_attrs/1">get_attrs/1</a>, <a href="erl_syntax.html#is_list_skeleton/1">is_list_skeleton/1</a>, <a href="erl_syntax.html#is_proper_list/1">is_proper_list/1</a>, <a href="erl_syntax.html#list/1">list/1</a>, <a href="erl_syntax.html#list_elements/1">list_elements/1</a>, <a href="erl_syntax.html#list_head/1">list_head/1</a>, <a href="erl_syntax.html#list_length/1">list_length/1</a>, <a href="erl_syntax.html#list_prefix/1">list_prefix/1</a>, <a href="erl_syntax.html#list_suffix/1">list_suffix/1</a>, <a href="erl_syntax.html#list_tail/1">list_tail/1</a>, <a href="erl_syntax.html#/0">nil/0</a>, <a href="erl_syntax.html#normalize_list/1">normalize_list/1</a>.</p>
  </section>
</section>
<section class="detail" id="list_comp/2">

  <div class="detail-header">
    <a href="#list_comp/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">list_comp(Template:: syntaxTree() , Body::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>list_comp(syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="list_comp-2"></a><p>Creates an abstract list comprehension. If <code>Body</code> is <code>[E1, ..., En]</code>, the result represents &quot;<code>[Template || E1, ..., En]</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#generator/2">generator/2</a>, <a href="erl_syntax.html#list_comp_body/1">list_comp_body/1</a>, <a href="erl_syntax.html#list_comp_template/1">list_comp_template/1</a>.</p>
  </section>
</section>
<section class="detail" id="list_comp_body/1">

  <div class="detail-header">
    <a href="#list_comp_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">list_comp_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>list_comp_body(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="list_comp_body-1"></a><p>Returns the list of body subtrees of a <code>list_comp</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#list_comp/2">list_comp/2</a>.</p>
  </section>
</section>
<section class="detail" id="list_comp_template/1">

  <div class="detail-header">
    <a href="#list_comp_template/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">list_comp_template(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>list_comp_template(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="list_comp_template-1"></a><p>Returns the template subtree of a <code>list_comp</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#list_comp/2">list_comp/2</a>.</p>
  </section>
</section>
<section class="detail" id="list_elements/1">

  <div class="detail-header">
    <a href="#list_elements/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">list_elements(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>list_elements(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="list_elements-1"></a><p>Returns the list of element subtrees of a list skeleton. <code>Node</code> must represent a proper list. E.g., if <code>Node</code> represents &quot;<code>[X1, X2 | [X3, X4 | []]</code>&quot;, then <code>list_elements(Node)</code> yields the list <code>[X1, X2, X3, X4]</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#is_proper_list/1">is_proper_list/1</a>, <a href="erl_syntax.html#list/2">list/2</a>.</p>
  </section>
</section>
<section class="detail" id="list_head/1">

  <div class="detail-header">
    <a href="#list_head/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">list_head(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>list_head(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="list_head-1"></a><p>Returns the head element subtree of a <code>list</code> node. If <code>Node</code> represents &quot;<code>[Head ...]</code>&quot;, the result will represent &quot;<code>Head</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#cons/2">cons/2</a>, <a href="erl_syntax.html#list/2">list/2</a>, <a href="erl_syntax.html#list_tail/1">list_tail/1</a>.</p>
  </section>
</section>
<section class="detail" id="list_length/1">

  <div class="detail-header">
    <a href="#list_length/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">list_length(Node:: syntaxTree() ) -&gt; non_neg_integer()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>list_length(syntaxTree()) -> non_neg_integer().</pre>

      </div>

<a id="list_length-1"></a><p>Returns the number of element subtrees of a list skeleton. <code>Node</code> must represent a proper list. E.g., if <code>Node</code> represents &quot;<code>[X1 | [X2, X3 | [X4, X5, X6]]]</code>&quot;, then <code>list_length(Node)</code> returns the integer 6.</p><p>Note: this is equivalent to <code>length(list_elements(Node))</code>, but potentially more efficient.</p><p><em>See also:</em> <a href="erl_syntax.html#is_proper_list/1">is_proper_list/1</a>, <a href="erl_syntax.html#list/2">list/2</a>, <a href="erl_syntax.html#list_elements/1">list_elements/1</a>.</p>
  </section>
</section>
<section class="detail" id="list_prefix/1">

  <div class="detail-header">
    <a href="#list_prefix/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">list_prefix(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>list_prefix(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="list_prefix-1"></a><p>Returns the prefix element subtrees of a <code>list</code> node. If <code>Node</code> represents &quot;<code>[E1, ..., En]</code>&quot; or &quot;<code>[E1, ..., En | Tail]</code>&quot;, the returned value is <code>[E1, ..., En]</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#list/2">list/2</a>.</p>
  </section>
</section>
<section class="detail" id="list_suffix/1">

  <div class="detail-header">
    <a href="#list_suffix/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">list_suffix(Node:: syntaxTree() ) -&gt; none |  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>list_suffix(syntaxTree()) -> none | syntaxTree().</pre>

      </div>

<a id="list_suffix-1"></a><p>Returns the suffix subtree of a <code>list</code> node, if one exists. If <code>Node</code> represents &quot;<code>[E1, ..., En | Tail]</code>&quot;, the returned value is <code>Tail</code>, otherwise, i.e., if <code>Node</code> represents &quot;<code>[E1, ..., En]</code>&quot;, <code>none</code> is returned.</p><p>Note that even if this function returns some <code>Tail</code> that is not <code>none</code>, the type of <code>Tail</code> can be <code>nil</code>, if the tail has been given explicitly, and the list skeleton has not been compacted (see <a href="erl_syntax.html#compact_list/1">compact_list/1</a>).</p><p><em>See also:</em> <a href="erl_syntax.html#compact_list/1">compact_list/1</a>, <a href="erl_syntax.html#list/2">list/2</a>, <a href="erl_syntax.html#/0">nil/0</a>.</p>
  </section>
</section>
<section class="detail" id="list_tail/1">

  <div class="detail-header">
    <a href="#list_tail/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">list_tail(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>list_tail(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="list_tail-1"></a><p>Returns the tail of a <code>list</code> node. If <code>Node</code> represents a single-element list &quot;<code>[E]</code>&quot;, then the result has type <code>nil</code>, representing &quot;<code>[]</code>&quot;. If <code>Node</code> represents &quot;<code>[E1, E2 ...]</code>&quot;, the result will represent &quot;<code>[E2 ...]</code>&quot;, and if <code>Node</code> represents &quot;<code>[Head | Tail]</code>&quot;, the result will represent &quot;<code>Tail</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#cons/2">cons/2</a>, <a href="erl_syntax.html#list/2">list/2</a>, <a href="erl_syntax.html#list_head/1">list_head/1</a>.</p>
  </section>
</section>
<section class="detail" id="macro/1">

  <div class="detail-header">
    <a href="#macro/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">macro(Name:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>macro(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="macro-1"></a><p>Equivalent to <a href="erl_syntax.html#macro/2">macro(Name, none)</a>.</p>
  </section>
</section>
<section class="detail" id="macro/2">

  <div class="detail-header">
    <a href="#macro/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">macro(Name:: syntaxTree() , Arguments::none | [ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>macro(syntaxTree(), none | [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="macro-2"></a><p>Creates an abstract macro application. If <code>Arguments</code> is <code>none</code>, the result represents &quot;<code>?Name</code>&quot;, otherwise, if <code>Arguments</code> is <code>[A1, ..., An]</code>, the result represents &quot;<code>?Name(A1, ..., An)</code>&quot;.</p><p>Notes: if <code>Arguments</code> is the empty list, the result will thus represent &quot;<code>?Name()</code>&quot;, including a pair of matching parentheses.</p><p>The only syntactical limitation imposed by the preprocessor on the arguments to a macro application (viewed as sequences of tokens) is that they must be balanced with respect to parentheses, brackets, <code>begin ... end</code>, <code>case ... end</code>, etc. The <code>text</code> node type can be used to represent arguments which are not regular Erlang constructs.</p><p><em>See also:</em> <a href="erl_syntax.html#macro/1">macro/1</a>, <a href="erl_syntax.html#macro_arguments/1">macro_arguments/1</a>, <a href="erl_syntax.html#macro_name/1">macro_name/1</a>, <a href="erl_syntax.html#text/1">text/1</a>.</p>
  </section>
</section>
<section class="detail" id="macro_arguments/1">

  <div class="detail-header">
    <a href="#macro_arguments/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">macro_arguments(Node:: syntaxTree() ) -&gt; none | [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>macro_arguments(syntaxTree()) -> none | [syntaxTree()].</pre>

      </div>

<a id="macro_arguments-1"></a><p>Returns the list of argument subtrees of a <code>macro</code> node, if any. If <code>Node</code> represents &quot;<code>?Name</code>&quot;, <code>none</code> is returned. Otherwise, if <code>Node</code> represents &quot;<code>?Name(A1, ..., An)</code>&quot;, <code>[A1, ..., An]</code> is returned.</p><p><em>See also:</em> <a href="erl_syntax.html#macro/2">macro/2</a>.</p>
  </section>
</section>
<section class="detail" id="macro_name/1">

  <div class="detail-header">
    <a href="#macro_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">macro_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>macro_name(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="macro_name-1"></a><p>Returns the name subtree of a <code>macro</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#macro/2">macro/2</a>.</p>
  </section>
</section>
<section class="detail" id="make_tree/2">

  <div class="detail-header">
    <a href="#make_tree/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">make_tree(X1::atom(), X2::[[ syntaxTree() ]]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>make_tree(atom(), [[syntaxTree()]]) -> syntaxTree().</pre>

      </div>

<a id="make_tree-2"></a><p>Creates a syntax tree with the given type and subtrees. <code>Type</code> must be a node type name (see <a href="erl_syntax.html#type/1">type/1</a>) that does not denote a leaf node type (see <a href="erl_syntax.html#is_leaf/1">is_leaf/1</a>). <code>Groups</code> must be a <em>nonempty</em> list of groups of syntax trees, representing the subtrees of a node of the given type, in left-to-right order as they would occur in the printed program text, grouped by category as done by <a href="erl_syntax.html#subtrees/1">subtrees/1</a>.</p><p>The result of <code>copy_attrs(Node, make_tree(type(Node), subtrees(Node)))</code> (see <a href="erl_syntax.html#update_tree/2">update_tree/2</a>) represents the same source code text as the original <code>Node</code>, assuming that <code>subtrees(Node)</code> yields a nonempty list. However, it does not necessarily have the same data representation as <code>Node</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#copy_attrs/2">copy_attrs/2</a>, <a href="erl_syntax.html#is_leaf/1">is_leaf/1</a>, <a href="erl_syntax.html#subtrees/1">subtrees/1</a>, <a href="erl_syntax.html#type/1">type/1</a>, <a href="erl_syntax.html#update_tree/2">update_tree/2</a>.</p>
  </section>
</section>
<section class="detail" id="map_expr/1">

  <div class="detail-header">
    <a href="#map_expr/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_expr(Fields::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_expr([syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="map_expr-1"></a><p>Equivalent to <a href="erl_syntax.html#map_expr/2">map_expr(none, Fields)</a>.</p>
  </section>
</section>
<section class="detail" id="map_expr/2">

  <div class="detail-header">
    <a href="#map_expr/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_expr(Argument::none |  syntaxTree() , Fields::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_expr(none | syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="map_expr-2"></a><p>Creates an abstract map expression. If <code>Fields</code> is <code>[F1, ..., Fn]</code>, then if <code>Argument</code> is <code>none</code>, the result represents &quot;<code>#{F1, ..., Fn}</code>&quot;, otherwise it represents &quot;<code>Argument#{F1, ..., Fn}</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#map_expr/1">map_expr/1</a>, <a href="erl_syntax.html#map_expr_argument/1">map_expr_argument/1</a>, <a href="erl_syntax.html#map_expr_fields/1">map_expr_fields/1</a>, <a href="erl_syntax.html#map_field_assoc/2">map_field_assoc/2</a>, <a href="erl_syntax.html#map_field_exact/2">map_field_exact/2</a>.</p>
  </section>
</section>
<section class="detail" id="map_expr_argument/1">

  <div class="detail-header">
    <a href="#map_expr_argument/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_expr_argument(Node:: syntaxTree() ) -&gt; none |  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_expr_argument(syntaxTree()) -> none | syntaxTree().</pre>

      </div>

<a id="map_expr_argument-1"></a><p>Returns the argument subtree of a <code>map_expr</code> node, if any. If <code>Node</code> represents &quot;<code>#{...}</code>&quot;, <code>none</code> is returned. Otherwise, if <code>Node</code> represents &quot;<code>Argument#{...}</code>&quot;, <code>Argument</code> is returned.</p><p><em>See also:</em> <a href="erl_syntax.html#map_expr/2">map_expr/2</a>.</p>
  </section>
</section>
<section class="detail" id="map_expr_fields/1">

  <div class="detail-header">
    <a href="#map_expr_fields/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_expr_fields(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_expr_fields(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="map_expr_fields-1"></a><p>Returns the list of field subtrees of a <code>map_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#map_expr/2">map_expr/2</a>.</p>
  </section>
</section>
<section class="detail" id="map_field_assoc/2">

  <div class="detail-header">
    <a href="#map_field_assoc/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_field_assoc(Name:: syntaxTree() , Value:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_field_assoc(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="map_field_assoc-2"></a><p>Creates an abstract map assoc field. The result represents &quot;<code>Name =&gt; Value</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#map_expr/2">map_expr/2</a>, <a href="erl_syntax.html#map_field_assoc_name/1">map_field_assoc_name/1</a>, <a href="erl_syntax.html#map_field_assoc_value/1">map_field_assoc_value/1</a>.</p>
  </section>
</section>
<section class="detail" id="map_field_assoc_name/1">

  <div class="detail-header">
    <a href="#map_field_assoc_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_field_assoc_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_field_assoc_name(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="map_field_assoc_name-1"></a><p>Returns the name subtree of a <code>map_field_assoc</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#map_field_assoc/2">map_field_assoc/2</a>.</p>
  </section>
</section>
<section class="detail" id="map_field_assoc_value/1">

  <div class="detail-header">
    <a href="#map_field_assoc_value/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_field_assoc_value(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_field_assoc_value(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="map_field_assoc_value-1"></a><p>Returns the value subtree of a <code>map_field_assoc</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#map_field_assoc/2">map_field_assoc/2</a>.</p>
  </section>
</section>
<section class="detail" id="map_field_exact/2">

  <div class="detail-header">
    <a href="#map_field_exact/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_field_exact(Name:: syntaxTree() , Value:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_field_exact(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="map_field_exact-2"></a><p>Creates an abstract map exact field. The result represents &quot;<code>Name := Value</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#map_expr/2">map_expr/2</a>, <a href="erl_syntax.html#map_field_exact_name/1">map_field_exact_name/1</a>, <a href="erl_syntax.html#map_field_exact_value/1">map_field_exact_value/1</a>.</p>
  </section>
</section>
<section class="detail" id="map_field_exact_name/1">

  <div class="detail-header">
    <a href="#map_field_exact_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_field_exact_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_field_exact_name(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="map_field_exact_name-1"></a><p>Returns the name subtree of a <code>map_field_exact</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#map_field_exact/2">map_field_exact/2</a>.</p>
  </section>
</section>
<section class="detail" id="map_field_exact_value/1">

  <div class="detail-header">
    <a href="#map_field_exact_value/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_field_exact_value(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_field_exact_value(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="map_field_exact_value-1"></a><p>Returns the value subtree of a <code>map_field_exact</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#map_field_exact/2">map_field_exact/2</a>.</p>
  </section>
</section>
<section class="detail" id="map_type/0">

  <div class="detail-header">
    <a href="#map_type/0" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_type() -&gt; term()
</h1>


  </div>

  <section class="docstring">

<a id="map_type-0"></a><p>Equivalent to <a href="erl_syntax.html#map_type/1">map_type(any_size)</a>.</p>
  </section>
</section>
<section class="detail" id="map_type/1">

  <div class="detail-header">
    <a href="#map_type/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_type(Fields::any_size | [ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_type(any_size | [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="map_type-1"></a><p>Creates an abstract type map. If <code>Fields</code> is <code>[F1, ..., Fn]</code>, the result represents &quot;<code>#{F1, ..., Fn}</code>&quot;; otherwise, if <code>Fields</code> is <code>any_size</code>, it represents &quot;<code>map()</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#map_type_fields/1">map_type_fields/1</a>.</p>
  </section>
</section>
<section class="detail" id="map_type_assoc/2">

  <div class="detail-header">
    <a href="#map_type_assoc/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_type_assoc(Name:: syntaxTree() , Value:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_type_assoc(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="map_type_assoc-2"></a><p>Creates an abstract map type assoc field. The result represents &quot;<code>Name =&gt; Value</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#map_type/1">map_type/1</a>, <a href="erl_syntax.html#map_type_assoc_name/1">map_type_assoc_name/1</a>, <a href="erl_syntax.html#map_type_assoc_value/1">map_type_assoc_value/1</a>.</p>
  </section>
</section>
<section class="detail" id="map_type_assoc_name/1">

  <div class="detail-header">
    <a href="#map_type_assoc_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_type_assoc_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_type_assoc_name(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="map_type_assoc_name-1"></a><p>Returns the name subtree of a <code>map_type_assoc</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#map_type_assoc/2">map_type_assoc/2</a>.</p>
  </section>
</section>
<section class="detail" id="map_type_assoc_value/1">

  <div class="detail-header">
    <a href="#map_type_assoc_value/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_type_assoc_value(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_type_assoc_value(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="map_type_assoc_value-1"></a><p>Returns the value subtree of a <code>map_type_assoc</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#map_type_assoc/2">map_type_assoc/2</a>.</p>
  </section>
</section>
<section class="detail" id="map_type_exact/2">

  <div class="detail-header">
    <a href="#map_type_exact/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_type_exact(Name:: syntaxTree() , Value:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_type_exact(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="map_type_exact-2"></a><p>Creates an abstract map type exact field. The result represents &quot;<code>Name := Value</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#map_type/1">map_type/1</a>, <a href="erl_syntax.html#map_type_exact_name/1">map_type_exact_name/1</a>, <a href="erl_syntax.html#map_type_exact_value/1">map_type_exact_value/1</a>.</p>
  </section>
</section>
<section class="detail" id="map_type_exact_name/1">

  <div class="detail-header">
    <a href="#map_type_exact_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_type_exact_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_type_exact_name(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="map_type_exact_name-1"></a><p>Returns the name subtree of a <code>map_type_exact</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#map_type_exact/2">map_type_exact/2</a>.</p>
  </section>
</section>
<section class="detail" id="map_type_exact_value/1">

  <div class="detail-header">
    <a href="#map_type_exact_value/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_type_exact_value(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_type_exact_value(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="map_type_exact_value-1"></a><p>Returns the value subtree of a <code>map_type_exact</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#map_type_exact/2">map_type_exact/2</a>.</p>
  </section>
</section>
<section class="detail" id="map_type_fields/1">

  <div class="detail-header">
    <a href="#map_type_fields/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map_type_fields(Node:: syntaxTree() ) -&gt; any_size | [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map_type_fields(syntaxTree()) -> any_size | [syntaxTree()].</pre>

      </div>

<a id="map_type_fields-1"></a><p>Returns the list of field subtrees of a <code>map_type</code> node. If <code>Node</code> represents &quot;<code>map()</code>&quot;, <code>any_size</code> is returned; otherwise, if <code>Node</code> represents &quot;<code>#{F1, ..., Fn}</code>&quot;, <code>[F1, ..., Fn]</code> is returned.</p><p><em>See also:</em> <a href="erl_syntax.html#map_type/0">map_type/0</a>, <a href="erl_syntax.html#map_type/1">map_type/1</a>.</p>
  </section>
</section>
<section class="detail" id="match_expr/2">

  <div class="detail-header">
    <a href="#match_expr/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">match_expr(Pattern:: syntaxTree() , Body:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>match_expr(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="match_expr-2"></a><p>Creates an abstract match-expression. The result represents &quot;<code>Pattern = Body</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#match_expr_body/1">match_expr_body/1</a>, <a href="erl_syntax.html#match_expr_pattern/1">match_expr_pattern/1</a>.</p>
  </section>
</section>
<section class="detail" id="match_expr_body/1">

  <div class="detail-header">
    <a href="#match_expr_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">match_expr_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>match_expr_body(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="match_expr_body-1"></a><p>Returns the body subtree of a <code>match_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#match_expr/2">match_expr/2</a>.</p>
  </section>
</section>
<section class="detail" id="match_expr_pattern/1">

  <div class="detail-header">
    <a href="#match_expr_pattern/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">match_expr_pattern(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>match_expr_pattern(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="match_expr_pattern-1"></a><p>Returns the pattern subtree of a <code>match_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#match_expr/2">match_expr/2</a>.</p>
  </section>
</section>
<section class="detail" id="meta/1">

  <div class="detail-header">
    <a href="#meta/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">meta(T:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>meta(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="meta-1"></a><p>Creates a meta-representation of a syntax tree. The result represents an Erlang expression &quot;<code>MetaTree</code>&quot; which, if evaluated, will yield a new syntax tree representing the same source code text as <code>Tree</code> (although the actual data representation may be different). The expression represented by <code>MetaTree</code> is <em>implementation independent</em> with regard to the data structures used by the abstract syntax tree implementation. Comments attached to nodes of <code>Tree</code> will be preserved, but other attributes are lost.</p><p>Any node in <code>Tree</code> whose node type is <code>variable</code> (see <a href="erl_syntax.html#type/1">type/1</a>), and whose list of annotations (see <a href="erl_syntax.html#get_ann/1">get_ann/1</a>) contains the atom <code>meta_var</code>, will remain unchanged in the resulting tree, except that exactly one occurrence of <code>meta_var</code> is removed from its annotation list.</p><p>The main use of the function <code>meta/1</code> is to transform a data structure <code>Tree</code>, which represents a piece of program code, into a form that is <em>representation independent when printed</em>. E.g., suppose <code>Tree</code> represents a variable named &quot;V&quot;. Then (assuming a function <code>print/1</code> for printing syntax trees), evaluating <code>print(abstract(Tree))</code> - simply using <a href="erl_syntax.html#abstract/1">abstract/1</a> to map the actual data structure onto a syntax tree representation - would output a string that might look something like &quot;<code>{tree, variable, ..., &quot;V&quot;, ...}</code>&quot;, which is obviously dependent on the implementation of the abstract syntax trees. This could e.g. be useful for caching a syntax tree in a file. However, in some situations like in a program generator generator (with two &quot;generator&quot;), it may be unacceptable. Using <code>print(meta(Tree))</code> instead would output a <em>representation independent</em> syntax tree generating expression; in the above case, something like &quot;<code>erl_syntax:variable(&quot;V&quot;)</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#abstract/1">abstract/1</a>, <a href="erl_syntax.html#get_ann/1">get_ann/1</a>, <a href="erl_syntax.html#type/1">type/1</a>.</p>
  </section>
</section>
<section class="detail" id="module_qualifier/2">

  <div class="detail-header">
    <a href="#module_qualifier/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">module_qualifier(Module:: syntaxTree() , Body:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>module_qualifier(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="module_qualifier-2"></a><p>Creates an abstract module qualifier. The result represents &quot;<code>Module:Body</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#module_qualifier_argument/1">module_qualifier_argument/1</a>, <a href="erl_syntax.html#module_qualifier_body/1">module_qualifier_body/1</a>.</p>
  </section>
</section>
<section class="detail" id="module_qualifier_argument/1">

  <div class="detail-header">
    <a href="#module_qualifier_argument/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">module_qualifier_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>module_qualifier_argument(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="module_qualifier_argument-1"></a><p>Returns the argument (the module) subtree of a <code>module_qualifier</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#module_qualifier/2">module_qualifier/2</a>.</p>
  </section>
</section>
<section class="detail" id="module_qualifier_body/1">

  <div class="detail-header">
    <a href="#module_qualifier_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">module_qualifier_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>module_qualifier_body(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="module_qualifier_body-1"></a><p>Returns the body subtree of a <code>module_qualifier</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#module_qualifier/2">module_qualifier/2</a>.</p>
  </section>
</section>
<section class="detail" id="named_fun_expr/2">

  <div class="detail-header">
    <a href="#named_fun_expr/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">named_fun_expr(Name:: syntaxTree() , Clauses::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>named_fun_expr(syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="named_fun_expr-2"></a><p>Creates an abstract named fun-expression. If <code>Clauses</code> is <code>[C1, ..., Cn]</code>, the result represents &quot;<code>fun Name C1; ...; Name Cn end</code>&quot;. More exactly, if each <code>Ci</code> represents &quot;<code>(Pi1, ..., Pim) Gi -&gt; Bi</code>&quot;, then the result represents &quot;<code>fun Name(P11, ..., P1m) G1 -&gt; B1; ...; Name(Pn1, ..., Pnm) Gn -&gt; Bn end</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#named_fun_expr_arity/1">named_fun_expr_arity/1</a>, <a href="erl_syntax.html#named_fun_expr_clauses/1">named_fun_expr_clauses/1</a>, <a href="erl_syntax.html#named_fun_expr_name/1">named_fun_expr_name/1</a>.</p>
  </section>
</section>
<section class="detail" id="named_fun_expr_arity/1">

  <div class="detail-header">
    <a href="#named_fun_expr_arity/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">named_fun_expr_arity(Node:: syntaxTree() ) -&gt; arity()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>named_fun_expr_arity(syntaxTree()) -> arity().</pre>

      </div>

<a id="named_fun_expr_arity-1"></a><p>Returns the arity of a <code>named_fun_expr</code> node. The result is the number of parameter patterns in the first clause of the named fun-expression; subsequent clauses are ignored.</p><p>An exception is thrown if <code>named_fun_expr_clauses(Node)</code> returns an empty list, or if the first element of that list is not a syntax tree <code>C</code> of type <code>clause</code> such that <code>clause_patterns(C)</code> is a nonempty list.</p><p><em>See also:</em> <a href="erl_syntax.html#clause/3">clause/3</a>, <a href="erl_syntax.html#clause_patterns/1">clause_patterns/1</a>, <a href="erl_syntax.html#named_fun_expr/2">named_fun_expr/2</a>, <a href="erl_syntax.html#named_fun_expr_clauses/1">named_fun_expr_clauses/1</a>.</p>
  </section>
</section>
<section class="detail" id="named_fun_expr_clauses/1">

  <div class="detail-header">
    <a href="#named_fun_expr_clauses/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">named_fun_expr_clauses(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>named_fun_expr_clauses(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="named_fun_expr_clauses-1"></a><p>Returns the list of clause subtrees of a <code>named_fun_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#named_fun_expr/2">named_fun_expr/2</a>.</p>
  </section>
</section>
<section class="detail" id="named_fun_expr_name/1">

  <div class="detail-header">
    <a href="#named_fun_expr_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">named_fun_expr_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>named_fun_expr_name(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="named_fun_expr_name-1"></a><p>Returns the name subtree of a <code>named_fun_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#named_fun_expr/2">named_fun_expr/2</a>.</p>
  </section>
</section>
<section class="detail" id="/0">

  <div class="detail-header">
    <a href="#/0" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">nil() -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>nil() -> syntaxTree().</pre>

      </div>

<a id="nil-0"></a><p>Creates an abstract empty list. The result represents &quot;<code>[]</code>&quot;. The empty list is traditionally called &quot;nil&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#is_list_skeleton/1">is_list_skeleton/1</a>, <a href="erl_syntax.html#list/2">list/2</a>.</p>
  </section>
</section>
<section class="detail" id="normalize_list/1">

  <div class="detail-header">
    <a href="#normalize_list/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">normalize_list(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>normalize_list(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="normalize_list-1"></a><p>Expands an abstract list skeleton to its most explicit form. If <code>Node</code> represents &quot;<code>[E1, ..., En | Tail]</code>&quot;, the result represents &quot;<code>[E1 | ... [En | Tail1] ... ]</code>&quot;, where <code>Tail1</code> is the result of <code>normalize_list(Tail)</code>. If <code>Node</code> represents &quot;<code>[E1, ..., En]</code>&quot;, the result simply represents &quot;<code>[E1 | ... [En | []] ... ]</code>&quot;. If <code>Node</code> does not represent a list skeleton, <code>Node</code> itself is returned.</p><p><em>See also:</em> <a href="erl_syntax.html#compact_list/1">compact_list/1</a>, <a href="erl_syntax.html#list/2">list/2</a>.</p>
  </section>
</section>
<section class="detail" id="operator/1">

  <div class="detail-header">
    <a href="#operator/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">operator(Name::atom() | string()) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>operator(atom() | string()) -> syntaxTree().</pre>

      </div>

<a id="operator-1"></a><p>Creates an abstract operator. The name of the operator is the character sequence represented by <code>Name</code>. This is analogous to the print name of an atom, but an operator is never written within single-quotes; e.g., the result of <code>operator('++')</code> represents &quot;<code>++</code>&quot; rather than &quot;<code>'++'</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#atom/1">atom/1</a>, <a href="erl_syntax.html#operator_literal/1">operator_literal/1</a>, <a href="erl_syntax.html#operator_name/1">operator_name/1</a>.</p>
  </section>
</section>
<section class="detail" id="operator_literal/1">

  <div class="detail-header">
    <a href="#operator_literal/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">operator_literal(Node:: syntaxTree() ) -&gt; string()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>operator_literal(syntaxTree()) -> string().</pre>

      </div>

<a id="operator_literal-1"></a><p>Returns the literal string represented by an <code>operator</code> node. This is simply the operator name as a string.</p><p><em>See also:</em> <a href="erl_syntax.html#operator/1">operator/1</a>.</p>
  </section>
</section>
<section class="detail" id="operator_name/1">

  <div class="detail-header">
    <a href="#operator_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">operator_name(Node:: syntaxTree() ) -&gt; atom()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>operator_name(syntaxTree()) -> atom().</pre>

      </div>

<a id="operator_name-1"></a><p>Returns the name of an <code>operator</code> node. Note that the name is returned as an atom.</p><p><em>See also:</em> <a href="erl_syntax.html#operator/1">operator/1</a>.</p>
  </section>
</section>
<section class="detail" id="parentheses/1">

  <div class="detail-header">
    <a href="#parentheses/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">parentheses(Expr:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>parentheses(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="parentheses-1"></a><p>Creates an abstract parenthesised expression. The result represents &quot;<code>(Body)</code>&quot;, independently of the context.</p><p><em>See also:</em> <a href="erl_syntax.html#parentheses_body/1">parentheses_body/1</a>.</p>
  </section>
</section>
<section class="detail" id="parentheses_body/1">

  <div class="detail-header">
    <a href="#parentheses_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">parentheses_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>parentheses_body(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="parentheses_body-1"></a><p>Returns the body subtree of a <code>parentheses</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#parentheses/1">parentheses/1</a>.</p>
  </section>
</section>
<section class="detail" id="prefix_expr/2">

  <div class="detail-header">
    <a href="#prefix_expr/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">prefix_expr(Operator:: syntaxTree() , Argument:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>prefix_expr(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="prefix_expr-2"></a><p>Creates an abstract prefix operator expression. The result represents &quot;<code>Operator Argument</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#infix_expr/3">infix_expr/3</a>, <a href="erl_syntax.html#prefix_expr_argument/1">prefix_expr_argument/1</a>, <a href="erl_syntax.html#prefix_expr_operator/1">prefix_expr_operator/1</a>.</p>
  </section>
</section>
<section class="detail" id="prefix_expr_argument/1">

  <div class="detail-header">
    <a href="#prefix_expr_argument/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">prefix_expr_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>prefix_expr_argument(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="prefix_expr_argument-1"></a><p>Returns the argument subtree of a <code>prefix_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#prefix_expr/2">prefix_expr/2</a>.</p>
  </section>
</section>
<section class="detail" id="prefix_expr_operator/1">

  <div class="detail-header">
    <a href="#prefix_expr_operator/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">prefix_expr_operator(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>prefix_expr_operator(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="prefix_expr_operator-1"></a><p>Returns the operator subtree of a <code>prefix_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#prefix_expr/2">prefix_expr/2</a>.</p>
  </section>
</section>
<section class="detail" id="receive_expr/1">

  <div class="detail-header">
    <a href="#receive_expr/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">receive_expr(Clauses::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>receive_expr([syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="receive_expr-1"></a><p>Equivalent to <a href="erl_syntax.html#receive_expr/3">receive_expr(Clauses, none, [])</a>.</p>
  </section>
</section>
<section class="detail" id="receive_expr/3">

  <div class="detail-header">
    <a href="#receive_expr/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">receive_expr(Clauses::[ syntaxTree() ], Timeout::none |  syntaxTree() , Action::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>receive_expr([syntaxTree()], none | syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="receive_expr-3"></a><p>Creates an abstract receive-expression. If <code>Timeout</code> is <code>none</code>, the result represents &quot;<code>receive C1; ...; Cn end</code>&quot; (the <code>Action</code> argument is ignored). Otherwise, if <code>Clauses</code> is <code>[C1, ..., Cn]</code> and <code>Action</code> is <code>[A1, ..., Am]</code>, the result represents &quot;<code>receive C1; ...; Cn after Timeout -&gt; A1, ..., Am end</code>&quot;. More exactly, if each <code>Ci</code> represents &quot;<code>(Pi) Gi -&gt; Bi</code>&quot;, then the result represents &quot;<code>receive P1 G1 -&gt; B1; ...; Pn Gn -&gt; Bn ... end</code>&quot;.</p><p>Note that in Erlang, a receive-expression must have at least one clause if no timeout part is specified.</p><p><em>See also:</em> <a href="erl_syntax.html#case_expr/2">case_expr/2</a>, <a href="erl_syntax.html#clause/3">clause/3</a>, <a href="erl_syntax.html#receive_expr/1">receive_expr/1</a>, <a href="erl_syntax.html#receive_expr_action/1">receive_expr_action/1</a>, <a href="erl_syntax.html#receive_expr_clauses/1">receive_expr_clauses/1</a>, <a href="erl_syntax.html#receive_expr_timeout/1">receive_expr_timeout/1</a>.</p>
  </section>
</section>
<section class="detail" id="receive_expr_action/1">

  <div class="detail-header">
    <a href="#receive_expr_action/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">receive_expr_action(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>receive_expr_action(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="receive_expr_action-1"></a><p>Returns the list of action body subtrees of a <code>receive_expr</code> node. If <code>Node</code> represents &quot;<code>receive C1; ...; Cn end</code>&quot;, this is the empty list.</p><p><em>See also:</em> <a href="erl_syntax.html#receive_expr/3">receive_expr/3</a>.</p>
  </section>
</section>
<section class="detail" id="receive_expr_clauses/1">

  <div class="detail-header">
    <a href="#receive_expr_clauses/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">receive_expr_clauses(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>receive_expr_clauses(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="receive_expr_clauses-1"></a><p>Returns the list of clause subtrees of a <code>receive_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#receive_expr/3">receive_expr/3</a>.</p>
  </section>
</section>
<section class="detail" id="receive_expr_timeout/1">

  <div class="detail-header">
    <a href="#receive_expr_timeout/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">receive_expr_timeout(Node:: syntaxTree() ) -&gt; none |  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>receive_expr_timeout(syntaxTree()) -> none | syntaxTree().</pre>

      </div>

<a id="receive_expr_timeout-1"></a><p>Returns the timeout subtree of a <code>receive_expr</code> node, if any. If <code>Node</code> represents &quot;<code>receive C1; ...; Cn end</code>&quot;, <code>none</code> is returned. Otherwise, if <code>Node</code> represents &quot;<code>receive C1; ...; Cn after Timeout -&gt; ... end</code>&quot;, <code>Timeout</code> is returned.</p><p><em>See also:</em> <a href="erl_syntax.html#receive_expr/3">receive_expr/3</a>.</p>
  </section>
</section>
<section class="detail" id="record_access/3">

  <div class="detail-header">
    <a href="#record_access/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_access(Argument:: syntaxTree() , Type:: syntaxTree() , Field:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_access(syntaxTree(), syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="record_access-3"></a><p>Creates an abstract record field access expression. The result represents &quot;<code>Argument#Type.Field</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#record_access_argument/1">record_access_argument/1</a>, <a href="erl_syntax.html#record_access_field/1">record_access_field/1</a>, <a href="erl_syntax.html#record_access_type/1">record_access_type/1</a>, <a href="erl_syntax.html#record_expr/3">record_expr/3</a>.</p>
  </section>
</section>
<section class="detail" id="record_access_argument/1">

  <div class="detail-header">
    <a href="#record_access_argument/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_access_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_access_argument(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="record_access_argument-1"></a><p>Returns the argument subtree of a <code>record_access</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#record_access/3">record_access/3</a>.</p>
  </section>
</section>
<section class="detail" id="record_access_field/1">

  <div class="detail-header">
    <a href="#record_access_field/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_access_field(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_access_field(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="record_access_field-1"></a><p>Returns the field subtree of a <code>record_access</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#record_access/3">record_access/3</a>.</p>
  </section>
</section>
<section class="detail" id="record_access_type/1">

  <div class="detail-header">
    <a href="#record_access_type/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_access_type(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_access_type(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="record_access_type-1"></a><p>Returns the type subtree of a <code>record_access</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#record_access/3">record_access/3</a>.</p>
  </section>
</section>
<section class="detail" id="record_expr/2">

  <div class="detail-header">
    <a href="#record_expr/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_expr(Type:: syntaxTree() , Fields::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_expr(syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="record_expr-2"></a><p>Equivalent to <a href="erl_syntax.html#record_expr/3">record_expr(none, Type, Fields)</a>.</p>
  </section>
</section>
<section class="detail" id="record_expr/3">

  <div class="detail-header">
    <a href="#record_expr/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_expr(Argument::none |  syntaxTree() , Type:: syntaxTree() , Fields::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_expr(none | syntaxTree(), syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="record_expr-3"></a><p>Creates an abstract record expression. If <code>Fields</code> is <code>[F1, ..., Fn]</code>, then if <code>Argument</code> is <code>none</code>, the result represents &quot;<code>#Type{F1, ..., Fn}</code>&quot;, otherwise it represents &quot;<code>Argument#Type{F1, ..., Fn}</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#record_access/3">record_access/3</a>, <a href="erl_syntax.html#record_expr/2">record_expr/2</a>, <a href="erl_syntax.html#record_expr_argument/1">record_expr_argument/1</a>, <a href="erl_syntax.html#record_expr_fields/1">record_expr_fields/1</a>, <a href="erl_syntax.html#record_expr_type/1">record_expr_type/1</a>, <a href="erl_syntax.html#record_field/2">record_field/2</a>, <a href="erl_syntax.html#record_index_expr/2">record_index_expr/2</a>.</p>
  </section>
</section>
<section class="detail" id="record_expr_argument/1">

  <div class="detail-header">
    <a href="#record_expr_argument/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_expr_argument(Node:: syntaxTree() ) -&gt; none |  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_expr_argument(syntaxTree()) -> none | syntaxTree().</pre>

      </div>

<a id="record_expr_argument-1"></a><p>Returns the argument subtree of a <code>record_expr</code> node, if any. If <code>Node</code> represents &quot;<code>#Type{...}</code>&quot;, <code>none</code> is returned. Otherwise, if <code>Node</code> represents &quot;<code>Argument#Type{...}</code>&quot;, <code>Argument</code> is returned.</p><p><em>See also:</em> <a href="erl_syntax.html#record_expr/3">record_expr/3</a>.</p>
  </section>
</section>
<section class="detail" id="record_expr_fields/1">

  <div class="detail-header">
    <a href="#record_expr_fields/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_expr_fields(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_expr_fields(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="record_expr_fields-1"></a><p>Returns the list of field subtrees of a <code>record_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#record_expr/3">record_expr/3</a>.</p>
  </section>
</section>
<section class="detail" id="record_expr_type/1">

  <div class="detail-header">
    <a href="#record_expr_type/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_expr_type(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_expr_type(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="record_expr_type-1"></a><p>Returns the type subtree of a <code>record_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#record_expr/3">record_expr/3</a>.</p>
  </section>
</section>
<section class="detail" id="record_field/1">

  <div class="detail-header">
    <a href="#record_field/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_field(Name:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_field(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="record_field-1"></a><p>Equivalent to <a href="erl_syntax.html#record_field/2">record_field(Name, none)</a>.</p>
  </section>
</section>
<section class="detail" id="record_field/2">

  <div class="detail-header">
    <a href="#record_field/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_field(Name:: syntaxTree() , Value::none |  syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_field(syntaxTree(), none | syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="record_field-2"></a><p>Creates an abstract record field specification. If <code>Value</code> is <code>none</code>, the result represents simply &quot;<code>Name</code>&quot;, otherwise it represents &quot;<code>Name = Value</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#record_expr/3">record_expr/3</a>, <a href="erl_syntax.html#record_field_name/1">record_field_name/1</a>, <a href="erl_syntax.html#record_field_value/1">record_field_value/1</a>.</p>
  </section>
</section>
<section class="detail" id="record_field_name/1">

  <div class="detail-header">
    <a href="#record_field_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_field_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_field_name(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="record_field_name-1"></a><p>Returns the name subtree of a <code>record_field</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#record_field/2">record_field/2</a>.</p>
  </section>
</section>
<section class="detail" id="record_field_value/1">

  <div class="detail-header">
    <a href="#record_field_value/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_field_value(Node:: syntaxTree() ) -&gt; none |  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_field_value(syntaxTree()) -> none | syntaxTree().</pre>

      </div>

<a id="record_field_value-1"></a><p>Returns the value subtree of a <code>record_field</code> node, if any. If <code>Node</code> represents &quot;<code>Name</code>&quot;, <code>none</code> is returned. Otherwise, if <code>Node</code> represents &quot;<code>Name = Value</code>&quot;, <code>Value</code> is returned.</p><p><em>See also:</em> <a href="erl_syntax.html#record_field/2">record_field/2</a>.</p>
  </section>
</section>
<section class="detail" id="record_index_expr/2">

  <div class="detail-header">
    <a href="#record_index_expr/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_index_expr(Type:: syntaxTree() , Field:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_index_expr(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="record_index_expr-2"></a><p>Creates an abstract record field index expression. The result represents &quot;<code>#Type.Field</code>&quot;.</p><p>(Note: the function name <code>record_index/2</code> is reserved by the Erlang compiler, which is why that name could not be used for this constructor.)</p><p><em>See also:</em> <a href="erl_syntax.html#record_expr/3">record_expr/3</a>, <a href="erl_syntax.html#record_index_expr_field/1">record_index_expr_field/1</a>, <a href="erl_syntax.html#record_index_expr_type/1">record_index_expr_type/1</a>.</p>
  </section>
</section>
<section class="detail" id="record_index_expr_field/1">

  <div class="detail-header">
    <a href="#record_index_expr_field/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_index_expr_field(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_index_expr_field(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="record_index_expr_field-1"></a><p>Returns the field subtree of a <code>record_index_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#record_index_expr/2">record_index_expr/2</a>.</p>
  </section>
</section>
<section class="detail" id="record_index_expr_type/1">

  <div class="detail-header">
    <a href="#record_index_expr_type/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_index_expr_type(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_index_expr_type(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="record_index_expr_type-1"></a><p>Returns the type subtree of a <code>record_index_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#record_index_expr/2">record_index_expr/2</a>.</p>
  </section>
</section>
<section class="detail" id="record_type/2">

  <div class="detail-header">
    <a href="#record_type/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_type(Name:: syntaxTree() , Fields::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_type(syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="record_type-2"></a><p>Creates an abstract record type. If <code>Fields</code> is <code>[F1, ..., Fn]</code>, the result represents &quot;<code>#Name{F1, ..., Fn}</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#record_type_fields/1">record_type_fields/1</a>, <a href="erl_syntax.html#record_type_name/1">record_type_name/1</a>.</p>
  </section>
</section>
<section class="detail" id="record_type_field/2">

  <div class="detail-header">
    <a href="#record_type_field/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_type_field(Name:: syntaxTree() , Type:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_type_field(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="record_type_field-2"></a><p>Creates an abstract record type field. The result represents &quot;<code>Name :: Type</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#record_type_field_name/1">record_type_field_name/1</a>, <a href="erl_syntax.html#record_type_field_type/1">record_type_field_type/1</a>.</p>
  </section>
</section>
<section class="detail" id="record_type_field_name/1">

  <div class="detail-header">
    <a href="#record_type_field_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_type_field_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_type_field_name(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="record_type_field_name-1"></a><p>Returns the name subtree of a <code>record_type_field</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#record_type_field/2">record_type_field/2</a>.</p>
  </section>
</section>
<section class="detail" id="record_type_field_type/1">

  <div class="detail-header">
    <a href="#record_type_field_type/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_type_field_type(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_type_field_type(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="record_type_field_type-1"></a><p>Returns the type subtree of a <code>record_type_field</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#record_type_field/2">record_type_field/2</a>.</p>
  </section>
</section>
<section class="detail" id="record_type_fields/1">

  <div class="detail-header">
    <a href="#record_type_fields/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_type_fields(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_type_fields(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="record_type_fields-1"></a><p>Returns the fields subtree of a <code>record_type</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#record_type/2">record_type/2</a>.</p>
  </section>
</section>
<section class="detail" id="record_type_name/1">

  <div class="detail-header">
    <a href="#record_type_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">record_type_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>record_type_name(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="record_type_name-1"></a><p>Returns the name subtree of a <code>record_type</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#record_type/2">record_type/2</a>.</p>
  </section>
</section>
<section class="detail" id="remove_comments/1">

  <div class="detail-header">
    <a href="#remove_comments/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">remove_comments(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>remove_comments(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="remove_comments-1"></a><p>Clears the associated comments of <code>Node</code>.</p><p>Note: This is equivalent to <code>set_precomments(set_postcomments(Node, []), [])</code>, but potentially more efficient.</p><p><em>See also:</em> <a href="erl_syntax.html#set_postcomments/2">set_postcomments/2</a>, <a href="erl_syntax.html#set_precomments/2">set_precomments/2</a>.</p>
  </section>
</section>
<section class="detail" id="revert/1">

  <div class="detail-header">
    <a href="#revert/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">revert(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>revert(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="revert-1"></a><p>Returns an <code>erl_parse</code>-compatible representation of a syntax tree, if possible. If <code>Tree</code> represents a well-formed Erlang program or expression, the conversion should work without problems. Typically, <a href="erl_syntax.html#is_tree/1">is_tree/1</a> yields <code>true</code> if conversion failed (i.e., the result is still an abstract syntax tree), and <code>false</code> otherwise.</p><p>The <a href="erl_syntax.html#is_tree/1">is_tree/1</a> test is not completely foolproof. For a few special node types (e.g. <code>arity_qualifier</code>), if such a node occurs in a context where it is not expected, it will be left unchanged as a non-reverted subtree of the result. This can only happen if <code>Tree</code> does not actually represent legal Erlang code.</p><p><em>See also:</em> <a href="https://wojtekmach.pl/otp_docs/stdlib/erl_parse.html">erl_parse(3)</a>, <a href="erl_syntax.html#revert_forms/1">revert_forms/1</a>.</p>
  </section>
</section>
<section class="detail" id="revert_forms/1">

  <div class="detail-header">
    <a href="#revert_forms/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">revert_forms(Forms:: forms() ) -&gt; [ erl_parse() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>revert_forms(forms()) -> [<a href="#t:erl_parse/0">erl_parse</a>()].</pre>

      </div>

<a id="revert_forms-1"></a><p>Reverts a sequence of Erlang source code forms. The sequence can be given either as a <code>form_list</code> syntax tree (possibly nested), or as a list of &quot;program form&quot; syntax trees. If successful, the corresponding flat list of <code>erl_parse</code>-compatible syntax trees is returned (see <a href="erl_syntax.html#revert/1">revert/1</a>). If some program form could not be reverted, <code>{error, Form}</code> is thrown. Standalone comments in the form sequence are discarded.</p><p><em>See also:</em> <a href="erl_syntax.html#form_list/1">form_list/1</a>, <a href="erl_syntax.html#is_form/1">is_form/1</a>, <a href="erl_syntax.html#revert/1">revert/1</a>.</p>
  </section>
</section>
<section class="detail" id="set_ann/2">

  <div class="detail-header">
    <a href="#set_ann/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">set_ann(Node:: syntaxTree() , As::[term()]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>set_ann(syntaxTree(), [term()]) -> syntaxTree().</pre>

      </div>

<a id="set_ann-2"></a><p>Sets the list of user annotations of <code>Node</code> to <code>Annotations</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#add_ann/2">add_ann/2</a>, <a href="erl_syntax.html#copy_ann/2">copy_ann/2</a>, <a href="erl_syntax.html#get_ann/1">get_ann/1</a>.</p>
  </section>
</section>
<section class="detail" id="set_attrs/2">

  <div class="detail-header">
    <a href="#set_attrs/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">set_attrs(Node:: syntaxTree() , Attr:: syntaxTreeAttributes() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>set_attrs(syntaxTree(), syntaxTreeAttributes()) -> syntaxTree().</pre>

      </div>

<a id="set_attrs-2"></a><p>Sets the attributes of <code>Node</code> to <code>Attributes</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#copy_attrs/2">copy_attrs/2</a>, <a href="erl_syntax.html#get_attrs/1">get_attrs/1</a>.</p>
  </section>
</section>
<section class="detail" id="set_pos/2">

  <div class="detail-header">
    <a href="#set_pos/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">set_pos(Node:: syntaxTree() , Pos:: annotation_or_location() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>set_pos(syntaxTree(), <a href="#t:annotation_or_location/0">annotation_or_location</a>()) -> syntaxTree().</pre>

      </div>

<a id="set_pos-2"></a><p>Sets the position information of <code>Node</code> to <code>Pos</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#copy_pos/2">copy_pos/2</a>, <a href="erl_syntax.html#get_pos/1">get_pos/1</a>.</p>
  </section>
</section>
<section class="detail" id="set_postcomments/2">

  <div class="detail-header">
    <a href="#set_postcomments/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">set_postcomments(Node:: syntaxTree() , Cs::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>set_postcomments(syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="set_postcomments-2"></a><p>Sets the post-comments of <code>Node</code> to <code>Comments</code>. <code>Comments</code> should be a possibly empty list of abstract comments, in top-down textual order</p><p><em>See also:</em> <a href="erl_syntax.html#add_postcomments/2">add_postcomments/2</a>, <a href="erl_syntax.html#comment/2">comment/2</a>, <a href="erl_syntax.html#copy_comments/2">copy_comments/2</a>, <a href="erl_syntax.html#get_postcomments/1">get_postcomments/1</a>, <a href="erl_syntax.html#join_comments/2">join_comments/2</a>, <a href="erl_syntax.html#remove_comments/1">remove_comments/1</a>, <a href="erl_syntax.html#set_precomments/2">set_precomments/2</a>.</p>
  </section>
</section>
<section class="detail" id="set_precomments/2">

  <div class="detail-header">
    <a href="#set_precomments/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">set_precomments(Node:: syntaxTree() , Cs::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>set_precomments(syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="set_precomments-2"></a><p>Sets the pre-comments of <code>Node</code> to <code>Comments</code>. <code>Comments</code> should be a possibly empty list of abstract comments, in top-down textual order.</p><p><em>See also:</em> <a href="erl_syntax.html#add_precomments/2">add_precomments/2</a>, <a href="erl_syntax.html#comment/2">comment/2</a>, <a href="erl_syntax.html#copy_comments/2">copy_comments/2</a>, <a href="erl_syntax.html#get_precomments/1">get_precomments/1</a>, <a href="erl_syntax.html#join_comments/2">join_comments/2</a>, <a href="erl_syntax.html#remove_comments/1">remove_comments/1</a>, <a href="erl_syntax.html#set_postcomments/2">set_postcomments/2</a>.</p>
  </section>
</section>
<section class="detail" id="size_qualifier/2">

  <div class="detail-header">
    <a href="#size_qualifier/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">size_qualifier(Body:: syntaxTree() , Size:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>size_qualifier(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="size_qualifier-2"></a><p>Creates an abstract size qualifier. The result represents &quot;<code>Body:Size</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#size_qualifier_argument/1">size_qualifier_argument/1</a>, <a href="erl_syntax.html#size_qualifier_body/1">size_qualifier_body/1</a>.</p>
  </section>
</section>
<section class="detail" id="size_qualifier_argument/1">

  <div class="detail-header">
    <a href="#size_qualifier_argument/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">size_qualifier_argument(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>size_qualifier_argument(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="size_qualifier_argument-1"></a><p>Returns the argument subtree (the size) of a <code>size_qualifier</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#size_qualifier/2">size_qualifier/2</a>.</p>
  </section>
</section>
<section class="detail" id="size_qualifier_body/1">

  <div class="detail-header">
    <a href="#size_qualifier_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">size_qualifier_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>size_qualifier_body(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="size_qualifier_body-1"></a><p>Returns the body subtree of a <code>size_qualifier</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#size_qualifier/2">size_qualifier/2</a>.</p>
  </section>
</section>
<section class="detail" id="string/1">

  <div class="detail-header">
    <a href="#string/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">string(String::string()) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>string()) -> syntaxTree().</pre>

      </div>

<a id="string-1"></a><p>Creates an abstract string literal. The result represents <code>&quot;Text&quot;</code> (including the surrounding double-quotes), where <code>Text</code> corresponds to the sequence of characters in <code>Value</code>, but not representing a <em>specific</em> string literal.</p><p>For example, the result of <code>string(&quot;x\ny&quot;)</code> represents any and all of <code>&quot;x\ny&quot;</code>, <code>&quot;x\12y&quot;</code>, <code>&quot;x\012y&quot;</code> and <code>&quot;x\^Jy&quot;</code>; see <a href="erl_syntax.html#char/1">char/1</a>.</p><p><em>See also:</em> <a href="erl_syntax.html#char/1">char/1</a>, <a href="erl_syntax.html#is_string/2">is_string/2</a>, <a href="erl_syntax.html#string_literal/1">string_literal/1</a>, <a href="erl_syntax.html#string_literal/2">string_literal/2</a>, <a href="erl_syntax.html#string_value/1">string_value/1</a>.</p>
  </section>
</section>
<section class="detail" id="string_literal/1">

  <div class="detail-header">
    <a href="#string_literal/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">string_literal(Node:: syntaxTree() ) -&gt; nonempty_string()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>string_literal(syntaxTree()) -> nonempty_string().</pre>

      </div>

<a id="string_literal-1"></a><p>Returns the literal string represented by a <code>string</code> node. This includes surrounding double-quote characters. Characters beyond 255 will be escaped.</p><p><em>See also:</em> <a href="erl_syntax.html#string/1">string/1</a>.</p>
  </section>
</section>
<section class="detail" id="string_literal/2">

  <div class="detail-header">
    <a href="#string_literal/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">string_literal(Node:: syntaxTree() , X2:: encoding() ) -&gt; nonempty_string()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>string_literal(syntaxTree(), <a href="#t:encoding/0">encoding</a>()) -> nonempty_string().</pre>

      </div>

<a id="string_literal-2"></a><p>Returns the literal string represented by a <code>string</code> node. This includes surrounding double-quote characters. Depending on the encoding characters beyond 255 will be escaped (<code>latin1</code>) or copied as is (<code>utf8</code>).</p><p><em>See also:</em> <a href="erl_syntax.html#string/1">string/1</a>.</p>
  </section>
</section>
<section class="detail" id="string_value/1">

  <div class="detail-header">
    <a href="#string_value/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">string_value(Node:: syntaxTree() ) -&gt; string()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>string_value(syntaxTree()) -> string().</pre>

      </div>

<a id="string_value-1"></a><p>Returns the value represented by a <code>string</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#string/1">string/1</a>.</p>
  </section>
</section>
<section class="detail" id="subtrees/1">

  <div class="detail-header">
    <a href="#subtrees/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">subtrees(T:: syntaxTree() ) -&gt; [[ syntaxTree() ]]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>subtrees(syntaxTree()) -> [[syntaxTree()]].</pre>

      </div>

<a id="subtrees-1"></a><p>Returns the grouped list of all subtrees of a syntax tree. If <code>Node</code> is a leaf node (see <a href="erl_syntax.html#is_leaf/1">is_leaf/1</a>), this is the empty list, otherwise the result is always a nonempty list, containing the lists of subtrees of <code>Node</code>, in left-to-right order as they occur in the printed program text, and grouped by category. Often, each group contains only a single subtree.</p><p>Depending on the type of <code>Node</code>, the size of some groups may be variable (e.g., the group consisting of all the elements of a tuple), while others always contain the same number of elements - usually exactly one (e.g., the group containing the argument expression of a case-expression). Note, however, that the exact structure of the returned list (for a given node type) should in general not be depended upon, since it might be subject to change without notice.</p><p>The function <a href="erl_syntax.html#subtrees/1">subtrees/1</a> and the constructor functions <a href="erl_syntax.html#make_tree/2">make_tree/2</a> and <a href="erl_syntax.html#update_tree/2">update_tree/2</a> can be a great help if one wants to traverse a syntax tree, visiting all its subtrees, but treat nodes of the tree in a uniform way in most or all cases. Using these functions makes this simple, and also assures that your code is not overly sensitive to extensions of the syntax tree data type, because any node types not explicitly handled by your code can be left to a default case.</p><p>For example:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="nf">postorder</span><span class="p" data-group-id="3129127649-1">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">Tree</span><span class="p" data-group-id="3129127649-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">F</span><span class="p" data-group-id="3129127649-2">(</span><span class="k">case</span><span class="w"> </span><span class="nf">subtrees</span><span class="p" data-group-id="3129127649-3">(</span><span class="n">Tree</span><span class="p" data-group-id="3129127649-3">)</span><span class="w"> </span><span class="k">of</span><span class="w">
            </span><span class="p" data-group-id="3129127649-4">[</span><span class="p" data-group-id="3129127649-4">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">Tree</span><span class="p">;</span><span class="w">
            </span><span class="n">List</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">update_tree</span><span class="p" data-group-id="3129127649-5">(</span><span class="n">Tree</span><span class="p">,</span><span class="w">
                                </span><span class="p" data-group-id="3129127649-6">[</span><span class="p" data-group-id="3129127649-7">[</span><span class="nf">postorder</span><span class="p" data-group-id="3129127649-8">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">Subtree</span><span class="p" data-group-id="3129127649-8">)</span><span class="w">
                                  </span><span class="p">||</span><span class="w"> </span><span class="n">Subtree</span><span class="w"> </span><span class="err">&amp;</span><span class="ss">lt</span><span class="p">;</span><span class="o">-</span><span class="w"> </span><span class="n">Group</span><span class="p" data-group-id="3129127649-7">]</span><span class="w">
                                 </span><span class="p">||</span><span class="w"> </span><span class="n">Group</span><span class="w"> </span><span class="err">&amp;</span><span class="ss">lt</span><span class="p">;</span><span class="o">-</span><span class="w"> </span><span class="n">List</span><span class="p" data-group-id="3129127649-6">]</span><span class="p" data-group-id="3129127649-5">)</span><span class="w">
          </span><span class="k">end</span><span class="p" data-group-id="3129127649-2">)</span><span class="p">.</span></code></pre><p>maps the function <code>F</code> on <code>Tree</code> and all its subtrees, doing a post-order traversal of the syntax tree. (Note the use of <a href="erl_syntax.html#update_tree/2">update_tree/2</a> to preserve node attributes.) For a simple function like:</p><pre><code class="makeup erlang"><span class="w">     </span><span class="nf">f</span><span class="p" data-group-id="4259134803-1">(</span><span class="n">Node</span><span class="p" data-group-id="4259134803-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="k">case</span><span class="w"> </span><span class="nf">type</span><span class="p" data-group-id="4259134803-2">(</span><span class="n">Node</span><span class="p" data-group-id="4259134803-2">)</span><span class="w"> </span><span class="k">of</span><span class="w">
            </span><span class="ss">atom</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">atom</span><span class="p" data-group-id="4259134803-3">(</span><span class="s">&quot;a_&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="nf">atom_name</span><span class="p" data-group-id="4259134803-4">(</span><span class="n">Node</span><span class="p" data-group-id="4259134803-4">)</span><span class="p" data-group-id="4259134803-3">)</span><span class="p">;</span><span class="w">
            </span><span class="p">_</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">Node</span><span class="w">
        </span><span class="k">end</span><span class="p">.</span></code></pre><p>the call <code>postorder(fun f/1, Tree)</code> will yield a new representation of <code>Tree</code> in which all atom names have been extended with the prefix &quot;a_&quot;, but nothing else (including comments, annotations and line numbers) has been changed.</p><p><em>See also:</em> <a href="erl_syntax.html#copy_attrs/2">copy_attrs/2</a>, <a href="erl_syntax.html#is_leaf/1">is_leaf/1</a>, <a href="erl_syntax.html#make_tree/2">make_tree/2</a>, <a href="erl_syntax.html#type/1">type/1</a>.</p>
  </section>
</section>
<section class="detail" id="text/1">

  <div class="detail-header">
    <a href="#text/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">text(String::string()) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>text(string()) -> syntaxTree().</pre>

      </div>

<a id="text-1"></a><p>Creates an abstract piece of source code text. The result represents exactly the sequence of characters in <code>String</code>. This is useful in cases when one wants full control of the resulting output, e.g., for the appearance of floating-point numbers or macro definitions.</p><p><em>See also:</em> <a href="erl_syntax.html#text_string/1">text_string/1</a>.</p>
  </section>
</section>
<section class="detail" id="text_string/1">

  <div class="detail-header">
    <a href="#text_string/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">text_string(Node:: syntaxTree() ) -&gt; string()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>text_string(syntaxTree()) -> string().</pre>

      </div>

<a id="text_string-1"></a><p>Returns the character sequence represented by a <code>text</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#text/1">text/1</a>.</p>
  </section>
</section>
<section class="detail" id="tree/1">

  <div class="detail-header">
    <a href="#tree/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">tree(Type::atom()) -&gt;  tree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>tree(atom()) -> <a href="#t:tree/0">tree</a>().</pre>

      </div>

<a id="tree-1"></a><p>Equivalent to <a href="erl_syntax.html#tree/2">tree(Type, [])</a>.</p>
  </section>
</section>
<section class="detail" id="tree/2">

  <div class="detail-header">
    <a href="#tree/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">tree(Type::atom(), Data::term()) -&gt;  tree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>tree(atom(), term()) -> <a href="#t:tree/0">tree</a>().</pre>

      </div>

<a id="tree-2"></a><p><em>For special purposes only</em>. Creates an abstract syntax tree node with type tag <code>Type</code> and associated data <code>Data</code>.</p><p>This function and the related <a href="erl_syntax.html#is_tree/1">is_tree/1</a> and <a href="erl_syntax.html#data/1">data/1</a> provide a uniform way to extend the set of <code>erl_parse</code> node types. The associated data is any term, whose format may depend on the type tag.</p><p><a id="Notes:"></a><em>Notes:</em></p><ul><li><p>Any nodes created outside of this module must have type tags distinct from those currently defined by this module; see <a href="erl_syntax.html#type/1">type/1</a> for a complete list.</p></li><li><p>The type tag of a syntax tree node may also be used as a primary tag by the <code>erl_parse</code> representation; in that case, the selector functions for that node type <em>must</em> handle both the abstract syntax tree and the <code>erl_parse</code> form. The function <code>type(T)</code> should return the correct type tag regardless of the representation of <code>T</code>, so that the user sees no difference between <code>erl_syntax</code> and <code>erl_parse</code> nodes.</p></li></ul><p></p><p><em>See also:</em> <a href="erl_syntax.html#data/1">data/1</a>, <a href="erl_syntax.html#is_tree/1">is_tree/1</a>, <a href="erl_syntax.html#type/1">type/1</a>.</p>
  </section>
</section>
<section class="detail" id="try_after_expr/2">

  <div class="detail-header">
    <a href="#try_after_expr/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">try_after_expr(Body::[ syntaxTree() ], After::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>try_after_expr([syntaxTree()], [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="try_after_expr-2"></a><p>Equivalent to <a href="erl_syntax.html#try_expr/4">try_expr(Body, [], [], After)</a>.</p>
  </section>
</section>
<section class="detail" id="try_expr/2">

  <div class="detail-header">
    <a href="#try_expr/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">try_expr(Body::[ syntaxTree() ], Handlers::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>try_expr([syntaxTree()], [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="try_expr-2"></a><p>Equivalent to <a href="erl_syntax.html#try_expr/3">try_expr(Body, [], Handlers)</a>.</p>
  </section>
</section>
<section class="detail" id="try_expr/3">

  <div class="detail-header">
    <a href="#try_expr/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">try_expr(Body::[ syntaxTree() ], Clauses::[ syntaxTree() ], Handlers::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>try_expr([syntaxTree()], [syntaxTree()], [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="try_expr-3"></a><p>Equivalent to <a href="erl_syntax.html#try_expr/4">try_expr(Body, Clauses, Handlers, [])</a>.</p>
  </section>
</section>
<section class="detail" id="try_expr/4">

  <div class="detail-header">
    <a href="#try_expr/4" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">try_expr(Body::[ syntaxTree() ], Clauses::[ syntaxTree() ], Handlers::[ syntaxTree() ], After::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>try_expr([syntaxTree()], [syntaxTree()], [syntaxTree()], [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="try_expr-4"></a><p>Creates an abstract try-expression. If <code>Body</code> is <code>[B1, ..., Bn]</code>, <code>Clauses</code> is <code>[C1, ..., Cj]</code>, <code>Handlers</code> is <code>[H1, ..., Hk]</code>, and <code>After</code> is <code>[A1, ..., Am]</code>, the result represents &quot;<code>try B1, ..., Bn of C1; ...; Cj catch H1; ...; Hk after A1, ..., Am end</code>&quot;. More exactly, if each <code>Ci</code> represents &quot;<code>(CPi) CGi -&gt; CBi</code>&quot;, and each <code>Hi</code> represents &quot;<code>(HPi) HGi -&gt; HBi</code>&quot;, then the result represents &quot;<code>try B1, ..., Bn of CP1 CG1 -&gt; CB1; ...; CPj CGj -&gt; CBj catch HP1 HG1 -&gt; HB1; ...; HPk HGk -&gt; HBk after A1, ..., Am end</code>&quot;; see <a href="erl_syntax.html#case_expr/2">case_expr/2</a>. If <code>Clauses</code> is the empty list, the <code>of ...</code> section is left out. If <code>After</code> is the empty list, the <code>after ...</code> section is left out. If <code>Handlers</code> is the empty list, and <code>After</code> is nonempty, the <code>catch ...</code> section is left out.</p><p><em>See also:</em> <a href="erl_syntax.html#case_expr/2">case_expr/2</a>, <a href="erl_syntax.html#class_qualifier/2">class_qualifier/2</a>, <a href="erl_syntax.html#clause/3">clause/3</a>, <a href="erl_syntax.html#try_after_expr/2">try_after_expr/2</a>, <a href="erl_syntax.html#try_expr/2">try_expr/2</a>, <a href="erl_syntax.html#try_expr/3">try_expr/3</a>, <a href="erl_syntax.html#try_expr_after/1">try_expr_after/1</a>, <a href="erl_syntax.html#try_expr_body/1">try_expr_body/1</a>, <a href="erl_syntax.html#try_expr_clauses/1">try_expr_clauses/1</a>, <a href="erl_syntax.html#try_expr_handlers/1">try_expr_handlers/1</a>.</p>
  </section>
</section>
<section class="detail" id="try_expr_after/1">

  <div class="detail-header">
    <a href="#try_expr_after/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">try_expr_after(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>try_expr_after(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="try_expr_after-1"></a><p>Returns the list of &quot;after&quot; subtrees of a <code>try_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#try_expr/4">try_expr/4</a>.</p>
  </section>
</section>
<section class="detail" id="try_expr_body/1">

  <div class="detail-header">
    <a href="#try_expr_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">try_expr_body(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>try_expr_body(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="try_expr_body-1"></a><p>Returns the list of body subtrees of a <code>try_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#try_expr/4">try_expr/4</a>.</p>
  </section>
</section>
<section class="detail" id="try_expr_clauses/1">

  <div class="detail-header">
    <a href="#try_expr_clauses/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">try_expr_clauses(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>try_expr_clauses(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="try_expr_clauses-1"></a><p>Returns the list of case-clause subtrees of a <code>try_expr</code> node. If <code>Node</code> represents &quot;<code>try Body catch H1; ...; Hn end</code>&quot;, the result is the empty list.</p><p><em>See also:</em> <a href="erl_syntax.html#try_expr/4">try_expr/4</a>.</p>
  </section>
</section>
<section class="detail" id="try_expr_handlers/1">

  <div class="detail-header">
    <a href="#try_expr_handlers/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">try_expr_handlers(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>try_expr_handlers(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="try_expr_handlers-1"></a><p>Returns the list of handler-clause subtrees of a <code>try_expr</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#try_expr/4">try_expr/4</a>.</p>
  </section>
</section>
<section class="detail" id="tuple/1">

  <div class="detail-header">
    <a href="#tuple/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">tuple(List::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>tuple([syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="tuple-1"></a><p>Creates an abstract tuple. If <code>Elements</code> is <code>[X1, ..., Xn]</code>, the result represents &quot;<code>{X1, ..., Xn}</code>&quot;.</p><p>Note: The Erlang language has distinct 1-tuples, i.e., <code>{X}</code> is always distinct from <code>X</code> itself.</p><p><em>See also:</em> <a href="erl_syntax.html#tuple_elements/1">tuple_elements/1</a>, <a href="erl_syntax.html#tuple_size/1">tuple_size/1</a>.</p>
  </section>
</section>
<section class="detail" id="tuple_elements/1">

  <div class="detail-header">
    <a href="#tuple_elements/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">tuple_elements(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>tuple_elements(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="tuple_elements-1"></a><p>Returns the list of element subtrees of a <code>tuple</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#tuple/1">tuple/1</a>.</p>
  </section>
</section>
<section class="detail" id="tuple_size/1">

  <div class="detail-header">
    <a href="#tuple_size/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">tuple_size(Node:: syntaxTree() ) -&gt; non_neg_integer()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>tuple_size(syntaxTree()) -> non_neg_integer().</pre>

      </div>

<a id="tuple_size-1"></a><p>Returns the number of elements of a <code>tuple</code> node.</p><p>Note: this is equivalent to <code>length(tuple_elements(Node))</code>, but potentially more efficient.</p><p><em>See also:</em> <a href="erl_syntax.html#tuple/1">tuple/1</a>, <a href="erl_syntax.html#tuple_elements/1">tuple_elements/1</a>.</p>
  </section>
</section>
<section class="detail" id="tuple_type/0">

  <div class="detail-header">
    <a href="#tuple_type/0" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">tuple_type() -&gt; term()
</h1>


  </div>

  <section class="docstring">

<a id="tuple_type-0"></a><p>Equivalent to <a href="erl_syntax.html#tuple_type/1">tuple_type(any_size)</a>.</p>
  </section>
</section>
<section class="detail" id="tuple_type/1">

  <div class="detail-header">
    <a href="#tuple_type/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">tuple_type(Elements::any_size | [ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>tuple_type(any_size | [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="tuple_type-1"></a><p>Creates an abstract type tuple. If <code>Elements</code> is <code>[T1, ..., Tn]</code>, the result represents &quot;<code>{T1, ..., Tn}</code>&quot;; otherwise, if <code>Elements</code> is <code>any_size</code>, it represents &quot;<code>tuple()</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#tuple_type_elements/1">tuple_type_elements/1</a>.</p>
  </section>
</section>
<section class="detail" id="tuple_type_elements/1">

  <div class="detail-header">
    <a href="#tuple_type_elements/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">tuple_type_elements(Node:: syntaxTree() ) -&gt; any_size | [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>tuple_type_elements(syntaxTree()) -> any_size | [syntaxTree()].</pre>

      </div>

<a id="tuple_type_elements-1"></a><p>Returns the list of type element subtrees of a <code>tuple_type</code> node. If <code>Node</code> represents &quot;<code>tuple()</code>&quot;, <code>any_size</code> is returned; otherwise, if <code>Node</code> represents &quot;<code>{T1, ..., Tn}</code>&quot;, <code>[T1, ..., Tn]</code> is returned.</p><p><em>See also:</em> <a href="erl_syntax.html#tuple_type/0">tuple_type/0</a>, <a href="erl_syntax.html#tuple_type/1">tuple_type/1</a>.</p>
  </section>
</section>
<section class="detail" id="type/1">

  <div class="detail-header">
    <a href="#type/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">type(Tree:: syntaxTree() ) -&gt; atom()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>type(syntaxTree()) -> atom().</pre>

      </div>

<a id="type-1"></a><p>Returns the type tag of <code>Node</code>. If <code>Node</code> does not represent a syntax tree, evaluation fails with reason <code>badarg</code>. Node types currently defined by this module are:</p><p>application annotated_type arity_qualifier atom<br/>attribute binary binary_field bitstring_type<br/>block_expr case_expr catch_expr char<br/>class_qualifier clause comment conjunction<br/>constrained_function_type constraint disjunction eof_marker<br/>error_marker float form_list fun_expr<br/>fun_type function function_type generator<br/>if_expr implicit_fun infix_expr integer<br/>integer_range_type list list_comp macro<br/>map_expr map_field_assoc map_field_exact map_type<br/>map_type_assoc map_type_exact match_expr module_qualifier<br/>named_fun_expr nil operator parentheses<br/>prefix_expr receive_expr record_access record_expr<br/>record_field record_index_expr record_type record_type_field<br/>size_qualifier string text try_expr<br/>tuple tuple_type typed_record_field type_application<br/>type_union underscore user_type_application variable<br/>warning_marker<br/></p><p>The user may (for special purposes) create additional nodes with other type tags, using the <a href="erl_syntax.html#tree/2">tree/2</a> function.</p><p>Note: The primary constructor functions for a node type should always have the same name as the node type itself.</p><p><em>See also:</em> <a href="erl_syntax.html#annotated_type/2">annotated_type/2</a>, <a href="erl_syntax.html#application/3">application/3</a>, <a href="erl_syntax.html#arity_qualifier/2">arity_qualifier/2</a>, <a href="erl_syntax.html#atom/1">atom/1</a>, <a href="erl_syntax.html#attribute/2">attribute/2</a>, <a href="erl_syntax.html#binary/1">binary/1</a>, <a href="erl_syntax.html#binary_field/2">binary_field/2</a>, <a href="erl_syntax.html#bitstring_type/2">bitstring_type/2</a>, <a href="erl_syntax.html#block_expr/1">block_expr/1</a>, <a href="erl_syntax.html#case_expr/2">case_expr/2</a>, <a href="erl_syntax.html#catch_expr/1">catch_expr/1</a>, <a href="erl_syntax.html#char/1">char/1</a>, <a href="erl_syntax.html#class_qualifier/2">class_qualifier/2</a>, <a href="erl_syntax.html#clause/3">clause/3</a>, <a href="erl_syntax.html#comment/2">comment/2</a>, <a href="erl_syntax.html#conjunction/1">conjunction/1</a>, <a href="erl_syntax.html#constrained_function_type/2">constrained_function_type/2</a>, <a href="erl_syntax.html#constraint/2">constraint/2</a>, <a href="erl_syntax.html#disjunction/1">disjunction/1</a>, <a href="erl_syntax.html#eof_marker/0">eof_marker/0</a>, <a href="erl_syntax.html#error_marker/1">error_marker/1</a>, <a href="erl_syntax.html#float/1">float/1</a>, <a href="erl_syntax.html#form_list/1">form_list/1</a>, <a href="erl_syntax.html#fun_expr/1">fun_expr/1</a>, <a href="erl_syntax.html#fun_type/0">fun_type/0</a>, <a href="erl_syntax.html#function/2">function/2</a>, <a href="erl_syntax.html#function_type/1">function_type/1</a>, <a href="erl_syntax.html#function_type/2">function_type/2</a>, <a href="erl_syntax.html#generator/2">generator/2</a>, <a href="erl_syntax.html#if_expr/1">if_expr/1</a>, <a href="erl_syntax.html#implicit_fun/2">implicit_fun/2</a>, <a href="erl_syntax.html#infix_expr/3">infix_expr/3</a>, <a href="erl_syntax.html#integer/1">integer/1</a>, <a href="erl_syntax.html#integer_range_type/2">integer_range_type/2</a>, <a href="erl_syntax.html#list/2">list/2</a>, <a href="erl_syntax.html#list_comp/2">list_comp/2</a>, <a href="erl_syntax.html#macro/2">macro/2</a>, <a href="erl_syntax.html#map_expr/2">map_expr/2</a>, <a href="erl_syntax.html#map_field_assoc/2">map_field_assoc/2</a>, <a href="erl_syntax.html#map_field_exact/2">map_field_exact/2</a>, <a href="erl_syntax.html#map_type/0">map_type/0</a>, <a href="erl_syntax.html#map_type/1">map_type/1</a>, <a href="erl_syntax.html#map_type_assoc/2">map_type_assoc/2</a>, <a href="erl_syntax.html#map_type_exact/2">map_type_exact/2</a>, <a href="erl_syntax.html#match_expr/2">match_expr/2</a>, <a href="erl_syntax.html#module_qualifier/2">module_qualifier/2</a>, <a href="erl_syntax.html#named_fun_expr/2">named_fun_expr/2</a>, <a href="erl_syntax.html#/0">nil/0</a>, <a href="erl_syntax.html#operator/1">operator/1</a>, <a href="erl_syntax.html#parentheses/1">parentheses/1</a>, <a href="erl_syntax.html#prefix_expr/2">prefix_expr/2</a>, <a href="erl_syntax.html#receive_expr/3">receive_expr/3</a>, <a href="erl_syntax.html#record_access/3">record_access/3</a>, <a href="erl_syntax.html#record_expr/2">record_expr/2</a>, <a href="erl_syntax.html#record_field/2">record_field/2</a>, <a href="erl_syntax.html#record_index_expr/2">record_index_expr/2</a>, <a href="erl_syntax.html#record_type/2">record_type/2</a>, <a href="erl_syntax.html#record_type_field/2">record_type_field/2</a>, <a href="erl_syntax.html#size_qualifier/2">size_qualifier/2</a>, <a href="erl_syntax.html#string/1">string/1</a>, <a href="erl_syntax.html#text/1">text/1</a>, <a href="erl_syntax.html#tree/2">tree/2</a>, <a href="erl_syntax.html#try_expr/3">try_expr/3</a>, <a href="erl_syntax.html#tuple/1">tuple/1</a>, <a href="erl_syntax.html#tuple_type/0">tuple_type/0</a>, <a href="erl_syntax.html#tuple_type/1">tuple_type/1</a>, <a href="erl_syntax.html#type_application/2">type_application/2</a>, <a href="erl_syntax.html#type_union/1">type_union/1</a>, <a href="erl_syntax.html#typed_record_field/2">typed_record_field/2</a>, <a href="erl_syntax.html#underscore/0">underscore/0</a>, <a href="erl_syntax.html#user_type_application/2">user_type_application/2</a>, <a href="erl_syntax.html#variable/1">variable/1</a>, <a href="erl_syntax.html#warning_marker/1">warning_marker/1</a>.</p>
  </section>
</section>
<section class="detail" id="type_application/2">

  <div class="detail-header">
    <a href="#type_application/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">type_application(TypeName:: syntaxTree() , Arguments::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>type_application(syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="type_application-2"></a><p>Creates an abstract type application expression. If <code>Arguments</code> is <code>[T1, ..., Tn]</code>, the result represents &quot;<code>TypeName(T1, ...Tn)</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#type_application/3">type_application/3</a>, <a href="erl_syntax.html#type_application_arguments/1">type_application_arguments/1</a>, <a href="erl_syntax.html#type_application_name/1">type_application_name/1</a>, <a href="erl_syntax.html#user_type_application/2">user_type_application/2</a>.</p>
  </section>
</section>
<section class="detail" id="type_application/3">

  <div class="detail-header">
    <a href="#type_application/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">type_application(Module::none |  syntaxTree() , TypeName:: syntaxTree() , Arguments::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>type_application(none | syntaxTree(), syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="type_application-3"></a><p>Creates an abstract type application expression. If <code>Module</code> is <code>none</code>, this is call is equivalent to <code>type_application(TypeName, Arguments)</code>, otherwise it is equivalent to <code>type_application(module_qualifier(Module, TypeName), Arguments)</code>.</p><p>(This is a utility function.)</p><p><em>See also:</em> <a href="erl_syntax.html#module_qualifier/2">module_qualifier/2</a>, <a href="erl_syntax.html#type_application/2">type_application/2</a>.</p>
  </section>
</section>
<section class="detail" id="type_application_arguments/1">

  <div class="detail-header">
    <a href="#type_application_arguments/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">type_application_arguments(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>type_application_arguments(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="type_application_arguments-1"></a><p>Returns the arguments subtrees of a <code>type_application</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#type_application/2">type_application/2</a>.</p>
  </section>
</section>
<section class="detail" id="type_application_name/1">

  <div class="detail-header">
    <a href="#type_application_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">type_application_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>type_application_name(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="type_application_name-1"></a><p>Returns the type name subtree of a <code>type_application</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#type_application/2">type_application/2</a>.</p>
  </section>
</section>
<section class="detail" id="type_union/1">

  <div class="detail-header">
    <a href="#type_union/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">type_union(Types::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>type_union([syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="type_union-1"></a><p>Creates an abstract type union. If <code>Types</code> is <code>[T1, ..., Tn]</code>, the result represents &quot;<code>T1 | ... | Tn</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#type_union_types/1">type_union_types/1</a>.</p>
  </section>
</section>
<section class="detail" id="type_union_types/1">

  <div class="detail-header">
    <a href="#type_union_types/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">type_union_types(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>type_union_types(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="type_union_types-1"></a><p>Returns the list of type subtrees of a <code>type_union</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#type_union/1">type_union/1</a>.</p>
  </section>
</section>
<section class="detail" id="typed_record_field/2">

  <div class="detail-header">
    <a href="#typed_record_field/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">typed_record_field(Field:: syntaxTree() , Type:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>typed_record_field(syntaxTree(), syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="typed_record_field-2"></a><p>Creates an abstract typed record field specification. The result represents &quot;<code>Field :: Type</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#typed_record_field_body/1">typed_record_field_body/1</a>, <a href="erl_syntax.html#typed_record_field_type/1">typed_record_field_type/1</a>.</p>
  </section>
</section>
<section class="detail" id="typed_record_field_body/1">

  <div class="detail-header">
    <a href="#typed_record_field_body/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">typed_record_field_body(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>typed_record_field_body(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="typed_record_field_body-1"></a><p>Returns the field subtree of a <code>typed_record_field</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#typed_record_field/2">typed_record_field/2</a>.</p>
  </section>
</section>
<section class="detail" id="typed_record_field_type/1">

  <div class="detail-header">
    <a href="#typed_record_field_type/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">typed_record_field_type(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>typed_record_field_type(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="typed_record_field_type-1"></a><p>Returns the type subtree of a <code>typed_record_field</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#typed_record_field/2">typed_record_field/2</a>.</p>
  </section>
</section>
<section class="detail" id="underscore/0">

  <div class="detail-header">
    <a href="#underscore/0" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">underscore() -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>underscore() -> syntaxTree().</pre>

      </div>

<a id="underscore-0"></a><p>Creates an abstract universal pattern (&quot;<code>_</code>&quot;). The lexical representation is a single underscore character. Note that this is <em>not</em> a variable, lexically speaking.</p><p><em>See also:</em> <a href="erl_syntax.html#variable/1">variable/1</a>.</p>
  </section>
</section>
<section class="detail" id="update_tree/2">

  <div class="detail-header">
    <a href="#update_tree/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">update_tree(Node:: syntaxTree() , Groups::[[ syntaxTree() ]]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>update_tree(syntaxTree(), [[syntaxTree()]]) -> syntaxTree().</pre>

      </div>

<a id="update_tree-2"></a><p>Creates a syntax tree with the same type and attributes as the given tree. This is equivalent to <code>copy_attrs(Node, make_tree(type(Node), Groups))</code>.</p><p><em>See also:</em> <a href="erl_syntax.html#copy_attrs/2">copy_attrs/2</a>, <a href="erl_syntax.html#make_tree/2">make_tree/2</a>, <a href="erl_syntax.html#type/1">type/1</a>.</p>
  </section>
</section>
<section class="detail" id="user_type_application/2">

  <div class="detail-header">
    <a href="#user_type_application/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">user_type_application(TypeName:: syntaxTree() , Arguments::[ syntaxTree() ]) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>user_type_application(syntaxTree(), [syntaxTree()]) -> syntaxTree().</pre>

      </div>

<a id="user_type_application-2"></a><p>Creates an abstract user type. If <code>Arguments</code> is <code>[T1, ..., Tn]</code>, the result represents &quot;<code>TypeName(T1, ...Tn)</code>&quot;.</p><p><em>See also:</em> <a href="erl_syntax.html#type_application/2">type_application/2</a>, <a href="erl_syntax.html#user_type_application_arguments/1">user_type_application_arguments/1</a>, <a href="erl_syntax.html#user_type_application_name/1">user_type_application_name/1</a>.</p>
  </section>
</section>
<section class="detail" id="user_type_application_arguments/1">

  <div class="detail-header">
    <a href="#user_type_application_arguments/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">user_type_application_arguments(Node:: syntaxTree() ) -&gt; [ syntaxTree() ]</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>user_type_application_arguments(syntaxTree()) -> [syntaxTree()].</pre>

      </div>

<a id="user_type_application_arguments-1"></a><p>Returns the arguments subtrees of a <code>user_type_application</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#user_type_application/2">user_type_application/2</a>.</p>
  </section>
</section>
<section class="detail" id="user_type_application_name/1">

  <div class="detail-header">
    <a href="#user_type_application_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">user_type_application_name(Node:: syntaxTree() ) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>user_type_application_name(syntaxTree()) -> syntaxTree().</pre>

      </div>

<a id="user_type_application_name-1"></a><p>Returns the type name subtree of a <code>user_type_application</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#user_type_application/2">user_type_application/2</a>.</p>
  </section>
</section>
<section class="detail" id="variable/1">

  <div class="detail-header">
    <a href="#variable/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">variable(Name::atom() | string()) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>variable(atom() | string()) -> syntaxTree().</pre>

      </div>

<a id="variable-1"></a><p>Creates an abstract variable with the given name. <code>Name</code> may be any atom or string that represents a lexically valid variable name, but <em>not</em> a single underscore character; see <a href="erl_syntax.html#underscore/0">underscore/0</a>.</p><p>Note: no checking is done whether the character sequence represents a proper variable name, i.e., whether or not its first character is an uppercase Erlang character, or whether it does not contain control characters, whitespace, etc.</p><p><em>See also:</em> <a href="erl_syntax.html#underscore/0">underscore/0</a>, <a href="erl_syntax.html#variable_literal/1">variable_literal/1</a>, <a href="erl_syntax.html#variable_name/1">variable_name/1</a>.</p>
  </section>
</section>
<section class="detail" id="variable_literal/1">

  <div class="detail-header">
    <a href="#variable_literal/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">variable_literal(Node:: syntaxTree() ) -&gt; string()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>variable_literal(syntaxTree()) -> string().</pre>

      </div>

<a id="variable_literal-1"></a><p>Returns the name of a <code>variable</code> node as a string.</p><p><em>See also:</em> <a href="erl_syntax.html#variable/1">variable/1</a>.</p>
  </section>
</section>
<section class="detail" id="variable_name/1">

  <div class="detail-header">
    <a href="#variable_name/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">variable_name(Node:: syntaxTree() ) -&gt; atom()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>variable_name(syntaxTree()) -> atom().</pre>

      </div>

<a id="variable_name-1"></a><p>Returns the name of a <code>variable</code> node as an atom.</p><p><em>See also:</em> <a href="erl_syntax.html#variable/1">variable/1</a>.</p>
  </section>
</section>
<section class="detail" id="warning_marker/1">

  <div class="detail-header">
    <a href="#warning_marker/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">warning_marker(Warning::term()) -&gt;  syntaxTree()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>warning_marker(term()) -> syntaxTree().</pre>

      </div>

<a id="warning_marker-1"></a><p>Creates an abstract warning marker. The result represents an occurrence of a possible problem in the source code, with an associated Erlang I/O ErrorInfo structure given by <code>Error</code> (see module <a href="https://wojtekmach.pl/otp_docs/stdlib/io.html">io(3)</a> for details). Warning markers are regarded as source code forms, but have no defined lexical form.</p><p>Note: this is supported only for backwards compatibility with existing parsers and tools.</p><p><em>See also:</em> <a href="erl_syntax.html#eof_marker/0">eof_marker/0</a>, <a href="erl_syntax.html#error_marker/1">error_marker/1</a>, <a href="erl_syntax.html#is_form/1">is_form/1</a>, <a href="erl_syntax.html#warning_marker_info/1">warning_marker_info/1</a>.</p>
  </section>
</section>
<section class="detail" id="warning_marker_info/1">

  <div class="detail-header">
    <a href="#warning_marker_info/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">warning_marker_info(Node:: syntaxTree() ) -&gt; term()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>warning_marker_info(syntaxTree()) -> term().</pre>

      </div>

<a id="warning_marker_info-1"></a><p>Returns the ErrorInfo structure of a <code>warning_marker</code> node.</p><p><em>See also:</em> <a href="erl_syntax.html#warning_marker/1">warning_marker/1</a>.</p>
  </section>
</section>

          </div>
        </section>

      <footer class="footer">

        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.25.1) for the
            <a href="https://elixir-lang.org" title="Elixir" target="_blank">Elixir programming language</a>.
          </span>
          <span class="line">
            Designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>

            <a href="api-reference.html" title="API reference" class="line footer-button">API Reference</a>

          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button display-quick-switch">
            Go to a HexDocs package
          </button>
          <button class="line footer-button tooltips-toggle">
            <span class="tooltips-option-disable">Disable tooltips</span>
            <span class="tooltips-option-enable">Enable tooltips</span>
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
