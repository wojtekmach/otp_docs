searchNodes=[{"doc":"This module is deprecated since OTP 23. Use the module uri_string to properly handle URIs, this is the recommended module since OTP 21. DATA TYPES Type definitions that are used more than once in this module: boolean() = true | false string() = list of ASCII characters URI DATA TYPES Type definitions that are related to URI: uri() = string() | binary() Syntax according to the URI definition in RFC 3986, for example, &quot;http://www.erlang.org/&quot; user_info() = string() | binary() scheme() = atom() Example: http, https host() = string() | binary() port() = inet:port_number() path() = string() | binary() Represents a file path or directory path query() = string() | binary() fragment() = string() | binary() For more information about URI, see RFC 3986 .","ref":"http_uri.html","title":"http_uri","type":"module"},{"doc":"HexEncodedURI = string() | binary() - A possibly hexadecimal encoded URI URI = uri() Decodes a possibly hexadecimal encoded URI.","ref":"http_uri.html#decode/1","title":"http_uri.decode/1","type":"function"},{"doc":"URI = uri() HexEncodedURI = string() | binary() - Hexadecimal encoded URI Encodes a hexadecimal encoded URI.","ref":"http_uri.html#encode/1","title":"http_uri.encode/1","type":"function"},{"doc":"URI = uri() Options = [Option] Option = {ipv6_host_with_brackets, boolean()} | {scheme_defaults, scheme_defaults()} | {fragment, boolean()} | {scheme_validation_fun, fun()} Result = {Scheme, UserInfo, Host, Port, Path, Query} | {Scheme, UserInfo, Host, Port, Path, Query, Fragment} Scheme = scheme() UserInfo = user_info() Host = host() Port = inet:port_number() Path = path() Query = query() Fragment = fragment() Reason = term() Parses a URI. If no scheme defaults are provided, the value of the scheme_defaults function is used. When parsing a URI with an unknown scheme (that is, a scheme not found in the scheme defaults), a port number must be provided, otherwise the parsing fails. If the fragment option is true , the URI fragment is returned as part of the parsing result, otherwise it is ignored. Scheme validation fun is to be defined as follows: fun ( SchemeStr : : string ( ) | binary ( ) ) -&gt; valid | { error , Reason : : term ( ) } . It is called before scheme string gets converted into scheme atom and thus possible atom leak could be prevented The scheme portion of the URI gets converted into atom, meaning that atom leak may occur. Specifying a scheme validation fun is recommended unless the URI is already sanitized.","ref":"http_uri.html#parse/1","title":"http_uri.parse/1","type":"function"},{"doc":"","ref":"http_uri.html#parse/2","title":"http_uri.parse/2","type":"function"},{"doc":"SchemeDefaults = [{scheme(), default_scheme_port_number()}] default_scheme_port_number() = inet:port_number() Provides a list of the scheme and their default port numbers supported (by default) by this utility.","ref":"http_uri.html#scheme_defaults/0","title":"http_uri.scheme_defaults/0","type":"function"},{"doc":"This module provides the API to an HTTP/1.1 compatible client according to RFC 2616 . Caching is not supported. When starting the Inets application, a manager process for the default profile is started. The functions in this API that do not explicitly use a profile accesses the default profile. A profile keeps track of proxy options, cookies, and other options that can be applied to more than one request. If the scheme https is used, the SSL application must be started. When https links need to go through a proxy, the CONNECT method extension to HTTP-1.1 is used to establish a tunnel and then the connection is upgraded to TLS. However, &quot;TLS upgrade&quot; according to RFC 2817 is not supported. Pipelining is only used if the pipeline time-out is set, otherwise persistent connections without pipelining are used. That is, the client always waits for the previous response before sending the next request. Some examples are provided in the Inets User's Guide. DATA TYPES Type definitions that are used more than once in this module: boolean() = true | false string() = list of ASCII characters request_id() = reference() profile() = atom() path() = string() representing a file path or directory path ip_address() = See the inet(3) manual page in Kernel. socket_opt() = See the options used by gen_tcp(3) gen_tcp(3) and ssl(3) connect(s) HTTP DATA TYPES Type definitions related to HTTP: method() = head | get | put | post | trace | options | delete | patch request() = {url(), headers()} | {url(), headers(), content_type(), body()} url() = string() syntax according to the URI definition in RFC 3986 , for example &quot;http://www.erlang.org&quot; Please note that httpc normalizes input URIs before internal processing and special care shall be taken when the URI has percent (&quot;%&quot;) characters. A percent serves as the indicator for percent-encoded octets and it must be percent-encoded as &quot;%25&quot; for that octet to be used as data within the URI. For example, in order to send an HTTP GET request with the URI http://localhost/foo%25bar , the percent character must be percent-encoded when creating the request: httpc:request(&quot;http://localhost/foo%2525bar&quot;). status_line() = {http_version(), status_code(), reason_phrase()} http_version() = string() , for example, &quot;HTTP/1.1&quot; status_code() = integer() reason_phrase() = string() content_type() = string() headers() = [header()] header() = {field(), value()} field() = string() value() = string() body() = string() | binary() | {fun(accumulator()) -&gt; body_processing_result(), accumulator()} | {chunkify, fun(accumulator()) -&gt; body_processing_result(), accumulator()} body_processing_result() = eof | {ok, iolist(), accumulator()} accumulator() = term() filename() = string() For more information about HTTP, see RFC 2616 . SSL DATA TYPES See ssl(3) for information about SSL options ( ssloptions() ). HTTP CLIENT SERVICE START/STOP An HTTP client can be configured to start when starting the Inets application or started dynamically in runtime by calling the Inets application API inets:start(httpc, ServiceConfig) or inets:start(httpc, ServiceConfig, How) , see inets(3) . The configuration options are as follows: {profile, profile()} Name of the profile, see DATA TYPES . This option is mandatory. {data_dir, path()} Directory where the profile can save persistent data. If omitted, all cookies are treated as session cookies. The client can be stopped using inets:stop(httpc, Pid) or inets:stop(httpc, Profile) . SEE ALSO RFC 2616 , inets(3) , gen_tcp(3) , ssl(3)","ref":"httpc.html","title":"httpc","type":"module"},{"doc":"RequestId = request_id() - A unique identifier as returned by request/4 Profile = profile() | pid() When started stand_alone only the pid can be used. Cancels an asynchronous HTTP request. Notice that this does not guarantee that the request response is not delivered. Because it is asynchronous, the request can already have been completed when the cancellation arrives.","ref":"httpc.html#cancel_request/1","title":"httpc.cancel_request/1","type":"function"},{"doc":"","ref":"httpc.html#cancel_request/2","title":"httpc.cancel_request/2","type":"function"},{"doc":"Url = url() Opts = [cookie_header_opt()] Profile = profile() | pid() When started stand_alone . cookie_header_opt() = {ipv6_host_with_brackets, boolean()} Returns the cookie header that would have been sent when making a request to Url using profile Profile . If no profile is specified, the default profile is used. Option ipv6_host_with_bracket deals with how to parse IPv6 addresses. For details, see argument Options of request/[4,5] .","ref":"httpc.html#cookie_header/1","title":"httpc.cookie_header/1","type":"function"},{"doc":"","ref":"httpc.html#cookie_header/2","title":"httpc.cookie_header/2","type":"function"},{"doc":"","ref":"httpc.html#cookie_header/3","title":"httpc.cookie_header/3","type":"function"},{"doc":"OptionItems = all | [option_item()] option_item() = proxy | https_proxy | max_sessions | keep_alive_timeout | max_keep_alive_length | pipeline_timeout | max_pipeline_length | cookies | ipfamily | ip | port | socket_opts | verbose | unix_socket Profile = profile() | pid() When started stand_alone only the pid can used. Values = [{option_item(), term()}] Reason = term() Retrieves the options currently used by the client.","ref":"httpc.html#get_options/1","title":"httpc.get_options/1","type":"function"},{"doc":"","ref":"httpc.html#get_options/2","title":"httpc.get_options/2","type":"function"},{"doc":"Profile = profile() | pid() When started stand_alone only the pid can be used. Produces a list of miscellaneous information. Intended for debugging. If no profile is specified, the default profile is used.","ref":"httpc.html#info/0","title":"httpc.info/0","type":"function"},{"doc":"","ref":"httpc.html#info/1","title":"httpc.info/1","type":"function"},{"doc":"Url = url() Result = {status_line(), headers(), Body} | {status_code(), Body} | request_id() Body = string() | binary() Profile = profile() | pid() When started stand_alone only the pid can be used. Reason = term() Equivalent to httpc:request(get, {Url, []}, [], []) .","ref":"httpc.html#request/1","title":"httpc.request/1","type":"function"},{"doc":"","ref":"httpc.html#request/2","title":"httpc.request/2","type":"function"},{"doc":"Method = method() Request = request() HTTPOptions = http_options() http_options() = [http_option()] http_option() = {timeout, timeout()} | {connect_timeout, timeout()} | {ssl, ssloptions()} | {essl, ssloptions()} | {autoredirect, boolean()} | {proxy_auth, {userstring(), passwordstring()}} | {version, http_version()} | {relaxed, boolean()} timeout() = integer() &gt;= 0 | infinity Options = options() options() = [option()] option() = {sync, boolean()} | {stream, stream_to()} | {body_format, body_format()} | {full_result, boolean()} | {headers_as_is, boolean() | {socket_opts, socket_opts()} | {receiver, receiver()} | {ipv6_host_with_brackets, boolean()} stream_to() = none | self | {self, once} | filename() socket_opts() = [socket_opt()] receiver() = pid() | function()/1 | {Module, Function, Args} Module = atom() Function = atom() Args = list() body_format() = string | binary Result = {status_line(), headers(), Body} | {status_code(), Body} | request_id() Body = string() | binary() Profile = profile() | pid() When started stand_alone only the pid can be used. Reason = term() Sends an HTTP request. The function can be both synchronous and asynchronous. In the latter case, the function returns {ok, RequestId} and then the information is delivered to the receiver depending on that value. HTTP option ( http_option() ) details: timeout Time-out time for the request. The clock starts ticking when the request is sent. Time is in milliseconds. Default is infinity . connect_timeout Connection time-out time, used during the initial request, when the client is connecting to the server. Time is in milliseconds. Default is the value of option timeout . ssl This is the SSL/TLS connectin configuration option. Defaults to [] . See ssl:connect/[2,3,4] for available options. autoredirect The client automatically retrieves the information from the new URI and returns that as the result, instead of a 30X-result code. For some 30X-result codes, automatic redirect is not allowed. In these cases the 30X-result is always returned. Default is true . proxy_auth A proxy-authorization header using the provided username and password is added to the request. version Can be used to make the client act as an HTTP/1.0 client. By default this is an HTTP/1.1 client. When using HTTP/1.0 persistent connections are not used. Default is the string &quot;HTTP/1.1&quot; . relaxed If set to true , workarounds for known server deviations from the HTTP-standard are enabled. Default is false . Option ( option() ) details: sync Option for the request to be synchronous or asynchronous. Default is true . stream Streams the body of a 200 or 206 response to the calling process or to a file. When streaming to the calling process using option self , the following stream messages are sent to that process: {http, {RequestId, stream_start, Headers}}, {http, {RequestId, stream, BinBodyPart}}, and {http, {RequestId, stream_end, Headers}} . When streaming to the calling processes using option {self, once} , the first message has an extra element, that is, {http, {RequestId, stream_start, Headers, Pid}} . This is the process id to be used as an argument to httpc:stream_next/1 to trigger the next message to be sent to the calling process. Notice that chunked encoding can add headers so that there are more headers in the stream_end message than in stream_start . When streaming to a file and the request is asynchronous, the message {http, {RequestId, saved_to_file}} is sent. Default is none . body_format Defines if the body is to be delivered as a string or binary. This option is only valid for the synchronous request. Default is string . full_result Defines if a &quot;full result&quot; is to be returned to the caller (that is, the body, the headers, and the entire status line) or not (the body and the status code). Default is true . headers_as_is Defines if the headers provided by the user are to be made lower case or to be regarded as case sensitive. The HTTP standard requires them to be case insensitive. Use this feature only if there is no other way to communicate with the server or for testing purpose. When this option is used, no headers are automatically added. All necessary headers must be provided by the user. Default is false . socket_opts Socket options to be used for this request. Overrides any value set by function set_options . The validity of the options is not checked by the HTTP client they are assumed to be correct and passed on to ssl application and inet driver, which may reject them if they are not correct. Persistent connections are not supported when setting the socket_opts option. When socket_opts is not set the current implementation assumes the requests to the same host, port combination will use the same socket options. By default the socket options set by function set_options/[1,2] are used when establishing a connection. receiver Defines how the client delivers the result of an asynchronous request ( sync has the value false ). pid() Messages are sent to this process in the format {http, ReplyInfo} . function/1 Information is delivered to the receiver through calls to the provided fun Receiver(ReplyInfo) . {Module, Function, Args} Information is delivered to the receiver through calls to the callback function apply(Module, Function, [ReplyInfo | Args]) . In all of these cases, ReplyInfo has the following structure: { RequestId , saved_to_file } { RequestId , { error , Reason } } { RequestId , Result } { RequestId , stream_start , Headers } { RequestId , stream_start , Headers , HandlerPid } { RequestId , stream , BinBodyPart } { RequestId , stream_end , Headers } Default is the pid of the process calling the request function ( self() ). ipv6_host_with_brackets Defines when parsing the Host-Port part of an URI with an IPv6 address with brackets, if those brackets are to be retained ( true ) or stripped ( false ). Default is false .","ref":"httpc.html#request/4","title":"httpc.request/4","type":"function"},{"doc":"","ref":"httpc.html#request/5","title":"httpc.request/5","type":"function"},{"doc":"Profile = profile() | pid() When started stand_alone only the pid can be used. Resets (clears) the cookie database for the specified Profile . If no profile is specified the default profile is used.","ref":"httpc.html#reset_cookies/0","title":"httpc.reset_cookies/0","type":"function"},{"doc":"","ref":"httpc.html#reset_cookies/1","title":"httpc.reset_cookies/1","type":"function"},{"doc":"Options = [Option] Option = {proxy, {Proxy, NoProxy}} | {https_proxy, {Proxy, NoProxy}} | {max_sessions, MaxSessions} | {max_keep_alive_length, MaxKeepAlive} | {keep_alive_timeout, KeepAliveTimeout} | {max_pipeline_length, MaxPipeline} | {pipeline_timeout, PipelineTimeout} | {cookies, CookieMode} | {ipfamily, IpFamily} | {ip, IpAddress} | {port, Port} | {socket_opts, socket_opts()} | {verbose, VerboseMode} | {unix_socket, UnixSocket} Proxy = {Hostname, Port} Hostname = string() Example: &quot;localhost&quot; or &quot;foo.bar.se&quot; Port = integer() Example: 8080 NoProxy = [NoProxyDesc] NoProxyDesc = DomainDesc | HostName | IPDesc DomainDesc = &quot;*.Domain&quot; Example: &quot;*.ericsson.se&quot; IpDesc = string() Example: &quot;134.138&quot; or &quot;[FEDC:BA98&quot; (all IP addresses starting with 134.138 or FEDC:BA98), &quot;66.35.250.150&quot; or &quot;[2010:836B:4179::836B:4179]&quot; (a complete IP address). proxy defaults to {undefined, []} , that is, no proxy is configured and https_proxy defaults to the value of proxy . MaxSessions = integer() Maximum number of persistent connections to a host. Default is 2 . MaxKeepAlive = integer() Maximum number of outstanding requests on the same connection to a host. Default is 5 . KeepAliveTimeout = integer() If a persistent connection is idle longer than the keep_alive_timeout in milliseconds, the client closes the connection. The server can also have such a time-out but do not take that for granted. Default is 120000 (= 2 min). MaxPipeline = integer() Maximum number of outstanding requests on a pipelined connection to a host. Default is 2 . PipelineTimeout = integer() If a persistent connection is idle longer than the pipeline_timeout in milliseconds, the client closes the connection. Default is 0 , which results in pipelining not being used. CookieMode = enabled | disabled | verify If cookies are enabled, all valid cookies are automatically saved in the cookie database of the client manager. If option verify is used, function store_cookies/2 has to be called for the cookies to be saved. Default is disabled . IpFamily = inet | inet6 | local Default is inet . IpAddress = ip_address() If the host has several network interfaces, this option specifies which one to use. See gen_tcp:connect/3,4 for details. Port = integer() Local port number to use. See gen_tcp:connect/3,4 for details. socket_opts() = [socket_opt()] The options are appended to the socket options used by the client. These are the default values when a new request handler is started (for the initial connect). They are passed directly to the underlying transport ( gen_tcp or SSL ) without verification. VerboseMode = false | verbose | debug | trace Default is false . This option is used to switch on (or off) different levels of Erlang trace on the client. It is a debug feature. Profile = profile() | pid() When started stand_alone only the pid can be used. UnixSocket = path() Experimental option for sending HTTP requests over a unix domain socket. The value of unix_socket shall be the full path to a unix domain socket file with read/write permissions for the erlang process. Default is undefined . Sets options to be used for subsequent requests. If possible, the client keeps its connections alive and uses persistent connections with or without pipeline depending on configuration and current circumstances. The HTTP/1.1 specification does not provide a guideline for how many requests that are ideal to be sent on a persistent connection. This depends much on the application. A long queue of requests can cause a user-perceived delay, as earlier requests can take a long time to complete. The HTTP/1.1 specification suggests a limit of two persistent connections per server, which is the default value of option max_sessions . The current implementation assumes the requests to the same host, port combination will use the same socket options.","ref":"httpc.html#set_options/1","title":"httpc.set_options/1","type":"function"},{"doc":"","ref":"httpc.html#set_options/2","title":"httpc.set_options/2","type":"function"},{"doc":"SetCookieHeaders = headers() - where field = &quot;set-cookie&quot; Url = url() Profile = profile() | pid() When started stand_alone only the pid can be used. Saves the cookies defined in SetCookieHeaders in the client profile cookie database. Call this function if option cookies is set to verify . If no profile is specified, the default profile is used.","ref":"httpc.html#store_cookies/2","title":"httpc.store_cookies/2","type":"function"},{"doc":"","ref":"httpc.html#store_cookies/3","title":"httpc.store_cookies/3","type":"function"},{"doc":"Pid = pid() As received in the stream_start message Triggers the next message to be streamed, that is, the same behavior as active ones for sockets.","ref":"httpc.html#stream_next/1","title":"httpc.stream_next/1","type":"function"},{"doc":"Profile = profile() | pid() When started stand_alone only the pid can be used. cookies() = [cookie_stores()] cookie_stores() = {cookies, cookies()} | {session_cookies, cookies()} cookies() = [cookie()] cookie() = term() Produces a list of the entire cookie database. Intended for debugging/testing purposes. If no profile is specified, the default profile is used.","ref":"httpc.html#which_cookies/0","title":"httpc.which_cookies/0","type":"function"},{"doc":"","ref":"httpc.html#which_cookies/1","title":"httpc.which_cookies/1","type":"function"},{"doc":"Profile = profile() | pid() When started stand_alone only the pid can be used. session_info() = {[session()], [term()], [term()]} session() = term() - Internal representation of a session This function is intended for debugging only. It produces a slightly processed dump of the session database. The first list of the session information tuple will contain session information on an internal format. The last two lists of the session information tuple should always be empty if the code is working as intended. If no profile is specified, the default profile is used.","ref":"httpc.html#which_sessions/0","title":"httpc.which_sessions/0","type":"function"},{"doc":"","ref":"httpc.html#which_sessions/1","title":"httpc.which_sessions/1","type":"function"},{"doc":"An implementation of an HTTP 1.1 compliant web server, as defined in RFC 2616 . Provides web server start options, administrative functions, and an Erlang callback API. DATA TYPES Type definitions that are used more than once in this module: boolean() = true | false string() = list of ASCII characters path() = string() representing a file or a directory path ip_address() = {N1,N2,N3,N4} % IPv4 | {K1,K2,K3,K4,K5,K6,K7,K8} % IPv6 hostname() = string() representing a host, for example, &quot;foo.bar.com&quot; property() = atom() ERLANG HTTP SERVER SERVICE START/STOP A web server can be configured to start when starting the Inets application, or dynamically in runtime by calling the Inets application API inets:start(httpd, ServiceConfig) or inets:start(httpd, ServiceConfig, How) , see inets(3) . The configuration options, also called properties, are as follows: File Properties When the web server is started at application start time, the properties are to be fetched from a configuration file that can consist of a regular Erlang property list, that is, [{Option, Value}] , where Option = property() and Value = term() , followed by a full stop. If the web server is started dynamically at runtime, a file can still be specified but also the complete property list. {proplist_file, path()} If this property is defined, Inets expects to find all other properties defined in this file. The file must include all properties listed under mandatory properties. Note support for legacy configuration file with Apache syntax is dropped in OTP-23. Mandatory Properties {port, integer()} The port that the HTTP server listen to. If zero is specified as port, an arbitrary available port is picked and function httpd:info/2 can be used to determine which port was picked. {server_name, string()} The name of your server, normally a fully qualified domain name. {server_root, path()} Defines the home directory of the server, where log files, and so on, can be stored. Relative paths specified in other properties refer to this directory. {document_root, path()} Defines the top directory for the documents that are available on the HTTP server. Communication Properties {bind_address, ip_address() | hostname() | any} Default is any {profile, atom()} Used together with bind_address and port to uniquely identify a HTTP server. This can be useful in a virtualized environment, where there can be more that one server that has the same bind_address and port. If this property is not explicitly set, it is assumed that the bind_address and port uniquely identifies the HTTP server. {socket_type, ip_comm | {ip_comm, Config::proplist()} | {essl, Config::proplist()}} For ip_comm configuration options, see gen_tcp:listen/2 , some options that are used internally by httpd cannot be set. For SSL configuration options, see ssl:listen/2 . Default is ip_comm . {ipfamily, inet | inet6} Default is inet , legacy option inet6fb4 no longer makes sense and will be translated to inet. {minimum_bytes_per_second, integer()} If given, sets a minimum of bytes per second value for connections. If the value is unreached, the socket closes for that connection. The option is good for reducing the risk of &quot;slow DoS&quot; attacks. Erlang Web Server API Modules {modules, [atom()]} Defines which modules the HTTP server uses when handling requests. Default is [mod_alias, mod_auth, mod_esi, mod_actions, mod_cgi, mod_dir, mod_get, mod_head, mod_log, mod_disk_log] . Notice that some mod -modules are dependent on others, so the order cannot be entirely arbitrary. See the Inets Web Server Modules in the User's Guide for details. Limit properties {customize, atom()} A callback module to customize the inets HTTP servers behaviour see httpd_custom_api {disable_chunked_transfer_encoding_send, boolean()} Allows you to disable chunked transfer-encoding when sending a response to an HTTP/1.1 client. Default is false . {keep_alive, boolean()} Instructs the server whether to use persistent connections when the client claims to be HTTP/1.1 compliant. Default is true . {keep_alive_timeout, integer()} The number of seconds the server waits for a subsequent request from the client before closing the connection. Default is 150 . {max_body_size, integer()} Limits the size of the message body of an HTTP request. Default is no limit. {max_clients, integer()} Limits the number of simultaneous requests that can be supported. Default is 150 . {max_header_size, integer()} Limits the size of the message header of an HTTP request. Default is 10240 . {max_content_length, integer()} Maximum content-length in an incoming request, in bytes. Requests with content larger than this are answered with status 413. Default is 100000000 (100 MB). {max_uri_size, integer()} Limits the size of the HTTP request URI. Default is no limit. {max_keep_alive_request, integer()} The number of requests that a client can do on one connection. When the server has responded to the number of requests defined by max_keep_alive_requests , the server closes the connection. The server closes it even if there are queued request. Default is no limit. {max_client_body_chunk, integer()} Enforces chunking of a HTTP PUT or POST body data to be delivered to the mod_esi callback. Note this is not supported for mod_cgi. Default is no limit e.i the whole body is delivered as one entity, which could be very memory consuming. mod_esi(3) . Administrative Properties {mime_types, [{MimeType, Extension}] | path()} MimeType = string() and Extension = string() . Files delivered to the client are MIME typed according to RFC 1590. File suffixes are mapped to MIME types before file delivery. The mapping between file suffixes and MIME types can be specified as an Apache-like file or directly in the property list. Such a file can look like the following: # MIME type Extension text / html html htm text / plain asc txt Default is [{&quot;html&quot;,&quot;text/html&quot;},{&quot;htm&quot;,&quot;text/html&quot;}]. {mime_type, string()} When the server is asked to provide a document type that cannot be determined by the MIME Type Settings, the server uses this default type. {server_admin, string()} Defines the email-address of the server administrator to be included in any error messages returned by the server. {server_tokens, none|prod|major|minor|minimal|os|full|{private, string()}} Defines the look of the value of the server header. Example: Assuming the version of Inets is 5.8.1, the server header string can look as follows for the different values of server-tokens: none &quot;&quot; % A Server: header will not be generated prod &quot;inets&quot; major &quot;inets/5&quot; minor &quot;inets/5.8&quot; minimal &quot;inets/5.8.1&quot; os &quot;inets/5.8.1 (unix)&quot; full &quot;inets/5.8.1 (unix/linux) OTP/R15B&quot; {private, &quot;foo/bar&quot;} &quot;foo/bar&quot; By default, the value is as before, that is, minimal . {logger, Options::list()} Currently only one option is supported: {error, ServerID::atom()} Produces logger events on logger level error under the hierarchical logger domain: [otp, inets, httpd, ServerID, error] The built in logger formatting function produces log entries from the error reports: \#{ server_name =&gt; string ( ) protocol =&gt; internal | &#39;TCP&#39; | &#39;TLS&#39; | &#39;HTTP&#39; , transport =&gt; &quot;TCP &quot; | &quot;TLS&quot; , %% Present when protocol = &#39;HTTP&#39; uri =&gt; string ( ) , %% Present when protocol = &#39;HTTP&#39; and URI is valid peer =&gt; inet : peername ( ) , host =&gt; inet : hostname ( ) , reason =&gt; term ( ) } An example of a log entry with only default settings of logger = ERROR REPORT == == 9 - Oct - 2019 : : 09 : 33 : 27.350235 == = Server : My Server Protocol : HTTP Transport : TLS URI : / not_there Host : 127.0 . 1.1 : 80 Peer : 127.0 . 0.1 : 45253 Reason : [ { statuscode , 404 } , { description , &quot;Object Not Found&quot; } ] Using this option makes mod_log and mod_disk_log error logs redundant. Add the filter { fun logger_filters : domain / 2 , { log , equal , [ otp , inets , httpd , ServerID , error ] } to appropriate logger handler to handle the events. For example to write the error log from an httpd server with a ServerID of my_server to a file you can use the following sys.config: [ { kernel , [ { logger , [ { handler , http_error_test , logger_std_h , \#{ config =&gt; \#{ file =&gt; &quot;log/http_error.log&quot; } , filters =&gt; [ { inets_httpd , { fun logger_filters : domain / 2 , { log , equal , [ otp , inets , httpd , my_server , error ] } } } ] , filter_default =&gt; stop } } ] } ] } ] . or if you want to add it to the default logger via an API: logger : add_handler_filter ( default , inets_httpd , { fun logger_filters : domain / 2 , { log , equal , [ otp , inets , httpd , my_server , error ] } } ) . {log_format, common | combined} Defines if access logs are to be written according to the common log format or the extended common log format. The common format is one line looking like this: remotehost rfc931 authuser [date] &quot;request&quot; status bytes . Here: remotehost Remote. rfc931 The remote username of the client ( RFC 931 ). authuser The username used for authentication. [date] Date and time of the request ( RFC 1123 ). &quot;request&quot; The request line as it came from the client ( RFC 1945 ). status The HTTP status code returned to the client ( RFC 1945 ). bytes The content-length of the document transferred. The combined format is one line looking like this: remotehost rfc931 authuser [date] &quot;request&quot; status bytes &quot;referer&quot; &quot;user_agent&quot; In addition to the earlier: &quot;referer&quot; The URL the client was on before requesting the URL (if it could not be determined, a minus sign is placed in this field). &quot;user_agent&quot; The software the client claims to be using (if it could not be determined, a minus sign is placed in this field). This affects the access logs written by mod_log and mod_disk_log . {error_log_format, pretty | compact} Default is pretty . If the error log is meant to be read directly by a human, pretty is the best option. pretty has a format corresponding to: io : format ( &quot;[ ~s ] ~s , reason: ~n ~p ~n ~n &quot; , [ Date , Msg , Reason ] ) . compact has a format corresponding to: io : format ( &quot;[ ~s ] ~s , reason: ~w ~n &quot; , [ Date , Msg , Reason ] ) . This affects the error logs written by mod_log and mod_disk_log . URL Aliasing Properties - Requires mod_alias {alias, {Alias, RealName}} Alias = string() and RealName = string() . alias allows documents to be stored in the local file system instead of the document_root location. URLs with a path beginning with url-path is mapped to local files beginning with directory-filename, for example: { alias , { &quot;/image&quot; , &quot;/ftp/pub/image&quot; } } Access to http://your.server.org/image/foo.gif would refer to the file /ftp/pub/image/foo.gif. {re_write, {Re, Replacement}} Re = string() and Replacement = string() . re_write allows documents to be stored in the local file system instead of the document_root location. URLs are rewritten by re:replace/3 to produce a path in the local file-system, for example: { re_write , { &quot;^/[~]([^/]+)(.*)$&quot; , &quot;/home/\\\\1/public\\\\2&quot; } } Access to http://your.server.org/~bob/foo.gif would refer to the file /home/bob/public/foo.gif. {directory_index, [string()]} directory_index specifies a list of resources to look for if a client requests a directory using a / at the end of the directory name. file depicts the name of a file in the directory. Several files can be given, in which case the server returns the first it finds, for example: { directory_index , [ &quot;index.html&quot; , &quot;welcome.html&quot; ] } Access to http://your.server.org/docs/ would return http://your.server.org/docs/index.html or http://your.server.org/docs/welcome.html if index.html does not exist. CGI Properties - Requires mod_cgi {script_alias, {Alias, RealName}} Alias = string() and RealName = string() . Have the same behavior as property alias , except that they also mark the target directory as containing CGI scripts. URLs with a path beginning with url-path are mapped to scripts beginning with directory-filename, for example: { script_alias , { &quot;/cgi-bin/&quot; , &quot;/web/cgi-bin/&quot; } } Access to http://your.server.org/cgi-bin/foo would cause the server to run the script /web/cgi-bin/foo. {script_re_write, {Re, Replacement}} Re = string() and Replacement = string() . Have the same behavior as property re_write , except that they also mark the target directory as containing CGI scripts. URLs with a path beginning with url-path are mapped to scripts beginning with directory-filename, for example: { script_re_write , { &quot;^/cgi-bin/(\\\\d+)/&quot; , &quot;/web/\\\\1/cgi-bin/&quot; } } Access to http://your.server.org/cgi-bin/17/foo would cause the server to run the script /web/17/cgi-bin/foo. {script_nocache, boolean()} If script_nocache is set to true , the HTTP server by default adds the header fields necessary to prevent proxies from caching the page. Generally this is preferred. Default to false . {script_timeout, integer()} The time in seconds the web server waits between each chunk of data from the script. If the CGI script does not deliver any data before the timeout, the connection to the client is closed. Default is 15 . {action, {MimeType, CgiScript}} - requires mod_action MimeType = string() and CgiScript = string() . action adds an action activating a CGI script whenever a file of a certain MIME type is requested. It propagates the URL and file path of the requested document using the standard CGI PATH_INFO and PATH_TRANSLATED environment variables. Example: { action , { &quot;text/plain&quot; , &quot;/cgi-bin/log_and_deliver_text&quot; } } {script, {Method, CgiScript}} - requires mod_action Method = string() and CgiScript = string() . script adds an action activating a CGI script whenever a file is requested using a certain HTTP method. The method is either GET or POST, as defined in RFC 1945 . It propagates the URL and file path of the requested document using the standard CGI PATH_INFO and PATH_TRANSLATED environment variables. Example: { script , { &quot;PUT&quot; , &quot;/cgi-bin/put&quot; } } ESI Properties - Requires mod_esi {erl_script_alias, {URLPath, [AllowedModule]}} URLPath = string() and AllowedModule = atom() . erl_script_alias marks all URLs matching url-path as erl scheme scripts. A matching URL is mapped into a specific module and function, for example: { erl_script_alias , { &quot;/cgi-bin/example&quot; , [ httpd_example ] } } A request to http://your.server.org/cgi-bin/example/httpd_example:yahoo would refer to httpd_example:yahoo/3 or, if that does not exist, httpd_example:yahoo/2 and http://your.server.org/cgi-bin/example/other:yahoo would not be allowed to execute. {erl_script_nocache, boolean()} If erl_script_nocache is set to true , the server adds HTTP header fields preventing proxies from caching the page. This is generally a good idea for dynamic content, as the content often varies between each request. Default is false . {erl_script_timeout, integer()} If erl_script_timeout sets the time in seconds the server waits between each chunk of data to be delivered through mod_esi:deliver/2 . Default is 15 . This is only relevant for scripts that use the erl scheme. Log Properties - Requires mod_log {error_log, path()} Defines the filename of the error log file to be used to log server errors. If the filename does not begin with a slash (/), it is assumed to be relative to the server_root . {security_log, path()} Defines the filename of the access log file to be used to log security events. If the filename does not begin with a slash (/), it is assumed to be relative to the server_root . {transfer_log, path()} Defines the filename of the access log file to be used to log incoming requests. If the filename does not begin with a slash (/), it is assumed to be relative to the server_root . Disk Log Properties - Requires mod_disk_log {disk_log_format, internal | external} Defines the file format of the log files. See disk_log for details. If the internal file format is used, the log file is repaired after a crash. When a log file is repaired, data can disappear. When the external file format is used, httpd does not start if the log file is broken. Default is external . {error_disk_log, path()} Defines the filename of the ( disk_log(3) ) error log file to be used to log server errors. If the filename does not begin with a slash (/), it is assumed to be relative to the server_root . {error_disk_log_size, {MaxBytes, MaxFiles}} MaxBytes = integer() and MaxFiles = integer() . Defines the properties of the ( disk_log(3) ) error log file. This file is of type wrap log and max bytes is written to each file and max files is used before the first file is truncated and reused. {security_disk_log, path()} Defines the filename of the ( disk_log(3) ) access log file logging incoming security events, that is, authenticated requests. If the filename does not begin with a slash (/), it is assumed to be relative to the server_root . {security_disk_log_size, {MaxBytes, MaxFiles}} MaxBytes = integer() and MaxFiles = integer() . Defines the properties of the disk_log(3) access log file. This file is of type wrap log and max bytes is written to each file and max files is used before the first file is truncated and reused. {transfer_disk_log, path()} Defines the filename of the ( disk_log(3) ) access log file logging incoming requests. If the filename does not begin with a slash (/), it is assumed to be relative to the server_root . {transfer_disk_log_size, {MaxBytes, MaxFiles}} MaxBytes = integer() and MaxFiles = integer() . Defines the properties of the disk_log(3) access log file. This file is of type wrap log and max bytes is written to each file and max files is used before the first file is truncated and reused. Authentication Properties - Requires mod_auth {directory, {path(), [{property(), term()}]}} The properties for directories are as follows: {allow_from, all | [RegxpHostString]} Defines a set of hosts to be granted access to a given directory, for example: { allow_from , [ &quot;123.34.56.11&quot; , &quot;150.100.23&quot; ] } The host 123.34.56.11 and all machines on the 150.100.23 subnet are allowed access. {deny_from, all | [RegxpHostString]} Defines a set of hosts to be denied access to a given directory, for example: { deny_from , [ &quot;123.34.56.11&quot; , &quot;150.100.23&quot; ] } The host 123.34.56.11 and all machines on the 150.100.23 subnet are not allowed access. {auth_type, plain | dets | mnesia} Sets the type of authentication database that is used for the directory. The key difference between the different methods is that dynamic data can be saved when Mnesia and Dets are used. {auth_user_file, path()} Sets the name of a file containing the list of users and passwords for user authentication. The filename can be either absolute or relative to the server_root . If using the plain storage method, this file is a plain text file where each line contains a username followed by a colon, followed by the non-encrypted password. If usernames are duplicated, the behavior is undefined. Example: ragnar : s7Xxv7 edward : wwjau8 If the Dets storage method is used, the user database is maintained by Dets and must not be edited by hand. Use the API functions in module mod_auth to create/edit the user database. This directive is ignored if the Mnesia storage method is used. For security reasons, ensure that auth_user_file is stored outside the document tree of the web server. If it is placed in the directory that it protects, clients can download it. {auth_group_file, path()} Sets the name of a file containing the list of user groups for user authentication. The filename can be either absolute or relative to the server_root . If the plain storage method is used, the group file is a plain text file, where each line contains a group name followed by a colon, followed by the members usernames separated by spaces. Example: group1 : bob joe ante If the Dets storage method is used, the group database is maintained by Dets and must not be edited by hand. Use the API for module mod_auth to create/edit the group database. This directive is ignored if the Mnesia storage method is used. For security reasons, ensure that the auth_group_file is stored outside the document tree of the web server. If it is placed in the directory that it protects, clients can download it. {auth_name, string()} Sets the name of the authorization realm (auth-domain) for a directory. This string informs the client about which username and password to use. {auth_access_password, string()} If set to other than &quot;NoPassword&quot;, the password is required for all API calls. If the password is set to &quot;DummyPassword&quot;, the password must be changed before any other API calls. To secure the authenticating data, the password must be changed after the web server is started. Otherwise it is written in clear text in the configuration file. {require_user, [string()]} Defines users to grant access to a given directory using a secret password. {require_group, [string()]} Defines users to grant access to a given directory using a secret password. Security Properties - Requires mod_security {security_directory, {path(), [{property(), term()}]}} The properties for the security directories are as follows: {data_file, path()} Name of the security data file. The filename can either be absolute or relative to the server_root . This file is used to store persistent data for module mod_security . {max_retries, integer()} Specifies the maximum number of attempts to authenticate a user before the user is blocked out. If a user successfully authenticates while blocked, the user receives a 403 (Forbidden) response from the server. If the user makes a failed attempt while blocked, the server returns 401 (Unauthorized), for security reasons. Default is 3 . Can be set to infinity. {block_time, integer()} Specifies the number of minutes a user is blocked. After this time has passed, the user automatically regains access. Default is 60 . {fail_expire_time, integer()} Specifies the number of minutes a failed user authentication is remembered. If a user authenticates after this time has passed, the previous failed authentications are forgotten. Default is 30 . {auth_timeout, integer()} Specifies the number of seconds a successful user authentication is remembered. After this time has passed, the authentication is no longer reported. Default is 30 . ERLANG WEB SERVER API DATA TYPES The Erlang web server API data types are as follows: ModData = #mod{} -record(mod, { data = [], socket_type = ip_comm, socket, config_db, method, absolute_uri, request_uri, http_version, request_line, parsed_header = [], entity_body, connection }). To acess the record in your callback-module use: - include_lib ( &quot;inets/include/httpd.hrl&quot; ) . The fields of record mod have the following meaning: data Type [{InteractionKey,InteractionValue}] is used to propagate data between modules. Depicted interaction_data() in function type declarations. socket_type socket_type() indicates whether it is an IP socket or an ssl socket. socket The socket, in format ip_comm or ssl , depending on socket_type . config_db The config file directives stored as key-value tuples in an ETS table. Depicted config_db() in function type declarations. method Type &quot;GET&quot; | &quot;POST&quot; | &quot;HEAD&quot; | &quot;TRACE&quot; , that is, the HTTP method. absolute_uri If the request is an HTTP/1.1 request, the URI can be in the absolute URI format. In that case, httpd saves the absolute URI in this field. An Example of an absolute URI is &quot;http://ServerName:Part/cgi-bin/find.pl?person=jocke&quot; request_uri The Request-URI as defined in RFC 1945 , for example, &quot;/cgi-bin/find.pl?person=jocke&quot; . http_version The HTTP version of the request, that is, &quot;HTTP/1.0&quot;, or &quot;HTTP/1.1&quot;. request_line The Request-Line as defined in RFC 1945 , for example, &quot;GET /cgi-bin/find.pl?person=jocke HTTP/1.0&quot; . parsed_header Type [{HeaderKey,HeaderValue}] . parsed_header contains all HTTP header fields from the HTTP request stored in a list as key-value tuples. See RFC 2616 for a listing of all header fields. For example, the date field is stored as {&quot;date&quot;,&quot;Wed, 15 Oct 1997 14:35:17 GMT&quot;} . RFC 2616 defines that HTTP is a case-insensitive protocol and the header fields can be in lower case or upper case. httpd ensures that all header field names are in lower case. entity_body The entity-Body as defined in RFC 2616 , for example, data sent from a CGI script using the POST method. connection true | false . If set to true , the connection to the client is a persistent connection and is not closed when the request is served. SEE ALSO RFC 2616 , inets(3) , ssl(3)","ref":"httpd.html","title":"httpd","type":"module"},{"doc":"Properties = [property()] Option = property() Value = term() Fetches information about the HTTP server. When called with only the pid, all properties are fetched. When called with a list of specific properties, they are fetched. The available properties are the same as the start options of the server. Pid is the pid returned from inets:start/[2,3] . Can also be retrieved form inets:services/0 and inets:services_info/0 , see inets(3) .","ref":"httpd.html#info/1","title":"httpd.info/1","type":"function"},{"doc":"","ref":"httpd.html#info/2","title":"httpd.info/2","type":"function"},{"doc":"Address = ip_address() Port = integer() Profile = atom() Properties = [property()] Option = property() Value = term() Fetches information about the HTTP server. When called with only Address and Port , all properties are fetched. When called with a list of specific properties, they are fetched. The available properties are the same as the start options of the server. The address must be the IP address and cannot be the hostname.","ref":"httpd.html#info/2","title":"httpd.info/2","type":"function"},{"doc":"","ref":"httpd.html#info/3","title":"httpd.info/3","type":"function"},{"doc":"","ref":"httpd.html#info/4","title":"httpd.info/4","type":"function"},{"doc":"QueryString = string() Key = string() Value = string() parse_query/1 parses incoming data to erl and eval scripts (see mod_esi(3) ) as defined in the standard URL format, that is, '+' becomes 'space' and decoding of hexadecimal characters ( %xx ).","ref":"httpd.html#parse_query/1","title":"httpd.parse_query/1","type":"function"},{"doc":"Config = path() | [{Option, Value}] Option = property() Value = term() Mode = non_disturbing | disturbing Reloads the HTTP server configuration without restarting the server. Incoming requests are answered with a temporary down message during the reload time. Available properties are the same as the start options of the server, but the properties bind_address and port cannot be changed. If mode is disturbing, the server is blocked forcefully, all ongoing requests terminates, and the reload starts immediately. If mode is non-disturbing, no new connections are accepted, but ongoing requests are allowed to complete before the reload is done.","ref":"httpd.html#reload_config/2","title":"httpd.reload_config/2","type":"function"},{"doc":"This module provides the Erlang web server API module programmer with utility functions for generic sockets communication. The appropriate communication mechanism is transparently used, that is, ip_comm or ssl . SEE ALSO httpd(3)","ref":"httpd_socket.html","title":"httpd_socket","type":"module"},{"doc":"SocketType = socket_type() Socket = socket() Data = io_list() | binary() Result = socket_closed | void() deliver/3 sends Data over Socket using the specified SocketType . Socket and SocketType is to be the socket and the socket_type form the mod record as defined in httpd.hrl","ref":"httpd_socket.html#deliver/3","title":"httpd_socket.deliver/3","type":"function"},{"doc":"SocketType = socket_type() Socket = socket() Port = integer() IPAddress = string() peername/2 returns the Port and IPAddress of the remote Socket .","ref":"httpd_socket.html#peername/2","title":"httpd_socket.peername/2","type":"function"},{"doc":"HostName = string() resolve/0 returns the official HostName of the current host.","ref":"httpd_socket.html#resolve/0","title":"httpd_socket.resolve/0","type":"function"},{"doc":"This module provides the Erlang web server API module programmer with miscellaneous utility functions. SEE ALSO httpd(3)","ref":"httpd_util.html","title":"httpd_util","type":"module"},{"doc":"DateString = string() ErlDate = calendar:datetime() convert_request_date/1 converts DateString to the Erlang date format. DateString must be in one of the three date formats defined in RFC 2616 .","ref":"httpd_util.html#convert_request_date/1","title":"httpd_util.convert_request_date/1","type":"function"},{"doc":"FileInfo = file_info() Etag = string() create_etag/1 calculates the Etag for a file from its size and time for last modification. FileInfo is a record defined in kernel/include/file.hrl .","ref":"httpd_util.html#create_etag/1","title":"httpd_util.create_etag/1","type":"function"},{"doc":"NthDayOfWeek = 1-7 DayOfWeek = string() day/1 converts the day of the week ( NthDayOfWeek ) from an integer (1-7) to an abbreviated string, that is: 1 = &quot;Mon&quot;, 2 = &quot;Tue&quot;, ..., 7 = &quot;Sat&quot;.","ref":"httpd_util.html#day/1","title":"httpd_util.day/1","type":"function"},{"doc":"HexValue = DecValue = string() Converts the hexadecimal value HexValue into its decimal equivalent ( DecValue ).","ref":"httpd_util.html#decode_hex/1","title":"httpd_util.decode_hex/1","type":"function"},{"doc":"NestedList = list() Size = integer() flatlength/1 computes the size of the possibly nested list NestedList , which can contain binaries.","ref":"httpd_util.html#flatlength/1","title":"httpd_util.flatlength/1","type":"function"},{"doc":"Number = integer() HexString = string() hexlist_to_integer converts the hexadecimal value of HexString to an integer.","ref":"httpd_util.html#hexlist_to_integer/1","title":"httpd_util.hexlist_to_integer/1","type":"function"},{"doc":"Number = integer() HexString = string() integer_to_hexlist/1 returns a string representing Number in a hexadecimal form.","ref":"httpd_util.html#integer_to_hexlist/1","title":"httpd_util.integer_to_hexlist/1","type":"function"},{"doc":"ETSTable = ets_table() Key = term() Result = term() | undefined | Undefined Undefined = term() lookup extracts {Key,Value} tuples from ETSTable and returns the Value associated with Key . If ETSTable is of type bag , only the first Value associated with Key is returned. lookup/2 returns undefined and lookup/3 returns Undefined if no Value is found.","ref":"httpd_util.html#lookup/2","title":"httpd_util.lookup/2","type":"function"},{"doc":"","ref":"httpd_util.html#lookup/3","title":"httpd_util.lookup/3","type":"function"},{"doc":"ConfigDB = ets_table() Suffix = string() MimeType = string() | undefined | Undefined Undefined = term() lookup_mime returns the MIME type associated with a specific file suffix as specified in the file mime.types (located in the config directory).","ref":"httpd_util.html#lookup_mime/2","title":"httpd_util.lookup_mime/2","type":"function"},{"doc":"","ref":"httpd_util.html#lookup_mime/3","title":"httpd_util.lookup_mime/3","type":"function"},{"doc":"ConfigDB = ets_table() Suffix = string() MimeType = string() | undefined | Undefined Undefined = term() lookup_mime_default returns the MIME type associated with a specific file suffix as specified in the mime.types file (located in the config directory). If no appropriate association is found, the value of DefaultType is returned.","ref":"httpd_util.html#lookup_mime_default/2","title":"httpd_util.lookup_mime_default/2","type":"function"},{"doc":"","ref":"httpd_util.html#lookup_mime_default/3","title":"httpd_util.lookup_mime_default/3","type":"function"},{"doc":"StatusCode = 301 | 400 | 403 | 404 | 500 | 501 | 504 PhraseArgs = term() ConfigDB = ets_table Message = string() message/3 returns an informative HTTP 1.1 status string in HTML. Each StatusCode requires a specific PhraseArgs : 301 string() : A URL pointing at the new document position. 400 | 401 | 500 none (no PhraseArgs ). 403 | 404 string() : A Request-URI as described in RFC 2616 . 501 {Method,RequestURI,HTTPVersion} : The HTTP Method , Request-URI , and HTTP-Version as defined in RFC 2616. 504 string() : A string describing why the service was unavailable.","ref":"httpd_util.html#message/3","title":"httpd_util.message/3","type":"function"},{"doc":"NthMonth = 1-12 Month = string() month/1 converts the month NthMonth as an integer (1-12) to an abbreviated string, that is: 1 = &quot;Jan&quot;, 2 = &quot;Feb&quot;, ..., 12 = &quot;Dec&quot;.","ref":"httpd_util.html#month/1","title":"httpd_util.month/1","type":"function"},{"doc":"ETSTable = ets_table() Key = term() Result = [term()] multi_lookup extracts all {Key,Value} tuples from an ETSTable and returns all Values associated with Key in a list.","ref":"httpd_util.html#multi_lookup/2","title":"httpd_util.multi_lookup/2","type":"function"},{"doc":"StatusCode = 100| 200 | 201 | 202 | 204 | 205 | 206 | 300 | 301 | 302 | 303 | 304 | 400 | 401 | 402 | 403 | 404 | 405 | 406 | 410 411 | 412 | 413 | 414 415 | 416 | 417 | 500 | 501 | 502 | 503 | 504 | 505 Description = string() reason_phrase returns Description of an HTTP 1.1 StatusCode , for example, 200 is &quot;OK&quot; and 201 is &quot;Created&quot;. For more information, see RFC 2616 .","ref":"httpd_util.html#reason_phrase/1","title":"httpd_util.reason_phrase/1","type":"function"},{"doc":"Date = calendar:datetime() RFC1123Date = string() rfc1123_date/0 returns the current date in RFC 1123 format. rfc_date/1 converts the date in the Erlang format to the RFC 1123 date format.","ref":"httpd_util.html#rfc1123_date/0","title":"httpd_util.rfc1123_date/0","type":"function"},{"doc":"","ref":"httpd_util.html#rfc1123_date/1","title":"httpd_util.rfc1123_date/1","type":"function"},{"doc":"String = RegExp = string() SplitRes = {ok, FieldList} | {error, errordesc()} Fieldlist = [string()] N = integer split/3 splits String in N chunks using RegExp . split/3 is equivalent to regexp:split/2 with the exception that N defines the maximum number of fields in FieldList .","ref":"httpd_util.html#split/3","title":"httpd_util.split/3","type":"function"},{"doc":"RequestLine = Path = QueryStringOrPathInfo = string() split_path/1 splits RequestLine in a file reference ( Path ), and a QueryString or a PathInfo string as specified in RFC 2616 . A QueryString is isolated from Path with a question mark ( ? ) and PathInfo with a slash (/). In the case of a QueryString , everything before ? is a Path and everything after ? is a QueryString . In the case of a PathInfo , RequestLine is scanned from left-to-right on the hunt for longest possible Path being a file or a directory. Everything after the longest possible Path , isolated with a / , is regarded as PathInfo . The resulting Path is decoded using decode_hex/1 before delivery.","ref":"httpd_util.html#split_path/1","title":"httpd_util.split_path/1","type":"function"},{"doc":"RequestLine = string() Splitted = not_a_script | {Path, PathInfo, QueryString} Path = QueryString = PathInfo = string() split_script_path/1 is equivalent to split_path/1 with one exception. If the longest possible path is not a regular, accessible, and executable file, then not_a_script is returned.","ref":"httpd_util.html#split_script_path/1","title":"httpd_util.split_script_path/1","type":"function"},{"doc":"String = Stripped = string() strip/1 removes any leading or trailing linear white space from the string. Linear white space is to be read as horizontal tab or space.","ref":"httpd_util.html#strip/1","title":"httpd_util.strip/1","type":"function"},{"doc":"FileName = Suffix = string() suffix/1 is equivalent to filename:extension/1 with the exception that Suffix is returned without a leading dot ( . ).","ref":"httpd_util.html#suffix/1","title":"httpd_util.suffix/1","type":"function"},{"doc":"This module provides the most basic API to the clients and servers that are part of the Inets application, such as start and stop. DATA TYPES Type definitions that are used more than once in this module: service() = httpc | httpd property() = atom() SEE ALSO httpc(3) , httpd(3)","ref":"inets.html","title":"inets","type":"module"},{"doc":"Service = service() Returns a list of available service names.","ref":"inets.html#service_names/0","title":"inets.service_names/0","type":"function"},{"doc":"Service = service() Pid = pid() Returns a list of currently running services. Services started as stand_alone are not listed.","ref":"inets.html#services/0","title":"inets.services/0","type":"function"},{"doc":"Service = service() Pid = pid() Info = [{Option, Value}] Option = property() Value = term() Returns a list of currently running services where each service is described by an [{Option, Value}] list. The information in the list is specific for each service and each service has probably its own info function that gives more details about the service.","ref":"inets.html#services_info/0","title":"inets.services_info/0","type":"function"},{"doc":"Type = permanent | transient | temporary Starts the Inets application. Default type is temporary . See also application(3) .","ref":"inets.html#start/0","title":"inets.start/0","type":"function"},{"doc":"","ref":"inets.html#start/1","title":"inets.start/1","type":"function"},{"doc":"Service = service() ServiceConfig = [{Option, Value}] Option = property() Value = term() How = inets | stand_alone - default is inets. Dynamically starts an Inets service after the Inets application has been started. Dynamically started services are not handled by application takeover and failover behavior when Inets is run as a distributed application. Nor are they automatically restarted when the Inets application is restarted. As long as the Inets application is operational, they are supervised and can be soft code upgraded. A service started as stand_alone , that is, the service is not started as part of the Inets application, lose all OTP application benefits, such as soft upgrade. The stand_alone -service is linked to the process that started it. Usually some supervision functionality is still in place and in some sense the calling process becomes the top supervisor.","ref":"inets.html#start/2","title":"inets.start/2","type":"function"},{"doc":"","ref":"inets.html#start/3","title":"inets.start/3","type":"function"},{"doc":"Stops the Inets application. See also application(3) .","ref":"inets.html#stop/0","title":"inets.stop/0","type":"function"},{"doc":"Service = service() | stand_alone Reference = pid() | term() - service-specified reference Reason = term() Stops a started service of the Inets application or takes down a stand_alone -service gracefully. When option stand_alone is used in start, only the pid is a valid argument to stop.","ref":"inets.html#stop/2","title":"inets.stop/2","type":"function"},{"doc":"Erlang web server internal API for handling of, for example, interaction data exported by module mod_alias .","ref":"mod_alias.html","title":"mod_alias","type":"module"},{"doc":"ConfigDB = config_db() Path = NewPath = string() If Path is a directory, default_index/2 , it starts searching for resources or files that are specified in the config directive DirectoryIndex . If an appropriate resource or file is found, it is appended to the end of Path and then returned. Path is returned unaltered if no appropriate file is found or if Path is not a directory. config_db() is the server config file in ETS table format as described in Inets User's Guide.","ref":"mod_alias.html#default_index/2","title":"mod_alias.default_index/2","type":"function"},{"doc":"PathData = interaction_data() ConfigDB = config_db() RequestURI = Path = string() path/3 returns the file Path in the RequestURI (see RFC 1945 ). If the interaction data {real_name,{Path,AfterPath}} has been exported by mod_alias , Path is returned. If no interaction data has been exported, ServerRoot is used to generate a file Path . config_db() and interaction_data() are as defined in Inets User's Guide.","ref":"mod_alias.html#path/3","title":"mod_alias.path/3","type":"function"},{"doc":"ConfigDB = config_db() RequestURI = string() Aliases = [{FakeName,RealName}] Ret = {ShortPath,Path,AfterPath} ShortPath = Path = AfterPath = string() real_name/3 traverses Aliases , typically extracted from ConfigDB , and matches each FakeName with RequestURI . If a match is found, FakeName is replaced with RealName in the match. The resulting path is split into two parts, ShortPath and AfterPath , as defined in httpd_util:split_path/1 . Path is generated from ShortPath , that is, the result from default_index/2 with ShortPath as an argument. config_db() is the server config file in ETS table format as described in Inets User's Guide.","ref":"mod_alias.html#real_name/3","title":"mod_alias.real_name/3","type":"function"},{"doc":"ConfigDB = config_db() RequestURI = string() ScriptAliases = [{FakeName,RealName}] Ret = {ShortPath,AfterPath} | not_a_script ShortPath = AfterPath = string() real_script_name/3 traverses ScriptAliases , typically extracted from ConfigDB , and matches each FakeName with RequestURI . If a match is found, FakeName is replaced with RealName in the match. If the resulting match is not an executable script, not_a_script is returned. If it is a script, the resulting script path is in two parts, ShortPath and AfterPath , as defined in httpd_util:split_script_path/1 . config_db() is the server config file in ETS table format as described in Inets User's Guide.","ref":"mod_alias.html#real_script_name/3","title":"mod_alias.real_script_name/3","type":"function"},{"doc":"This module provides for basic user authentication using textual files, Dets databases, or Mnesia databases. SEE ALSO httpd(3) , mod_alias(3)","ref":"mod_auth.html","title":"mod_auth","type":"module"},{"doc":"GroupName = string() UserName = string() Options = [Option] Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword} Port = integer() Address = {A,B,C,D} | string() | undefined Dir = string() AuthPassword = string() Reason = term() add_group_member/3, add_group_member/4 , and add_group_member/5 each adds a user to a group. If the group does not exist, it is created and the user is added to the group. Upon successful operation, this function returns true . When add_group_members/3 is called, options Port and Dir are mandatory.","ref":"mod_auth.html#add_group_member/3","title":"mod_auth.add_group_member/3","type":"function"},{"doc":"","ref":"mod_auth.html#add_group_member/4","title":"mod_auth.add_group_member/4","type":"function"},{"doc":"","ref":"mod_auth.html#add_group_member/5","title":"mod_auth.add_group_member/5","type":"function"},{"doc":"UserName = string() Options = [Option] Option = {password,Password} | {userData,UserData} | {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword} Password = string() UserData = term() Port = integer() Address = {A,B,C,D} | string() | undefined Dir = string() AuthPassword =string() Reason = term() add_user/2, add_user/5 , and add_user/6 each adds a user to the user database. If the operation is successful, this function returns true . If an error occurs, {error,Reason} is returned. When add_user/2 is called, options Password , UserData , Port , and Dir are mandatory.","ref":"mod_auth.html#add_user/2","title":"mod_auth.add_user/2","type":"function"},{"doc":"","ref":"mod_auth.html#add_user/5","title":"mod_auth.add_user/5","type":"function"},{"doc":"","ref":"mod_auth.html#add_user/6","title":"mod_auth.add_user/6","type":"function"},{"doc":"Options = [Option] Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword} Port = integer() Address = {A,B,C,D} | string() | undefined Dir = string() GroupName = string() AuthPassword = string() Reason = term() delete_group/2, delete_group/3 , and delete_group/4 each deletes the group specified and returns true . If there is an error, {error, Reason} is returned. When delete_group/2 is called, option Port and Dir are mandatory.","ref":"mod_auth.html#delete_group/2","title":"mod_auth.delete_group/2","type":"function"},{"doc":"","ref":"mod_auth.html#delete_group/4","title":"mod_auth.delete_group/4","type":"function"},{"doc":"GroupName = string() UserName = string() Options = [Option] Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword} Port = integer() Address = {A,B,C,D} | string() | undefined Dir = string() AuthPassword = string() Reason = term() delete_group_member/3, delete_group_member/4 , and delete_group_member/5 each deletes a user from a group. If the group or the user does not exist, this function returns an error, otherwise true . When delete_group_member/3 is called, the options Port and Dir are mandatory.","ref":"mod_auth.html#delete_group_member/3","title":"mod_auth.delete_group_member/3","type":"function"},{"doc":"","ref":"mod_auth.html#delete_group_member/4","title":"mod_auth.delete_group_member/4","type":"function"},{"doc":"","ref":"mod_auth.html#delete_group_member/5","title":"mod_auth.delete_group_member/5","type":"function"},{"doc":"UserName = string() Options = [Option] Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword} Port = integer() Address = {A,B,C,D} | string() | undefined Dir = string() AuthPassword = string() Reason = term() delete_user/2, delete_user/3 , and delete_user/4 each deletes a user from the user database. If the operation is successful, this function returns true . If an error occurs, {error,Reason} is returned. When delete_user/2 is called, options Port and Dir are mandatory.","ref":"mod_auth.html#delete_user/2","title":"mod_auth.delete_user/2","type":"function"},{"doc":"","ref":"mod_auth.html#delete_user/3","title":"mod_auth.delete_user/3","type":"function"},{"doc":"","ref":"mod_auth.html#delete_user/4","title":"mod_auth.delete_user/4","type":"function"},{"doc":"UserName = string() Options = [Option] Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword} Port = integer() Address = {A,B,C,D} | string() | undefined Dir = string() AuthPassword = string() Reason = term() get_user/2, get_user/3 , and get_user/4 each returns an httpd_user record containing the userdata for a specific user. If the user cannot be found, {error, Reason} is returned. When get_user/2 is called, options Port and Dir are mandatory.","ref":"mod_auth.html#get_user/2","title":"mod_auth.get_user/2","type":"function"},{"doc":"","ref":"mod_auth.html#get_user/3","title":"mod_auth.get_user/3","type":"function"},{"doc":"","ref":"mod_auth.html#get_user/4","title":"mod_auth.get_user/4","type":"function"},{"doc":"GroupName = string() Options = [Option] Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword} Port = integer() Address = {A,B,C,D} | string() | undefined Dir = string() Users = list() AuthPassword = string() Reason = term() list_group_members/2, list_group_members/3 , and list_group_members/4 each lists the members of a specified group. If the group does not exist or there is an error, {error, Reason} is returned. When list_group_members/2 is called, options Port and Dir are mandatory.","ref":"mod_auth.html#list_group_members/2","title":"mod_auth.list_group_members/2","type":"function"},{"doc":"","ref":"mod_auth.html#list_group_members/3","title":"mod_auth.list_group_members/3","type":"function"},{"doc":"","ref":"mod_auth.html#list_group_members/4","title":"mod_auth.list_group_members/4","type":"function"},{"doc":"Options = [Option] Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword} Port = integer() Address = {A,B,C,D} | string() | undefined Dir = string() Groups = list() AuthPassword = string() Reason = term() list_groups/1, list_groups/2 , and list_groups/3 each lists all the groups available. If there is an error, {error, Reason} is returned. When list_groups/1 is called, options Port and Dir are mandatory.","ref":"mod_auth.html#list_groups/1","title":"mod_auth.list_groups/1","type":"function"},{"doc":"","ref":"mod_auth.html#list_groups/2","title":"mod_auth.list_groups/2","type":"function"},{"doc":"","ref":"mod_auth.html#list_groups/3","title":"mod_auth.list_groups/3","type":"function"},{"doc":"Options = [Option] Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword} Port = integer() Address = {A,B,C,D} | string() | undefined Dir = string() Users = list() AuthPassword = string() Reason = atom() list_users/1, list_users/2 , and list_users/3 each returns a list of users in the user database for a specific Port/Dir . When list_users/1 is called, options Port and Dir are mandatory.","ref":"mod_auth.html#list_users/1","title":"mod_auth.list_users/1","type":"function"},{"doc":"","ref":"mod_auth.html#list_users/2","title":"mod_auth.list_users/2","type":"function"},{"doc":"","ref":"mod_auth.html#list_users/3","title":"mod_auth.list_users/3","type":"function"},{"doc":"Port = integer() Address = {A,B,C,D} | string() | undefined Dir = string() GroupName = string() OldPassword = string() NewPassword = string() Reason = term() update_password/5 and update_password/6 each updates AuthAccessPassword for the specified directory. If NewPassword is equal to &quot;NoPassword&quot;, no password is required to change authorisation data. If NewPassword is equal to &quot;DummyPassword&quot;, no changes can be done without changing the password first.","ref":"mod_auth.html#update_password/5","title":"mod_auth.update_password/5","type":"function"},{"doc":"","ref":"mod_auth.html#update_password/6","title":"mod_auth.update_password/6","type":"function"},{"doc":"This module defines the Erlang Server Interface (ESI) API. It is a more efficient way of writing Erlang scripts for your Inets web server than writing them as common CGI scripts. DATA TYPES The following data types are used in the functions for mod_esi: env() = {EnvKey()::atom(), Value::term()} Currently supported key value pairs {server_software, string()} Indicates the inets version. {server_name, string()} The local hostname. {gateway_interface, string()} Legacy string used in CGI, just ignore. {server_protocol, string()} HTTP version, currently &quot;HTTP/1.1&quot; {server_port, integer()} Servers port number. {request_method, &quot;GET | &quot;PUT&quot; | &quot;DELETE&quot; | &quot;POST&quot; | &quot;PATCH&quot;} HTTP request method. {remote_adress, inet:ip_address()} The clients ip address. {peer_cert, undefined | no_peercert | DER:binary()} For TLS connections where client certificates are used this will be an ASN.1 DER-encoded X509-certificate as an Erlang binary. If client certificates are not used the value will be no_peercert , and if TLS is not used (HTTP or connection is lost due to network failure) the value will be undefined . {script_name, string()} Request URI {http_LowerCaseHTTPHeaderName, string()} example: {http_content_type, &quot;text/html&quot;}","ref":"mod_esi.html","title":"mod_esi","type":"module"},{"doc":"SessionID = term() Data = string() | io_list() | binary() Reason = term() This function is only intended to be used from functions called by the Erl Scheme interface to deliver parts of the content to the user. Sends data from an Erl Scheme script back to the client. If any HTTP header fields are added by the script, they must be in the first call to deliver/2 , and the data in the call must be a string. Calls after the headers are complete can contain binary data to reduce copying overhead. Do not assume anything about the data type of SessionID . SessionID must be the value given as input to the ESI callback function that you implemented.","ref":"mod_esi.html#deliver/2","title":"mod_esi.deliver/2","type":"function"},{"doc":"Security Audit and Trailing Functionality","ref":"mod_security.html","title":"mod_security","type":"module"},{"doc":"User = string() Port = integer() Address = {A,B,C,D} | string() | undefined Dir = string() Seconds = integer() | infinity Reason = no_such_directory block_user/4 and block_user/5 each blocks the user User from directory Dir for a specified amount of time.","ref":"mod_security.html#block_user/4","title":"mod_security.block_user/4","type":"function"},{"doc":"","ref":"mod_security.html#block_user/5","title":"mod_security.block_user/5","type":"function"},{"doc":"Port = integer() Address = {A,B,C,D} | string() | undefined Dir = string() Users = list() = [string()] list_auth_users/1 , list_auth_users/2 , and list_auth_users/3 each returns a list of users that are currently authenticated. Authentications are stored for SecurityAuthTimeout seconds, and then discarded.","ref":"mod_security.html#list_auth_users/1","title":"mod_security.list_auth_users/1","type":"function"},{"doc":"","ref":"mod_security.html#list_auth_users/2","title":"mod_security.list_auth_users/2","type":"function"},{"doc":"","ref":"mod_security.html#list_auth_users/3","title":"mod_security.list_auth_users/3","type":"function"},{"doc":"Port = integer() Address = {A,B,C,D} | string() | undefined Dir = string() Users = list() = [string()] list_blocked_users/1 , list_blocked_users/2 , and list_blocked_users/3 each returns a list of users that are currently blocked from access.","ref":"mod_security.html#list_blocked_users/1","title":"mod_security.list_blocked_users/1","type":"function"},{"doc":"","ref":"mod_security.html#list_blocked_users/2","title":"mod_security.list_blocked_users/2","type":"function"},{"doc":"","ref":"mod_security.html#list_blocked_users/3","title":"mod_security.list_blocked_users/3","type":"function"},{"doc":"User = string() Port = integer() Address = {A,B,C,D} | string() | undefined Dir = string() Reason = term() unblock_user/2 , unblock_user/3 , and unblock_user/4 each removes the user User from the list of blocked users for Port (and Dir ).","ref":"mod_security.html#unblock_user/2","title":"mod_security.unblock_user/2","type":"function"},{"doc":"","ref":"mod_security.html#unblock_user/3","title":"mod_security.unblock_user/3","type":"function"},{"doc":"","ref":"mod_security.html#unblock_user/4","title":"mod_security.unblock_user/4","type":"function"}]