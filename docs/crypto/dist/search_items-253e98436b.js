searchNodes=[{"doc":"This module provides a set of cryptographic functions. Hash functions SHA1, SHA2 Secure Hash Standard [FIPS PUB 180-4] SHA3 SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions [FIPS PUB 202] BLAKE2 BLAKE2 â€” fast secure hashing MD5 The MD5 Message Digest Algorithm [RFC 1321] MD4 The MD4 Message Digest Algorithm [RFC 1320] MACs - Message Authentication Codes Hmac functions Keyed-Hashing for Message Authentication [RFC 2104] Cmac functions The AES-CMAC Algorithm [RFC 4493] POLY1305 ChaCha20 and Poly1305 for IETF Protocols [RFC 7539] Symmetric Ciphers DES, 3DES and AES Block Cipher Techniques [NIST] Blowfish Fast Software Encryption, Cambridge Security Workshop Proceedings (December 1993), Springer-Verlag, 1994, pp. 191-204. Chacha20 ChaCha20 and Poly1305 for IETF Protocols [RFC 7539] Chacha20_poly1305 ChaCha20 and Poly1305 for IETF Protocols [RFC 7539] Modes ECB, CBC, CFB, OFB and CTR Recommendation for Block Cipher Modes of Operation: Methods and Techniques [NIST SP 800-38A] GCM Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC [NIST SP 800-38D] CCM Recommendation for Block Cipher Modes of Operation: The CCM Mode for Authentication and Confidentiality [NIST SP 800-38C] Asymetric Ciphers - Public Key Techniques RSA PKCS #1: RSA Cryptography Specifications [RFC 3447] DSS Digital Signature Standard (DSS) [FIPS 186-4] ECDSA Elliptic Curve Digital Signature Algorithm [ECDSA] SRP The SRP Authentication and Key Exchange System [RFC 2945] The actual supported algorithms and features depends on their availability in the actual libcrypto used. See the crypto (App) about dependencies. Enabling FIPS mode will also disable algorithms and features. The CRYPTO User's Guide has more information on FIPS, Engines and Algorithm Details like key lengths.","ref":"crypto.html","title":"crypto","type":"module"},{"doc":"Convert binary representation, of an integer, to an Erlang integer.","ref":"crypto.html#bytes_to_integer/1","title":"crypto.bytes_to_integer/1","type":"function"},{"doc":"Provides a map with information about block_size, key_length, iv_length, aead support and possibly other properties of the cipher algorithm in question. The ciphers aes_cbc , aes_cfb8 , aes_cfb128 , aes_ctr , aes_ecb , aes_gcm and aes_ccm has no keylength in the Type as opposed to for example aes_128_ctr . They adapt to the length of the key provided in the encrypt and decrypt function. Therefor it is impossible to return a valid keylength in the map. Always use a Type with an explicit key length, For a list of supported cipher algorithms, see supports(ciphers) .","ref":"crypto.html#cipher_info/1","title":"crypto.cipher_info/1","type":"function"},{"doc":"Computes the shared secret from the private key and the other party's public key. See also public_key:compute_key/2","ref":"crypto.html#compute_key/4","title":"crypto.compute_key/4","type":"function"},{"doc":"Initializes a series of encryptions or decryptions where the IV is provided later. The actual encryption or decryption is done by crypto_dyn_iv_update/3 . The function is equivalent to crypto_init(Cipher, Key, undefined, FlagOrOptions) .","ref":"crypto.html#crypto_dyn_iv_init/3","title":"crypto.crypto_dyn_iv_init/3","type":"function"},{"doc":"Do an actual crypto operation on a part of the full text and the IV is supplied for each part. The State should be created with crypto_dyn_iv_init/3 .","ref":"crypto.html#crypto_dyn_iv_update/3","title":"crypto.crypto_dyn_iv_update/3","type":"function"},{"doc":"Finalizes a series of encryptions or decryptions and delivers the final bytes of the final block. The data returned from this function may be empty if no padding was enabled in crypto_init/3,4 or crypto_dyn_iv_init/3 .","ref":"crypto.html#crypto_final/1","title":"crypto.crypto_final/1","type":"function"},{"doc":"Returns information about the State in the argument. The information is the form of a map, which currently contains at least: size The number of bytes encrypted or decrypted so far. padding_size After a call to crypto_final/1 it contains the number of bytes padded. Otherwise 0. padding_type The type of the padding as provided in the call ot crypto_init/3,4 . encrypt Is true if encryption is performed. It is false otherwise.","ref":"crypto.html#crypto_get_data/1","title":"crypto.crypto_get_data/1","type":"function"},{"doc":"Equivalent to the call crypto_init(Cipher, Key, &lt;&lt;&gt;&gt;, FlagOrOptions) . It is intended for ciphers without an IV (nounce).","ref":"crypto.html#crypto_init/3","title":"crypto.crypto_init/3","type":"function"},{"doc":"Initializes a series of encryptions or decryptions and creates an internal state with a reference that is returned. If IV = &lt;&lt;&gt;&gt; , no IV is used. This is intended for ciphers without an IV (nounce). See crypto_init/3 . If IV = undefined , the IV must be added by calls to crypto_dyn_iv_update/3 . This is intended for cases where the IV (nounce) need to be changed for each encryption and decryption. See crypto_dyn_iv_init/3 . The actual encryption or decryption is done by crypto_update/2 (or crypto_dyn_iv_update/3 ). For encryption, set the FlagOrOptions to true or [{encrypt,true}] . For decryption, set it to false or [{encrypt,false}] . Padding could be enabled with the option {padding,Padding} . The cryptolib_padding enables pkcs_padding or no padding ( none ). The paddings zero or random fills the last part of the last block with zeroes or random bytes. If the last block is already full, nothing is added. In decryption, the cryptolib_padding removes such padding, if present. The otp_padding is not removed - it has to be done elsewhere. If padding is {padding,none} or not specifed and the total data from all subsequent crypto_updates does not fill the last block fully, that last data is lost. In case of {padding,none} there will be an error in this case. If padding is not specified, the bytes of the unfilled block is silently discarded. The actual padding is performed by crypto_final/1 . For blocksizes call cipher_info/1 . See examples in the User's Guide.","ref":"crypto.html#crypto_init/4","title":"crypto.crypto_init/4","type":"function"},{"doc":"As crypto_one_time/5 but for ciphers without IVs.","ref":"crypto.html#crypto_one_time/4","title":"crypto.crypto_one_time/4","type":"function"},{"doc":"Do a complete encrypt or decrypt of the full text in the argument Data . For encryption, set the FlagOrOptions to true . For decryption, set it to false . For setting other options, see crypto_init/4 . See examples in the User's Guide.","ref":"crypto.html#crypto_one_time/5","title":"crypto.crypto_one_time/5","type":"function"},{"doc":"Do a complete encrypt or decrypt with an AEAD cipher of the full text. For encryption, set the EncryptFlag to true and set the TagOrTagLength to the wanted size (in bytes) of the tag, that is, the tag length. If the default length is wanted, the crypto_aead/6 form may be used. For decryption, set the EncryptFlag to false and put the tag to be checked in the argument TagOrTagLength . See examples in the User's Guide.","ref":"crypto.html#crypto_one_time_aead/6","title":"crypto.crypto_one_time_aead/6","type":"function"},{"doc":"","ref":"crypto.html#crypto_one_time_aead/7","title":"crypto.crypto_one_time_aead/7","type":"function"},{"doc":"It does an actual crypto operation on a part of the full text. If the part is less than a number of full blocks, only the full blocks (possibly none) are encrypted or decrypted and the remaining bytes are saved to the next crypto_update operation. The State should be created with crypto_init/3 or crypto_init/4 . See examples in the User's Guide.","ref":"crypto.html#crypto_update/2","title":"crypto.crypto_update/2","type":"function"},{"doc":"Return the defining parameters of a elliptic curve.","ref":"crypto.html#ec_curve/1","title":"crypto.ec_curve/1","type":"function"},{"doc":"Can be used to determine which named elliptic curves are supported.","ref":"crypto.html#ec_curves/0","title":"crypto.ec_curves/0","type":"function"},{"doc":"Enables ( Enable = true ) or disables ( Enable = false ) FIPS mode. Returns true if the operation was successful or false otherwise. Note that to enable FIPS mode succesfully, OTP must be built with the configure option --enable-fips , and the underlying libcrypto must also support FIPS. See also info_fips/0 .","ref":"crypto.html#enable_fips_mode/1","title":"crypto.enable_fips_mode/1","type":"function"},{"doc":"Add the engine to OpenSSL's internal list. The function raises a error:badarg if the parameters are in wrong format. It may also raise the exception error:notsup in case there is no engine support in the underlying OpenSSL implementation.","ref":"crypto.html#engine_add/1","title":"crypto.engine_add/1","type":"function"},{"doc":"Get a reference to an already loaded engine with EngineId . An error tuple is returned if the engine can't be unloaded. The function raises a error:badarg if the parameter is in wrong format. It may also raise the exception error:notsup in case there is no engine support in the underlying OpenSSL implementation. See also the chapter Engine Load in the User's Guide.","ref":"crypto.html#engine_by_id/1","title":"crypto.engine_by_id/1","type":"function"},{"doc":"Sends ctrl commands to the OpenSSL engine given by Engine . This function is the same as calling engine_ctrl_cmd_string/4 with Optional set to false . The function raises a error:badarg if the parameters are in wrong format. It may also raise the exception error:notsup in case there is no engine support in the underlying OpenSSL implementation.","ref":"crypto.html#engine_ctrl_cmd_string/3","title":"crypto.engine_ctrl_cmd_string/3","type":"function"},{"doc":"Sends ctrl commands to the OpenSSL engine given by Engine . Optional is a boolean argument that can relax the semantics of the function. If set to true it will only return failure if the ENGINE supported the given command name but failed while executing it, if the ENGINE doesn't support the command name it will simply return success without doing anything. In this case we assume the user is only supplying commands specific to the given ENGINE so we set this to false . The function raises a error:badarg if the parameters are in wrong format. It may also raise the exception error:notsup in case there is no engine support in the underlying OpenSSL implementation.","ref":"crypto.html#engine_ctrl_cmd_string/4","title":"crypto.engine_ctrl_cmd_string/4","type":"function"},{"doc":"Returns a list of all possible engine methods. May raise exception error:notsup in case there is no engine support in the underlying OpenSSL implementation. See also the chapter Engine Load in the User's Guide.","ref":"crypto.html#engine_get_all_methods/0","title":"crypto.engine_get_all_methods/0","type":"function"},{"doc":"Return the ID for the engine, or an empty binary if there is no id set. The function raises a error:badarg if the parameters are in wrong format. It may also raise the exception error:notsup in case there is no engine support in the underlying OpenSSL implementation.","ref":"crypto.html#engine_get_id/1","title":"crypto.engine_get_id/1","type":"function"},{"doc":"Return the name (eg a description) for the engine, or an empty binary if there is no name set. The function raises a error:badarg if the parameters are in wrong format. It may also raise the exception error:notsup in case there is no engine support in the underlying OpenSSL implementation.","ref":"crypto.html#engine_get_name/1","title":"crypto.engine_get_name/1","type":"function"},{"doc":"List the id's of all engines in OpenSSL's internal list. It may also raise the exception error:notsup in case there is no engine support in the underlying OpenSSL implementation. See also the chapter Engine Load in the User's Guide. May raise exception error:notsup in case engine functionality is not supported by the underlying OpenSSL implementation.","ref":"crypto.html#engine_list/0","title":"crypto.engine_list/0","type":"function"},{"doc":"Loads the OpenSSL engine given by EngineId if it is available and then returns ok and an engine handle. This function is the same as calling engine_load/4 with EngineMethods set to a list of all the possible methods. An error tuple is returned if the engine can't be loaded. The function raises a error:badarg if the parameters are in wrong format. It may also raise the exception error:notsup in case there is no engine support in the underlying OpenSSL implementation. See also the chapter Engine Load in the User's Guide.","ref":"crypto.html#engine_load/3","title":"crypto.engine_load/3","type":"function"},{"doc":"Loads the OpenSSL engine given by EngineId if it is available and then returns ok and an engine handle. An error tuple is returned if the engine can't be loaded. The function raises a error:badarg if the parameters are in wrong format. It may also raise the exception error:notsup in case there is no engine support in the underlying OpenSSL implementation. See also the chapter Engine Load in the User's Guide.","ref":"crypto.html#engine_load/4","title":"crypto.engine_load/4","type":"function"},{"doc":"Remove the engine from OpenSSL's internal list. The function raises a error:badarg if the parameters are in wrong format. It may also raise the exception error:notsup in case there is no engine support in the underlying OpenSSL implementation.","ref":"crypto.html#engine_remove/1","title":"crypto.engine_remove/1","type":"function"},{"doc":"Unloads the OpenSSL engine given by Engine . An error tuple is returned if the engine can't be unloaded. The function raises a error:badarg if the parameter is in wrong format. It may also raise the exception error:notsup in case there is no engine support in the underlying OpenSSL implementation. See also the chapter Engine Load in the User's Guide.","ref":"crypto.html#engine_unload/1","title":"crypto.engine_unload/1","type":"function"},{"doc":"Loads the OpenSSL engine given by EngineId and the path to the dynamic library implementing the engine. This function is the same as calling ensure_engine_loaded/3 with EngineMethods set to a list of all the possible methods. An error tuple is returned if the engine can't be loaded. The function raises a error:badarg if the parameters are in wrong format. It may also raise the exception error:notsup in case there is no engine support in the underlying OpenSSL implementation. See also the chapter Engine Load in the User's Guide.","ref":"crypto.html#ensure_engine_loaded/2","title":"crypto.ensure_engine_loaded/2","type":"function"},{"doc":"Loads the OpenSSL engine given by EngineId and the path to the dynamic library implementing the engine. This function differs from the normal engine_load in that sense it also add the engine id to the internal list in OpenSSL. Then in the following calls to the function it just fetch the reference to the engine instead of loading it again. An error tuple is returned if the engine can't be loaded. The function raises a error:badarg if the parameters are in wrong format. It may also raise the exception error:notsup in case there is no engine support in the underlying OpenSSL implementation. See also the chapter Engine Load in the User's Guide.","ref":"crypto.html#ensure_engine_loaded/3","title":"crypto.ensure_engine_loaded/3","type":"function"},{"doc":"Unloads an engine loaded with the ensure_engine_loaded function. It both removes the label from the OpenSSL internal engine list and unloads the engine. This function is the same as calling ensure_engine_unloaded/2 with EngineMethods set to a list of all the possible methods. An error tuple is returned if the engine can't be unloaded. The function raises a error:badarg if the parameters are in wrong format. It may also raise the exception error:notsup in case there is no engine support in the underlying OpenSSL implementation. See also the chapter Engine Load in the User's Guide.","ref":"crypto.html#ensure_engine_unloaded/1","title":"crypto.ensure_engine_unloaded/1","type":"function"},{"doc":"Unloads an engine loaded with the ensure_engine_loaded function. It both removes the label from the OpenSSL internal engine list and unloads the engine. An error tuple is returned if the engine can't be unloaded. The function raises a error:badarg if the parameters are in wrong format. It may also raise the exception error:notsup in case there is no engine support in the underlying OpenSSL implementation. See also the chapter Engine Load in the User's Guide.","ref":"crypto.html#ensure_engine_unloaded/2","title":"crypto.ensure_engine_unloaded/2","type":"function"},{"doc":"Performs bit-wise XOR (exclusive or) on the data supplied.","ref":"crypto.html#exor/2","title":"crypto.exor/2","type":"function"},{"doc":"Generates a public key of type Type . See also public_key:generate_key/1 . May raise exception: error:badarg : an argument is of wrong type or has an illegal value, error:low_entropy : the random generator failed due to lack of secure &quot;randomness&quot;, error:computation_failed : the computation fails of another reason than low_entropy . RSA key generation is only available if the runtime was built with dirty scheduler support. Otherwise, attempting to generate an RSA key will raise exception error:notsup .","ref":"crypto.html#generate_key/2","title":"crypto.generate_key/2","type":"function"},{"doc":"","ref":"crypto.html#generate_key/3","title":"crypto.generate_key/3","type":"function"},{"doc":"Computes a message digest of type Type from Data . May raise exception error:notsup in case the chosen Type is not supported by the underlying libcrypto implementation.","ref":"crypto.html#hash/2","title":"crypto.hash/2","type":"function"},{"doc":"Constant time memory comparison for fixed length binaries, such as results of HMAC computations. Returns true if the binaries are identical, false if they are of the same length but not identical. The function raises an error:badarg exception if the binaries are of different size.","ref":"crypto.html#hash_equals/2","title":"crypto.hash_equals/2","type":"function"},{"doc":"Finalizes the hash operation referenced by Context returned from a previous call to hash_update . The size of Digest is determined by the type of hash function used to generate it.","ref":"crypto.html#hash_final/1","title":"crypto.hash_final/1","type":"function"},{"doc":"Provides a map with information about block_size, size and possibly other properties of the hash algorithm in question. For a list of supported hash algorithms, see supports(hashs) .","ref":"crypto.html#hash_info/1","title":"crypto.hash_info/1","type":"function"},{"doc":"Initializes the context for streaming hash operations. Type determines which digest to use. The returned context should be used as argument to hash_update . May raise exception error:notsup in case the chosen Type is not supported by the underlying libcrypto implementation.","ref":"crypto.html#hash_init/1","title":"crypto.hash_init/1","type":"function"},{"doc":"Updates the digest represented by Context using the given Data . Context must have been generated using hash_init or a previous call to this function. Data can be any length. NewContext must be passed into the next call to hash_update or hash_final .","ref":"crypto.html#hash_update/2","title":"crypto.hash_update/2","type":"function"},{"doc":"Provides information about the FIPS operating status of crypto and the underlying libcrypto library. If crypto was built with FIPS support this can be either enabled (when running in FIPS mode) or not_enabled . For other builds this value is always not_supported . See enable_fips_mode/1 about how to enable FIPS mode. In FIPS mode all non-FIPS compliant algorithms are disabled and raise exception error:notsup . Check supports(ciphers) that in FIPS mode returns the restricted list of available algorithms.","ref":"crypto.html#info_fips/0","title":"crypto.info_fips/0","type":"function"},{"doc":"Provides the name and version of the libraries used by crypto. Name is the name of the library. VerNum is the numeric version according to the library's own versioning scheme. VerStr contains a text variant of the version. &gt; info_lib ( ) . [ { &lt;&lt; &quot;OpenSSL&quot; &gt;&gt; , 269484095 , &lt;&lt; &quot;OpenSSL 1.1.0c 10 Nov 2016&quot; &quot; &gt;&gt; } ] From OTP R16 the numeric version represents the version of the OpenSSL header files ( openssl/opensslv.h ) used when crypto was compiled. The text variant represents the libcrypto library used at runtime. In earlier OTP versions both numeric and text was taken from the library.","ref":"crypto.html#info_lib/0","title":"crypto.info_lib/0","type":"function"},{"doc":"Short for mac(Type, undefined, Key, Data) .","ref":"crypto.html#mac/3","title":"crypto.mac/3","type":"function"},{"doc":"Computes a MAC (Message Authentication Code) of type Type from Data . SubType depends on the MAC Type : For hmac it is a hash algorithm, see Algorithm Details in the User's Guide. For cmac it is a cipher suitable for cmac, see Algorithm Details in the User's Guide. For poly1305 it should be set to undefined or the mac/2 function could be used instead, see Algorithm Details in the User's Guide. Key is the authentication key with a length according to the Type and SubType . The key length could be found with the hash_info/1 ( hmac ) for and cipher_info/1 ( cmac ) functions. For poly1305 the key length is 32 bytes. Note that the cryptographic quality of the key is not checked. The Mac result will have a default length depending on the Type and SubType . To set a shorter length, use macN/4 or macN/5 instead. The default length is documented in Algorithm Details in the User's Guide.","ref":"crypto.html#mac/4","title":"crypto.mac/4","type":"function"},{"doc":"Short for macN(Type, undefined, Key, Data, MacLength) .","ref":"crypto.html#macN/4","title":"crypto.macN/4","type":"function"},{"doc":"Computes a MAC (Message Authentication Code) as mac/3 and mac/4 but MacLength will limit the size of the resultant Mac to at most MacLength bytes. Note that if MacLength is greater than the actual number of bytes returned from the underlying hash, the returned hash will have that shorter length instead. The max MacLength is documented in Algorithm Details in the User's Guide.","ref":"crypto.html#macN/5","title":"crypto.macN/5","type":"function"},{"doc":"Finalizes the MAC operation referenced by State . The Mac result will have a default length depending on the Type and SubType in the mac_init/2,3 call. To set a shorter length, use mac_finalN/2 instead. The default length is documented in Algorithm Details in the User's Guide.","ref":"crypto.html#mac_final/1","title":"crypto.mac_final/1","type":"function"},{"doc":"Finalizes the MAC operation referenced by State . Mac will be a binary with at most MacLength bytes. Note that if MacLength is greater than the actual number of bytes returned from the underlying hash, the returned hash will have that shorter length instead. The max MacLength is documented in Algorithm Details in the User's Guide.","ref":"crypto.html#mac_finalN/2","title":"crypto.mac_finalN/2","type":"function"},{"doc":"Short for mac_init(Type, undefined, Key) .","ref":"crypto.html#mac_init/2","title":"crypto.mac_init/2","type":"function"},{"doc":"Initializes the context for streaming MAC operations. Type determines which mac algorithm to use in the MAC operation. SubType depends on the MAC Type : For hmac it is a hash algorithm, see Algorithm Details in the User's Guide. For cmac it is a cipher suitable for cmac, see Algorithm Details in the User's Guide. For poly1305 it should be set to undefined or the mac/2 function could be used instead, see Algorithm Details in the User's Guide. Key is the authentication key with a length according to the Type and SubType . The key length could be found with the hash_info/1 ( hmac ) for and cipher_info/1 ( cmac ) functions. For poly1305 the key length is 32 bytes. Note that the cryptographic quality of the key is not checked. The returned State should be used in one or more subsequent calls to mac_update/2 . The MAC value is finally returned by calling mac_final/1 or mac_finalN/2 . See examples in the User's Guide.","ref":"crypto.html#mac_init/3","title":"crypto.mac_init/3","type":"function"},{"doc":"Updates the MAC represented by State0 using the given Data which could be of any length. The State0 is the State value originally from a MAC init function, that is mac_init/2 , mac_init/3 or a previous call of mac_update/2 . The value State0 is returned unchanged by the function as State .","ref":"crypto.html#mac_update/2","title":"crypto.mac_update/2","type":"function"},{"doc":"Computes the function N^P mod M .","ref":"crypto.html#mod_pow/3","title":"crypto.mod_pow/3","type":"function"},{"doc":"Decrypts the CipherText , encrypted with public_encrypt/4 (or equivalent function) using the PrivateKey , and returns the plaintext (message digest). This is a low level signature verification operation used for instance by older versions of the SSL protocol. See also public_key:decrypt_private/[2,3]","ref":"crypto.html#private_decrypt/4","title":"crypto.private_decrypt/4","type":"function"},{"doc":"Encrypts the PlainText using the PrivateKey and returns the ciphertext. This is a low level signature operation used for instance by older versions of the SSL protocol. See also public_key:encrypt_private/[2,3]","ref":"crypto.html#private_encrypt/4","title":"crypto.private_encrypt/4","type":"function"},{"doc":"Fetches the corresponding public key from a private key stored in an Engine. The key must be of the type indicated by the Type parameter.","ref":"crypto.html#privkey_to_pubkey/2","title":"crypto.privkey_to_pubkey/2","type":"function"},{"doc":"Decrypts the CipherText , encrypted with private_encrypt/4 (or equivalent function) using the PrivateKey , and returns the plaintext (message digest). This is a low level signature verification operation used for instance by older versions of the SSL protocol. See also public_key:decrypt_public/[2,3]","ref":"crypto.html#public_decrypt/4","title":"crypto.public_decrypt/4","type":"function"},{"doc":"Encrypts the PlainText (message digest) using the PublicKey and returns the CipherText . This is a low level signature operation used for instance by older versions of the SSL protocol. See also public_key:encrypt_public/[2,3]","ref":"crypto.html#public_encrypt/4","title":"crypto.public_encrypt/4","type":"function"},{"doc":"Creates state object for random number generation , in order to generate cryptographically strong random numbers (based on OpenSSL's BN_rand_range ), and saves it in the process dictionary before returning it as well. See also rand:seed/1 and rand_seed_s/0 . When using the state object from this function the rand functions using it may raise exception error:low_entropy in case the random generator failed due to lack of secure &quot;randomness&quot;. Example _ = crypto : rand_seed ( ) , _ IntegerValue = rand : uniform ( 42 ) , % [1; 42] _ FloatValue = rand : uniform ( ) . % [0.0; 1.0[","ref":"crypto.html#rand_seed/0","title":"crypto.rand_seed/0","type":"function"},{"doc":"Set the seed for PRNG to the given binary. This calls the RAND_seed function from openssl. Only use this if the system you are running on does not have enough &quot;randomness&quot; built in. Normally this is when strong_rand_bytes/1 raises error:low_entropy","ref":"crypto.html#rand_seed/1","title":"crypto.rand_seed/1","type":"function"},{"doc":"Alg = crypto | crypto_cache Creates state object for random number generation , in order to generate cryptographically strong random numbers, and saves it in the process dictionary before returning it as well. See also rand:seed/1 and rand_seed_alg_s/1 . When using the state object from this function the rand functions using it may raise exception error:low_entropy in case the random generator failed due to lack of secure &quot;randomness&quot;. Example _ = crypto : rand_seed_alg ( crypto_cache ) , _ IntegerValue = rand : uniform ( 42 ) , % [1; 42] _ FloatValue = rand : uniform ( ) . % [0.0; 1.0[","ref":"crypto.html#rand_seed_alg/1","title":"crypto.rand_seed_alg/1","type":"function"},{"doc":"Alg = crypto_aes Creates a state object for random number generation , in order to generate cryptographically unpredictable random numbers, and saves it in the process dictionary before returning it as well. See also rand_seed_alg_s/2 . Example _ = crypto : rand_seed_alg ( crypto_aes , &quot;my seed&quot; ) , IntegerValue = rand : uniform ( 42 ) , % [1; 42] FloatValue = rand : uniform ( ) , % [0.0; 1.0[ _ = crypto : rand_seed_alg ( crypto_aes , &quot;my seed&quot; ) , IntegerValue = rand : uniform ( 42 ) , % Same values FloatValue = rand : uniform ( ) . % again","ref":"crypto.html#rand_seed_alg/2","title":"crypto.rand_seed_alg/2","type":"function"},{"doc":"Alg = crypto | crypto_cache Creates state object for random number generation , in order to generate cryptographically strongly random numbers. See also rand:seed_s/1 . If Alg is crypto this function behaves exactly like rand_seed_s/0 . If Alg is crypto_cache this function fetches random data with OpenSSL's RAND_bytes and caches it for speed using an internal word size of 56 bits that makes calculations fast on 64 bit machines. When using the state object from this function the rand functions using it may raise exception error:low_entropy in case the random generator failed due to lack of secure &quot;randomness&quot;. The cache size can be changed from its default value using the crypto app's configuration parameter rand_cache_size . When using the state object from this function the rand functions using it may throw exception low_entropy in case the random generator failed due to lack of secure &quot;randomness&quot;. The state returned from this function cannot be used to get a reproducable random sequence as from the other rand functions, since reproducability does not match cryptographically safe. In fact since random data is cached some numbers may get reproduced if you try, but this is unpredictable. The only supported usage is to generate one distinct random sequence from this start state.","ref":"crypto.html#rand_seed_alg_s/1","title":"crypto.rand_seed_alg_s/1","type":"function"},{"doc":"Alg = crypto_aes Creates a state object for random number generation , in order to generate cryptographically unpredictable random numbers. See also rand_seed_alg/1 . To get a long period the Xoroshiro928 generator from the rand module is used as a counter (with period 2^928 - 1) and the generator states are scrambled through AES to create 58-bit pseudo random values. The result should be statistically completely unpredictable random values, since the scrambling is cryptographically strong and the period is ridiculously long. But the generated numbers are not to be regarded as cryptographically strong since there is no re-keying schedule. If you need cryptographically strong random numbers use rand_seed_alg_s/1 with Alg =:= crypto or Alg =:= crypto_cache . If you need to be able to repeat the sequence use this function. If you do not need the statistical quality of this function, there are faster algorithms in the rand module. Thanks to the used generator the state object supports the rand:jump/0,1 function with distance 2^512. Numbers are generated in batches and cached for speed reasons. The cache size can be changed from its default value using the crypto app's configuration parameter rand_cache_size .","ref":"crypto.html#rand_seed_alg_s/2","title":"crypto.rand_seed_alg_s/2","type":"function"},{"doc":"Creates state object for random number generation , in order to generate cryptographically strongly random numbers (based on OpenSSL's BN_rand_range ). See also rand:seed_s/1 . When using the state object from this function the rand functions using it may raise exception error:low_entropy in case the random generator failed due to lack of secure &quot;randomness&quot;. The state returned from this function cannot be used to get a reproducable random sequence as from the other rand functions, since reproducability does not match cryptographically safe. The only supported usage is to generate one distinct random sequence from this start state.","ref":"crypto.html#rand_seed_s/0","title":"crypto.rand_seed_s/0","type":"function"},{"doc":"Lo, Hi, N = integer() Generate a random number N, Lo =&lt; N &lt; Hi. Uses the crypto library pseudo-random number generator. Hi must be larger than Lo .","ref":"crypto.html#rand_uniform/2","title":"crypto.rand_uniform/2","type":"function"},{"doc":"Creates a digital signature. The msg is either the binary &quot;cleartext&quot; data to be signed or it is the hashed value of &quot;cleartext&quot; i.e. the digest (plaintext). Algorithm dss can only be used together with digest type sha . See also public_key:sign/3 .","ref":"crypto.html#sign/4","title":"crypto.sign/4","type":"function"},{"doc":"","ref":"crypto.html#sign/5","title":"crypto.sign/5","type":"function"},{"doc":"Equivalent to application:start(crypto).","ref":"crypto.html#start/0","title":"crypto.start/0","type":"function"},{"doc":"Equivalent to application:stop(crypto).","ref":"crypto.html#stop/0","title":"crypto.stop/0","type":"function"},{"doc":"Generates N bytes randomly uniform 0..255, and returns the result in a binary. Uses a cryptographically secure prng seeded and periodically mixed with operating system provided entropy. By default this is the RAND_bytes method from OpenSSL. May raise exception error:low_entropy in case the random generator failed due to lack of secure &quot;randomness&quot;.","ref":"crypto.html#strong_rand_bytes/1","title":"crypto.strong_rand_bytes/1","type":"function"},{"doc":"Can be used to determine which crypto algorithms that are supported by the underlying libcrypto library See hash_info/1 and cipher_info/1 for information about the hash and cipher algorithms.","ref":"crypto.html#supports/1","title":"crypto.supports/1","type":"function"},{"doc":"Verifies a digital signature The msg is either the binary &quot;cleartext&quot; data to be signed or it is the hashed value of &quot;cleartext&quot; i.e. the digest (plaintext). Algorithm dss can only be used together with digest type sha . See also public_key:verify/4 .","ref":"crypto.html#verify/5","title":"crypto.verify/5","type":"function"},{"doc":"","ref":"crypto.html#verify/6","title":"crypto.verify/6","type":"function"},{"doc":"","ref":"crypto.html#t:blake2/0","title":"crypto.blake2/0","type":"type"},{"doc":"","ref":"crypto.html#t:cipher/0","title":"crypto.cipher/0","type":"type"},{"doc":"Ciphers known by the CRYPTO application. Note that this list might be reduced if the underlying libcrypto does not support all of them.","ref":"crypto.html#t:cipher_aead/0","title":"crypto.cipher_aead/0","type":"type"},{"doc":"","ref":"crypto.html#t:cipher_iv/0","title":"crypto.cipher_iv/0","type":"type"},{"doc":"","ref":"crypto.html#t:cipher_no_iv/0","title":"crypto.cipher_no_iv/0","type":"type"},{"doc":"","ref":"crypto.html#t:cmac_cipher_algorithm/0","title":"crypto.cmac_cipher_algorithm/0","type":"type"},{"doc":"The compatibility_only_hash() algorithms are recommended only for compatibility with existing applications.","ref":"crypto.html#t:compatibility_only_hash/0","title":"crypto.compatibility_only_hash/0","type":"type"},{"doc":"Selects encryption ( {encrypt,true} ) or decryption ( {encrypt,false} ).","ref":"crypto.html#t:crypto_opt/0","title":"crypto.crypto_opt/0","type":"type"},{"doc":"Selects encryption ( {encrypt,true} ) or decryption ( {encrypt,false} ).","ref":"crypto.html#t:crypto_opts/0","title":"crypto.crypto_opts/0","type":"type"},{"doc":"Contexts with an internal state that should not be manipulated but passed between function calls.","ref":"crypto.html#t:crypto_state/0","title":"crypto.crypto_state/0","type":"opaque"},{"doc":"The cryptolib_padding are paddings that may be present in the underlying cryptolib linked to the Erlang/OTP crypto app. For OpenSSL, see the OpenSSL documentation . and find EVP_CIPHER_CTX_set_padding() in cryptolib for your linked version.","ref":"crypto.html#t:cryptolib_padding/0","title":"crypto.cryptolib_padding/0","type":"type"},{"doc":"This is a more developed variant of the older run_time_error() . The exception is: { Tag , { C_FileName , LineNumber } , Description } Tag = badarg | notsup | error C_FileName = string ( ) LineNumber = integer ( ) Description = string ( ) It is like the older type an exception of the error class. In addition they contain a descriptive text in English. That text is targeted to a developer. Examples are &quot;Bad key size&quot; or &quot;Cipher id is not an atom&quot;. The exception tags are: badarg Signifies that one or more arguments are of wrong data type or are otherwise badly formed. notsup Signifies that the algorithm is known but is not supported by current underlying libcrypto or explicitly disabled when building that one. error An error condition that should not occur, for example a memory allocation failed or the underlying cryptolib returned an error code, for example &quot;Can't initialize context, step 1&quot;. Those text usually needs searching the C-code to be understood. To catch the exception, use for example: try crypto : crypto_init ( Ciph , Key , IV , true ) catch error : { Tag , { C_FileName , LineNumber } , Description } -&gt; do_something ( . . . . . . ) . . . . . end","ref":"crypto.html#t:descriptive_error/0","title":"crypto.descriptive_error/0","type":"type"},{"doc":"dh_params ( ) = [ P , G ] | [ P , G , PrivateKeyBitLength ]","ref":"crypto.html#t:dh_params/0","title":"crypto.dh_params/0","type":"type"},{"doc":"","ref":"crypto.html#t:dh_private/0","title":"crypto.dh_private/0","type":"type"},{"doc":"","ref":"crypto.html#t:dh_public/0","title":"crypto.dh_public/0","type":"type"},{"doc":"","ref":"crypto.html#t:dss_digest_type/0","title":"crypto.dss_digest_type/0","type":"type"},{"doc":"dss_public ( ) = [ P , Q , G , Y ] Where P, Q and G are the dss parameters and Y is the public key. dss_private ( ) = [ P , Q , G , X ] Where P, Q and G are the dss parameters and X is the private key.","ref":"crypto.html#t:dss_private/0","title":"crypto.dss_private/0","type":"type"},{"doc":"dss_public ( ) = [ P , Q , G , Y ] Where P, Q and G are the dss parameters and Y is the public key. dss_private ( ) = [ P , Q , G , X ] Where P, Q and G are the dss parameters and X is the private key.","ref":"crypto.html#t:dss_public/0","title":"crypto.dss_public/0","type":"type"},{"doc":"Curve definition details.","ref":"crypto.html#t:ec_basis/0","title":"crypto.ec_basis/0","type":"type"},{"doc":"Curve definition details.","ref":"crypto.html#t:ec_characteristic_two_field/0","title":"crypto.ec_characteristic_two_field/0","type":"type"},{"doc":"Parametric curve definition.","ref":"crypto.html#t:ec_curve/0","title":"crypto.ec_curve/0","type":"type"},{"doc":"Parametric curve definition.","ref":"crypto.html#t:ec_explicit_curve/0","title":"crypto.ec_explicit_curve/0","type":"type"},{"doc":"Parametric curve definition.","ref":"crypto.html#t:ec_field/0","title":"crypto.ec_field/0","type":"type"},{"doc":"Note that some curves are disabled if FIPS is enabled.","ref":"crypto.html#t:ec_named_curve/0","title":"crypto.ec_named_curve/0","type":"type"},{"doc":"Curve definition details.","ref":"crypto.html#t:ec_prime_field/0","title":"crypto.ec_prime_field/0","type":"type"},{"doc":"","ref":"crypto.html#t:ecdh_params/0","title":"crypto.ecdh_params/0","type":"type"},{"doc":"","ref":"crypto.html#t:ecdh_private/0","title":"crypto.ecdh_private/0","type":"type"},{"doc":"","ref":"crypto.html#t:ecdh_public/0","title":"crypto.ecdh_public/0","type":"type"},{"doc":"","ref":"crypto.html#t:ecdsa_digest_type/0","title":"crypto.ecdsa_digest_type/0","type":"type"},{"doc":"","ref":"crypto.html#t:ecdsa_params/0","title":"crypto.ecdsa_params/0","type":"type"},{"doc":"","ref":"crypto.html#t:ecdsa_private/0","title":"crypto.ecdsa_private/0","type":"type"},{"doc":"","ref":"crypto.html#t:ecdsa_public/0","title":"crypto.ecdsa_public/0","type":"type"},{"doc":"","ref":"crypto.html#t:eddsa_params/0","title":"crypto.eddsa_params/0","type":"type"},{"doc":"","ref":"crypto.html#t:eddsa_private/0","title":"crypto.eddsa_private/0","type":"type"},{"doc":"","ref":"crypto.html#t:eddsa_public/0","title":"crypto.eddsa_public/0","type":"type"},{"doc":"Note that some curves are disabled if FIPS is enabled.","ref":"crypto.html#t:edwards_curve_dh/0","title":"crypto.edwards_curve_dh/0","type":"type"},{"doc":"Note that some curves are disabled if FIPS is enabled.","ref":"crypto.html#t:edwards_curve_ed/0","title":"crypto.edwards_curve_ed/0","type":"type"},{"doc":"Pre and Post commands for engine_load/3 and /4 .","ref":"crypto.html#t:engine_cmnd/0","title":"crypto.engine_cmnd/0","type":"type"},{"doc":"The result of a call to engine_load/3 .","ref":"crypto.html#t:engine_key_ref/0","title":"crypto.engine_key_ref/0","type":"type"},{"doc":"","ref":"crypto.html#t:engine_method_type/0","title":"crypto.engine_method_type/0","type":"type"},{"doc":"The result of a call to engine_load/3 .","ref":"crypto.html#t:engine_ref/0","title":"crypto.engine_ref/0","type":"type"},{"doc":"","ref":"crypto.html#t:hash_algorithm/0","title":"crypto.hash_algorithm/0","type":"type"},{"doc":"Contexts with an internal state that should not be manipulated but passed between function calls.","ref":"crypto.html#t:hash_state/0","title":"crypto.hash_state/0","type":"opaque"},{"doc":"","ref":"crypto.html#t:hmac_hash_algorithm/0","title":"crypto.hmac_hash_algorithm/0","type":"type"},{"doc":"Identifies the key to be used. The format depends on the loaded engine. It is passed to the ENGINE_load_(private|public)_key functions in libcrypto.","ref":"crypto.html#t:key_id/0","title":"crypto.key_id/0","type":"type"},{"doc":"Always binary() when used as return value","ref":"crypto.html#t:key_integer/0","title":"crypto.key_integer/0","type":"type"},{"doc":"Contexts with an internal state that should not be manipulated but passed between function calls.","ref":"crypto.html#t:mac_state/0","title":"crypto.mac_state/0","type":"opaque"},{"doc":"Erlang/OTP adds a either padding of zeroes or padding with random bytes.","ref":"crypto.html#t:otp_padding/0","title":"crypto.otp_padding/0","type":"type"},{"doc":"This option handles padding in the last block. If not set, no padding is done and any bytes in the last unfilled block is silently discarded.","ref":"crypto.html#t:padding/0","title":"crypto.padding/0","type":"type"},{"doc":"The password of the key stored in an engine.","ref":"crypto.html#t:password/0","title":"crypto.password/0","type":"type"},{"doc":"Algorithms for public key encrypt/decrypt. Only RSA is supported.","ref":"crypto.html#t:pk_encrypt_decrypt_algs/0","title":"crypto.pk_encrypt_decrypt_algs/0","type":"type"},{"doc":"Options for public key encrypt/decrypt. Only RSA is supported. The RSA options are experimental. The exact set of options and there syntax may be changed without prior notice.","ref":"crypto.html#t:pk_encrypt_decrypt_opts/0","title":"crypto.pk_encrypt_decrypt_opts/0","type":"type"},{"doc":"Algorithms for sign and verify.","ref":"crypto.html#t:pk_sign_verify_algs/0","title":"crypto.pk_sign_verify_algs/0","type":"type"},{"doc":"Options for sign and verify. The RSA options are experimental. The exact set of options and there syntax may be changed without prior notice.","ref":"crypto.html#t:pk_sign_verify_opts/0","title":"crypto.pk_sign_verify_opts/0","type":"type"},{"doc":"Those option forms are kept only for compatibility and should not be used in new code.","ref":"crypto.html#t:rsa_compat_opts/0","title":"crypto.rsa_compat_opts/0","type":"type"},{"doc":"","ref":"crypto.html#t:rsa_digest_type/0","title":"crypto.rsa_digest_type/0","type":"type"},{"doc":"Options for public key encrypt/decrypt. Only RSA is supported. The RSA options are experimental. The exact set of options and there syntax may be changed without prior notice.","ref":"crypto.html#t:rsa_opt/0","title":"crypto.rsa_opt/0","type":"type"},{"doc":"Options for public key encrypt/decrypt. Only RSA is supported. The RSA options are experimental. The exact set of options and there syntax may be changed without prior notice.","ref":"crypto.html#t:rsa_padding/0","title":"crypto.rsa_padding/0","type":"type"},{"doc":"rsa_public ( ) = [ E , N ] rsa_private ( ) = [ E , N , D ] | [ E , N , D , P1 , P2 , E1 , E2 , C ] Where E is the public exponent, N is public modulus and D is the private exponent. The longer key format contains redundant information that will make the calculation faster. P1 and P2 are first and second prime factors. E1 and E2 are first and second exponents. C is the CRT coefficient. The terminology is taken from RFC 3447 .","ref":"crypto.html#t:rsa_params/0","title":"crypto.rsa_params/0","type":"type"},{"doc":"rsa_public ( ) = [ E , N ] rsa_private ( ) = [ E , N , D ] | [ E , N , D , P1 , P2 , E1 , E2 , C ] Where E is the public exponent, N is public modulus and D is the private exponent. The longer key format contains redundant information that will make the calculation faster. P1 and P2 are first and second prime factors. E1 and E2 are first and second exponents. C is the CRT coefficient. The terminology is taken from RFC 3447 .","ref":"crypto.html#t:rsa_private/0","title":"crypto.rsa_private/0","type":"type"},{"doc":"rsa_public ( ) = [ E , N ] rsa_private ( ) = [ E , N , D ] | [ E , N , D , P1 , P2 , E1 , E2 , C ] Where E is the public exponent, N is public modulus and D is the private exponent. The longer key format contains redundant information that will make the calculation faster. P1 and P2 are first and second prime factors. E1 and E2 are first and second exponents. C is the CRT coefficient. The terminology is taken from RFC 3447 .","ref":"crypto.html#t:rsa_public/0","title":"crypto.rsa_public/0","type":"type"},{"doc":"Options for sign and verify. The RSA options are experimental. The exact set of options and there syntax may be changed without prior notice.","ref":"crypto.html#t:rsa_sign_verify_opt/0","title":"crypto.rsa_sign_verify_opt/0","type":"type"},{"doc":"Options for sign and verify. The RSA options are experimental. The exact set of options and there syntax may be changed without prior notice.","ref":"crypto.html#t:rsa_sign_verify_padding/0","title":"crypto.rsa_sign_verify_padding/0","type":"type"},{"doc":"The exception error:badarg signifies that one or more arguments are of wrong data type, or are otherwise badly formed. The exception error:notsup signifies that the algorithm is known but is not supported by current underlying libcrypto or explicitly disabled when building that. For a list of supported algorithms, see supports(ciphers) .","ref":"crypto.html#t:run_time_error/0","title":"crypto.run_time_error/0","type":"type"},{"doc":"","ref":"crypto.html#t:sha1/0","title":"crypto.sha1/0","type":"type"},{"doc":"","ref":"crypto.html#t:sha2/0","title":"crypto.sha2/0","type":"type"},{"doc":"","ref":"crypto.html#t:sha3/0","title":"crypto.sha3/0","type":"type"},{"doc":"Where Verifier is v , Generator is g and Prime is N , DerivedKey is X , and Scrambler is u (optional will be generated if not provided) from SRP design Version = '3' | '6' | '6a'","ref":"crypto.html#t:srp_comp_params/0","title":"crypto.srp_comp_params/0","type":"type"},{"doc":"Where Verifier is v , Generator is g and Prime is N , DerivedKey is X , and Scrambler is u (optional will be generated if not provided) from SRP design Version = '3' | '6' | '6a'","ref":"crypto.html#t:srp_gen_params/0","title":"crypto.srp_gen_params/0","type":"type"},{"doc":"Where Verifier is v , Generator is g and Prime is N , DerivedKey is X , and Scrambler is u (optional will be generated if not provided) from SRP design Version = '3' | '6' | '6a'","ref":"crypto.html#t:srp_host_comp_params/0","title":"crypto.srp_host_comp_params/0","type":"type"},{"doc":"Where Verifier is v , Generator is g and Prime is N , DerivedKey is X , and Scrambler is u (optional will be generated if not provided) from SRP design Version = '3' | '6' | '6a'","ref":"crypto.html#t:srp_host_gen_params/0","title":"crypto.srp_host_gen_params/0","type":"type"},{"doc":"srp_public ( ) = key_integer ( ) Where is A or B from SRP design srp_private ( ) = key_integer ( ) Where is a or b from SRP design","ref":"crypto.html#t:srp_private/0","title":"crypto.srp_private/0","type":"type"},{"doc":"srp_public ( ) = key_integer ( ) Where is A or B from SRP design srp_private ( ) = key_integer ( ) Where is a or b from SRP design","ref":"crypto.html#t:srp_public/0","title":"crypto.srp_public/0","type":"type"},{"doc":"Where Verifier is v , Generator is g and Prime is N , DerivedKey is X , and Scrambler is u (optional will be generated if not provided) from SRP design Version = '3' | '6' | '6a'","ref":"crypto.html#t:srp_user_comp_params/0","title":"crypto.srp_user_comp_params/0","type":"type"},{"doc":"Where Verifier is v , Generator is g and Prime is N , DerivedKey is X , and Scrambler is u (optional will be generated if not provided) from SRP design Version = '3' | '6' | '6a'","ref":"crypto.html#t:srp_user_gen_params/0","title":"crypto.srp_user_gen_params/0","type":"type"}]