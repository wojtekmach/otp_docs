searchNodes=[{"doc":"This module provides a client api to the Lightweight Directory Access Protocol (LDAP). References: RFC 4510 - RFC 4519 RFC 2830 The above publications can be found at IETF . DATA TYPES Type definitions that are used more than once in this module: handle() Connection handle attribute() = {Type = string(), Values=[string()]} modify_op() See mod_add/2 , mod_delete/2 , mod_replace/2 scope() See baseObject/0 , singleLevel/0 , wholeSubtree/0 dereference() See neverDerefAliases/0 , derefInSearching/0 , derefFindingBaseObj/0 , derefAlways/0 filter() See present/1 , substrings/2 , equalityMatch/2 , greaterOrEqual/2 , lessOrEqual/2 , approxMatch/2 , extensibleMatch/2 , 'and'/1, 'or'/1, 'not'/1 return_value() = ok | {ok, {referral,referrals()}} | {error,Error} referrals() = [Address = string()] The contents of Address is server dependent.","ref":"eldap.html","title":"eldap","type":"module"},{"doc":"Handle = handle() Dn = string() Attribute = attribute() Add an entry. The entry must not exist. add ( Handle , &quot;cn=Bill Valentine, ou=people, o=Example Org, dc=example, dc=com&quot; , [ { &quot;objectclass&quot; , [ &quot;person&quot; ] } , { &quot;cn&quot; , [ &quot;Bill Valentine&quot; ] } , { &quot;sn&quot; , [ &quot;Valentine&quot; ] } , { &quot;telephoneNumber&quot; , [ &quot;545 555 00&quot; ] } ] )","ref":"eldap.html#add/3","title":"eldap.add/3","type":"function"},{"doc":"Filter = filter() Creates a filter where all Filter must be true.","ref":"eldap.html#and/1","title":"eldap.and/1","type":"function"},{"doc":"Type = string() Value = string() Create a approximation match filter.","ref":"eldap.html#approxMatch/2","title":"eldap.approxMatch/2","type":"function"},{"doc":"Search baseobject only.","ref":"eldap.html#baseObject/0","title":"eldap.baseObject/0","type":"function"},{"doc":"Handle = handle() Shutdown the connection after sending an unbindRequest to the server. If the connection is tls the connection will be closed with ssl:close/1 , otherwise with gen_tcp:close/1 .","ref":"eldap.html#close/1","title":"eldap.close/1","type":"function"},{"doc":"Dn = string() Delete an entry. delete ( Handle , &quot;cn=Bill Valentine, ou=people, o=Example Org, dc=example, dc=com&quot; )","ref":"eldap.html#delete/2","title":"eldap.delete/2","type":"function"},{"doc":"Always derefrence aliases.","ref":"eldap.html#derefAlways/0","title":"eldap.derefAlways/0","type":"function"},{"doc":"Derefrence aliases only in finding the base.","ref":"eldap.html#derefFindingBaseObj/0","title":"eldap.derefFindingBaseObj/0","type":"function"},{"doc":"Derefrence aliases only when searching.","ref":"eldap.html#derefInSearching/0","title":"eldap.derefInSearching/0","type":"function"},{"doc":"Type = string() Value = string() Create a equality filter.","ref":"eldap.html#equalityMatch/2","title":"eldap.equalityMatch/2","type":"function"},{"doc":"MatchValue = string() OptionalAttrs = [Attr] Attr = {matchingRule,string()} | {type,string()} | {dnAttributes,boolean()} Creates an extensible match filter. For example, eldap : extensibleMatch ( &quot;Bar&quot; , [ { type , &quot;sn&quot; } , { matchingRule , &quot;caseExactMatch&quot; } ] ) ) creates a filter which performs a caseExactMatch on the attribute sn and matches with the value &quot;Bar&quot; . The default value of dnAttributes is false .","ref":"eldap.html#extensibleMatch/2","title":"eldap.extensibleMatch/2","type":"function"},{"doc":"Type = string() Value = string() Create a greater or equal filter.","ref":"eldap.html#greaterOrEqual/2","title":"eldap.greaterOrEqual/2","type":"function"},{"doc":"Type = string() Value = string() Create a less or equal filter.","ref":"eldap.html#lessOrEqual/2","title":"eldap.lessOrEqual/2","type":"function"},{"doc":"Type = string() Value = string() Create an add modification operation.","ref":"eldap.html#mod_add/2","title":"eldap.mod_add/2","type":"function"},{"doc":"Type = string() Value = string() Create a delete modification operation.","ref":"eldap.html#mod_delete/2","title":"eldap.mod_delete/2","type":"function"},{"doc":"Type = string() Value = string() Create a replace modification operation.","ref":"eldap.html#mod_replace/2","title":"eldap.mod_replace/2","type":"function"},{"doc":"Dn = string() ModifyOp = modify_op() Modify an entry. modify ( Handle , &quot;cn=Bill Valentine, ou=people, o=Example Org, dc=example, dc=com&quot; , [ eldap : mod_replace ( &quot;telephoneNumber&quot; , [ &quot;555 555 00&quot; ] ) , eldap : mod_add ( &quot;description&quot; , [ &quot;LDAP Hacker&quot; ] ) ] )","ref":"eldap.html#modify/3","title":"eldap.modify/3","type":"function"},{"doc":"Dn = string() NewRDN = string() DeleteOldRDN = boolean() NewSupDN = string() Modify the DN of an entry. DeleteOldRDN indicates whether the current RDN should be removed from the attribute list after the operation. NewSupDN is the new parent that the RDN shall be moved to. If the old parent should remain as parent, NewSupDN shall be &quot;&quot;. modify_dn ( Handle , &quot;cn=Bill Valentine, ou=people, o=Example Org, dc=example, dc=com &quot; , &quot;cn=Bill Jr Valentine&quot; , true , &quot;&quot; )","ref":"eldap.html#modify_dn/5","title":"eldap.modify_dn/5","type":"function"},{"doc":"Dn = string() NewPasswd = string() Modify the password of a user. See modify_password/4 .","ref":"eldap.html#modify_password/3","title":"eldap.modify_password/3","type":"function"},{"doc":"Dn = string() NewPasswd = string() OldPasswd = string() GenPasswd = string() Modify the password of a user. Dn . The user to modify. Should be &quot;&quot; if the modify request is for the user of the LDAP session. NewPasswd . The new password to set. Should be &quot;&quot; if the server is to generate the password. In this case, the result will be {ok, GenPasswd} . OldPasswd . Sometimes required by server policy for a user to change their password. If not required, use modify_password/3 .","ref":"eldap.html#modify_password/4","title":"eldap.modify_password/4","type":"function"},{"doc":"Never derefrence aliases, treat aliases as entries.","ref":"eldap.html#neverDerefAliases/0","title":"eldap.neverDerefAliases/0","type":"function"},{"doc":"Filter = filter() Negate a filter.","ref":"eldap.html#not/1","title":"eldap.not/1","type":"function"},{"doc":"Handle = handle() Setup a connection to an LDAP server, the HOST 's are tried in order.","ref":"eldap.html#open/1","title":"eldap.open/1","type":"function"},{"doc":"Handle = handle() Option = {port, integer()} | {log, function()} | {timeout, integer()} | {ssl, boolean()} | {sslopts, list()} | {tcpopts, list()} Setup a connection to an LDAP server, the HOST 's are tried in order. The log function takes three arguments, fun(Level, FormatString, [FormatArg]) end . Timeout set the maximum time in milliseconds that each server request may take. All TCP socket options are accepted except active , binary , deliver , list , mode and packet","ref":"eldap.html#open/2","title":"eldap.open/2","type":"function"},{"doc":"Filter = filter() Create a filter where at least one of the Filter must be true.","ref":"eldap.html#or/1","title":"eldap.or/1","type":"function"},{"doc":"Type = string() Create a filter which filters on attribute type presence.","ref":"eldap.html#present/1","title":"eldap.present/1","type":"function"},{"doc":"SearchOptions = #eldap_search{} | [SearchOption] SearchOption = {base, string()} | {filter, filter()} | {scope, scope()} | {attributes, [string()]} | {deref, dereference()} | | {types_only, boolean()} | {timeout, integer()} Search the directory with the supplied the SearchOptions. The base and filter options must be supplied. Default values: scope is wholeSubtree() , deref is derefAlways() , types_only is false and timeout is 0 (meaning infinity). Filter = eldap : substrings ( &quot;cn&quot; , [ { any , &quot;V&quot; } ] ) , search ( Handle , [ { base , &quot;dc=example, dc=com&quot; } , { filter , Filter } , { attributes , [ &quot;cn&quot; ] } ] ) , The timeout option in the SearchOptions is for the ldap server, while the timeout in eldap:open/2 is used for each individual request in the search operation.","ref":"eldap.html#search/2","title":"eldap.search/2","type":"function"},{"doc":"Handle = handle() Dn = string() Password = string() Authenticate the connection using simple authentication.","ref":"eldap.html#simple_bind/3","title":"eldap.simple_bind/3","type":"function"},{"doc":"Search the specified level only, i.e. do not recurse.","ref":"eldap.html#singleLevel/0","title":"eldap.singleLevel/0","type":"function"},{"doc":"Same as start_tls(Handle, Options, infinity)","ref":"eldap.html#start_tls/2","title":"eldap.start_tls/2","type":"function"},{"doc":"Handle = handle() Options = ssl:ssl_options() Timeout = infinity | positive_integer() Upgrade the connection associated with Handle to a tls connection if possible. The upgrade is done in two phases: first the server is asked for permission to upgrade. Second, if the request is acknowledged, the upgrade to tls is performed. Error responses from phase one will not affect the current encryption state of the connection. Those responses are: tls_already_started The connection is already encrypted. The connection is not affected. {response,ResponseFromServer} The upgrade was refused by the LDAP server. The ResponseFromServer is an atom delivered byt the LDAP server explained in section 2.3 of rfc 2830. The connection is not affected, so it is still un-encrypted. Errors in the second phase will however end the connection: Error Any error responded from ssl:connect/3 The Timeout parameter is for the actual tls upgrade (phase 2) while the timeout in eldap:open/2 is used for the initial negotiation about upgrade (phase 1).","ref":"eldap.html#start_tls/3","title":"eldap.start_tls/3","type":"function"},{"doc":"Type = string() SubString = {StringPart, string()} StringPart = initial | any | final Create a filter which filters on substrings.","ref":"eldap.html#substrings/2","title":"eldap.substrings/2","type":"function"},{"doc":"Search the entire subtree.","ref":"eldap.html#wholeSubtree/0","title":"eldap.wholeSubtree/0","type":"function"}]