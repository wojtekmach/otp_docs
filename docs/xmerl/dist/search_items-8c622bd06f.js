searchNodes=[{"doc":"Functions for exporting XML data to an external format.","ref":"xmerl.html","title":"xmerl","type":"module"},{"doc":"Module = atom() Result = [atom()] Find the list of inherited callback modules for a given module.","ref":"xmerl.html#callbacks/1","title":"xmerl.callbacks/1","type":"function"},{"doc":"Equivalent to export(Data, Callback, []) .","ref":"xmerl.html#export/2","title":"xmerl.export/2","type":"function"},{"doc":"Content = [Element] Callback = atom() RootAttributes = [XmlAttributes] Exports normal, well-formed XML content, using the specified callback-module. Element is any of: #xmlText{} #xmlElement{} #xmlPI{} #xmlComment{} #xmlDecl{} (See xmerl.hrl for the record definitions.) Text in #xmlText{} elements can be deep lists of characters and/or binaries. RootAttributes is a list of #xmlAttribute{} attributes for the #root# element, which implicitly becomes the parent of the given Content . The tag-handler function for #root# is thus called with the complete exported data of Content . Root attributes can be used to specify e.g. encoding or other metadata of an XML or HTML document. The Callback module should contain hook functions for all tags present in the data structure. A hook function must have the following format: Tag ( Data , Attributes , Parents , E ) where E is the corresponding #xmlElement{} , Data is the already-exported contents of E and Attributes is the list of #xmlAttribute{} records of E . Finally, Parents is the list of parent nodes of E , on the form [{ParentTag::atom(), ParentPosition::integer()}] . The hook function should return either the data to be exported, or a tuple {'#xml-alias#', NewTag::atom()} , or a tuple {'#xml-redefine#', Content} , where Content is a content list (which can be on simple-form; see export_simple/2 for details). A callback module can inherit definitions from other callback modules, through the required function '#xml-interitance#() -&gt; [ModuleName::atom()] . See also: export/2 , export_simple/3 .","ref":"xmerl.html#export/3","title":"xmerl.export/3","type":"function"},{"doc":"Content = [Element] Callback = [atom()] Exports normal XML content directly, without further context.","ref":"xmerl.html#export_content/2","title":"xmerl.export_content/2","type":"function"},{"doc":"Exports a normal XML element directly, without further context.","ref":"xmerl.html#export_element/2","title":"xmerl.export_element/2","type":"function"},{"doc":"For on-the-fly exporting during parsing (SAX style) of the XML document.","ref":"xmerl.html#export_element/3","title":"xmerl.export_element/3","type":"function"},{"doc":"Equivalent to export_simple(Content, Callback, []) .","ref":"xmerl.html#export_simple/2","title":"xmerl.export_simple/2","type":"function"},{"doc":"Content = [Element] Callback = atom() RootAttributes = [XmlAttributes] Exports &quot;simple-form&quot; XML content, using the specified callback-module. Element is any of: {Tag, Attributes, Content} {Tag, Content} Tag IOString #xmlText{} #xmlElement{} #xmlPI{} #xmlComment{} #xmlDecl{} where Tag = atom() Attributes = [{Name, Value}] Name = atom() Value = IOString | atom() | integer() Normal-form XML elements can thus be included in the simple-form representation. Note that content lists must be flat. An IOString is a (possibly deep) list of characters and/or binaries. RootAttributes is a list of: XmlAttributes = #xmlAttribute{} See export/3 for details on the callback module and the root attributes. The XML-data is always converted to normal form before being passed to the callback module. See also: export/3 , export_simple/2 .","ref":"xmerl.html#export_simple/3","title":"xmerl.export_simple/3","type":"function"},{"doc":"Exports simple XML content directly, without further context.","ref":"xmerl.html#export_simple_content/2","title":"xmerl.export_simple_content/2","type":"function"},{"doc":"Exports a simple XML element directly, without further context.","ref":"xmerl.html#export_simple_element/2","title":"xmerl.export_simple_element/2","type":"function"},{"doc":"Simple event-based front-ends to xmerl_scan for processing of XML documents in streams and for parsing in SAX style. Each contain more elaborate settings of xmerl_scan that makes usage of the customization functions. DATA TYPES option_list() Options allow to customize the behaviour of the scanner. See also tutorial on customization functions. Possible options are: {acc_fun, Fun} Call back function to accumulate contents of entity. {continuation_fun, Fun} | {continuation_fun, Fun, ContinuationState} Call back function to decide what to do if the scanner runs into EOF before the document is complete. {event_fun, Fun} | {event_fun, Fun, EventState} Call back function to handle scanner events. {fetch_fun, Fun} | {fetch_fun, Fun, FetchState} Call back function to fetch an external resource. {hook_fun, Fun} | {hook_fun, Fun, HookState} Call back function to process the document entities once identified. {close_fun, Fun} Called when document has been completely parsed. {rules, ReadFun, WriteFun, RulesState} | {rules, Rules} Handles storing of scanner information when parsing. {user_state, UserState} Global state variable accessible from all customization functions {fetch_path, PathList} PathList is a list of directories to search when fetching files. If the file in question is not in the fetch_path, the URI will be used as a file name. {space, Flag} 'preserve' (default) to preserve spaces, 'normalize' to accumulate consecutive whitespace and replace it with one space. {line, Line} To specify starting line for scanning in document which contains fragments of XML. {namespace_conformant, Flag} Controls whether to behave as a namespace conformant XML parser, 'false' (default) to not otherwise 'true'. {validation, Flag} Controls whether to process as a validating XML parser: 'off' (default) no validation, or validation 'dtd' by DTD or 'schema' by XML Schema. 'false' and 'true' options are obsolete (i.e. they may be removed in a future release), if used 'false' equals 'off' and 'true' equals 'dtd'. {schemaLocation, [{Namespace,Link}|...]} Tells explicitly which XML Schema documents to use to validate the XML document. Used together with the {validation,schema} option. {quiet, Flag} Set to 'true' if xmerl should behave quietly and not output any information to standard output (default 'false'). {doctype_DTD, DTD} Allows to specify DTD name when it isn't available in the XML document. This option has effect only together with {validation,'dtd' option. {xmlbase, Dir} XML Base directory. If using string/1 default is current directory. If using file/1 default is directory of given file. {encoding, Enc} Set default character set used (default UTF-8). This character set is used only if not explicitly given by the XML declaration. {document, Flag} Set to 'true' if xmerl should return a complete XML document as an xmlDocument record (default 'false'). {comments, Flag} Set to 'false' if xmerl should skip comments otherwise they will be returned as xmlComment records (default 'true'). {default_attrs, Flag} Set to 'true' if xmerl should add to elements missing attributes with a defined default value (default 'false'). xmlElement() = #xmlElement{}","ref":"xmerl_eventp.html","title":"xmerl_eventp","type":"module"},{"doc":"Parse file containing an XML document, SAX style. Wrapper for a call to the XML parser xmerl_scan with a hook_fun for using xmerl export functionality directly after an entity is parsed.","ref":"xmerl_eventp.html#file_sax/4","title":"xmerl_eventp.file_sax/4","type":"function"},{"doc":"Parse file containing an XML document as a stream, DOM style. Wrapper for a call to the XML parser xmerl_scan with a continuation_fun for handling streams of XML data. Note that the continuation_fun , acc_fun , fetch_fun , rules and close_fun options cannot be user defined using this parser.","ref":"xmerl_eventp.html#stream/2","title":"xmerl_eventp.stream/2","type":"function"},{"doc":"Fname = string() CallBackModule = atom() Options = option_list() Parse file containing an XML document as a stream, SAX style. Wrapper for a call to the XML parser xmerl_scan with a continuation_fun for handling streams of XML data. Note that the continuation_fun , acc_fun , fetch_fun , rules , hook_fun , close_fun and user_state options cannot be user defined using this parser.","ref":"xmerl_eventp.html#stream_sax/4","title":"xmerl_eventp.stream_sax/4","type":"function"},{"doc":"Parse file containing an XML document, SAX style. Wrapper for a call to the XML parser xmerl_scan with a hook_fun for using xmerl export functionality directly after an entity is parsed.","ref":"xmerl_eventp.html#string_sax/4","title":"xmerl_eventp.string_sax/4","type":"function"},{"doc":"A SAX parser for XML that sends the events through a callback interface. SAX is the Simple API for XML , originally a Java-only API. SAX was the first widely adopted API for XML in Java, and is a de facto standard where there are versions for several programming language environments other than Java. DATA TYPES option() Options used to customize the behaviour of the parser. Possible options are: {continuation_fun, ContinuationFun} ContinuationFun is a call back function to decide what to do if the parser runs into EOF before the document is complete. {continuation_state, term()} State that is accessible in the continuation call back function. {event_fun, EventFun} EventFun is the call back function for parser events. {event_state, term()} State that is accessible in the event call back function. {file_type, FileType} Flag that tells the parser if it's parsing a DTD or a normal XML file (default normal). FileType = normal | dtd {encoding, Encoding} Set default character set used (default UTF-8). This character set is used only if not explicitly given by the XML document. Encoding = utf8 | {utf16,big} | {utf16,little} | latin1 | list skip_external_dtd Skips the external DTD during parsing. event() The SAX events that are sent to the user via the callback. startDocument Receive notification of the beginning of a document. The SAX parser will send this event only once before any other event callbacks. endDocument Receive notification of the end of a document. The SAX parser will send this event only once, and it will be the last event during the parse. {startPrefixMapping, Prefix, Uri} Begin the scope of a prefix-URI Namespace mapping. Note that start/endPrefixMapping events are not guaranteed to be properly nested relative to each other: all startPrefixMapping events will occur immediately before the corresponding startElement event, and all endPrefixMapping events will occur immediately after the corresponding endElement event, but their order is not otherwise guaranteed. There will not be start/endPrefixMapping events for the &quot;xml&quot; prefix, since it is predeclared and immutable. Prefix = string() Uri = string() {endPrefixMapping, Prefix} End the scope of a prefix-URI mapping. Prefix = string() {startElement, Uri, LocalName, QualifiedName, Attributes} Receive notification of the beginning of an element. The Parser will send this event at the beginning of every element in the XML document; there will be a corresponding endElement event for every startElement event (even when the element is empty). All of the element's content will be reported, in order, before the corresponding endElement event. Uri = string() LocalName = string() QualifiedName = {Prefix, LocalName} Prefix = string() Attributes = [{Uri, Prefix, AttributeName, Value}] AttributeName = string() Value = string() {endElement, Uri, LocalName, QualifiedName} Receive notification of the end of an element. The SAX parser will send this event at the end of every element in the XML document; there will be a corresponding startElement event for every endElement event (even when the element is empty). Uri = string() LocalName = string() QualifiedName = {Prefix, LocalName} Prefix = string() {characters, string()} Receive notification of character data. {ignorableWhitespace, string()} Receive notification of ignorable whitespace in element content. {processingInstruction, Target, Data} Receive notification of a processing instruction. The Parser will send this event once for each processing instruction found: note that processing instructions may occur before or after the main document element. Target = string() Data = string() {comment, string()} Report an XML comment anywhere in the document (both inside and outside of the document element). startCDATA Report the start of a CDATA section. The contents of the CDATA section will be reported through the regular characters event. endCDATA Report the end of a CDATA section. {startDTD, Name, PublicId, SystemId} Report the start of DTD declarations, it's reporting the start of the DOCTYPE declaration. If the document has no DOCTYPE declaration, this event will not be sent. Name = string() PublicId = string() SystemId = string() endDTD Report the end of DTD declarations, it's reporting the end of the DOCTYPE declaration. {startEntity, SysId} Report the beginning of some internal and external XML entities. ??? {endEntity, SysId} Report the end of an entity. ??? {elementDecl, Name, Model} Report an element type declaration. The content model will consist of the string &quot;EMPTY&quot;, the string &quot;ANY&quot;, or a parenthesised group, optionally followed by an occurrence indicator. The model will be normalized so that all parameter entities are fully resolved and all whitespace is removed,and will include the enclosing parentheses. Other normalization (such as removing redundant parentheses or simplifying occurrence indicators) is at the discretion of the parser. Name = string() Model = string() {attributeDecl, ElementName, AttributeName, Type, Mode, Value} Report an attribute type declaration. ElementName = string() AttributeName = string() Type = string() Mode = string() Value = string() {internalEntityDecl, Name, Value} Report an internal entity declaration. Name = string() Value = string() {externalEntityDecl, Name, PublicId, SystemId} Report a parsed external entity declaration. Name = string() PublicId = string() SystemId = string() {unparsedEntityDecl, Name, PublicId, SystemId, Ndata} Receive notification of an unparsed entity declaration event. Name = string() PublicId = string() SystemId = string() Ndata = string() {notationDecl, Name, PublicId, SystemId} Receive notification of a notation declaration event. Name = string() PublicId = string() SystemId = string() unicode_char() Integer representing valid unicode codepoint. unicode_binary() Binary with characters encoded in UTF-8 or UTF-16. latin1_binary() Binary with characters encoded in iso-latin-1.","ref":"xmerl_sax_parser.html","title":"xmerl_sax_parser","type":"module"},{"doc":"Filename = string() Options = [option()] Result = {ok, EventState, Rest} |    {Tag, Location, Reason, EndTags, EventState} Rest = unicode_binary() | latin1_binary() Tag = atom() (fatal_error, or user defined tag) Location = {CurrentLocation, EntityName, LineNo} CurrentLocation = string() EntityName = string() LineNo = integer() EventState = term() Reason = term() Parse file containing an XML document. This functions uses a default continuation function to read the file in blocks.","ref":"xmerl_sax_parser.html#file/2","title":"xmerl_sax_parser.file/2","type":"function"},{"doc":"Xml = unicode_binary() | latin1_binary() | [unicode_char()] Options = [option()] Result = {ok, EventState, Rest} |    {Tag, Location, Reason, EndTags, EventState} Rest = unicode_binary() | latin1_binary() | [unicode_char()] Tag = atom() (fatal_error or user defined tag) Location = {CurrentLocation, EntityName, LineNo} CurrentLocation = string() EntityName = string() LineNo = integer() EventState = term() Reason = term() Parse a stream containing an XML document.","ref":"xmerl_sax_parser.html#stream/2","title":"xmerl_sax_parser.stream/2","type":"function"},{"doc":"This module is the interface to the XML parser, it handles XML 1.0. The XML parser is activated through xmerl_scan:string/[1,2] or xmerl_scan:file/[1,2] . It returns records of the type defined in xmerl.hrl. See also tutorial on customization functions. DATA TYPES document() = xmlElement() | xmlDocument() The document returned by xmerl_scan:string/[1,2] and xmerl_scan:file/[1,2] . The type of the returned record depends on the value of the document option passed to the function. global_state() The global state of the scanner, represented by the #xmerl_scanner{} record. option_list() Options allow to customize the behaviour of the scanner. See also tutorial on customization functions. Possible options are: {acc_fun, Fun} Call back function to accumulate contents of entity. {continuation_fun, Fun} | {continuation_fun, Fun, ContinuationState} Call back function to decide what to do if the scanner runs into EOF before the document is complete. {event_fun, Fun} | {event_fun, Fun, EventState} Call back function to handle scanner events. {fetch_fun, Fun} | {fetch_fun, Fun, FetchState} Call back function to fetch an external resource. {hook_fun, Fun} | {hook_fun, Fun, HookState} Call back function to process the document entities once identified. {close_fun, Fun} Called when document has been completely parsed. {rules, ReadFun, WriteFun, RulesState} | {rules, Rules} Handles storing of scanner information when parsing. {user_state, UserState} Global state variable accessible from all customization functions {fetch_path, PathList} PathList is a list of directories to search when fetching files. If the file in question is not in the fetch_path, the URI will be used as a file name. {space, Flag} 'preserve' (default) to preserve spaces, 'normalize' to accumulate consecutive whitespace and replace it with one space. {line, Line} To specify starting line for scanning in document which contains fragments of XML. {namespace_conformant, Flag} Controls whether to behave as a namespace conformant XML parser, 'false' (default) to not otherwise 'true'. {validation, Flag} Controls whether to process as a validating XML parser: 'off' (default) no validation, or validation 'dtd' by DTD or 'schema' by XML Schema. 'false' and 'true' options are obsolete (i.e. they may be removed in a future release), if used 'false' equals 'off' and 'true' equals 'dtd'. {schemaLocation, [{Namespace,Link}|...]} Tells explicitly which XML Schema documents to use to validate the XML document. Used together with the {validation,schema} option. {quiet, Flag} Set to 'true' if xmerl should behave quietly and not output any information to standard output (default 'false'). {doctype_DTD, DTD} Allows to specify DTD name when it isn't available in the XML document. This option has effect only together with {validation,'dtd' option. {xmlbase, Dir} XML Base directory. If using string/1 default is current directory. If using file/1 default is directory of given file. {encoding, Enc} Set default character set used (default UTF-8). This character set is used only if not explicitly given by the XML declaration. {document, Flag} Set to 'true' if xmerl should return a complete XML document as an xmlDocument record (default 'false'). {comments, Flag} Set to 'false' if xmerl should skip comments otherwise they will be returned as xmlComment records (default 'true'). {default_attrs, Flag} Set to 'true' if xmerl should add to elements missing attributes with a defined default value (default 'false'). xmlDocument() = #xmlDocument{} The record definition is found in xmerl.hrl. xmlElement() = #xmlElement{}","ref":"xmerl_scan.html","title":"xmerl_scan","type":"module"},{"doc":"Function to accumulate and normalize whitespace.","ref":"xmerl_scan.html#accumulate_whitespace/4","title":"xmerl_scan.accumulate_whitespace/4","type":"function"},{"doc":"Equivalent to cont_state(ContinuationState, S) .","ref":"xmerl_scan.html#cont_state/1","title":"xmerl_scan.cont_state/1","type":"function"},{"doc":"For controlling the ContinuationState, to be used in a continuation function, and called when the parser encounters the end of the byte stream. See tutorial on customization functions.","ref":"xmerl_scan.html#cont_state/2","title":"xmerl_scan.cont_state/2","type":"function"},{"doc":"Equivalent to event_state(EventState, S) .","ref":"xmerl_scan.html#event_state/1","title":"xmerl_scan.event_state/1","type":"function"},{"doc":"For controlling the EventState, to be used in an event function, and called at the beginning and at the end of a parsed entity. See tutorial on customization functions.","ref":"xmerl_scan.html#event_state/2","title":"xmerl_scan.event_state/2","type":"function"},{"doc":"Equivalent to fetch_state(FetchState, S) .","ref":"xmerl_scan.html#fetch_state/1","title":"xmerl_scan.fetch_state/1","type":"function"},{"doc":"For controlling the FetchState, to be used in a fetch function, and called when the parser fetch an external resource (eg. a DTD). See tutorial on customization functions.","ref":"xmerl_scan.html#fetch_state/2","title":"xmerl_scan.fetch_state/2","type":"function"},{"doc":"Rest = list() Equivalent to file(Filename, []) .","ref":"xmerl_scan.html#file/1","title":"xmerl_scan.file/1","type":"function"},{"doc":"Rest = list() Parse file containing an XML document","ref":"xmerl_scan.html#file/2","title":"xmerl_scan.file/2","type":"function"},{"doc":"Equivalent to hook_state(HookState, S) .","ref":"xmerl_scan.html#hook_state/1","title":"xmerl_scan.hook_state/1","type":"function"},{"doc":"For controlling the HookState, to be used in a hook function, and called when the parser has parsed a complete entity. See tutorial on customization functions.","ref":"xmerl_scan.html#hook_state/2","title":"xmerl_scan.hook_state/2","type":"function"},{"doc":"Equivalent to rules_state(RulesState, S) .","ref":"xmerl_scan.html#rules_state/1","title":"xmerl_scan.rules_state/1","type":"function"},{"doc":"For controlling the RulesState, to be used in a rules function, and called when the parser store scanner information in a rules database. See tutorial on customization functions.","ref":"xmerl_scan.html#rules_state/2","title":"xmerl_scan.rules_state/2","type":"function"},{"doc":"Rest = list() Equivalent to string(Text, []) .","ref":"xmerl_scan.html#string/1","title":"xmerl_scan.string/1","type":"function"},{"doc":"Rest = list() Parse string containing an XML document","ref":"xmerl_scan.html#string/2","title":"xmerl_scan.string/2","type":"function"},{"doc":"Equivalent to user_state(UserState, S) .","ref":"xmerl_scan.html#user_state/1","title":"xmerl_scan.user_state/1","type":"function"},{"doc":"For controlling the UserState, to be used in a user function. See tutorial on customization functions.","ref":"xmerl_scan.html#user_state/2","title":"xmerl_scan.user_state/2","type":"function"},{"doc":"The xmerl_xpath module handles the entire XPath 1.0 spec. XPath expressions typically occur in XML attributes and are used to address parts of an XML document. The grammar is defined in xmerl_xpath_parse.yrl . The core functions are defined in xmerl_xpath_pred.erl . Some useful shell commands for debugging the XPath parser c ( xmerl_xpath_scan ) . yecc : yecc ( &quot;xmerl_xpath_parse.yrl&quot; , &quot;xmerl_xpath_parse&quot; , true , [ ] ) . c ( xmerl_xpath_parse ) . xmerl_xpath_parse : parse ( xmerl_xpath_scan : tokens ( &quot;position() &gt; -1&quot; ) ) . xmerl_xpath_parse : parse ( xmerl_xpath_scan : tokens ( &quot;5 * 6 div 2&quot; ) ) . xmerl_xpath_parse : parse ( xmerl_xpath_scan : tokens ( &quot;5 + 6 mod 2&quot; ) ) . xmerl_xpath_parse : parse ( xmerl_xpath_scan : tokens ( &quot;5 * 6&quot; ) ) . xmerl_xpath_parse : parse ( xmerl_xpath_scan : tokens ( &quot;-----6&quot; ) ) . xmerl_xpath_parse : parse ( xmerl_xpath_scan : tokens ( &quot;parent::node()&quot; ) ) . xmerl_xpath_parse : parse ( xmerl_xpath_scan : tokens ( &quot;descendant-or-self::node()&quot; ) ) . xmerl_xpath_parse : parse ( xmerl_xpath_scan : tokens ( &quot;parent::processing-instruction(&#39;foo&#39;)&quot; ) ) . DATA TYPES docEntity() = #xmlDocument{} | [ docNodes() ] docNodes() = #xmlElement{} | #xmlAttribute{} | #xmlText{} | #xmlPI{} | #xmlComment{} | #xmlNsNode{} nodeEntity() = #xmlElement{} | #xmlAttribute{} | #xmlText{} | #xmlPI{} | #xmlComment{} | #xmlNsNode{} | #xmlDocument{} option_list() Options allows to customize the behaviour of the XPath scanner. Possible options are: {namespace, #xmlNamespace} Set namespace nodes, from XmlNamspace, in xmlContext {namespace, Nodes} Set namespace nodes in xmlContext. parentList() = [{atom(), integer()}] xPathString() = string()","ref":"xmerl_xpath.html","title":"xmerl_xpath","type":"module"},{"doc":"Equivalent to string(Str, Doc, []) .","ref":"xmerl_xpath.html#string/2","title":"xmerl_xpath.string/2","type":"function"},{"doc":"Equivalent to string(Str, Doc, [], Doc, Options) .","ref":"xmerl_xpath.html#string/3","title":"xmerl_xpath.string/3","type":"function"},{"doc":"Str = xPathString() Node = nodeEntity() Parents = parentList() Doc = nodeEntity() Options = option_list() Scalar = #xmlObj{} Extracts the nodes from the parsed XML tree according to XPath. xmlObj is a record with fields type and value, where type is boolean | number | string","ref":"xmerl_xpath.html#string/5","title":"xmerl_xpath.string/5","type":"function"},{"doc":"Erlang has similarities to XSLT since both languages have a functional programming approach. Using xmerl_xpath it is possible to write XSLT like transforms in Erlang. XSLT stylesheets are often used when transforming XML documents, to other XML documents or (X)HTML for presentation. XSLT contains quite many functions and learning them all may take some effort. This document assumes a basic level of understanding of XSLT. Since XSLT is based on a functional programming approach with pattern matching and recursion it is possible to write similar style sheets in Erlang. At least for basic transforms. This document describes how to use the XPath implementation together with Erlangs pattern matching and a couple of functions to write XSLT like transforms. This approach is probably easier for an Erlanger but if you need to use real XSLT stylesheets in order to &quot;comply to the standard&quot; there is an adapter available to the Sablotron XSLT package which is written i C++. See also the Tutorial .","ref":"xmerl_xs.html","title":"xmerl_xs","type":"module"},{"doc":"The default fallback behaviour. Template funs should end with: template(E) -&gt; built_in_rules(fun template/1, E) .","ref":"xmerl_xs.html#built_in_rules/2","title":"xmerl_xs.built_in_rules/2","type":"function"},{"doc":"Extracts the nodes from the xml tree according to XPath. See also: value_of/1 .","ref":"xmerl_xs.html#select/2","title":"xmerl_xs.select/2","type":"function"},{"doc":"E = term() Concatenates all text nodes within the tree. Example: &lt; xsl : template match = &quot;title&quot; &gt; &lt; div align = &quot;center&quot; &gt; &lt; h1 &gt; &lt; xsl : value - of select = &quot;.&quot; / &gt; &lt; / h1 &gt; &lt; / div &gt; &lt; / xsl : template &gt; becomes: template ( E = # xmlElement { name = &#39;title&#39; } ) -&gt; [ &quot;&lt;div align=&quot; center &quot;&gt;&lt;h1&gt;&quot; , value_of ( select ( &quot;.&quot; , E ) ) , &quot;&lt;/h1&gt;&lt;/div&gt;&quot; ]","ref":"xmerl_xs.html#value_of/1","title":"xmerl_xs.value_of/1","type":"function"},{"doc":"Function = () -&gt; list() xslapply is a wrapper to make things look similar to xsl:apply-templates. Example, original XSLT: &lt; xsl : template match = &quot;doc/title&quot; &gt; &lt; h1 &gt; &lt; xsl : apply - templates / &gt; &lt; / h1 &gt; &lt; / xsl : template &gt; becomes in Erlang: template ( E = # xmlElement { parents = [ { &#39;doc&#39; , _ } | _ ] , name = &#39;title&#39; } ) -&gt; [ &quot;&lt;h1&gt;&quot; , xslapply ( fun template / 1 , E ) , &quot;&lt;/h1&gt;&quot; ] ;","ref":"xmerl_xs.html#xslapply/2","title":"xmerl_xs.xslapply/2","type":"function"},{"doc":"Interface module for XML Schema validation. It handles the W3.org specifications of XML Schema second edition 28 october 2004. For an introduction to XML Schema study part 0. An XML structure is validated by xmerl_xsd:validate/[2,3]. DATA TYPES filename() = string() global_state() The global state of the validator. It is representated by the #xsd_state{} record. option_list() Options allow to customize the behaviour of the validation. Possible options are : {tab2file,boolean()} Enables saving of abstract structure on file for debugging purpose. {xsdbase,filename()} XSD Base directory. {fetch_fun,FetchFun} Call back function to fetch an external resource. {fetch_path,PathList} PathList is a list of directories to search when fetching files. If the file in question is not in the fetch_path, the URI will be used as a file name. {state,State} It is possible by this option to provide a state with process information from an earlier validation.","ref":"xmerl_xsd.html","title":"xmerl_xsd","type":"module"},{"doc":"State = global_state() FileName = string() Reads the schema state with all information of the processed schema from a file created with state2file/[1,2] . The format of this file is internal. The state can then be used validating an XML document.","ref":"xmerl_xsd.html#file2state/1","title":"xmerl_xsd.file2state/1","type":"function"},{"doc":"Errors = tuple() | [tuple()] Result = string() | [string()] Formats error descriptions to human readable strings.","ref":"xmerl_xsd.html#format_error/1","title":"xmerl_xsd.format_error/1","type":"function"},{"doc":"Equivalent to process_schema(Schema, []) .","ref":"xmerl_xsd.html#process_schema/1","title":"xmerl_xsd.process_schema/1","type":"function"},{"doc":"Schema = string() Result = {ok, State} | {error, Reason} State = global_state() Reason = [ErrorReason] | ErrorReason Options = option_list() Reads the referenced XML schema and checks that it is valid. Returns the global_state() with schema info or an error reason. The error reason may be a list of several errors or a single error encountered during the processing.","ref":"xmerl_xsd.html#process_schema/2","title":"xmerl_xsd.process_schema/2","type":"function"},{"doc":"Equivalent to process_schema(Schemas, []) .","ref":"xmerl_xsd.html#process_schemas/1","title":"xmerl_xsd.process_schemas/1","type":"function"},{"doc":"Schemas = [{NameSpace, string()} | Schemas] | [] Result = {ok, State} | {error, Reason} Reason = [ErrorReason] | ErrorReason Options = option_list() Reads the referenced XML schemas and controls they are valid. Returns the global_state() with schema info or an error reason. The error reason may be a list of several errors or a single error encountered during the processing.","ref":"xmerl_xsd.html#process_schemas/2","title":"xmerl_xsd.process_schemas/2","type":"function"},{"doc":"Equivalent to process_validate(Schema, Xml, []) .","ref":"xmerl_xsd.html#process_validate/2","title":"xmerl_xsd.process_validate/2","type":"function"},{"doc":"Schema = string() Element = XmlElement Options = option_list() Result = {ValidXmlElement, State} | {error, Reason} Reason = [ErrorReason] | ErrorReason Validates a parsed well-formed XML element towards an XML schema. Validates in two steps. First it processes the schema, saves the type and structure info in an ets table and then validates the element towards the schema. Usage example: 1&gt;{E,_} = xmerl_scan:file(&quot;my_XML_document.xml&quot;). 2&gt;{E2,_} = xmerl_xsd:validate(&quot;my_XML_Schema.xsd&quot;,E). Observe that E2 may differ from E if for instance there are default values defined in my_XML_Schema.xsd .","ref":"xmerl_xsd.html#process_validate/3","title":"xmerl_xsd.process_validate/3","type":"function"},{"doc":"Same as state2file(State,SchemaName) The name of the saved file is the same as the name of the schema, but with .xss extension.","ref":"xmerl_xsd.html#state2file/1","title":"xmerl_xsd.state2file/1","type":"function"},{"doc":"State = global_state() FileName = string() Saves the schema state with all information of the processed schema in a file. You can provide the file name for the saved state. FileName is saved with the .xss extension added.","ref":"xmerl_xsd.html#state2file/2","title":"xmerl_xsd.state2file/2","type":"function"},{"doc":"Equivalent to validate(Element, State, []) .","ref":"xmerl_xsd.html#validate/2","title":"xmerl_xsd.validate/2","type":"function"},{"doc":"Element = XmlElement Options = option_list() Result = {ValidElement, global_state() } | {error, Reasons} ValidElement = XmlElement State = global_state() Reasons = [ErrorReason] | ErrorReason Validates a parsed well-formed XML element (Element). A call to validate/2 or validate/3 must provide a well formed parsed XML element #xmlElement{} and a State, global_state() , which holds necessary information from an already processed schema. Thus validate enables reuse of the schema information and therefore if one shall validate several times towards the same schema it reduces time consumption. The result, ValidElement, is the valid element that conforms to the post-schema-validation infoset. When the validator finds an error it tries to continue and reports a list of all errors found. In those cases an unexpected error is found it may cause a single error reason. Usage example: 1&gt;{E,_} = xmerl_scan:file(&quot;my_XML_document.xml&quot;). 2&gt;{ok,S} = xmerl_xsd:process_schema(&quot;my_XML_Schema.xsd&quot;). 3&gt;{E2,_} = xmerl_xsd:validate(E,S). Observe that E2 may differ from E if for instance there are default values defined in my_XML_Schema.xsd .","ref":"xmerl_xsd.html#validate/3","title":"xmerl_xsd.validate/3","type":"function"}]