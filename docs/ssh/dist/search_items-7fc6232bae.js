searchNodes=[{"doc":"This is the interface module for the SSH application. The Secure Shell (SSH) Protocol is a protocol for secure remote login and other secure network services over an insecure network. See ssh(6) for details of supported RFCs, versions, algorithms and unicode handling. With the SSH application it is possible to start clients and to start daemons (servers). Clients are started with connect/2 , connect/3 or connect/4 . They open an encrypted connection on top of TCP/IP. In that encrypted connection one or more channels could be opened with ssh_connection:session_channel/2,4 . Each channel is an isolated &quot;pipe&quot; between a client-side process and a server-side process. Those process pairs could handle for example file transfers (sftp) or remote command execution (shell, exec and/or cli). If a custom shell is implemented, the user of the client could execute the special commands remotely. Note that the user is not necessarily a human but probably a system interfacing the SSH app. A server-side subssystem (channel) server is requested by the client with ssh_connection:subsystem/4 . A server (daemon) is started with daemon/1 , daemon/2 or daemon/3 . Possible channel handlers (subsystems) are declared with the subsystem option when the daemon is started. To just run a shell on a remote machine, there are functions that bundles the needed three steps needed into one: shell/1,2,3 . Similarily, to just open an sftp (file transfer) connection to a remote machine, the simplest way is to use ssh_sftp:start_channel/1,2,3 . To write your own client channel handler, use the behaviour ssh_client_channel . For server channel handlers use ssh_server_channel behaviour (replaces ssh_daemon_channel). Both clients and daemons accepts options that controls the exact behaviour. Some options are common to both. The three sets are called Client Options , Daemon Options and Common Options . The descriptions of the options uses the Erlang Type Language with explaining text. The User's Guide has examples and a Getting Started section. Keys and files A number of objects must be present for the SSH application to work. Those objects are per default stored in files. The default names, paths and file formats are the same as for OpenSSH . Keys could be generated with the ssh-keygen program from OpenSSH. See the User's Guide. The paths could easily be changed by options: user_dir and system_dir . A completly different storage could be interfaced by writing call-back modules using the behaviours ssh_client_key_api and/or ssh_server_key_api . A callback module is installed with the option key_cb to the client and/or the daemon. Daemons The keys are by default stored in files: Mandatory: one or more Host key(s) , both private and public. Default is to store them in the directory /etc/ssh in the files ssh_host_dsa_key and ssh_host_dsa_key.pub ssh_host_rsa_key and ssh_host_rsa_key.pub ssh_host_ecdsa_key and ssh_host_ecdsa_key.pub The host keys directory could be changed with the option system_dir . Optional: one or more User's public key in case of publickey authorization. Default is to store them concatenated in the file .ssh/authorized_keys in the user's home directory. The user keys directory could be changed with the option user_dir . Clients The keys and some other data are by default stored in files in the directory .ssh in the user's home directory. The directory could be changed with the option user_dir . Optional: a list of Host public key(s) for previously connected hosts. This list is handled by the SSH application without any need of user assistance. The default is to store them in the file known_hosts . The host_accepting_client_options() are associated with this list of keys. Optional: one or more User's private key(s) in case of publickey authorization. The default files are id_dsa and id_dsa.pub id_rsa and id_rsa.pub id_ecdsa and id_ecdsa.pub","ref":"ssh.html","title":"ssh","type":"module"},{"doc":"Closes an SSH connection.","ref":"ssh.html#close/1","title":"ssh.close/1","type":"function"},{"doc":"Host = host() Port = inet:port_number() Options = client_options() TcpSocket = open_socket() NegotiationTimeout = timeout() Result = {ok, connection_ref() } | {error, term()} Connects to an SSH server at the Host on Port . As an alternative, an already open TCP socket could be passed to the function in TcpSocket . The SSH initiation and negotiation will be initiated on that one with the SSH that should be at the other end. No channel is started. This is done by calling ssh_connection:session_channel/[2, 4] . The NegotiationTimeout is in milli-seconds. The default value is infinity . For connection timeout, use the option connect_timeout .","ref":"ssh.html#connect/2","title":"ssh.connect/2","type":"function"},{"doc":"","ref":"ssh.html#connect/3","title":"ssh.connect/3","type":"function"},{"doc":"","ref":"ssh.html#connect/4","title":"ssh.connect/4","type":"function"},{"doc":"Returns information about a connection intended for e.g debugging or logging. When the Key is a single Item , the result is a single InfoTuple","ref":"ssh.html#connection_info/1","title":"ssh.connection_info/1","type":"function"},{"doc":"","ref":"ssh.html#connection_info/2","title":"ssh.connection_info/2","type":"function"},{"doc":"Port = integer() TcpSocket = open_socket() Options = daemon_options() HostAddress = host() | any Result = {ok, daemon_ref() } | {error, atom()} Starts a server listening for SSH connections on the given port. If the Port is 0, a random free port is selected. See daemon_info/1 about how to find the selected port number. As an alternative, an already open TCP socket could be passed to the function in TcpSocket . The SSH initiation and negotiation will be initiated on that one when an SSH starts at the other end of the TCP socket. For a description of the options, see Daemon Options . Please note that by historical reasons both the HostAddress argument and the gen_tcp connect_option() {ip,Address} set the listening address. This is a source of possible inconsistent settings. The rules for handling the two address passing options are: if HostAddress is an IP-address, that IP-address is the listening address. An 'ip'-option will be discarded if present. if HostAddress is the atom loopback , the listening address is loopback and an loopback address will be choosen by the underlying layers. An 'ip'-option will be discarded if present. if HostAddress is the atom any and no 'ip'-option is present, the listening address is any and the socket will listen to all addresses if HostAddress is any and an 'ip'-option is present, the listening address is set to the value of the 'ip'-option","ref":"ssh.html#daemon/1","title":"ssh.daemon/1","type":"function"},{"doc":"","ref":"ssh.html#daemon/2","title":"ssh.daemon/2","type":"function"},{"doc":"","ref":"ssh.html#daemon/3","title":"ssh.daemon/3","type":"function"},{"doc":"Returns information about a daemon intended for e.g debugging or logging. When the Key is a single Item , the result is a single InfoTuple Note that daemon_info/1 and daemon_info/2 returns different types due to compatibility reasons.","ref":"ssh.html#daemon_info/1","title":"ssh.daemon_info/1","type":"function"},{"doc":"","ref":"ssh.html#daemon_info/2","title":"ssh.daemon_info/2","type":"function"},{"doc":"Returns a key-value list, where the keys are the different types of algorithms and the values are the algorithms themselves. See the User's Guide for an example.","ref":"ssh.html#default_algorithms/0","title":"ssh.default_algorithms/0","type":"function"},{"doc":"Get tcp socket option values of the tcp-socket below an ssh connection. This function calls the inet:getopts/2 , read that documentation.","ref":"ssh.html#get_sock_opts/2","title":"ssh.get_sock_opts/2","type":"function"},{"doc":"HostKey = public_key:public_key() DigestType = public_key:digest_type() Calculates a ssh fingerprint from a public host key as openssh does. The algorithm in hostkey_fingerprint/1 is md5 to be compatible with older ssh-keygen commands. The string from the second variant is prepended by the algorithm name in uppercase as in newer ssh-keygen commands. Examples: 2 &gt; ssh : hostkey_fingerprint ( Key ) . &quot;f5:64:a6:c1:5a:cb:9f:0a:10:46:a2:5c:3e:2f:57:84&quot; 3 &gt; ssh : hostkey_fingerprint ( md5 , Key ) . &quot;MD5:f5:64:a6:c1:5a:cb:9f:0a:10:46:a2:5c:3e:2f:57:84&quot; 4 &gt; ssh : hostkey_fingerprint ( sha , Key ) . &quot;SHA1:bSLY/C4QXLDL/Iwmhyg0PGW9UbY&quot; 5 &gt; ssh : hostkey_fingerprint ( sha256 , Key ) . &quot;SHA256:aZGXhabfbf4oxglxltItWeHU7ub3Dc31NcNw2cMJePQ&quot; 6 &gt; ssh : hostkey_fingerprint ( [ sha , sha256 ] , Key ) . [ &quot;SHA1:bSLY/C4QXLDL/Iwmhyg0PGW9UbY&quot; , &quot;SHA256:aZGXhabfbf4oxglxltItWeHU7ub3Dc31NcNw2cMJePQ&quot; ]","ref":"ssh.html#hostkey_fingerprint/1","title":"ssh.hostkey_fingerprint/1","type":"function"},{"doc":"","ref":"ssh.html#hostkey_fingerprint/2","title":"ssh.hostkey_fingerprint/2","type":"function"},{"doc":"Sets tcp socket options on the tcp-socket below an ssh connection. This function calls the inet:setopts/2 , read that documentation and for gen_tcp:option() . All gen_tcp socket options except active deliver mode and packet are allowed. The excluded options are reserved by the SSH application. This is an extremly dangerous function. You use it on your own risk. Some options are OS and OS version dependent. Do not use it unless you know what effect your option values will have on an TCP stream. Some values may destroy the functionality of the SSH protocol.","ref":"ssh.html#set_sock_opts/2","title":"ssh.set_sock_opts/2","type":"function"},{"doc":"Host = host() TcpSocket = open_socket() Port = inet:port_number() Options = client_options() Result = ok | {error, Reason::term()} Connects to an SSH server at Host and Port (defaults to 22) and starts an interactive shell on that remote host. As an alternative, an already open TCP socket could be passed to the function in TcpSocket . The SSH initiation and negotiation will be initiated on that one and finaly a shell will be started on the host at the other end of the TCP socket. For a description of the options, see Client Options . The function waits for user input, and does not return until the remote shell is ended (that is, exit from the shell).","ref":"ssh.html#shell/1","title":"ssh.shell/1","type":"function"},{"doc":"","ref":"ssh.html#shell/2","title":"ssh.shell/2","type":"function"},{"doc":"","ref":"ssh.html#shell/3","title":"ssh.shell/3","type":"function"},{"doc":"Utility function that starts the applications crypto , public_key , and ssh . Default type is temporary . For more information, see the application(3) manual page in Kernel.","ref":"ssh.html#start/0","title":"ssh.start/0","type":"function"},{"doc":"","ref":"ssh.html#start/1","title":"ssh.start/1","type":"function"},{"doc":"Stops the ssh application. For more information, see the application(3) manual page in Kernel.","ref":"ssh.html#stop/0","title":"ssh.stop/0","type":"function"},{"doc":"Stops the listener and all connections started by the listener.","ref":"ssh.html#stop_daemon/1","title":"ssh.stop_daemon/1","type":"function"},{"doc":"","ref":"ssh.html#stop_daemon/2","title":"ssh.stop_daemon/2","type":"function"},{"doc":"","ref":"ssh.html#stop_daemon/3","title":"ssh.stop_daemon/3","type":"function"},{"doc":"Stops the listener, but leaves existing connections started by the listener operational.","ref":"ssh.html#stop_listener/1","title":"ssh.stop_listener/1","type":"function"},{"doc":"","ref":"ssh.html#stop_listener/2","title":"ssh.stop_listener/2","type":"function"},{"doc":"","ref":"ssh.html#stop_listener/3","title":"ssh.stop_listener/3","type":"function"},{"doc":"Asks the remote server of ConnectionRef to listen to ListenHost:ListenPort . When someone connects that address, the connection is forwarded in an encrypted channel from the server to the client. The client (that is, at the node that calls this function) then connects to ConnectToHost:ConnectToPort . The returned TrueListenPort is the port that is listened to. It is the same as ListenPort , except when ListenPort = 0 . In that case a free port is selected by the underlying OS. Note that in case of an Erlang/OTP SSH server (daemon) as peer, that server must have been started with the option tcpip_tunnel_out to allow the connection.","ref":"ssh.html#tcpip_tunnel_from_server/5","title":"ssh.tcpip_tunnel_from_server/5","type":"function"},{"doc":"","ref":"ssh.html#tcpip_tunnel_from_server/6","title":"ssh.tcpip_tunnel_from_server/6","type":"function"},{"doc":"Tells the local client to listen to ListenHost:ListenPort . When someone connects to that address, the connection is forwarded in an encrypted channel to the peer server of ConnectionRef . That server then connects to ConnectToHost:ConnectToPort . The returned TrueListenPort is the port that is listened to. It is the same as ListenPort , except when ListenPort = 0 . In that case a free port is selected by the underlying OS. Note that in case of an Erlang/OTP SSH server (daemon) as peer, that server must have been started with the option tcpip_tunnel_in to allow the connection.","ref":"ssh.html#tcpip_tunnel_to_server/5","title":"ssh.tcpip_tunnel_to_server/5","type":"function"},{"doc":"","ref":"ssh.html#tcpip_tunnel_to_server/6","title":"ssh.tcpip_tunnel_to_server/6","type":"function"},{"doc":"silently_accept_hosts This option guides the connect function on how to act when the connected server presents a Host Key that the client has not seen before. The default is to ask the user with a question on stdio of whether to accept or reject the new Host Key. See the option user_dir for specifying the path to the file known_hosts where previously accepted Host Keys are recorded. See also the option key_cb for the general way to handle keys. The option can be given in three different forms as seen above : The value is a boolean() . The value true will make the client accept any unknown Host Key without any user interaction. The value false preserves the default behaviour of asking the user on stdio. An accept_callback() will be called and the boolean return value true will make the client accept the Host Key. A return value of false will make the client to reject the Host Key and as a result the connection will be closed. The arguments to the fun are: PeerName - a string with the name or address of the remote host. FingerPrint - the fingerprint of the Host Key as hostkey_fingerprint/1 calculates it. A tuple {HashAlgoSpec, accept_callback} . The HashAlgoSpec specifies which hash algorithm shall be used to calculate the fingerprint used in the call of the accept_callback() . The HashALgoSpec is either an atom or a list of atoms as the first argument in hostkey_fingerprint/2 . If it is a list of hash algorithm names, the FingerPrint argument in the accept_callback() will be a list of fingerprints in the same order as the corresponding name in the HashAlgoSpec list. user_interaction If false , disables the client to connect to the server if any user interaction is needed, such as accepting the server to be added to the known_hosts file, or supplying a password. Even if user interaction is allowed it can be suppressed by other options, such as silently_accept_hosts and password . However, those options are not always desirable to use from a security point of view. Defaults to true . save_accepted_host If true , the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option key_cb is not present, the key is saved in the file &quot;known_hosts&quot;. See option user_dir for the location of that file. If false , the key is not saved and the key will still be unknown at the next access of the same host. Defaults to true quiet_mode If true , the client does not print anything on authorization. Defaults to false","ref":"ssh.html#t:accept_callback/0","title":"ssh.accept_callback/0","type":"type"},{"doc":"silently_accept_hosts This option guides the connect function on how to act when the connected server presents a Host Key that the client has not seen before. The default is to ask the user with a question on stdio of whether to accept or reject the new Host Key. See the option user_dir for specifying the path to the file known_hosts where previously accepted Host Keys are recorded. See also the option key_cb for the general way to handle keys. The option can be given in three different forms as seen above : The value is a boolean() . The value true will make the client accept any unknown Host Key without any user interaction. The value false preserves the default behaviour of asking the user on stdio. An accept_callback() will be called and the boolean return value true will make the client accept the Host Key. A return value of false will make the client to reject the Host Key and as a result the connection will be closed. The arguments to the fun are: PeerName - a string with the name or address of the remote host. FingerPrint - the fingerprint of the Host Key as hostkey_fingerprint/1 calculates it. A tuple {HashAlgoSpec, accept_callback} . The HashAlgoSpec specifies which hash algorithm shall be used to calculate the fingerprint used in the call of the accept_callback() . The HashALgoSpec is either an atom or a list of atoms as the first argument in hostkey_fingerprint/2 . If it is a list of hash algorithm names, the FingerPrint argument in the accept_callback() will be a list of fingerprints in the same order as the corresponding name in the HashAlgoSpec list. user_interaction If false , disables the client to connect to the server if any user interaction is needed, such as accepting the server to be added to the known_hosts file, or supplying a password. Even if user interaction is allowed it can be suppressed by other options, such as silently_accept_hosts and password . However, those options are not always desirable to use from a security point of view. Defaults to true . save_accepted_host If true , the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option key_cb is not present, the key is saved in the file &quot;known_hosts&quot;. See option user_dir for the location of that file. If false , the key is not saved and the key will still be unknown at the next access of the same host. Defaults to true quiet_mode If true , the client does not print anything on authorization. Defaults to false","ref":"ssh.html#t:accept_hosts/0","title":"ssh.accept_hosts/0","type":"type"},{"doc":"List of algorithms to use in the algorithm negotiation. The default algs_list() can be obtained from default_algorithms/0 . If an alg_entry() is missing in the algs_list(), the default value is used for that entry. Here is an example of this option: { preferred_algorithms , [ { public_key , [ &#39;ssh-rsa&#39; , &#39;ssh-dss&#39; ] } , { cipher , [ { client2server , [ &#39;aes128-ctr&#39; ] } , { server2client , [ &#39;aes128-cbc&#39; , &#39;3des-cbc&#39; ] } ] } , { mac , [ &#39;hmac-sha2-256&#39; , &#39;hmac-sha1&#39; ] } , { compression , [ none , zlib ] } ] } The example specifies different algorithms in the two directions (client2server and server2client), for cipher but specifies the same algorithms for mac and compression in both directions. The kex (key exchange) is implicit but public_key is set explicitly. For background and more examples see the User's Guide. If an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the property lists are also assumed to occur at most one time. Changing the values can make a connection less secure. Do not change unless you know exactly what you are doing. If you do not understand the values then you are not supposed to change them.","ref":"ssh.html#t:alg_entry/0","title":"ssh.alg_entry/0","type":"type"},{"doc":"List of algorithms to use in the algorithm negotiation. The default algs_list() can be obtained from default_algorithms/0 . If an alg_entry() is missing in the algs_list(), the default value is used for that entry. Here is an example of this option: { preferred_algorithms , [ { public_key , [ &#39;ssh-rsa&#39; , &#39;ssh-dss&#39; ] } , { cipher , [ { client2server , [ &#39;aes128-ctr&#39; ] } , { server2client , [ &#39;aes128-cbc&#39; , &#39;3des-cbc&#39; ] } ] } , { mac , [ &#39;hmac-sha2-256&#39; , &#39;hmac-sha1&#39; ] } , { compression , [ none , zlib ] } ] } The example specifies different algorithms in the two directions (client2server and server2client), for cipher but specifies the same algorithms for mac and compression in both directions. The kex (key exchange) is implicit but public_key is set explicitly. For background and more examples see the User's Guide. If an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the property lists are also assumed to occur at most one time. Changing the values can make a connection less secure. Do not change unless you know exactly what you are doing. If you do not understand the values then you are not supposed to change them.","ref":"ssh.html#t:algs_list/0","title":"ssh.algs_list/0","type":"type"},{"doc":"Comma-separated string that determines which authentication methods that the client shall support and in which order they are tried. Defaults to &quot;publickey,keyboard-interactive,password&quot; Note that the client is free to use any order and to exclude methods.","ref":"ssh.html#t:auth_methods_common_option/0","title":"ssh.auth_methods_common_option/0","type":"type"},{"doc":"user Provides the username. If this option is not given, ssh reads from the environment ( LOGNAME or USER on UNIX, USERNAME on Windows). password Provides a password for password authentication. If this option is not given, the user is asked for a password, if the password authentication method is attempted.","ref":"ssh.html#t:authentication_client_options/0","title":"ssh.authentication_client_options/0","type":"type"},{"doc":"auth_method_kb_interactive_data Sets the text strings that the daemon sends to the client for presentation to the user when using keyboard-interactive authentication. If the fun/3 or fun/4 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc. The parameter Echo guides the client about need to hide the password. The default value is: {auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \\&quot;&quot;++User++&quot;\\&quot;&quot;, &quot;password: &quot;, false}&gt; user_passwords Provides passwords for password authentication. The passwords are used when someone tries to connect to the server and public key user-authentication fails. The option provides a list of valid usernames and the corresponding passwords. Note that this is very insecure due to the plain-text passwords; it is intended for test purposes. Use the pwdfun option to handle the password checking instead. pk_check_user Enables checking of the client's user name in the server when doing public key authentication. It is disabled by default. The term &quot;user&quot; is used differently in OpenSSH and SSH in Erlang/OTP: see more in the User's Guide. If the option is enabled, and no pwdfun is present, the user name must present in the user_passwords for the check to succeed but the value of the password is not checked. In case of a pwdfun checking the user, the atom pubkey is put in the password argument. password Provides a global password that authenticates any user. Intended to facilitate testing. From a security perspective this option makes the server very vulnerable. pwdfun with pwdfun_4() Provides a function for password validation. This could used for calling an external system or handeling passwords stored as hash values. This fun can also be used to make delays in authentication tries for example by calling timer:sleep/1 . To facilitate for instance counting of failed tries, the State variable could be used. This state is per connection only. The first time the pwdfun is called for a connection, the State variable has the value undefined . The fun should return: true if the user and password is valid false if the user or password is invalid disconnect if a SSH_MSG_DISCONNECT message should be sent immediately. It will be followed by a close of the underlying tcp connection. {true, NewState:any()} if the user and password is valid {false, NewState:any()} if the user or password is invalid A third usage is to block login attempts from a missbehaving peer. The State described above can be used for this. The return value disconnect is useful for this. In case of the pk_check_user is set, the atom pubkey is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid. pwdfun with pwdfun_2() Provides a function for password validation. This function is called with user and password as strings, and returns: true if the user and password is valid false if the user or password is invalid In case of the pk_check_user is set, the atom pubkey is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid. This variant is kept for compatibility.","ref":"ssh.html#t:authentication_daemon_options/0","title":"ssh.authentication_daemon_options/0","type":"type"},{"doc":"connectfun Provides a fun to implement your own logging when a user authenticates to the server. failfun Provides a fun to implement your own logging when a user fails to authenticate.","ref":"ssh.html#t:callbacks_daemon_options/0","title":"ssh.callbacks_daemon_options/0","type":"type"},{"doc":"Opaque data type representing a channel inside a connection. Returned by the functions ssh_connection:session_channel/2,4 .","ref":"ssh.html#t:channel_id/0","title":"ssh.channel_id/0","type":"opaque"},{"doc":"List of algorithms to use in the algorithm negotiation. The default algs_list() can be obtained from default_algorithms/0 . If an alg_entry() is missing in the algs_list(), the default value is used for that entry. Here is an example of this option: { preferred_algorithms , [ { public_key , [ &#39;ssh-rsa&#39; , &#39;ssh-dss&#39; ] } , { cipher , [ { client2server , [ &#39;aes128-ctr&#39; ] } , { server2client , [ &#39;aes128-cbc&#39; , &#39;3des-cbc&#39; ] } ] } , { mac , [ &#39;hmac-sha2-256&#39; , &#39;hmac-sha1&#39; ] } , { compression , [ none , zlib ] } ] } The example specifies different algorithms in the two directions (client2server and server2client), for cipher but specifies the same algorithms for mac and compression in both directions. The kex (key exchange) is implicit but public_key is set explicitly. For background and more examples see the User's Guide. If an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the property lists are also assumed to occur at most one time. Changing the values can make a connection less secure. Do not change unless you know exactly what you are doing. If you do not understand the values then you are not supposed to change them.","ref":"ssh.html#t:cipher_alg/0","title":"ssh.cipher_alg/0","type":"type"},{"doc":"Options for clients . The individual options are further explained below or by following the hyperlinks. Note that not every gen_tcp:connect_option() is accepted. See set_sock_opts/2 for a list of prohibited options. Also note that setting a gen_tcp:connect_option() could change the socket in a way that impacts the ssh client's behaviour negatively. You use it on your own risk.","ref":"ssh.html#t:client_option/0","title":"ssh.client_option/0","type":"type"},{"doc":"Options for clients . The individual options are further explained below or by following the hyperlinks. Note that not every gen_tcp:connect_option() is accepted. See set_sock_opts/2 for a list of prohibited options. Also note that setting a gen_tcp:connect_option() could change the socket in a way that impacts the ssh client's behaviour negatively. You use it on your own risk.","ref":"ssh.html#t:client_options/0","title":"ssh.client_options/0","type":"type"},{"doc":"The options above can be used both in clients and in daemons (servers). They are further explained below.","ref":"ssh.html#t:common_option/0","title":"ssh.common_option/0","type":"type"},{"doc":"The options above can be used both in clients and in daemons (servers). They are further explained below.","ref":"ssh.html#t:common_options/0","title":"ssh.common_options/0","type":"type"},{"doc":"List of algorithms to use in the algorithm negotiation. The default algs_list() can be obtained from default_algorithms/0 . If an alg_entry() is missing in the algs_list(), the default value is used for that entry. Here is an example of this option: { preferred_algorithms , [ { public_key , [ &#39;ssh-rsa&#39; , &#39;ssh-dss&#39; ] } , { cipher , [ { client2server , [ &#39;aes128-ctr&#39; ] } , { server2client , [ &#39;aes128-cbc&#39; , &#39;3des-cbc&#39; ] } ] } , { mac , [ &#39;hmac-sha2-256&#39; , &#39;hmac-sha1&#39; ] } , { compression , [ none , zlib ] } ] } The example specifies different algorithms in the two directions (client2server and server2client), for cipher but specifies the same algorithms for mac and compression in both directions. The kex (key exchange) is implicit but public_key is set explicitly. For background and more examples see the User's Guide. If an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the property lists are also assumed to occur at most one time. Changing the values can make a connection less secure. Do not change unless you know exactly what you are doing. If you do not understand the values then you are not supposed to change them.","ref":"ssh.html#t:compression_alg/0","title":"ssh.compression_alg/0","type":"type"},{"doc":"Return values from the connection_info/1 and connection_info/2 functions. In the option info tuple are only the options included that differs from the default values.","ref":"ssh.html#t:conn_info_algs/0","title":"ssh.conn_info_algs/0","type":"type"},{"doc":"Return values from the connection_info/1 and connection_info/2 functions. In the option info tuple are only the options included that differs from the default values.","ref":"ssh.html#t:conn_info_channels/0","title":"ssh.conn_info_channels/0","type":"type"},{"doc":"Sets a timeout on the transport layer connect time. For gen_tcp the time is in milli-seconds and the default value is infinity . See the parameter Timeout in connect/4 for a timeout of the negotiation phase.","ref":"ssh.html#t:connect_timeout_client_option/0","title":"ssh.connect_timeout_client_option/0","type":"type"},{"doc":"Return values from the connection_info/1 and connection_info/2 functions. In the option info tuple are only the options included that differs from the default values.","ref":"ssh.html#t:connection_info_tuple/0","title":"ssh.connection_info_tuple/0","type":"type"},{"doc":"Opaque data type representing a connection between a client and a server (daemon). Returned by the functions connect/2,3,4 and ssh_sftp:start_channel/2,3 .","ref":"ssh.html#t:connection_ref/0","title":"ssh.connection_ref/0","type":"type"},{"doc":"Return values from the daemon_info/1 and daemon_info/2 functions. In the option info tuple are only the options included that differs from the default values.","ref":"ssh.html#t:daemon_info_tuple/0","title":"ssh.daemon_info_tuple/0","type":"type"},{"doc":"Options for daemons . The individual options are further explained below or by following the hyperlinks. Note that not every gen_tcp:listen_option() is accepted. See set_sock_opts/2 for a list of prohibited options. Also note that setting a gen_tcp:listen_option() could change the socket in a way that impacts the ssh deamon's behaviour negatively. You use it on your own risk.","ref":"ssh.html#t:daemon_option/0","title":"ssh.daemon_option/0","type":"type"},{"doc":"Options for daemons . The individual options are further explained below or by following the hyperlinks. Note that not every gen_tcp:listen_option() is accepted. See set_sock_opts/2 for a list of prohibited options. Also note that setting a gen_tcp:listen_option() could change the socket in a way that impacts the ssh deamon's behaviour negatively. You use it on your own risk.","ref":"ssh.html#t:daemon_options/0","title":"ssh.daemon_options/0","type":"type"},{"doc":"Opaque data type representing a daemon. Returned by the functions daemon/1,2,3 .","ref":"ssh.html#t:daemon_ref/0","title":"ssh.daemon_ref/0","type":"opaque"},{"doc":"Old-style exec specification that are kept for compatibility, but should not be used in new programs","ref":"ssh.html#t:deprecated_exec_opt/0","title":"ssh.deprecated_exec_opt/0","type":"type"},{"doc":"Sets the three diffie-hellman-group-exchange parameters that guides the connected server in choosing a group. See RFC 4419 for the details. The default value is {1024, 6144, 8192} .","ref":"ssh.html#t:diffie_hellman_group_exchange_client_option/0","title":"ssh.diffie_hellman_group_exchange_client_option/0","type":"type"},{"doc":"dh_gex_groups Defines the groups the server may choose among when diffie-hellman-group-exchange is negotiated. See RFC 4419 for details. The three variants of this option are: {Size=integer(),G=integer(),P=integer()} The groups are given explicitly in this list. There may be several elements with the same Size . In such a case, the server will choose one randomly in the negotiated Size. {file,filename()} The file must have one or more three-tuples {Size=integer(),G=integer(),P=integer()} terminated by a dot. The file is read when the daemon starts. {ssh_moduli_file,filename()} The file must be in ssh-keygen moduli file format . The file is read when the daemon starts. The default list is fetched from the public_key application. dh_gex_limits Limits what a client can ask for in diffie-hellman-group-exchange. The limits will be {MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)} where MaxClient and MinClient are the values proposed by a connecting client. The default value is {0,infinity} . If MaxUsed &lt; MinUsed in a key exchange, it will fail with a disconnect. See RFC 4419 for the function of the Max and Min values.","ref":"ssh.html#t:diffie_hellman_group_exchange_daemon_option/0","title":"ssh.diffie_hellman_group_exchange_daemon_option/0","type":"type"},{"doc":"Provides a fun to implement your own logging or other handling at disconnects.","ref":"ssh.html#t:disconnectfun_common_option/0","title":"ssh.disconnectfun_common_option/0","type":"type"},{"doc":"List of algorithms to use in the algorithm negotiation. The default algs_list() can be obtained from default_algorithms/0 . If an alg_entry() is missing in the algs_list(), the default value is used for that entry. Here is an example of this option: { preferred_algorithms , [ { public_key , [ &#39;ssh-rsa&#39; , &#39;ssh-dss&#39; ] } , { cipher , [ { client2server , [ &#39;aes128-ctr&#39; ] } , { server2client , [ &#39;aes128-cbc&#39; , &#39;3des-cbc&#39; ] } ] } , { mac , [ &#39;hmac-sha2-256&#39; , &#39;hmac-sha1&#39; ] } , { compression , [ none , zlib ] } ] } The example specifies different algorithms in the two directions (client2server and server2client), for cipher but specifies the same algorithms for mac and compression in both directions. The kex (key exchange) is implicit but public_key is set explicitly. For background and more examples see the User's Guide. If an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the property lists are also assumed to occur at most one time. Changing the values can make a connection less secure. Do not change unless you know exactly what you are doing. If you do not understand the values then you are not supposed to change them.","ref":"ssh.html#t:double_algs/1","title":"ssh.double_algs/1","type":"type"},{"doc":"","ref":"ssh.html#t:exec_daemon_option/0","title":"ssh.exec_daemon_option/0","type":"type"},{"doc":"","ref":"ssh.html#t:exec_fun/0","title":"ssh.exec_fun/0","type":"type"},{"doc":"","ref":"ssh.html#t:exec_fun/1/0","title":"ssh.exec_fun/1/0","type":"type"},{"doc":"","ref":"ssh.html#t:exec_fun/2/0","title":"ssh.exec_fun/2/0","type":"type"},{"doc":"","ref":"ssh.html#t:exec_fun/3/0","title":"ssh.exec_fun/3/0","type":"type"},{"doc":"This option changes how the daemon executes exec-requests from clients. The term in the return value is formatted to a string if it is a non-string type. No trailing newline is added in the ok-case. See the User's Guide section on One-Time Execution for examples. Error texts are returned on channel-type 1 which usually is piped to stderr on e.g Linux systems. Texts from a successful execution are returned on channel-type 0 and will in similar manner be piped to stdout . The exit-status code is set to 0 for success and 255 for errors. The exact results presented on the client side depends on the client and the client's operating system. In case of the {direct, exec_fun()} variant or no exec-option at all, all reads from standard_input will be from the received data-events of type 0. Those are sent by the client. Similarily all writes to standard_output will be sent as data-events to the client. An OS shell client like the command 'ssh' will usally use stdin and stdout for the user interface. The option cooperates with the daemon-option shell in the following way: 1. If neither the exec-option nor the shell-option is present: The default Erlang evaluator is used both for exec and shell requests. The result is returned to the client. 2. If the exec_spec 's value is disabled (the shell-option may or may not be present): No exec-requests are executed but shell-requests are not affected, they follow the shell_spec 's value. 3. If the exec-option is present and the exec_spec value =/= disabled (the shell-option may or may not be present): The exec_spec fun() is called with the same number of parameters as the arity of the fun, and the result is returned to the client. Shell-requests are not affected, they follow the shell_spec 's value. 4. If the exec-option is absent, and the shell-option is present with the default Erlang shell as the shell_spec 's value: The default Erlang evaluator is used both for exec and shell requests. The result is returned to the client. 5. If the exec-option is absent, and the shell-option is present with a value that is neither the default Erlang shell nor the value disabled : The exec-request is not evaluated and an error message is returned to the client. Shell-requests are executed according to the value of the shell_spec . 6. If the exec-option is absent, and the shell_spec 's value is disabled : Exec requests are executed by the default shell, but shell-requests are not executed. If a custom CLI is installed (see the option ssh_cli ) the rules above are replaced by thoose implied by the custom CLI. The exec-option has existed for a long time but has not previously been documented. The old definition and behaviour are retained but obey the rules 1-6 above if conflicting. The old and undocumented style should not be used in new programs.","ref":"ssh.html#t:exec_result/0","title":"ssh.exec_result/0","type":"type"},{"doc":"","ref":"ssh.html#t:exec_spec/0","title":"ssh.exec_spec/0","type":"type"},{"doc":"dh_gex_groups Defines the groups the server may choose among when diffie-hellman-group-exchange is negotiated. See RFC 4419 for details. The three variants of this option are: {Size=integer(),G=integer(),P=integer()} The groups are given explicitly in this list. There may be several elements with the same Size . In such a case, the server will choose one randomly in the negotiated Size. {file,filename()} The file must have one or more three-tuples {Size=integer(),G=integer(),P=integer()} terminated by a dot. The file is read when the daemon starts. {ssh_moduli_file,filename()} The file must be in ssh-keygen moduli file format . The file is read when the daemon starts. The default list is fetched from the public_key application. dh_gex_limits Limits what a client can ask for in diffie-hellman-group-exchange. The limits will be {MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)} where MaxClient and MinClient are the values proposed by a connecting client. The default value is {0,infinity} . If MaxUsed &lt; MinUsed in a key exchange, it will fail with a disconnect. See RFC 4419 for the function of the Max and Min values.","ref":"ssh.html#t:explicit_group/0","title":"ssh.explicit_group/0","type":"type"},{"doc":"dh_gex_groups Defines the groups the server may choose among when diffie-hellman-group-exchange is negotiated. See RFC 4419 for details. The three variants of this option are: {Size=integer(),G=integer(),P=integer()} The groups are given explicitly in this list. There may be several elements with the same Size . In such a case, the server will choose one randomly in the negotiated Size. {file,filename()} The file must have one or more three-tuples {Size=integer(),G=integer(),P=integer()} terminated by a dot. The file is read when the daemon starts. {ssh_moduli_file,filename()} The file must be in ssh-keygen moduli file format . The file is read when the daemon starts. The default list is fetched from the public_key application. dh_gex_limits Limits what a client can ask for in diffie-hellman-group-exchange. The limits will be {MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)} where MaxClient and MinClient are the values proposed by a connecting client. The default value is {0,infinity} . If MaxUsed &lt; MinUsed in a key exchange, it will fail with a disconnect. See RFC 4419 for the function of the Max and Min values.","ref":"ssh.html#t:explicit_group_file/0","title":"ssh.explicit_group_file/0","type":"type"},{"doc":"Allows an existing file-descriptor to be used (passed on to the transport protocol).","ref":"ssh.html#t:fd_common_option/0","title":"ssh.fd_common_option/0","type":"type"},{"doc":"silently_accept_hosts This option guides the connect function on how to act when the connected server presents a Host Key that the client has not seen before. The default is to ask the user with a question on stdio of whether to accept or reject the new Host Key. See the option user_dir for specifying the path to the file known_hosts where previously accepted Host Keys are recorded. See also the option key_cb for the general way to handle keys. The option can be given in three different forms as seen above : The value is a boolean() . The value true will make the client accept any unknown Host Key without any user interaction. The value false preserves the default behaviour of asking the user on stdio. An accept_callback() will be called and the boolean return value true will make the client accept the Host Key. A return value of false will make the client to reject the Host Key and as a result the connection will be closed. The arguments to the fun are: PeerName - a string with the name or address of the remote host. FingerPrint - the fingerprint of the Host Key as hostkey_fingerprint/1 calculates it. A tuple {HashAlgoSpec, accept_callback} . The HashAlgoSpec specifies which hash algorithm shall be used to calculate the fingerprint used in the call of the accept_callback() . The HashALgoSpec is either an atom or a list of atoms as the first argument in hostkey_fingerprint/2 . If it is a list of hash algorithm names, the FingerPrint argument in the accept_callback() will be a list of fingerprints in the same order as the corresponding name in the HashAlgoSpec list. user_interaction If false , disables the client to connect to the server if any user interaction is needed, such as accepting the server to be added to the known_hosts file, or supplying a password. Even if user interaction is allowed it can be suppressed by other options, such as silently_accept_hosts and password . However, those options are not always desirable to use from a security point of view. Defaults to true . save_accepted_host If true , the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option key_cb is not present, the key is saved in the file &quot;known_hosts&quot;. See option user_dir for the location of that file. If false , the key is not saved and the key will still be unknown at the next access of the same host. Defaults to true quiet_mode If true , the client does not print anything on authorization. Defaults to false","ref":"ssh.html#t:fingerprint/0","title":"ssh.fingerprint/0","type":"type"},{"doc":"silently_accept_hosts This option guides the connect function on how to act when the connected server presents a Host Key that the client has not seen before. The default is to ask the user with a question on stdio of whether to accept or reject the new Host Key. See the option user_dir for specifying the path to the file known_hosts where previously accepted Host Keys are recorded. See also the option key_cb for the general way to handle keys. The option can be given in three different forms as seen above : The value is a boolean() . The value true will make the client accept any unknown Host Key without any user interaction. The value false preserves the default behaviour of asking the user on stdio. An accept_callback() will be called and the boolean return value true will make the client accept the Host Key. A return value of false will make the client to reject the Host Key and as a result the connection will be closed. The arguments to the fun are: PeerName - a string with the name or address of the remote host. FingerPrint - the fingerprint of the Host Key as hostkey_fingerprint/1 calculates it. A tuple {HashAlgoSpec, accept_callback} . The HashAlgoSpec specifies which hash algorithm shall be used to calculate the fingerprint used in the call of the accept_callback() . The HashALgoSpec is either an atom or a list of atoms as the first argument in hostkey_fingerprint/2 . If it is a list of hash algorithm names, the FingerPrint argument in the accept_callback() will be a list of fingerprints in the same order as the corresponding name in the HashAlgoSpec list. user_interaction If false , disables the client to connect to the server if any user interaction is needed, such as accepting the server to be added to the known_hosts file, or supplying a password. Even if user interaction is allowed it can be suppressed by other options, such as silently_accept_hosts and password . However, those options are not always desirable to use from a security point of view. Defaults to true . save_accepted_host If true , the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option key_cb is not present, the key is saved in the file &quot;known_hosts&quot;. See option user_dir for the location of that file. If false , the key is not saved and the key will still be unknown at the next access of the same host. Defaults to true quiet_mode If true , the client does not print anything on authorization. Defaults to false","ref":"ssh.html#t:fp_digest_alg/0","title":"ssh.fp_digest_alg/0","type":"type"},{"doc":"max_sessions The maximum number of simultaneous sessions that are accepted at any time for this daemon. This includes sessions that are being authorized. Thus, if set to N , and N clients have connected but not started the login process, connection attempt N+1 is aborted. If N connections are authenticated and still logged in, no more logins are accepted until one of the existing ones log out. The counter is per listening port. Thus, if two daemons are started, one with {max_sessions,N} and the other with {max_sessions,M} , in total N+M connections are accepted for the whole ssh application. Notice that if parallel_login is false , only one client at a time can be in the authentication phase. By default, this option is not set. This means that the number is not limited. max_channels The maximum number of channels with active remote subsystem that are accepted for each connection to this daemon By default, this option is not set. This means that the number is not limited. parallel_login If set to false (the default value), only one login is handled at a time. If set to true, an unlimited number of login attempts are allowed simultaneously. If the max_sessions option is set to N and parallel_login is set to true , the maximum number of simultaneous login attempts at any time is limited to N-K , where K is the number of authenticated connections present at this daemon. Do not enable parallel_logins without protecting the server by other means, for example, by the max_sessions option or a firewall configuration. If set to true , there is no protection against DOS attacks. minimal_remote_max_packet_size The least maximum packet size that the daemon will accept in channel open requests from the client. The default value is 0.","ref":"ssh.html#t:hardening_daemon_options/0","title":"ssh.hardening_daemon_options/0","type":"type"},{"doc":"Maximum time in milliseconds for the first part of the ssh session setup, the hello message exchange. Defaults to 30000 ms (30 seconds). If the client fails to send the first message within this time, the connection is closed.","ref":"ssh.html#t:hello_timeout_daemon_option/0","title":"ssh.hello_timeout_daemon_option/0","type":"type"},{"doc":"","ref":"ssh.html#t:host/0","title":"ssh.host/0","type":"type"},{"doc":"silently_accept_hosts This option guides the connect function on how to act when the connected server presents a Host Key that the client has not seen before. The default is to ask the user with a question on stdio of whether to accept or reject the new Host Key. See the option user_dir for specifying the path to the file known_hosts where previously accepted Host Keys are recorded. See also the option key_cb for the general way to handle keys. The option can be given in three different forms as seen above : The value is a boolean() . The value true will make the client accept any unknown Host Key without any user interaction. The value false preserves the default behaviour of asking the user on stdio. An accept_callback() will be called and the boolean return value true will make the client accept the Host Key. A return value of false will make the client to reject the Host Key and as a result the connection will be closed. The arguments to the fun are: PeerName - a string with the name or address of the remote host. FingerPrint - the fingerprint of the Host Key as hostkey_fingerprint/1 calculates it. A tuple {HashAlgoSpec, accept_callback} . The HashAlgoSpec specifies which hash algorithm shall be used to calculate the fingerprint used in the call of the accept_callback() . The HashALgoSpec is either an atom or a list of atoms as the first argument in hostkey_fingerprint/2 . If it is a list of hash algorithm names, the FingerPrint argument in the accept_callback() will be a list of fingerprints in the same order as the corresponding name in the HashAlgoSpec list. user_interaction If false , disables the client to connect to the server if any user interaction is needed, such as accepting the server to be added to the known_hosts file, or supplying a password. Even if user interaction is allowed it can be suppressed by other options, such as silently_accept_hosts and password . However, those options are not always desirable to use from a security point of view. Defaults to true . save_accepted_host If true , the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option key_cb is not present, the key is saved in the file &quot;known_hosts&quot;. See option user_dir for the location of that file. If false , the key is not saved and the key will still be unknown at the next access of the same host. Defaults to true quiet_mode If true , the client does not print anything on authorization. Defaults to false","ref":"ssh.html#t:host_accepting_client_options/0","title":"ssh.host_accepting_client_options/0","type":"type"},{"doc":"The string the daemon will present to a connecting peer initially. The default value is &quot;Erlang/VSN&quot; where VSN is the ssh application version number. The value random will cause a random string to be created at each connection attempt. This is to make it a bit more difficult for a malicious peer to find the ssh software brand and version. The value {random, Nmin, Nmax} will make a random string with at least Nmin characters and at most Nmax characters.","ref":"ssh.html#t:id_string_common_option/0","title":"ssh.id_string_common_option/0","type":"type"},{"doc":"IP version to use when the host address is specified as any .","ref":"ssh.html#t:inet_common_option/0","title":"ssh.inet_common_option/0","type":"type"},{"doc":"","ref":"ssh.html#t:ip_port/0","title":"ssh.ip_port/0","type":"type"},{"doc":"auth_method_kb_interactive_data Sets the text strings that the daemon sends to the client for presentation to the user when using keyboard-interactive authentication. If the fun/3 or fun/4 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc. The parameter Echo guides the client about need to hide the password. The default value is: {auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \\&quot;&quot;++User++&quot;\\&quot;&quot;, &quot;password: &quot;, false}&gt; user_passwords Provides passwords for password authentication. The passwords are used when someone tries to connect to the server and public key user-authentication fails. The option provides a list of valid usernames and the corresponding passwords. Note that this is very insecure due to the plain-text passwords; it is intended for test purposes. Use the pwdfun option to handle the password checking instead. pk_check_user Enables checking of the client's user name in the server when doing public key authentication. It is disabled by default. The term &quot;user&quot; is used differently in OpenSSH and SSH in Erlang/OTP: see more in the User's Guide. If the option is enabled, and no pwdfun is present, the user name must present in the user_passwords for the check to succeed but the value of the password is not checked. In case of a pwdfun checking the user, the atom pubkey is put in the password argument. password Provides a global password that authenticates any user. Intended to facilitate testing. From a security perspective this option makes the server very vulnerable. pwdfun with pwdfun_4() Provides a function for password validation. This could used for calling an external system or handeling passwords stored as hash values. This fun can also be used to make delays in authentication tries for example by calling timer:sleep/1 . To facilitate for instance counting of failed tries, the State variable could be used. This state is per connection only. The first time the pwdfun is called for a connection, the State variable has the value undefined . The fun should return: true if the user and password is valid false if the user or password is invalid disconnect if a SSH_MSG_DISCONNECT message should be sent immediately. It will be followed by a close of the underlying tcp connection. {true, NewState:any()} if the user and password is valid {false, NewState:any()} if the user or password is invalid A third usage is to block login attempts from a missbehaving peer. The State described above can be used for this. The return value disconnect is useful for this. In case of the pk_check_user is set, the atom pubkey is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid. pwdfun with pwdfun_2() Provides a function for password validation. This function is called with user and password as strings, and returns: true if the user and password is valid false if the user or password is invalid In case of the pk_check_user is set, the atom pubkey is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid. This variant is kept for compatibility.","ref":"ssh.html#t:kb_int_fun_3/0","title":"ssh.kb_int_fun_3/0","type":"type"},{"doc":"auth_method_kb_interactive_data Sets the text strings that the daemon sends to the client for presentation to the user when using keyboard-interactive authentication. If the fun/3 or fun/4 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc. The parameter Echo guides the client about need to hide the password. The default value is: {auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \\&quot;&quot;++User++&quot;\\&quot;&quot;, &quot;password: &quot;, false}&gt; user_passwords Provides passwords for password authentication. The passwords are used when someone tries to connect to the server and public key user-authentication fails. The option provides a list of valid usernames and the corresponding passwords. Note that this is very insecure due to the plain-text passwords; it is intended for test purposes. Use the pwdfun option to handle the password checking instead. pk_check_user Enables checking of the client's user name in the server when doing public key authentication. It is disabled by default. The term &quot;user&quot; is used differently in OpenSSH and SSH in Erlang/OTP: see more in the User's Guide. If the option is enabled, and no pwdfun is present, the user name must present in the user_passwords for the check to succeed but the value of the password is not checked. In case of a pwdfun checking the user, the atom pubkey is put in the password argument. password Provides a global password that authenticates any user. Intended to facilitate testing. From a security perspective this option makes the server very vulnerable. pwdfun with pwdfun_4() Provides a function for password validation. This could used for calling an external system or handeling passwords stored as hash values. This fun can also be used to make delays in authentication tries for example by calling timer:sleep/1 . To facilitate for instance counting of failed tries, the State variable could be used. This state is per connection only. The first time the pwdfun is called for a connection, the State variable has the value undefined . The fun should return: true if the user and password is valid false if the user or password is invalid disconnect if a SSH_MSG_DISCONNECT message should be sent immediately. It will be followed by a close of the underlying tcp connection. {true, NewState:any()} if the user and password is valid {false, NewState:any()} if the user or password is invalid A third usage is to block login attempts from a missbehaving peer. The State described above can be used for this. The return value disconnect is useful for this. In case of the pk_check_user is set, the atom pubkey is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid. pwdfun with pwdfun_2() Provides a function for password validation. This function is called with user and password as strings, and returns: true if the user and password is valid false if the user or password is invalid In case of the pk_check_user is set, the atom pubkey is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid. This variant is kept for compatibility.","ref":"ssh.html#t:kb_int_fun_4/0","title":"ssh.kb_int_fun_4/0","type":"type"},{"doc":"auth_method_kb_interactive_data Sets the text strings that the daemon sends to the client for presentation to the user when using keyboard-interactive authentication. If the fun/3 or fun/4 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc. The parameter Echo guides the client about need to hide the password. The default value is: {auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \\&quot;&quot;++User++&quot;\\&quot;&quot;, &quot;password: &quot;, false}&gt; user_passwords Provides passwords for password authentication. The passwords are used when someone tries to connect to the server and public key user-authentication fails. The option provides a list of valid usernames and the corresponding passwords. Note that this is very insecure due to the plain-text passwords; it is intended for test purposes. Use the pwdfun option to handle the password checking instead. pk_check_user Enables checking of the client's user name in the server when doing public key authentication. It is disabled by default. The term &quot;user&quot; is used differently in OpenSSH and SSH in Erlang/OTP: see more in the User's Guide. If the option is enabled, and no pwdfun is present, the user name must present in the user_passwords for the check to succeed but the value of the password is not checked. In case of a pwdfun checking the user, the atom pubkey is put in the password argument. password Provides a global password that authenticates any user. Intended to facilitate testing. From a security perspective this option makes the server very vulnerable. pwdfun with pwdfun_4() Provides a function for password validation. This could used for calling an external system or handeling passwords stored as hash values. This fun can also be used to make delays in authentication tries for example by calling timer:sleep/1 . To facilitate for instance counting of failed tries, the State variable could be used. This state is per connection only. The first time the pwdfun is called for a connection, the State variable has the value undefined . The fun should return: true if the user and password is valid false if the user or password is invalid disconnect if a SSH_MSG_DISCONNECT message should be sent immediately. It will be followed by a close of the underlying tcp connection. {true, NewState:any()} if the user and password is valid {false, NewState:any()} if the user or password is invalid A third usage is to block login attempts from a missbehaving peer. The State described above can be used for this. The return value disconnect is useful for this. In case of the pk_check_user is set, the atom pubkey is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid. pwdfun with pwdfun_2() Provides a function for password validation. This function is called with user and password as strings, and returns: true if the user and password is valid false if the user or password is invalid In case of the pk_check_user is set, the atom pubkey is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid. This variant is kept for compatibility.","ref":"ssh.html#t:kb_int_tuple/0","title":"ssh.kb_int_tuple/0","type":"type"},{"doc":"List of algorithms to use in the algorithm negotiation. The default algs_list() can be obtained from default_algorithms/0 . If an alg_entry() is missing in the algs_list(), the default value is used for that entry. Here is an example of this option: { preferred_algorithms , [ { public_key , [ &#39;ssh-rsa&#39; , &#39;ssh-dss&#39; ] } , { cipher , [ { client2server , [ &#39;aes128-ctr&#39; ] } , { server2client , [ &#39;aes128-cbc&#39; , &#39;3des-cbc&#39; ] } ] } , { mac , [ &#39;hmac-sha2-256&#39; , &#39;hmac-sha1&#39; ] } , { compression , [ none , zlib ] } ] } The example specifies different algorithms in the two directions (client2server and server2client), for cipher but specifies the same algorithms for mac and compression in both directions. The kex (key exchange) is implicit but public_key is set explicitly. For background and more examples see the User's Guide. If an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the property lists are also assumed to occur at most one time. Changing the values can make a connection less secure. Do not change unless you know exactly what you are doing. If you do not understand the values then you are not supposed to change them.","ref":"ssh.html#t:kex_alg/0","title":"ssh.kex_alg/0","type":"type"},{"doc":"Module implementing the behaviour ssh_client_key_api and/or ssh_server_key_api . Can be used to customize the handling of public keys. If callback options are provided along with the module name, they are made available to the callback module via the options passed to it under the key 'key_cb_private'. The Opts defaults to [] when only the Module is specified. The default value of this option is {ssh_file, []} . See also the manpage of ssh_file . A call to the call-back function F will be Module : F ( . . . , [ { key_cb_private , Opts } | UserOptions ] ) where ... are arguments to F as in ssh_client_key_api and/or ssh_server_key_api . The UserOptions are the options given to ssh:connect , ssh:shell or ssh:daemon .","ref":"ssh.html#t:key_cb_common_option/0","title":"ssh.key_cb_common_option/0","type":"type"},{"doc":"Sets the limit when rekeying is to be initiated. Both the max time and max amount of data could be configured: {Minutes, Bytes} initiate rekeying when any of the limits are reached. Bytes initiate rekeying when Bytes number of bytes are transferred, or at latest after one hour. When a rekeying is done, both the timer and the byte counter are restarted. Defaults to one hour and one GByte. If Minutes is set to infinity , no rekeying will ever occur due to that max time has passed. Setting Bytes to infinity will inhibit rekeying after a certain amount of data has been transferred. If the option value is set to {infinity, infinity} , no rekeying will be initiated. Note that rekeying initiated by the peer will still be performed.","ref":"ssh.html#t:limit_bytes/0","title":"ssh.limit_bytes/0","type":"type"},{"doc":"Sets the limit when rekeying is to be initiated. Both the max time and max amount of data could be configured: {Minutes, Bytes} initiate rekeying when any of the limits are reached. Bytes initiate rekeying when Bytes number of bytes are transferred, or at latest after one hour. When a rekeying is done, both the timer and the byte counter are restarted. Defaults to one hour and one GByte. If Minutes is set to infinity , no rekeying will ever occur due to that max time has passed. Setting Bytes to infinity will inhibit rekeying after a certain amount of data has been transferred. If the option value is set to {infinity, infinity} , no rekeying will be initiated. Note that rekeying initiated by the peer will still be performed.","ref":"ssh.html#t:limit_time/0","title":"ssh.limit_time/0","type":"type"},{"doc":"List of algorithms to use in the algorithm negotiation. The default algs_list() can be obtained from default_algorithms/0 . If an alg_entry() is missing in the algs_list(), the default value is used for that entry. Here is an example of this option: { preferred_algorithms , [ { public_key , [ &#39;ssh-rsa&#39; , &#39;ssh-dss&#39; ] } , { cipher , [ { client2server , [ &#39;aes128-ctr&#39; ] } , { server2client , [ &#39;aes128-cbc&#39; , &#39;3des-cbc&#39; ] } ] } , { mac , [ &#39;hmac-sha2-256&#39; , &#39;hmac-sha1&#39; ] } , { compression , [ none , zlib ] } ] } The example specifies different algorithms in the two directions (client2server and server2client), for cipher but specifies the same algorithms for mac and compression in both directions. The kex (key exchange) is implicit but public_key is set explicitly. For background and more examples see the User's Guide. If an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the property lists are also assumed to occur at most one time. Changing the values can make a connection less secure. Do not change unless you know exactly what you are doing. If you do not understand the values then you are not supposed to change them.","ref":"ssh.html#t:mac_alg/0","title":"ssh.mac_alg/0","type":"type"},{"doc":"Sets a time-out on a connection when no channels are open. Defaults to infinity . The unit is milliseconds. The timeout is not active until channels are started, so it does not limit the time from the connection creation to the first channel opening.","ref":"ssh.html#t:max_idle_time_common_option/0","title":"ssh.max_idle_time_common_option/0","type":"type"},{"doc":"","ref":"ssh.html#t:mod_args/0","title":"ssh.mod_args/0","type":"type"},{"doc":"","ref":"ssh.html#t:mod_fun_args/0","title":"ssh.mod_fun_args/0","type":"type"},{"doc":"Modifies the list of algorithms to use in the algorithm negotiation. The modifications are applied after the option preferred_algorithms (if existing) is applied. The algoritm for modifications works like this: Input is the modify_algs_list() and a set of algorithms A obtained from the preferred_algorithms option if existing, or else from the ssh:default_algorithms/0 . The head of the modify_algs_list() modifies A giving the result A' . The possible modifications are: Append or prepend supported but not enabled algorithm(s) to the list of algorithms. If the wanted algorithms already are in A they will first be removed and then appended or prepended, Remove (rm) one or more algorithms from A . Repeat the modification step with the tail of modify_algs_list() and the resulting A' . If an unsupported algorithm is in the modify_algs_list() , it will be silently ignored If there are more than one modify_algorithms options, the result is undefined. Here is an example of this option: { modify_algorithms , [ { prepend , [ { kex , [ &#39;diffie-hellman-group1-sha1&#39; ] } ] , { rm , [ { compression , [ none ] } ] } ] } The example specifies that: the old key exchange algorithm 'diffie-hellman-group1-sha1' should be the main alternative. It will be the main alternative since it is prepened to the list The compression algorithm none (= no compression) is removed so compression is enforced For background and more examples see the User's Guide.","ref":"ssh.html#t:modify_algorithms_common_option/0","title":"ssh.modify_algorithms_common_option/0","type":"type"},{"doc":"Modifies the list of algorithms to use in the algorithm negotiation. The modifications are applied after the option preferred_algorithms (if existing) is applied. The algoritm for modifications works like this: Input is the modify_algs_list() and a set of algorithms A obtained from the preferred_algorithms option if existing, or else from the ssh:default_algorithms/0 . The head of the modify_algs_list() modifies A giving the result A' . The possible modifications are: Append or prepend supported but not enabled algorithm(s) to the list of algorithms. If the wanted algorithms already are in A they will first be removed and then appended or prepended, Remove (rm) one or more algorithms from A . Repeat the modification step with the tail of modify_algs_list() and the resulting A' . If an unsupported algorithm is in the modify_algs_list() , it will be silently ignored If there are more than one modify_algorithms options, the result is undefined. Here is an example of this option: { modify_algorithms , [ { prepend , [ { kex , [ &#39;diffie-hellman-group1-sha1&#39; ] } ] , { rm , [ { compression , [ none ] } ] } ] } The example specifies that: the old key exchange algorithm 'diffie-hellman-group1-sha1' should be the main alternative. It will be the main alternative since it is prepened to the list The compression algorithm none (= no compression) is removed so compression is enforced For background and more examples see the User's Guide.","ref":"ssh.html#t:modify_algs_list/0","title":"ssh.modify_algs_list/0","type":"type"},{"doc":"Maximum time in milliseconds for the authentication negotiation. Defaults to 120000 ms (2 minutes). If the client fails to log in within this time, the connection is closed.","ref":"ssh.html#t:negotiation_timeout_daemon_option/0","title":"ssh.negotiation_timeout_daemon_option/0","type":"type"},{"doc":"Opaque types that define experimental options that are not to be used in products.","ref":"ssh.html#t:opaque_client_options/0","title":"ssh.opaque_client_options/0","type":"type"},{"doc":"Opaque types that define experimental options that are not to be used in products.","ref":"ssh.html#t:opaque_common_options/0","title":"ssh.opaque_common_options/0","type":"type"},{"doc":"Opaque types that define experimental options that are not to be used in products.","ref":"ssh.html#t:opaque_daemon_options/0","title":"ssh.opaque_daemon_options/0","type":"type"},{"doc":"The socket is supposed to be result of a gen_tcp:connect or a gen_tcp:accept . The socket must be in passive mode (that is, opened with the option {active,false}) .","ref":"ssh.html#t:open_socket/0","title":"ssh.open_socket/0","type":"type"},{"doc":"List of user (client) public key algorithms to try to use. The default value is the public_key entry in the list returned by ssh:default_algorithms/0 . If there is no public key of a specified type available, the corresponding entry is ignored. Note that the available set is dependent on the underlying cryptolib and current user's public keys. See also the option user_dir for specifying the path to the user's keys.","ref":"ssh.html#t:pref_public_key_algs_common_option/0","title":"ssh.pref_public_key_algs_common_option/0","type":"type"},{"doc":"List of algorithms to use in the algorithm negotiation. The default algs_list() can be obtained from default_algorithms/0 . If an alg_entry() is missing in the algs_list(), the default value is used for that entry. Here is an example of this option: { preferred_algorithms , [ { public_key , [ &#39;ssh-rsa&#39; , &#39;ssh-dss&#39; ] } , { cipher , [ { client2server , [ &#39;aes128-ctr&#39; ] } , { server2client , [ &#39;aes128-cbc&#39; , &#39;3des-cbc&#39; ] } ] } , { mac , [ &#39;hmac-sha2-256&#39; , &#39;hmac-sha1&#39; ] } , { compression , [ none , zlib ] } ] } The example specifies different algorithms in the two directions (client2server and server2client), for cipher but specifies the same algorithms for mac and compression in both directions. The kex (key exchange) is implicit but public_key is set explicitly. For background and more examples see the User's Guide. If an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the property lists are also assumed to occur at most one time. Changing the values can make a connection less secure. Do not change unless you know exactly what you are doing. If you do not understand the values then you are not supposed to change them.","ref":"ssh.html#t:preferred_algorithms_common_option/0","title":"ssh.preferred_algorithms_common_option/0","type":"type"},{"doc":"Used together with ip-address and port to uniquely identify a ssh daemon. This can be useful in a virtualized environment, where there can be more that one server that has the same ip-address and port . If this property is not explicitly set, it is assumed that the the ip-address and port uniquely identifies the SSH daemon.","ref":"ssh.html#t:profile_common_option/0","title":"ssh.profile_common_option/0","type":"type"},{"doc":"auth_method_kb_interactive_data Sets the text strings that the daemon sends to the client for presentation to the user when using keyboard-interactive authentication. If the fun/3 or fun/4 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc. The parameter Echo guides the client about need to hide the password. The default value is: {auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \\&quot;&quot;++User++&quot;\\&quot;&quot;, &quot;password: &quot;, false}&gt; user_passwords Provides passwords for password authentication. The passwords are used when someone tries to connect to the server and public key user-authentication fails. The option provides a list of valid usernames and the corresponding passwords. Note that this is very insecure due to the plain-text passwords; it is intended for test purposes. Use the pwdfun option to handle the password checking instead. pk_check_user Enables checking of the client's user name in the server when doing public key authentication. It is disabled by default. The term &quot;user&quot; is used differently in OpenSSH and SSH in Erlang/OTP: see more in the User's Guide. If the option is enabled, and no pwdfun is present, the user name must present in the user_passwords for the check to succeed but the value of the password is not checked. In case of a pwdfun checking the user, the atom pubkey is put in the password argument. password Provides a global password that authenticates any user. Intended to facilitate testing. From a security perspective this option makes the server very vulnerable. pwdfun with pwdfun_4() Provides a function for password validation. This could used for calling an external system or handeling passwords stored as hash values. This fun can also be used to make delays in authentication tries for example by calling timer:sleep/1 . To facilitate for instance counting of failed tries, the State variable could be used. This state is per connection only. The first time the pwdfun is called for a connection, the State variable has the value undefined . The fun should return: true if the user and password is valid false if the user or password is invalid disconnect if a SSH_MSG_DISCONNECT message should be sent immediately. It will be followed by a close of the underlying tcp connection. {true, NewState:any()} if the user and password is valid {false, NewState:any()} if the user or password is invalid A third usage is to block login attempts from a missbehaving peer. The State described above can be used for this. The return value disconnect is useful for this. In case of the pk_check_user is set, the atom pubkey is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid. pwdfun with pwdfun_2() Provides a function for password validation. This function is called with user and password as strings, and returns: true if the user and password is valid false if the user or password is invalid In case of the pk_check_user is set, the atom pubkey is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid. This variant is kept for compatibility.","ref":"ssh.html#t:prompt_texts/0","title":"ssh.prompt_texts/0","type":"type"},{"doc":"Return values from the connection_info/1 and connection_info/2 functions. In the option info tuple are only the options included that differs from the default values.","ref":"ssh.html#t:protocol_version/0","title":"ssh.protocol_version/0","type":"type"},{"doc":"List of algorithms to use in the algorithm negotiation. The default algs_list() can be obtained from default_algorithms/0 . If an alg_entry() is missing in the algs_list(), the default value is used for that entry. Here is an example of this option: { preferred_algorithms , [ { public_key , [ &#39;ssh-rsa&#39; , &#39;ssh-dss&#39; ] } , { cipher , [ { client2server , [ &#39;aes128-ctr&#39; ] } , { server2client , [ &#39;aes128-cbc&#39; , &#39;3des-cbc&#39; ] } ] } , { mac , [ &#39;hmac-sha2-256&#39; , &#39;hmac-sha1&#39; ] } , { compression , [ none , zlib ] } ] } The example specifies different algorithms in the two directions (client2server and server2client), for cipher but specifies the same algorithms for mac and compression in both directions. The kex (key exchange) is implicit but public_key is set explicitly. For background and more examples see the User's Guide. If an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the property lists are also assumed to occur at most one time. Changing the values can make a connection less secure. Do not change unless you know exactly what you are doing. If you do not understand the values then you are not supposed to change them.","ref":"ssh.html#t:pubkey_alg/0","title":"ssh.pubkey_alg/0","type":"type"},{"doc":"auth_method_kb_interactive_data Sets the text strings that the daemon sends to the client for presentation to the user when using keyboard-interactive authentication. If the fun/3 or fun/4 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc. The parameter Echo guides the client about need to hide the password. The default value is: {auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \\&quot;&quot;++User++&quot;\\&quot;&quot;, &quot;password: &quot;, false}&gt; user_passwords Provides passwords for password authentication. The passwords are used when someone tries to connect to the server and public key user-authentication fails. The option provides a list of valid usernames and the corresponding passwords. Note that this is very insecure due to the plain-text passwords; it is intended for test purposes. Use the pwdfun option to handle the password checking instead. pk_check_user Enables checking of the client's user name in the server when doing public key authentication. It is disabled by default. The term &quot;user&quot; is used differently in OpenSSH and SSH in Erlang/OTP: see more in the User's Guide. If the option is enabled, and no pwdfun is present, the user name must present in the user_passwords for the check to succeed but the value of the password is not checked. In case of a pwdfun checking the user, the atom pubkey is put in the password argument. password Provides a global password that authenticates any user. Intended to facilitate testing. From a security perspective this option makes the server very vulnerable. pwdfun with pwdfun_4() Provides a function for password validation. This could used for calling an external system or handeling passwords stored as hash values. This fun can also be used to make delays in authentication tries for example by calling timer:sleep/1 . To facilitate for instance counting of failed tries, the State variable could be used. This state is per connection only. The first time the pwdfun is called for a connection, the State variable has the value undefined . The fun should return: true if the user and password is valid false if the user or password is invalid disconnect if a SSH_MSG_DISCONNECT message should be sent immediately. It will be followed by a close of the underlying tcp connection. {true, NewState:any()} if the user and password is valid {false, NewState:any()} if the user or password is invalid A third usage is to block login attempts from a missbehaving peer. The State described above can be used for this. The return value disconnect is useful for this. In case of the pk_check_user is set, the atom pubkey is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid. pwdfun with pwdfun_2() Provides a function for password validation. This function is called with user and password as strings, and returns: true if the user and password is valid false if the user or password is invalid In case of the pk_check_user is set, the atom pubkey is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid. This variant is kept for compatibility.","ref":"ssh.html#t:pwdfun_2/0","title":"ssh.pwdfun_2/0","type":"type"},{"doc":"auth_method_kb_interactive_data Sets the text strings that the daemon sends to the client for presentation to the user when using keyboard-interactive authentication. If the fun/3 or fun/4 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc. The parameter Echo guides the client about need to hide the password. The default value is: {auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \\&quot;&quot;++User++&quot;\\&quot;&quot;, &quot;password: &quot;, false}&gt; user_passwords Provides passwords for password authentication. The passwords are used when someone tries to connect to the server and public key user-authentication fails. The option provides a list of valid usernames and the corresponding passwords. Note that this is very insecure due to the plain-text passwords; it is intended for test purposes. Use the pwdfun option to handle the password checking instead. pk_check_user Enables checking of the client's user name in the server when doing public key authentication. It is disabled by default. The term &quot;user&quot; is used differently in OpenSSH and SSH in Erlang/OTP: see more in the User's Guide. If the option is enabled, and no pwdfun is present, the user name must present in the user_passwords for the check to succeed but the value of the password is not checked. In case of a pwdfun checking the user, the atom pubkey is put in the password argument. password Provides a global password that authenticates any user. Intended to facilitate testing. From a security perspective this option makes the server very vulnerable. pwdfun with pwdfun_4() Provides a function for password validation. This could used for calling an external system or handeling passwords stored as hash values. This fun can also be used to make delays in authentication tries for example by calling timer:sleep/1 . To facilitate for instance counting of failed tries, the State variable could be used. This state is per connection only. The first time the pwdfun is called for a connection, the State variable has the value undefined . The fun should return: true if the user and password is valid false if the user or password is invalid disconnect if a SSH_MSG_DISCONNECT message should be sent immediately. It will be followed by a close of the underlying tcp connection. {true, NewState:any()} if the user and password is valid {false, NewState:any()} if the user or password is invalid A third usage is to block login attempts from a missbehaving peer. The State described above can be used for this. The return value disconnect is useful for this. In case of the pk_check_user is set, the atom pubkey is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid. pwdfun with pwdfun_2() Provides a function for password validation. This function is called with user and password as strings, and returns: true if the user and password is valid false if the user or password is invalid In case of the pk_check_user is set, the atom pubkey is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid. This variant is kept for compatibility.","ref":"ssh.html#t:pwdfun_4/0","title":"ssh.pwdfun_4/0","type":"type"},{"doc":"Make the client tell the server that the client accepts extension negotiation, that is, include ext-info-c in the kexinit message sent. See RFC 8308 for details and ssh(6) for a list of currently implemented extensions. Default value is true which is compatible with other implementations not supporting ext-info.","ref":"ssh.html#t:recv_ext_info_client_option/0","title":"ssh.recv_ext_info_client_option/0","type":"type"},{"doc":"Sets the limit when rekeying is to be initiated. Both the max time and max amount of data could be configured: {Minutes, Bytes} initiate rekeying when any of the limits are reached. Bytes initiate rekeying when Bytes number of bytes are transferred, or at latest after one hour. When a rekeying is done, both the timer and the byte counter are restarted. Defaults to one hour and one GByte. If Minutes is set to infinity , no rekeying will ever occur due to that max time has passed. Setting Bytes to infinity will inhibit rekeying after a certain amount of data has been transferred. If the option value is set to {infinity, infinity} , no rekeying will be initiated. Note that rekeying initiated by the peer will still be performed.","ref":"ssh.html#t:rekey_limit_common_option/0","title":"ssh.rekey_limit_common_option/0","type":"type"},{"doc":"Make the server (daemon) tell the client that the server accepts extension negotiation, that is, include ext-info-s in the kexinit message sent. See RFC 8308 for details and ssh(6) for a list of currently implemented extensions. Default value is true which is compatible with other implementations not supporting ext-info.","ref":"ssh.html#t:send_ext_info_daemon_option/0","title":"ssh.send_ext_info_daemon_option/0","type":"type"},{"doc":"Defines the read-eval-print loop used in a daemon when a shell is requested by the client. The default is to use the Erlang shell: {shell, start, []} See the option exec-option for a description of how the daemon executes shell-requests and exec-requests depending on the shell- and exec-options.","ref":"ssh.html#t:shell_daemon_option/0","title":"ssh.shell_daemon_option/0","type":"type"},{"doc":"Defines the read-eval-print loop used in a daemon when a shell is requested by the client. The default is to use the Erlang shell: {shell, start, []} See the option exec-option for a description of how the daemon executes shell-requests and exec-requests depending on the shell- and exec-options.","ref":"ssh.html#t:shell_fun/0","title":"ssh.shell_fun/0","type":"type"},{"doc":"Defines the read-eval-print loop used in a daemon when a shell is requested by the client. The default is to use the Erlang shell: {shell, start, []} See the option exec-option for a description of how the daemon executes shell-requests and exec-requests depending on the shell- and exec-options.","ref":"ssh.html#t:shell_fun/1/0","title":"ssh.shell_fun/1/0","type":"type"},{"doc":"Defines the read-eval-print loop used in a daemon when a shell is requested by the client. The default is to use the Erlang shell: {shell, start, []} See the option exec-option for a description of how the daemon executes shell-requests and exec-requests depending on the shell- and exec-options.","ref":"ssh.html#t:shell_fun/2/0","title":"ssh.shell_fun/2/0","type":"type"},{"doc":"Defines the read-eval-print loop used in a daemon when a shell is requested by the client. The default is to use the Erlang shell: {shell, start, []} See the option exec-option for a description of how the daemon executes shell-requests and exec-requests depending on the shell- and exec-options.","ref":"ssh.html#t:shell_spec/0","title":"ssh.shell_spec/0","type":"type"},{"doc":"Return values from the connection_info/1 and connection_info/2 functions. In the option info tuple are only the options included that differs from the default values.","ref":"ssh.html#t:software_version/0","title":"ssh.software_version/0","type":"type"},{"doc":"Provides your own CLI implementation in a daemon. It is a channel callback module that implements a shell and command execution. The shell's read-eval-print loop can be customized, using the option shell . This means less work than implementing an own CLI channel. If ssh_cli is set to no_cli , the CLI channels like shell and exec are disabled and only subsystem channels are allowed.","ref":"ssh.html#t:ssh_cli_daemon_option/0","title":"ssh.ssh_cli_daemon_option/0","type":"type"},{"doc":"dh_gex_groups Defines the groups the server may choose among when diffie-hellman-group-exchange is negotiated. See RFC 4419 for details. The three variants of this option are: {Size=integer(),G=integer(),P=integer()} The groups are given explicitly in this list. There may be several elements with the same Size . In such a case, the server will choose one randomly in the negotiated Size. {file,filename()} The file must have one or more three-tuples {Size=integer(),G=integer(),P=integer()} terminated by a dot. The file is read when the daemon starts. {ssh_moduli_file,filename()} The file must be in ssh-keygen moduli file format . The file is read when the daemon starts. The default list is fetched from the public_key application. dh_gex_limits Limits what a client can ask for in diffie-hellman-group-exchange. The limits will be {MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)} where MaxClient and MinClient are the values proposed by a connecting client. The default value is {0,infinity} . If MaxUsed &lt; MinUsed in a key exchange, it will fail with a disconnect. See RFC 4419 for the function of the Max and Min values.","ref":"ssh.html#t:ssh_moduli_file/0","title":"ssh.ssh_moduli_file/0","type":"type"},{"doc":"Provide a fun to implement your own logging of the SSH message SSH_MSG_DEBUG. The last three parameters are from the message, see RFC 4253, section 11.3 . The connection_ref() is the reference to the connection on which the message arrived. The return value from the fun is not checked. The default behaviour is ignore the message. To get a printout for each message with AlwaysDisplay = true , use for example {ssh_msg_debug_fun, fun(_,true,M,_)-&gt; io:format(&quot;DEBUG: ~p~n&quot;, [M]) end}","ref":"ssh.html#t:ssh_msg_debug_fun_common_option/0","title":"ssh.ssh_msg_debug_fun_common_option/0","type":"type"},{"doc":"Defines a subsystem in the daemon. The subsystem_name is the name that a client requests to start with for example ssh_connection:subsystem/4 . The channel_callback is the module that implements the ssh_server_channel (replaces ssh_daemon_channel) behaviour in the daemon. See the section Creating a Subsystem in the User's Guide for more information and an example. If the subsystems option is not present, the value of ssh_sftpd:subsystem_spec([]) is used. This enables the sftp subsystem by default. The option can be set to the empty list if you do not want the daemon to run any subsystems.","ref":"ssh.html#t:subsystem_daemon_option/0","title":"ssh.subsystem_daemon_option/0","type":"type"},{"doc":"Defines a subsystem in the daemon. The subsystem_name is the name that a client requests to start with for example ssh_connection:subsystem/4 . The channel_callback is the module that implements the ssh_server_channel (replaces ssh_daemon_channel) behaviour in the daemon. See the section Creating a Subsystem in the User's Guide for more information and an example. If the subsystems option is not present, the value of ssh_sftpd:subsystem_spec([]) is used. This enables the sftp subsystem by default. The option can be set to the empty list if you do not want the daemon to run any subsystems.","ref":"ssh.html#t:subsystem_spec/0","title":"ssh.subsystem_spec/0","type":"type"},{"doc":"Defines a subsystem in the daemon. The subsystem_name is the name that a client requests to start with for example ssh_connection:subsystem/4 . The channel_callback is the module that implements the ssh_server_channel (replaces ssh_daemon_channel) behaviour in the daemon. See the section Creating a Subsystem in the User's Guide for more information and an example. If the subsystems option is not present, the value of ssh_sftpd:subsystem_spec([]) is used. This enables the sftp subsystem by default. The option can be set to the empty list if you do not want the daemon to run any subsystems.","ref":"ssh.html#t:subsystem_specs/0","title":"ssh.subsystem_specs/0","type":"type"},{"doc":"Enables ( true ) or disables ( false ) the possibility to tunnel a TCP/IP connection in to a server . Disabled per default.","ref":"ssh.html#t:tcpip_tunnel_in_daemon_option/0","title":"ssh.tcpip_tunnel_in_daemon_option/0","type":"type"},{"doc":"Enables ( true ) or disables ( false ) the possibility to tunnel a TCP/IP connection out of a server . Disabled per default.","ref":"ssh.html#t:tcpip_tunnel_out_daemon_option/0","title":"ssh.tcpip_tunnel_out_daemon_option/0","type":"type"},{"doc":"Provides a fun to implement your own logging or other action when an unexpected message arrives. If the fun returns report the usual info report is issued but if skip is returned no report is generated.","ref":"ssh.html#t:unexpectedfun_common_option/0","title":"ssh.unexpectedfun_common_option/0","type":"type"},{"doc":"Return values from the connection_info/1 and connection_info/2 functions. In the option info tuple are only the options included that differs from the default values.","ref":"ssh.html#t:version/0","title":"ssh.version/0","type":"type"},{"doc":"This module defines a callback handler for the communication with an SSH Agent and can be used to replace the default callback . This allows to issue signing requests to an agent that stores SSH private keys to perform authentication. Ssh_agent implements the ssh_client_key_api , to allow it to be used by setting the option key_cb when starting a client (with for example ssh:connect , ssh:shell ). {key_cb, {ssh_agent, []}} The agent communication is established through a UNIX domain socket. By default, the socket path will be fetched from the SSH_AUTH_SOCK enviroment variable, which is the default socket path in the agent implementation of OpenSSH . In order to set a different socket path the socket_path option can be set. {key_cb, {ssh_agent, [{socket_path, SocketPath}]}} The functions are Callbacks for the SSH app. They are not intended to be called from the user's code!","ref":"ssh_agent.html","title":"ssh_agent","type":"module"},{"doc":"This callback is delegated to the ssh_file module.","ref":"ssh_agent.html#add_host_key/3","title":"ssh_agent.add_host_key/3","type":"function"},{"doc":"","ref":"ssh_agent.html#add_host_key/4","title":"ssh_agent.add_host_key/4","type":"function"},{"doc":"This callback is delegated to the ssh_file module.","ref":"ssh_agent.html#is_host_key/4","title":"ssh_agent.is_host_key/4","type":"function"},{"doc":"","ref":"ssh_agent.html#is_host_key/5","title":"ssh_agent.is_host_key/5","type":"function"},{"doc":"Types and description See the api description in ssh_client_key_api, Module:user_key/2 .","ref":"ssh_agent.html#user_key/2","title":"ssh_agent.user_key/2","type":"function"},{"doc":"The module which the add_host_key and is_host_key callbacks are delegated to. Defaults to the ssh_file module.","ref":"ssh_agent.html#t:call_ssh_file_option/0","title":"ssh_agent.call_ssh_file_option/0","type":"type"},{"doc":"Sets the socket path for the communication with the agent.","ref":"ssh_agent.html#t:socket_path_option/0","title":"ssh_agent.socket_path_option/0","type":"type"},{"doc":"Sets the time-out in milliseconds when communicating with the agent via the socket. The default value is 1000 .","ref":"ssh_agent.html#t:timeout_option/0","title":"ssh_agent.timeout_option/0","type":"type"},{"doc":"This module replaces ssh_channel. The old module is still available for compatibility, but should not be used for new programs. The old module will not be maintained except for some error corrections SSH services (clients and servers) are implemented as channels that are multiplexed over an SSH connection and communicates over the SSH Connection Protocol . This module provides a callback API that takes care of generic channel aspects for clients, such as flow control and close messages. It lets the callback functions take care of the service (application) specific parts. This behavior also ensures that the channel process honors the principal of an OTP-process so that it can be part of a supervisor tree. This is a requirement of channel processes implementing a subsystem that will be added to the ssh applications supervisor tree. When implementing a ssh subsystem for daemons, use -behaviour(ssh_server_channel) (Replaces ssh_daemon_channel) instead. Functions in this module are not supposed to be called outside a module implementing this behaviour!","ref":"ssh_client_channel.html","title":"ssh_client_channel","type":"behaviour"},{"doc":"ChannelRef = pid() As returned by start_link/4 Msg = term() Timeout = timeout() Reply = term() Reason = closed | timeout Makes a synchronous call to the channel process by sending a message and waiting until a reply arrives, or a time-out occurs. The channel calls Module:handle_call/3 to handle the message. If the channel process does not exist, {error, closed} is returned.","ref":"ssh_client_channel.html#call/2","title":"ssh_client_channel.call/2","type":"function"},{"doc":"","ref":"ssh_client_channel.html#call/3","title":"ssh_client_channel.call/3","type":"function"},{"doc":"ChannelRef = pid() As returned by start_link/4 Msg = term() Sends an asynchronous message to the channel process and returns ok immediately, ignoring if the destination node or channel process does not exist. The channel calls Module:handle_cast/2 to handle the message.","ref":"ssh_client_channel.html#cast/2","title":"ssh_client_channel.cast/2","type":"function"},{"doc":"OldVsn = term() In the case of an upgrade, OldVsn is Vsn , and in the case of a downgrade, OldVsn is {down,Vsn} . Vsn is defined by the vsn attribute(s) of the old version of the callback module Module . If no such attribute is defined, the version is the checksum of the BEAM file. State = term() Internal state of the channel. Extra = term() Passed &quot;as-is&quot; from the {advanced,Extra} part of the update instruction. Converts process state when code is changed. This function is called by a client-side channel when it is to update its internal state during a release upgrade or downgrade, that is, when the instruction {update,Module,Change,...} , where Change={advanced,Extra} , is given in the appup file. For more information, refer to Section 9.11.6 Release Handling Instructions in the System Documentation. Soft upgrade according to the OTP release concept is not straight forward for the server side, as subsystem channel processes are spawned by the ssh application and hence added to its supervisor tree. The subsystem channels can be upgraded when upgrading the user application, if the callback functions can handle two versions of the state, but this function cannot be used in the normal way.","ref":"ssh_client_channel.html#c:code_change/3","title":"ssh_client_channel.code_change/3","type":"callback"},{"doc":"State = term() as returned by init/1 Makes an existing process an ssh_client_channel (replaces ssh_channel) process. Does not return, instead the calling process enters the ssh_client_channel (replaces ssh_channel) process receive loop and become an ssh_client_channel process. The process must have been started using one of the start functions in proc_lib , see the proc_lib(3) manual page in STDLIB. The user is responsible for any initialization of the process and must call init/1 .","ref":"ssh_client_channel.html#enter_loop/1","title":"ssh_client_channel.enter_loop/1","type":"function"},{"doc":"Msg = term() From = opaque() Is to be used as argument to reply/2 State = term() Result = {reply, Reply, NewState} | {reply, Reply, NewState, timeout()} | {noreply, NewState} | {noreply , NewState, timeout()} | {stop, Reason, Reply, NewState} | {stop, Reason, NewState} Reply = term() Will be the return value of call/[2,3] NewState = term() Reason = term() Handles messages sent by calling call/[2,3] For more detailed information on time-outs,, see Section Callback timeouts .","ref":"ssh_client_channel.html#c:handle_call/3","title":"ssh_client_channel.handle_call/3","type":"callback"},{"doc":"Msg = term() State = term() Result = {noreply, NewState} | {noreply, NewState, timeout()} | {stop, Reason, NewState} NewState = term() Reason = term() Handles messages sent by calling cast/2 . For more detailed information on time-outs, see Section Callback timeouts .","ref":"ssh_client_channel.html#c:handle_cast/2","title":"ssh_client_channel.handle_cast/2","type":"callback"},{"doc":"Msg = timeout | term() ChannelId = ssh:channel_id() State = term() Handles other messages than SSH Connection Protocol, call, or cast messages sent to the channel. Possible Erlang 'EXIT' messages is to be handled by this function and all channels are to handle the following message. {ssh_channel_up, ssh:channel_id() , ssh:connection_ref() } This is the first message that the channel receives. It is sent just before the init/1 function returns successfully. This is especially useful if the server wants to send a message to the client without first receiving a message from it. If the message is not useful for your particular scenario, ignore it by immediately returning {ok, State} .","ref":"ssh_client_channel.html#c:handle_msg/2","title":"ssh_client_channel.handle_msg/2","type":"callback"},{"doc":"Msg = ssh_connection:event() ChannelId = ssh:channel_id() State = term() Handles SSH Connection Protocol messages that may need service-specific attention. For details, see ssh_connection:event() . The following message is taken care of by the ssh_client_channel behavior. {closed, ssh:channel_id() } The channel behavior sends a close message to the other side, if such a message has not already been sent. Then it terminates the channel with reason normal .","ref":"ssh_client_channel.html#c:handle_ssh_msg/2","title":"ssh_client_channel.handle_ssh_msg/2","type":"callback"},{"doc":"Options = [{Option, Value}] State = term() Timeout = timeout() Reason = term() The following options must be present: {channel_cb, atom()} The module that implements the channel behaviour. {init_args(), list()} The list of arguments to the init function of the callback module. {cm, ssh:connection_ref() } Reference to the ssh connection as returned by ssh:connect/3 . {channel_id, ssh:channel_id() } Id of the ssh channel as returned by ssh_connection:session_channel/2,4 . This function is normally not called by the user. The user only needs to call if the channel process needs to be started with help of proc_lib instead of calling start/4 or start_link/4 .","ref":"ssh_client_channel.html#init/1","title":"ssh_client_channel.init/1","type":"function"},{"doc":"Args = term() Last argument to start_link/4 . State = term() Reason = term() Makes necessary initializations and returns the initial channel state if the initializations succeed. For more detailed information on time-outs, see Section Callback timeouts .","ref":"ssh_client_channel.html#c:init/1","title":"ssh_client_channel.init/1","type":"callback"},{"doc":"Client = opaque() Reply = term() This function can be used by a channel to send a reply to a client that called call/[2,3] when the reply cannot be defined in the return value of Module:handle_call/3 . Client must be the From argument provided to the callback function handle_call/3 . Reply is an arbitrary term, which is given back to the client as the return value of call/[2,3].","ref":"ssh_client_channel.html#reply/2","title":"ssh_client_channel.reply/2","type":"function"},{"doc":"SshConnection = ssh:connection_ref() As returned by ssh:connect/3 ChannelId = ssh:channel_id() As returned by ssh_connection:session_channel/[2,4] . ChannelCb = atom() Name of the module implementing the service-specific parts of the channel. CbInitArgs = [term()] Argument list for the init function in the callback module. ChannelRef = pid() Starts a process that handles an SSH channel. It is called internally, by the ssh daemon, or explicitly by the ssh client implementations. The behavior sets the trap_exit flag to true .","ref":"ssh_client_channel.html#start/4","title":"ssh_client_channel.start/4","type":"function"},{"doc":"","ref":"ssh_client_channel.html#start_link/4","title":"ssh_client_channel.start_link/4","type":"function"},{"doc":"Reason = term() State = term() This function is called by a channel process when it is about to terminate. Before this function is called, ssh_connection:close/2 is called, if it has not been called earlier. This function does any necessary cleaning up. When it returns, the channel process terminates with reason Reason . The return value is ignored.","ref":"ssh_client_channel.html#c:terminate/2","title":"ssh_client_channel.terminate/2","type":"callback"},{"doc":"The SSH Connection Protocol is used by clients and servers, that is, SSH channels, to communicate over the SSH connection. The API functions in this module send SSH Connection Protocol events, which are received as messages by the remote channel handling the remote channel. The Erlang format of thoose messages is (see also below ): {ssh_cm, ssh:connection_ref() , channel_msg() } If the ssh_client_channel behavior is used to implement the channel process, these messages are handled by handle_ssh_msg/2 .","ref":"ssh_connection.html","title":"ssh_connection","type":"module"},{"doc":"Adjusts the SSH flow control window. This is to be done by both the client- and server-side channel processes. Channels implemented with the ssh_client_channel behavior do not normally need to call this function as flow control is handled by the behavior. The behavior adjusts the window every time the callback handle_ssh_msg/2 returns after processing channel data.","ref":"ssh_connection.html#adjust_window/3","title":"ssh_connection.adjust_window/3","type":"function"},{"doc":"A server- or client-channel process can choose to close their session by sending a close event. This function is called by the ssh_client_channel behavior when the channel is terminated, see ssh_client_channel(3) . Thus, channels implemented with the behavior are not to call this function explicitly.","ref":"ssh_connection.html#close/2","title":"ssh_connection.close/2","type":"function"},{"doc":"Is to be called by a client-channel process to request that the server starts executing the given command. The result is several messages according to the following pattern. The last message is a channel close message, as the exec request is a one-time execution that closes the channel when it is done. N x data message(s) The result of executing the command can be only one line or thousands of lines depending on the command. 0 or 1 x eof message Indicates that no more data is to be sent. 0 or 1 x exit signal message Not all systems send signals. For details on valid string values, see RFC 4254, Section 6.10 0 or 1 x exit status message It is recommended by the SSH Connection Protocol to send this message, but that is not always the case. 1 x closed status message Indicates that the ssh_client_channel started for the execution of the command has now been shut down. See the User's Guide section on One-Time Execution for examples.","ref":"ssh_connection.html#exec/4","title":"ssh_connection.exec/4","type":"function"},{"doc":"Is to be called by a server-channel process to send the exit status of a command to the client.","ref":"ssh_connection.html#exit_status/3","title":"ssh_connection.exit_status/3","type":"function"},{"doc":"Sends an SSH Connection Protocol pty_req , to allocate a pseudo-terminal. Is to be called by an SSH client process. Options: {term, string()} Defaults to os:getenv(&quot;TERM&quot;) or vt100 if it is undefined. {width, integer()} Defaults to 80 if pixel_width is not defined. {height, integer()} Defaults to 24 if pixel_height is not defined. {pixel_width, integer()} Is disregarded if width is defined. {pixel_height, integer()} Is disregarded if height is defined. {pty_opts, [{posix_atom(), integer()}]} Option can be an empty list. Otherwise, see possible POSIX names in Section 8 in RFC 4254 .","ref":"ssh_connection.html#ptty_alloc/3","title":"ssh_connection.ptty_alloc/3","type":"function"},{"doc":"","ref":"ssh_connection.html#ptty_alloc/4","title":"ssh_connection.ptty_alloc/4","type":"function"},{"doc":"Sends status replies to requests where the requester has stated that it wants a status report, that is, WantReply = true . If WantReply is false , calling this function becomes a &quot;noop&quot;. Is to be called while handling an SSH Connection Protocol message containing a WantReply boolean value.","ref":"ssh_connection.html#reply_request/4","title":"ssh_connection.reply_request/4","type":"function"},{"doc":"ConnectionRef = ssh:connection_ref() ChannelId = ssh:channel_id() Data = iodata() Type = ssh_data_type_code() Timeout = timeout() Error = {error, reason() } Is to be called by client- and server-channel processes to send data to each other. The function subsystem/4 and subsequent calls of send/3,4,5 must be executed in the same process.","ref":"ssh_connection.html#send/3","title":"ssh_connection.send/3","type":"function"},{"doc":"","ref":"ssh_connection.html#send/4","title":"ssh_connection.send/4","type":"function"},{"doc":"","ref":"ssh_connection.html#send/5","title":"ssh_connection.send/5","type":"function"},{"doc":"Sends EOF on channel ChannelId .","ref":"ssh_connection.html#send_eof/2","title":"ssh_connection.send_eof/2","type":"function"},{"doc":"Opens a channel for an SSH session. The channel id returned from this function is the id used as input to the other functions in this module.","ref":"ssh_connection.html#session_channel/2","title":"ssh_connection.session_channel/2","type":"function"},{"doc":"","ref":"ssh_connection.html#session_channel/4","title":"ssh_connection.session_channel/4","type":"function"},{"doc":"Environment variables can be passed before starting the shell/command. Is to be called by a client channel processes.","ref":"ssh_connection.html#setenv/5","title":"ssh_connection.setenv/5","type":"function"},{"doc":"Is to be called by a client channel process to request that the user default shell (typically defined in /etc/passwd in Unix systems) is executed at the server end. Note: the return value is ok instead of success unlike in other functions in this module. This is a fault that was introduced so long ago that any change would break a large number of existing software.","ref":"ssh_connection.html#shell/2","title":"ssh_connection.shell/2","type":"function"},{"doc":"Is to be called by a client-channel process for requesting to execute a predefined subsystem on the server. The function subsystem/4 and subsequent calls of send/3,4,5 must be executed in the same process.","ref":"ssh_connection.html#subsystem/4","title":"ssh_connection.subsystem/4","type":"function"},{"doc":"As mentioned in the introduction, the SSH Connection Protocol events are handled as messages. When writing a channel handling process without using the support by the ssh_client_channel behavior the process must handle thoose messages.","ref":"ssh_connection.html#t:channel_msg/0","title":"ssh_connection.channel_msg/0","type":"type"},{"doc":"This event is sent as a result of calling ssh_connection:close/2 . Both the handling of this event and sending it are taken care of by the ssh_client_channel behavior.","ref":"ssh_connection.html#t:closed_ch_msg/0","title":"ssh_connection.closed_ch_msg/0","type":"type"},{"doc":"Data has arrived on the channel. This event is sent as a result of calling ssh_connection:send/[3,4,5] .","ref":"ssh_connection.html#t:data_ch_msg/0","title":"ssh_connection.data_ch_msg/0","type":"type"},{"doc":"Environment variables can be passed to the shell/command to be started later. This event is sent as a result of calling ssh_connection:setenv/5 .","ref":"ssh_connection.html#t:env_ch_msg/0","title":"ssh_connection.env_ch_msg/0","type":"type"},{"doc":"Indicates that the other side sends no more data. This event is sent as a result of calling ssh_connection:send_eof/2 .","ref":"ssh_connection.html#t:eof_ch_msg/0","title":"ssh_connection.eof_ch_msg/0","type":"type"},{"doc":"As mentioned in the introduction, the SSH Connection Protocol events are handled as messages. When writing a channel handling process without using the support by the ssh_client_channel behavior the process must handle thoose messages.","ref":"ssh_connection.html#t:event/0","title":"ssh_connection.event/0","type":"type"},{"doc":"This message requests that the server starts execution of the given command. This event is sent as a result of calling ssh_connection:exec/4 .","ref":"ssh_connection.html#t:exec_ch_msg/0","title":"ssh_connection.exec_ch_msg/0","type":"type"},{"doc":"A remote execution can terminate violently because of a signal. Then this message can be received. For details on valid string values, see RFC 4254 Section 6.10, which shows a special case of these signals.","ref":"ssh_connection.html#t:exit_signal_ch_msg/0","title":"ssh_connection.exit_signal_ch_msg/0","type":"type"},{"doc":"When the command running at the other end terminates, the following message can be sent to return the exit status of the command. A zero exit_status usually means that the command terminated successfully. This event is sent as a result of calling ssh_connection:exit_status/3 .","ref":"ssh_connection.html#t:exit_status_ch_msg/0","title":"ssh_connection.exit_status_ch_msg/0","type":"type"},{"doc":"A pseudo-terminal has been requested for the session. Terminal is the value of the TERM environment variable value, that is, vt100 . Zero dimension parameters must be ignored. The character/row dimensions override the pixel dimensions (when non-zero). Pixel dimensions refer to the drawable area of the window. Opcode in the TerminalModes list is the mnemonic name, represented as a lowercase Erlang atom, defined in RFC 4254 , Section 8. It can also be an Opcode if the mnemonic name is not listed in the RFC. Example: OP code: 53, mnemonic name ECHO erlang atom: echo . This event is sent as a result of calling ssh_connection:ptty_alloc/4 .","ref":"ssh_connection.html#t:pty_ch_msg/0","title":"ssh_connection.pty_ch_msg/0","type":"type"},{"doc":"The result of a call. If the request reached the peer, was handled and the response reached the requesting node the req_status() is the status reported from the peer. If not, the reason() indicates what went wrong: closed indicates that the channel or connection was closed when trying to send the request timeout indicates that the operation exceeded a time limit","ref":"ssh_connection.html#t:reason/0","title":"ssh_connection.reason/0","type":"type"},{"doc":"The status of a request. Coresponds to the SSH_MSG_CHANNEL_SUCCESS and SSH_MSG_CHANNEL_FAILURE values in RFC 4254, Section 5.4 .","ref":"ssh_connection.html#t:req_status/0","title":"ssh_connection.req_status/0","type":"type"},{"doc":"The result of a call. If the request reached the peer, was handled and the response reached the requesting node the req_status() is the status reported from the peer. If not, the reason() indicates what went wrong: closed indicates that the channel or connection was closed when trying to send the request timeout indicates that the operation exceeded a time limit","ref":"ssh_connection.html#t:result/0","title":"ssh_connection.result/0","type":"type"},{"doc":"This message requests that the user default shell is started at the other end. This event is sent as a result of calling ssh_connection:shell/2 .","ref":"ssh_connection.html#t:shell_ch_msg/0","title":"ssh_connection.shell_ch_msg/0","type":"type"},{"doc":"A signal can be delivered to the remote process/service using the following message. Some systems do not support signals, in which case they are to ignore this message. There is currently no function to generate this event as the signals referred to are on OS-level and not something generated by an Erlang program.","ref":"ssh_connection.html#t:signal_ch_msg/0","title":"ssh_connection.signal_ch_msg/0","type":"type"},{"doc":"The valid values are 0 (&quot;normal&quot;) and 1 (&quot;stderr&quot;), see RFC 4254, Section 5.2 .","ref":"ssh_connection.html#t:ssh_data_type_code/0","title":"ssh_connection.ssh_data_type_code/0","type":"type"},{"doc":"A pseudo-terminal has been requested for the session. Terminal is the value of the TERM environment variable value, that is, vt100 . Zero dimension parameters must be ignored. The character/row dimensions override the pixel dimensions (when non-zero). Pixel dimensions refer to the drawable area of the window. Opcode in the TerminalModes list is the mnemonic name, represented as a lowercase Erlang atom, defined in RFC 4254 , Section 8. It can also be an Opcode if the mnemonic name is not listed in the RFC. Example: OP code: 53, mnemonic name ECHO erlang atom: echo . This event is sent as a result of calling ssh_connection:ptty_alloc/4 .","ref":"ssh_connection.html#t:term_mode/0","title":"ssh_connection.term_mode/0","type":"type"},{"doc":"Messages that include a WantReply expect the channel handling process to call ssh_connection:reply_request/4 with the boolean value of WantReply as the second argument.","ref":"ssh_connection.html#t:want_reply/0","title":"ssh_connection.want_reply/0","type":"type"},{"doc":"When the window (terminal) size changes on the client side, it can send a message to the server side to inform it of the new dimensions. No API function generates this event.","ref":"ssh_connection.html#t:window_change_ch_msg/0","title":"ssh_connection.window_change_ch_msg/0","type":"type"},{"doc":"This module implements an SSH FTP (SFTP) client. SFTP is a secure, encrypted file transfer service available for SSH.","ref":"ssh_sftp.html","title":"ssh_sftp","type":"module"},{"doc":"The apread/4 function reads from a specified position, combining the position/3 and aread/3 functions.","ref":"ssh_sftp.html#apread/4","title":"ssh_sftp.apread/4","type":"function"},{"doc":"The apwrite/4 function writes to a specified position, combining the position/3 and awrite/3 functions.","ref":"ssh_sftp.html#apwrite/4","title":"ssh_sftp.apwrite/4","type":"function"},{"doc":"Reads from an open file, without waiting for the result. If the handle is valid, the function returns {async, N} , where N is a term guaranteed to be unique between calls of aread . The actual data is sent as a message to the calling process. This message has the form {async_reply, N, Result} , where Result is the result from the read, either {ok, Data} , eof , or {error, reason()} .","ref":"ssh_sftp.html#aread/3","title":"ssh_sftp.aread/3","type":"function"},{"doc":"Writes to an open file, without waiting for the result. If the handle is valid, the function returns {async, N} , where N is a term guaranteed to be unique between calls of awrite . The result of the write operation is sent as a message to the calling process. This message has the form {async_reply, N, Result} , where Result is the result from the write, either ok , or {error, reason()} .","ref":"ssh_sftp.html#awrite/3","title":"ssh_sftp.awrite/3","type":"function"},{"doc":"Closes a handle to an open file or directory on the server.","ref":"ssh_sftp.html#close/2","title":"ssh_sftp.close/2","type":"function"},{"doc":"","ref":"ssh_sftp.html#close/3","title":"ssh_sftp.close/3","type":"function"},{"doc":"Deletes a directory specified by Name . The directory must be empty before it can be successfully deleted.","ref":"ssh_sftp.html#del_dir/2","title":"ssh_sftp.del_dir/2","type":"function"},{"doc":"","ref":"ssh_sftp.html#del_dir/3","title":"ssh_sftp.del_dir/3","type":"function"},{"doc":"Deletes the file specified by Name .","ref":"ssh_sftp.html#delete/2","title":"ssh_sftp.delete/2","type":"function"},{"doc":"","ref":"ssh_sftp.html#delete/3","title":"ssh_sftp.delete/3","type":"function"},{"doc":"Lists the given directory on the server, returning the filenames as a list of strings.","ref":"ssh_sftp.html#list_dir/2","title":"ssh_sftp.list_dir/2","type":"function"},{"doc":"","ref":"ssh_sftp.html#list_dir/3","title":"ssh_sftp.list_dir/3","type":"function"},{"doc":"Creates a directory specified by Name . Name must be a full path to a new directory. The directory can only be created in an existing directory.","ref":"ssh_sftp.html#make_dir/2","title":"ssh_sftp.make_dir/2","type":"function"},{"doc":"","ref":"ssh_sftp.html#make_dir/3","title":"ssh_sftp.make_dir/3","type":"function"},{"doc":"Creates a symbolic link pointing to Target with the name Name .","ref":"ssh_sftp.html#make_symlink/3","title":"ssh_sftp.make_symlink/3","type":"function"},{"doc":"","ref":"ssh_sftp.html#make_symlink/4","title":"ssh_sftp.make_symlink/4","type":"function"},{"doc":"Opens a file on the server and returns a handle, which can be used for reading or writing.","ref":"ssh_sftp.html#open/3","title":"ssh_sftp.open/3","type":"function"},{"doc":"","ref":"ssh_sftp.html#open/4","title":"ssh_sftp.open/4","type":"function"},{"doc":"Opens a handle to a tar file on the server, associated with ChannelPid . The handle can be used for remote tar creation and extraction. The actual writing and reading is performed by calls to erl_tar:add/3,4 and erl_tar:extract/2 . Note: The erl_tar:init/3 function should not be called, that one is called by this open_tar function. For code examples see Section SFTP Client with TAR Compression in the ssh Users Guide. The crypto mode option is explained in the data types section above, see Crypto operations for open_tar . Encryption is assumed if the Mode contains write , and decryption if the Mode contains read .","ref":"ssh_sftp.html#open_tar/3","title":"ssh_sftp.open_tar/3","type":"function"},{"doc":"","ref":"ssh_sftp.html#open_tar/4","title":"ssh_sftp.open_tar/4","type":"function"},{"doc":"Opens a handle to a directory on the server. The handle can be used for reading directory contents.","ref":"ssh_sftp.html#opendir/2","title":"ssh_sftp.opendir/2","type":"function"},{"doc":"","ref":"ssh_sftp.html#opendir/3","title":"ssh_sftp.opendir/3","type":"function"},{"doc":"Sets the file position of the file referenced by Handle . Returns {ok, NewPosition} (as an absolute offset) if successful, otherwise {error, reason()} . Location is one of the following: Offset The same as {bof, Offset} . {bof, Offset} Absolute offset. {cur, Offset} Offset from the current position. {eof, Offset} Offset from the end of file. bof | cur | eof The same as eariler with Offset 0, that is, {bof, 0} | {cur, 0} | {eof, 0} .","ref":"ssh_sftp.html#position/3","title":"ssh_sftp.position/3","type":"function"},{"doc":"","ref":"ssh_sftp.html#position/4","title":"ssh_sftp.position/4","type":"function"},{"doc":"The pread/3,4 function reads from a specified position, combining the position/3 and read/3,4 functions.","ref":"ssh_sftp.html#pread/4","title":"ssh_sftp.pread/4","type":"function"},{"doc":"","ref":"ssh_sftp.html#pread/5","title":"ssh_sftp.pread/5","type":"function"},{"doc":"The pwrite/3,4 function writes to a specified position, combining the position/3 and write/3,4 functions.","ref":"ssh_sftp.html#pwrite/4","title":"ssh_sftp.pwrite/4","type":"function"},{"doc":"","ref":"ssh_sftp.html#pwrite/5","title":"ssh_sftp.pwrite/5","type":"function"},{"doc":"Reads Len bytes from the file referenced by Handle . Returns {ok, Data} , eof , or {error, reason()} . If the file is opened with binary , Data is a binary, otherwise it is a string. If the file is read past eof , only the remaining bytes are read and returned. If no bytes are read, eof is returned.","ref":"ssh_sftp.html#read/3","title":"ssh_sftp.read/3","type":"function"},{"doc":"","ref":"ssh_sftp.html#read/4","title":"ssh_sftp.read/4","type":"function"},{"doc":"Reads a file from the server, and returns the data in a binary.","ref":"ssh_sftp.html#read_file/2","title":"ssh_sftp.read_file/2","type":"function"},{"doc":"","ref":"ssh_sftp.html#read_file/3","title":"ssh_sftp.read_file/3","type":"function"},{"doc":"Returns a file_info record from the file system object specified by Name or Handle . See file:read_file_info/2 for information about the record. Depending on the underlying OS:es links might be followed and info on the final file, directory etc is returned. See read_link_info/2 on how to get information on links instead.","ref":"ssh_sftp.html#read_file_info/2","title":"ssh_sftp.read_file_info/2","type":"function"},{"doc":"","ref":"ssh_sftp.html#read_file_info/3","title":"ssh_sftp.read_file_info/3","type":"function"},{"doc":"Reads the link target from the symbolic link specified by name .","ref":"ssh_sftp.html#read_link/2","title":"ssh_sftp.read_link/2","type":"function"},{"doc":"","ref":"ssh_sftp.html#read_link/3","title":"ssh_sftp.read_link/3","type":"function"},{"doc":"Returns a file_info record from the symbolic link specified by Name or Handle . See file:read_link_info/2 for information about the record.","ref":"ssh_sftp.html#read_link_info/2","title":"ssh_sftp.read_link_info/2","type":"function"},{"doc":"","ref":"ssh_sftp.html#read_link_info/3","title":"ssh_sftp.read_link_info/3","type":"function"},{"doc":"Renames a file named OldName and gives it the name NewName .","ref":"ssh_sftp.html#rename/3","title":"ssh_sftp.rename/3","type":"function"},{"doc":"","ref":"ssh_sftp.html#rename/4","title":"ssh_sftp.rename/4","type":"function"},{"doc":"Host = ssh:host() Port = inet:port_number() TcpSocket = ssh:open_socket() Options = [ sftp_option() | ssh:client_option() ] SftpOptions = [ sftp_option() ] ChannelPid = pid() ConnectionRef = ssh:connection_ref() Error = {error, reason() } If no connection reference is provided, a connection is set up, and the new connection is returned. An SSH channel process is started to handle the communication with the SFTP server. The returned pid for this process is to be used as input to all other API functions in this module. Options: {timeout, timeout()} There are two ways to set a timeout for the underlying ssh connection: If the connection timeout option connect_timeout is set, that value is used also for the negotiation timeout and this option ( timeout ) is ignored. Otherwise, this option ( timeout ) is used as the negotiation timeout only and there is no connection timeout set The value defaults to infinity . {sftp_vsn, integer()} Desired SFTP protocol version. The actual version is the minimum of the desired version and the maximum supported versions by the SFTP server. All other options are directly passed to ssh:connect/3 or ignored if a connection is already provided.","ref":"ssh_sftp.html#start_channel/1","title":"ssh_sftp.start_channel/1","type":"function"},{"doc":"","ref":"ssh_sftp.html#start_channel/2","title":"ssh_sftp.start_channel/2","type":"function"},{"doc":"","ref":"ssh_sftp.html#start_channel/3","title":"ssh_sftp.start_channel/3","type":"function"},{"doc":"Stops an SFTP channel. Does not close the SSH connection. Use ssh:close/1 to close it.","ref":"ssh_sftp.html#stop_channel/1","title":"ssh_sftp.stop_channel/1","type":"function"},{"doc":"Writes data to the file referenced by Handle . The file is to be opened with write or append flag. Returns ok if successful or {error, reason()} otherwise.","ref":"ssh_sftp.html#write/3","title":"ssh_sftp.write/3","type":"function"},{"doc":"","ref":"ssh_sftp.html#write/4","title":"ssh_sftp.write/4","type":"function"},{"doc":"Writes a file to the server. The file is created if it does not exist but overwritten if it exists.","ref":"ssh_sftp.html#write_file/3","title":"ssh_sftp.write_file/3","type":"function"},{"doc":"","ref":"ssh_sftp.html#write_file/4","title":"ssh_sftp.write_file/4","type":"function"},{"doc":"Writes file information from a file_info record to the file specified by Name . See file:write_file_info/[2,3] for information about the record.","ref":"ssh_sftp.html#write_file_info/3","title":"ssh_sftp.write_file_info/3","type":"function"},{"doc":"","ref":"ssh_sftp.html#write_file_info/4","title":"ssh_sftp.write_file_info/4","type":"function"},{"doc":"The init_fun() in the tar_crypto_spec is applied once prior to any other crypto operation. The intention is that this function initiates the encryption or decryption for example by calling crypto:crypto_init/4 or similar. The crypto_state() is the state such a function may return. If the selected cipher needs to have the input data partioned into blocks of a certain size, the init_fun() should return the second form of return value with the chunk_size() set to the block size. If the chunk_size() is undefined , the size of the PlainBin s varies, because this is intended for stream crypto, whereas a fixed chunk_size() is intended for block crypto. A chunk_size() can be changed in the return from the crypto_fun() . The value can be changed between pos_integer() and undefined .","ref":"ssh_sftp.html#t:chunk_size/0","title":"ssh_sftp.chunk_size/0","type":"type"},{"doc":"The initial crypto_state() returned from the init_fun() is folded into repeated applications of the crypto_fun() in the tar_crypto_spec . The binary returned from that fun is sent to the remote SFTP server and the new crypto_state() is used in the next call of the crypto_fun() . If the crypto_fun() reurns a chunk_size() , that value is as block size for further blocks in calls to crypto_fun() .","ref":"ssh_sftp.html#t:crypto_fun/0","title":"ssh_sftp.crypto_fun/0","type":"type"},{"doc":"The initial crypto_state() returned from the init_fun() is folded into repeated applications of the crypto_fun() in the tar_crypto_spec . The binary returned from that fun is sent to the remote SFTP server and the new crypto_state() is used in the next call of the crypto_fun() . If the crypto_fun() reurns a chunk_size() , that value is as block size for further blocks in calls to crypto_fun() .","ref":"ssh_sftp.html#t:crypto_result/0","title":"ssh_sftp.crypto_result/0","type":"type"},{"doc":"The init_fun() in the tar_crypto_spec is applied once prior to any other crypto operation. The intention is that this function initiates the encryption or decryption for example by calling crypto:crypto_init/4 or similar. The crypto_state() is the state such a function may return. If the selected cipher needs to have the input data partioned into blocks of a certain size, the init_fun() should return the second form of return value with the chunk_size() set to the block size. If the chunk_size() is undefined , the size of the PlainBin s varies, because this is intended for stream crypto, whereas a fixed chunk_size() is intended for block crypto. A chunk_size() can be changed in the return from the crypto_fun() . The value can be changed between pos_integer() and undefined .","ref":"ssh_sftp.html#t:crypto_state/0","title":"ssh_sftp.crypto_state/0","type":"type"},{"doc":"Specifies the encryption or decryption applied to tar files when using open_tar/3 or open_tar/4 . The encryption or decryption is applied to the generated stream of bytes prior to sending the resulting stream to the SFTP server. For code examples see Section Example with encryption in the ssh Users Guide.","ref":"ssh_sftp.html#t:decrypt_spec/0","title":"ssh_sftp.decrypt_spec/0","type":"type"},{"doc":"Specifies the encryption or decryption applied to tar files when using open_tar/3 or open_tar/4 . The encryption or decryption is applied to the generated stream of bytes prior to sending the resulting stream to the SFTP server. For code examples see Section Example with encryption in the ssh Users Guide.","ref":"ssh_sftp.html#t:encrypt_spec/0","title":"ssh_sftp.encrypt_spec/0","type":"type"},{"doc":"If doing encryption, the final_fun() in the tar_crypto_spec is applied to the last piece of data. The final_fun() is responsible for padding (if needed) and encryption of that last piece.","ref":"ssh_sftp.html#t:final_fun/0","title":"ssh_sftp.final_fun/0","type":"type"},{"doc":"The init_fun() in the tar_crypto_spec is applied once prior to any other crypto operation. The intention is that this function initiates the encryption or decryption for example by calling crypto:crypto_init/4 or similar. The crypto_state() is the state such a function may return. If the selected cipher needs to have the input data partioned into blocks of a certain size, the init_fun() should return the second form of return value with the chunk_size() set to the block size. If the chunk_size() is undefined , the size of the PlainBin s varies, because this is intended for stream crypto, whereas a fixed chunk_size() is intended for block crypto. A chunk_size() can be changed in the return from the crypto_fun() . The value can be changed between pos_integer() and undefined .","ref":"ssh_sftp.html#t:init_fun/0","title":"ssh_sftp.init_fun/0","type":"type"},{"doc":"A description of the reason why an operation failed. The atom() value is formed from the sftp error codes in the protocol-level responses as defined in draft-ietf-secsh-filexfer-13 section 9.1. The codes are named as SSH_FX_* which are transformed into lowercase of the star-part. E.g. the error code SSH_FX_NO_SUCH_FILE will cause the reason() to be no_such_file . The string() reason is the error information from the server in case of an exit-signal. If that information is empty, the reason is the exit signal name. The tuple() reason are other errors like for example {exit_status,1} .","ref":"ssh_sftp.html#t:reason/0","title":"ssh_sftp.reason/0","type":"type"},{"doc":"","ref":"ssh_sftp.html#t:sftp_option/0","title":"ssh_sftp.sftp_option/0","type":"type"},{"doc":"Specifies the encryption or decryption applied to tar files when using open_tar/3 or open_tar/4 . The encryption or decryption is applied to the generated stream of bytes prior to sending the resulting stream to the SFTP server. For code examples see Section Example with encryption in the ssh Users Guide.","ref":"ssh_sftp.html#t:tar_crypto_spec/0","title":"ssh_sftp.tar_crypto_spec/0","type":"type"},{"doc":"Specifies a channel process to handle an SFTP subsystem.","ref":"ssh_sftpd.html","title":"ssh_sftpd","type":"module"},{"doc":"Is to be used together with ssh:daemon/[1,2,3] The Name is &quot;sftp&quot; and CbMod is the name of the Erlang module implementing the subsystem using the ssh_server_channel (replaces ssh_daemon_channel) behaviour. Options: cwd Sets the initial current working directory for the server. file_handler Determines which module to call for accessing the file server. The default value is ssh_sftpd_file , which uses the file and filelib APIs to access the standard OTP file server. This option can be used to plug in other file servers. max_files The default value is 0 , which means that there is no upper limit. If supplied, the number of filenames returned to the SFTP client per READDIR request is limited to at most the given value. root Sets the SFTP root directory. Then the user cannot see any files above this root. If, for example, the root directory is set to /tmp , then the user sees this directory as / . If the user then writes cd /etc , the user moves to /tmp/etc . sftpd_vsn Sets the SFTP version to use. Defaults to 5. Version 6 is under development and limited.","ref":"ssh_sftpd.html#subsystem_spec/1","title":"ssh_sftpd.subsystem_spec/1","type":"function"}]