<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.25.1">
    <meta name="project" content="kernel v8.0.2">

    <title>erpc â€” kernel v8.0.2</title>
    <link rel="stylesheet" href="dist/erlang-951161c89561e05735a5.css" />

    <script src="dist/sidebar_items-69e02f009e.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-f97730d45ef67f3e6188.js"></script>


  </head>
  <body data-type="modules">
    <script>

      try {
        if (localStorage.getItem('night-mode') === 'true') {
          document.body.classList.add('night-mode');
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <span class="icon-search" aria-hidden="true" title="Submit search"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <span class="icon-cross" aria-hidden="true" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="api-reference.html" class="sidebar-projectName">
kernel
      </a>
      <strong class="sidebar-projectVersion">
        v8.0.2
      </strong>
    </div>

  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list-link" href="#full-list">Pages</a></li>

      <li><a id="modules-list-link" href="#full-list">Modules</a></li>


  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

      <h1>
erpc <small class="app-vsn">(kernel v8.0.2)</small>

      </h1>


        <section id="moduledoc">
<p>This module provide services similar to Remote Procedure Calls. A remote procedure call is a method to call a function on a remote node and collect the answer. It is used for collecting information on a remote node, or for running a function with some specific side effects on the remote node.</p><p>This is an enhanced subset of the operations provided by the <a href="rpc.html"><code>rpc</code></a> module. Enhanced in the sense that it makes it possible to distinguish between returned value, raised exceptions, and other errors. <code>erpc</code> also has better performance and scalability than the original <code>rpc</code> implementation. However, current <code>rpc</code> module will utilize <code>erpc</code> in order to also provide these properties when possible.</p><p>In order for an <code>erpc</code> operation to succeed, the remote node also needs to support <code>erpc</code>. Typically only ordinary Erlang nodes as of OTP 23 have <code>erpc</code> support.</p><p>Note that it is up to the user to ensure that correct code to execute via <code>erpc</code> is available on the involved nodes.</p>
        </section>


        <section id="summary" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#summary">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
            Summary
          </h1>

  <div class="summary-types summary">
    <h2>
      <a href="#types">Types</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:request_id/0">-type request_id() :: term().</a>

  </div>

    <div class="summary-synopsis"><p>An opaque type of call request identifiers. For more information see <a href="erpc.html#send_request/4"><code>send_request/4</code></a>.</p></div>

</div>

  </div>

  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#call/2">call/2</a>

  </div>

    <div class="summary-synopsis"><p>The same as calling <a href="erpc.html#call/5"><code>erpc:call(Node,erlang,apply,[Fun,[]],Timeout)</code></a>. May raise all the same exceptions as <code>erpc:call/5</code> plus an <code>{erpc, badarg}</code> <code>error</code> exception if <code>Fun</code> is not a fun of zero arity.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#call/3">call/3</a>

  </div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#call/4">call/4</a>

  </div>

    <div class="summary-synopsis"><p>Evaluates <code>apply(Module, Function, Args)</code> on node <code>Node</code> and returns the corresponding value <code>Result</code>. <code>Timeout</code> is an integer representing the timeout in milliseconds or the atom <code>infinity</code> which prevents the operation from ever timing out.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#call/5">call/5</a>

  </div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#cast/2">cast/2</a>

  </div>

    <div class="summary-synopsis"><p>The same as calling <a href="erpc.html#cast/4"><code>erpc:cast(Node,erlang,apply,[Fun,[]])</code></a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#cast/4">cast/4</a>

  </div>

    <div class="summary-synopsis"><p>Evaluates <code>apply(Module, Function, Args)</code> on node <code>Node</code>. No response is delivered to the calling process. <code>erpc:cast()</code> returns immediately after the cast request has been sent. Any failures beside bad arguments are silently ignored.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#check_response/2">check_response/2</a>

  </div>

    <div class="summary-synopsis"><p>Check if a message is a response to a <code>call</code> request previously made by the calling process using <a href="erpc.html#send_request/4"><code>erpc:send_request/4</code></a>. <code>RequestId</code> should be the value returned from the previously made <code>erpc:send_request()</code> call, and the corresponding response should not already have been received and handled to completion by <code>erpc:check_response()</code>, <a href="erpc.html#receive_response/2"><code>erpc:receive_response()</code></a>, or <a href="erpc.html#wait_response/2"><code>erpc:wait_response()</code></a>. <code>Message</code> is the message to check.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#multicall/2">multicall/2</a>

  </div>

    <div class="summary-synopsis"><p>The same as calling <a href="erpc.html#multicall/5"><code>erpc:multicall(Nodes,erlang,apply,[Fun,[]],Timeout)</code></a>. May raise all the same exceptions as <code>erpc:multicall/5</code> plus an <code>{erpc, badarg}</code> <code>error</code> exception if <code>Fun</code> is not a fun of zero arity.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#multicall/3">multicall/3</a>

  </div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#multicall/4">multicall/4</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li name="caught_call_exception"></li><li name="stack_item"></li></ul><p>Performs multiple <code>call</code> operations in parallel on multiple nodes. That is, evaluates <code>apply(Module, Function, Args)</code> on the nodes <code>Nodes</code> in parallel. <code>Timeout</code> is an integer representing the timeout in milliseconds or the atom <code>infinity</code> which prevents the operation from ever timing out. The result is returned as a list where the result from each node is placed at the same position as the node name is placed in <code>Nodes</code>. Each item in the resulting list is formatted as either</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#multicall/5">multicall/5</a>

  </div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#multicast/2">multicast/2</a>

  </div>

    <div class="summary-synopsis"><p>The same as calling <a href="erpc.html#multicast/4"><code>erpc:multicast(Nodes,erlang,apply,[Fun,[]])</code></a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#multicast/4">multicast/4</a>

  </div>

    <div class="summary-synopsis"><p>Evaluates <code>apply(Module, Function, Args)</code> on the nodes <code>Nodes</code>. No response is delivered to the calling process. <code>erpc:multicast()</code> returns immediately after the cast requests have been sent. Any failures beside bad arguments are silently ignored.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#receive_response/1">receive_response/1</a>

  </div>

    <div class="summary-synopsis"><p>Receive a response to a <code>call</code> request previously made by the calling process using <a href="erpc.html#send_request/4"><code>erpc:send_request/4</code></a>. <code>RequestId</code> should be the value returned from the previously made <code>erpc:send_request()</code> call, and the corresponding response should not already have been received and handled to completion by <a href="erpc.html#check_response/2"><code>erpc:check_response()</code></a>, <code>erpc:receive_response()</code>, or <a href="erpc.html#wait_response/2"><code>erpc:wait_response()</code></a>. <code>Timeout</code> is an integer representing the timeout in milliseconds or the atom <code>infinity</code> which prevents the operation from ever timing out. The <code>call</code> operation is completed once the <code>erpc:receive_response()</code> call returns or raise an exception.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#receive_response/2">receive_response/2</a>

  </div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#send_request/2">send_request/2</a>

  </div>

    <div class="summary-synopsis"><p>The same as calling <a href="erpc.html#send_request/4"><code>erpc:send_request(Node,erlang,apply,[Fun,[]])</code></a>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#send_request/4">send_request/4</a>

  </div>

    <div class="summary-synopsis"><p>Send an asynchronous <code>call</code> request to the node <code>Node</code>. <code>erpc:send_request()</code> returns a request identifier that later is to be passed as argument to either <a href="erpc.html#receive_response/1"><code>erpc:receive_response()</code></a>, <a href="erpc.html#wait_response/1"><code>erpc:wait_response()</code></a>, or, <a href="erpc.html#check_response/2"><code>erpc:check_response()</code></a> in order to get the response of the call request.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#wait_response/1">wait_response/1</a>

  </div>

    <div class="summary-synopsis"><p>Wait or poll for a response message to a <code>call</code> request previously made by the calling process using <a href="erpc.html#send_request/4"><code>erpc:send_request/4</code></a>. <code>RequestId</code> should be the value returned from the previously made <code>erpc:send_request()</code> call, and the corresponding response should not already have been received and handled to completion by <a href="erpc.html#check_response/2"><code>erpc:check_response()</code></a>, <a href="erpc.html#receive_response/2"><code>erpc:receive_response()</code></a>, or <code>erpc:wait_response()</code>. <code>WaitTime</code> equals the time to wait in milliseconds (or the atom <code>infinity</code>) during the wait. <code>WaitTime</code> is an integer representing time to wait in milliseconds or the atom <code>infinity</code> which will cause <code>wait_response/2</code> to wait for a response until it appears regardless of how long time that is.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#wait_response/2">wait_response/2</a>

  </div>

</div>

  </div>

        </section>


        <section id="types" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#types">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Types
          </h1>
          <div class="types-list">
<section class="detail" id="t:request_id/0">

  <div class="detail-header">
    <a href="#t:request_id/0" class="detail-link" title="Link to this opaque">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this opaque</span>
    </a>
    <h1 class="signature">-type request_id() :: term().</h1>


      <span class="note">(opaque)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>request_id()</pre>

      </div>

<p>An opaque type of call request identifiers. For more information see <a href="erpc.html#send_request/4"><code>send_request/4</code></a>.</p>
  </section>
</section>

          </div>
        </section>

        <section id="functions" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#functions">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Functions
          </h1>
          <div class="functions-list">
<section class="detail" id="call/2">

  <div class="detail-header">
    <a href="#call/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">call/2</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>call(Node, Fun) -> Result when Node :: node(), Fun :: function(), Result :: term().</pre>

      </div>

<p>The same as calling <a href="erpc.html#call/5"><code>erpc:call(Node,erlang,apply,[Fun,[]],Timeout)</code></a>. May raise all the same exceptions as <code>erpc:call/5</code> plus an <code>{erpc, badarg}</code> <code>error</code> exception if <code>Fun</code> is not a fun of zero arity.</p><p>The call <code>erpc:call(Node,Fun)</code> is the same as the call <code>erpc:call(Node,Fun,infinity)</code>.</p>
  </section>
</section>
<section class="detail" id="call/3">

  <div class="detail-header">
    <a href="#call/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">call/3</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>call(Node, Fun, Timeout) -> Result
        when
            Node :: node(),
            Fun :: function(),
            Timeout :: 0..4294967295 | infinity,
            Result :: term().</pre>

      </div>


  </section>
</section>
<section class="detail" id="call/4">

  <div class="detail-header">
    <a href="#call/4" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">call/4</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>call(Node, Module, Function, Args) -> Result
        when
            Node :: node(),
            Module :: atom(),
            Function :: atom(),
            Args :: [term()],
            Result :: term().</pre>

      </div>

<p>Evaluates <code>apply(Module, Function, Args)</code> on node <code>Node</code> and returns the corresponding value <code>Result</code>. <code>Timeout</code> is an integer representing the timeout in milliseconds or the atom <code>infinity</code> which prevents the operation from ever timing out.</p><p>The call <code>erpc:call(Node, Module, Function, Args)</code> is equivalent to the call <code>erpc:call(Node, Module, Function, Args, infinity)</code></p><p>The <code>call()</code> function only returns if the applied function successfully returned without raising any uncaught exceptions, the operation did not time out, and no failures occurred. In all other cases an exception is raised. The following exceptions, listed by exception class, can currently be raised by <code>erpc:call()</code>:</p><dl><dt><code>throw</code></dt><dd><p>The applied function called <code>throw(Value)</code> and did not catch this exception. The exception reason <code>Value</code> equals the argument passed to <code>throw/1</code>.</p></dd><dt><code>exit</code></dt><dd><p>Exception reason:</p><dl><dt><code>{exception, ExitReason}</code></dt><dd><p>The applied function called <code>exit(ExitReason)</code> and did not catch this exception. The exit reason <code>ExitReason</code> equals the argument passed to <code>exit/1</code>.</p></dd><dt><code>{signal, ExitReason}</code></dt><dd><p>The process that applied the function received an exit signal and terminated due to this signal. The process terminated with exit reason <code>ExitReason</code>.</p></dd></dl></dd><dt><code>error</code></dt><dd><p>Exception reason:</p><dl><dt><code>{exception, ErrorReason, StackTrace}</code></dt><dd><p>A runtime error occurred which raised and error exception while applying the function, and the applied function did not catch the exception. The error reason <code>ErrorReason</code> indicates the type of error that occurred. <code>StackTrace</code> is formatted as when caught in a <code>try/catch</code> construct. The <code>StackTrace</code> is limited to the applied function and functions called by it.</p></dd><dt><code>{erpc, ERpcErrorReason}</code></dt><dd><p>The <code>erpc</code> operation failed. The following <code>ERpcErrorReason</code>s are the most common ones:</p><dl><dt><code>badarg</code></dt><dd><p>If any one of these are true:</p><ul><li><p><code>Node</code> is not an atom.</p></li><li><p><code>Module</code> is not an atom.</p></li><li><p><code>Function</code> is not an atom.</p></li><li><p><code>Args</code> is not a list. Note that the list is not verified to be a proper list at the client side.</p></li><li><p><code>Timeout</code> is not the atom <code>infinity</code> or an integer in valid range.</p></li></ul></dd><dt><code>noconnection</code></dt><dd><p>The connection to <code>Node</code> was lost or could not be established. The function may or may not be applied.</p></dd><dt><code>system_limit</code></dt><dd><p>The <code>erpc</code> operation failed due to some system limit being reached. This typically due to failure to create a process on the remote node <code>Node</code>, but can be other things as well.</p></dd><dt><code>timeout</code></dt><dd><p>The <code>erpc</code> operation timed out. The function may or may not be applied.</p></dd><dt><code>notsup</code></dt><dd><p>The remote node <code>Node</code> does not support this <code>erpc</code> operation.</p></dd></dl></dd></dl></dd></dl><p>If the <code>erpc</code> operation fails, but it is unknown if the function is/will be applied (that is, a timeout or a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</p><div class="note"><p>You cannot make <em>any</em> assumptions about the process that will perform the <code>apply()</code>. It may be the calling process itself, a server, or a freshly spawned process.</p></div>
  </section>
</section>
<section class="detail" id="call/5">

  <div class="detail-header">
    <a href="#call/5" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">call/5</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>call(Node, Module, Function, Args, Timeout) -> Result
        when
            Node :: node(),
            Module :: atom(),
            Function :: atom(),
            Args :: [term()],
            Timeout :: 0..4294967295 | infinity,
            Result :: term().</pre>

      </div>


  </section>
</section>
<section class="detail" id="cast/2">

  <div class="detail-header">
    <a href="#cast/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">cast/2</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>cast(Node, Fun) -> ok when Node :: node(), Fun :: function().</pre>

      </div>

<p>The same as calling <a href="erpc.html#cast/4"><code>erpc:cast(Node,erlang,apply,[Fun,[]])</code></a>.</p><p><code>erpc:cast/2</code> fails with an <code>{erpc, badarg}</code> <code>error</code> exception if:</p><ul><li><p><code>Node</code> is not an atom.</p></li><li><p><code>Fun</code> is not a a fun of zero arity.</p></li></ul>
  </section>
</section>
<section class="detail" id="cast/4">

  <div class="detail-header">
    <a href="#cast/4" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">cast/4</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>cast(Node, Module, Function, Args) -> ok
        when Node :: node(), Module :: atom(), Function :: atom(), Args :: [term()].</pre>

      </div>

<p>Evaluates <code>apply(Module, Function, Args)</code> on node <code>Node</code>. No response is delivered to the calling process. <code>erpc:cast()</code> returns immediately after the cast request has been sent. Any failures beside bad arguments are silently ignored.</p><p><code>erpc:cast/4</code> fails with an <code>{erpc, badarg}</code> <code>error</code> exception if:</p><ul><li><p><code>Node</code> is not an atom.</p></li><li><p><code>Module</code> is not an atom.</p></li><li><p><code>Function</code> is not an atom.</p></li><li><p><code>Args</code> is not a list. Note that the list is not verified to be a proper list at the client side.</p></li></ul><div class="note"><p>You cannot make <em>any</em> assumptions about the process that will perform the <code>apply()</code>. It may be a server, or a freshly spawned process.</p></div>
  </section>
</section>
<section class="detail" id="check_response/2">

  <div class="detail-header">
    <a href="#check_response/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">check_response/2</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>check_response(Message, RequestId) -> {response, Result} | no_response
                  when Message :: term(), RequestId :: <a href="#t:request_id/0">request_id</a>(), Result :: term().</pre>

      </div>

<p>Check if a message is a response to a <code>call</code> request previously made by the calling process using <a href="erpc.html#send_request/4"><code>erpc:send_request/4</code></a>. <code>RequestId</code> should be the value returned from the previously made <code>erpc:send_request()</code> call, and the corresponding response should not already have been received and handled to completion by <code>erpc:check_response()</code>, <a href="erpc.html#receive_response/2"><code>erpc:receive_response()</code></a>, or <a href="erpc.html#wait_response/2"><code>erpc:wait_response()</code></a>. <code>Message</code> is the message to check.</p><p>If <code>Message</code> does not correspond to the response, the atom <code>no_response</code> is returned. If <code>Message</code> corresponds to the response, the <code>call</code> operation is completed and either the result is returned as <code>{response, Result}</code> where <code>Result</code> corresponds to the value returned from the applied function or an exception is raised. The exceptions that can be raised corresponds to the same exceptions as can be raised by <a href="erpc.html#call/4"><code>erpc:call/4</code></a>. That is, no <code>{erpc, timeout}</code> <code>error</code> exception can be raised. <code>erpc:check_response()</code> will fail with an <code>{erpc, badarg}</code> exception if/when an invalid <code>RequestId</code> is detected.</p><p>If the <code>erpc</code> operation fails, but it is unknown if the function is/will be applied (that is, a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</p>
  </section>
</section>
<section class="detail" id="multicall/2">

  <div class="detail-header">
    <a href="#multicall/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">multicall/2</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>multicall(Nodes, Fun) -> Result when Nodes :: [atom()], Fun :: function(), Result :: term().</pre>

      </div>

<p>The same as calling <a href="erpc.html#multicall/5"><code>erpc:multicall(Nodes,erlang,apply,[Fun,[]],Timeout)</code></a>. May raise all the same exceptions as <code>erpc:multicall/5</code> plus an <code>{erpc, badarg}</code> <code>error</code> exception if <code>Fun</code> is not a fun of zero arity.</p><p>The call <code>erpc:multicall(Nodes,Fun)</code> is the same as the call <code>erpc:multicall(Nodes,Fun, infinity)</code>.</p>
  </section>
</section>
<section class="detail" id="multicall/3">

  <div class="detail-header">
    <a href="#multicall/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">multicall/3</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>multicall(Nodes, Fun, Timeout) -> Result
             when
                 Nodes :: [atom()],
                 Fun :: function(),
                 Timeout :: 0..4294967295 | infinity,
                 Result :: term().</pre>

      </div>


  </section>
</section>
<section class="detail" id="multicall/4">

  <div class="detail-header">
    <a href="#multicall/4" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">multicall/4</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>multicall(Nodes, Module, Function, Args) -> Result
             when
                 Nodes :: [atom()],
                 Module :: atom(),
                 Function :: atom(),
                 Args :: [term()],
                 Result :: [{ok, ReturnValue :: term()} | <a href="#t:caught_call_exception/0">caught_call_exception</a>()].</pre>

      </div>

<ul class="types"><li name="caught_call_exception"></li><li name="stack_item"></li></ul><p>Performs multiple <code>call</code> operations in parallel on multiple nodes. That is, evaluates <code>apply(Module, Function, Args)</code> on the nodes <code>Nodes</code> in parallel. <code>Timeout</code> is an integer representing the timeout in milliseconds or the atom <code>infinity</code> which prevents the operation from ever timing out. The result is returned as a list where the result from each node is placed at the same position as the node name is placed in <code>Nodes</code>. Each item in the resulting list is formatted as either:</p><dl><dt><code>{ok, Result}</code></dt><dd><p>The <code>call</code> operation for this specific node returned <code>Result</code>.</p></dd><dt><code>{Class, ExceptionReason}</code></dt><dd><p>The <code>call</code> operation for this specific node raised an exception of class <code>Class</code> with exception reason <code>ExceptionReason</code>. These corresponds the the exceptions that <a href="erpc.html#call/5"><code>erpc:call/5</code></a> can raise.</p></dd></dl><p><code>erpc:multicall/5</code> fails with an <code>{erpc, badarg}</code> <code>error</code> exception if:</p><ul><li><p><code>Nodes</code> is not a proper list of atoms. Note that some requests may already have been sent when the failure occurs. That is, the function may or may not be applied on some nodes.</p></li><li><p><code>Module</code> is not an atom.</p></li><li><p><code>Function</code> is not an atom.</p></li><li><p><code>Args</code> is not a list. Note that the list is not verified to be a proper list at the client side.</p></li></ul><p>The call <code>erpc:multicall(Nodes, Module, Function, Args)</code> is equivalent to the call <code>erpc:multicall(Nodes, Module, Function, Args, infinity)</code>. These calls are also equivalent to calling <code>my_multicall(Nodes, Module, Function, Args)</code> if one disregard performance and failure behavior:</p><pre><code>my_multicall(Nodes, Module, Function, Args) -&gt;
  ReqIds = lists:map(fun (Node) -&gt;
                       <a href="erpc.html#send_request/4">erpc:send_request(Node, Module, Function, Args)</a>
                     end,
                     Nodes),
  lists:map(fun (ReqId) -&gt;
              try
                {ok, <a href="erpc.html#receive_response/2">erpc:receive_response(ReqId, infinity)</a>}
              catch
                Class:Reason -&gt;
                  {Class, Reason}
              end
            end,
            ReqIds).</code></pre><p>The <code>Timeout</code> value in milliseconds sets an upper time limit for all <code>call</code> operations to complete.</p><p>If an <code>erpc</code> operation fails, but it is unknown if the function is/will be applied (that is, a timeout, connection loss, or an improper <code>Nodes</code> list), the caller will not receive any further information about the result if/when the applied function completes. If the applied function communicates with the calling process, such communication may, of course, reach the calling process.</p><div class="note"><p>You cannot make <em>any</em> assumptions about the process that will perform the <code>apply()</code>. It may be the calling process itself, a server, or a freshly spawned process.</p></div>
  </section>
</section>
<section class="detail" id="multicall/5">

  <div class="detail-header">
    <a href="#multicall/5" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">multicall/5</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>multicall(Nodes, Module, Function, Args, Timeout) -> Result
             when
                 Nodes :: [atom()],
                 Module :: atom(),
                 Function :: atom(),
                 Args :: [term()],
                 Timeout :: 0..4294967295 | infinity,
                 Result :: [{ok, ReturnValue :: term()} | <a href="#t:caught_call_exception/0">caught_call_exception</a>()].</pre>

      </div>


  </section>
</section>
<section class="detail" id="multicast/2">

  <div class="detail-header">
    <a href="#multicast/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">multicast/2</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>multicast(Nodes, Fun) -> ok when Nodes :: [node()], Fun :: function().</pre>

      </div>

<p>The same as calling <a href="erpc.html#multicast/4"><code>erpc:multicast(Nodes,erlang,apply,[Fun,[]])</code></a>.</p><p><code>erpc:multicast/2</code> fails with an <code>{erpc, badarg}</code> <code>error</code> exception if:</p><ul><li><p><code>Nodes</code> is not a proper list of atoms.</p></li><li><p><code>Fun</code> is not a a fun of zero arity.</p></li></ul>
  </section>
</section>
<section class="detail" id="multicast/4">

  <div class="detail-header">
    <a href="#multicast/4" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">multicast/4</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>multicast(Nodes, Module, Function, Args) -> ok
             when Nodes :: [node()], Module :: atom(), Function :: atom(), Args :: [term()].</pre>

      </div>

<p>Evaluates <code>apply(Module, Function, Args)</code> on the nodes <code>Nodes</code>. No response is delivered to the calling process. <code>erpc:multicast()</code> returns immediately after the cast requests have been sent. Any failures beside bad arguments are silently ignored.</p><p><code>erpc:multicast/4</code> fails with an <code>{erpc, badarg}</code> <code>error</code> exception if:</p><ul><li><p><code>Nodes</code> is not a proper list of atoms. Note that some requests may already have been sent when the failure occurs. That is, the function may or may not be applied on some nodes.</p></li><li><p><code>Module</code> is not an atom.</p></li><li><p><code>Function</code> is not an atom.</p></li><li><p><code>Args</code> is not a list. Note that the list is not verified to be a proper list at the client side.</p></li></ul><div class="note"><p>You cannot make <em>any</em> assumptions about the process that will perform the <code>apply()</code>. It may be a server, or a freshly spawned process.</p></div>
  </section>
</section>
<section class="detail" id="receive_response/1">

  <div class="detail-header">
    <a href="#receive_response/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">receive_response/1</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>receive_response(RequestId) -> Result when RequestId :: <a href="#t:request_id/0">request_id</a>(), Result :: term().</pre>

      </div>

<p>Receive a response to a <code>call</code> request previously made by the calling process using <a href="erpc.html#send_request/4"><code>erpc:send_request/4</code></a>. <code>RequestId</code> should be the value returned from the previously made <code>erpc:send_request()</code> call, and the corresponding response should not already have been received and handled to completion by <a href="erpc.html#check_response/2"><code>erpc:check_response()</code></a>, <code>erpc:receive_response()</code>, or <a href="erpc.html#wait_response/2"><code>erpc:wait_response()</code></a>. <code>Timeout</code> is an integer representing the timeout in milliseconds or the atom <code>infinity</code> which prevents the operation from ever timing out. The <code>call</code> operation is completed once the <code>erpc:receive_response()</code> call returns or raise an exception.</p><p>The call <code>erpc:receive_response(RequestId)</code> is equivalent to the call <code>erpc:receive_response(RequestId, infinity)</code>.</p><p>A call to the function <code>my_call(Node, Module, Function, Args, Timeout)</code> below is equivalent to the call <a href="erpc.html#call/5"><code>erpc:call(Node, Module, Function, Args, Timeout)</code></a> if one disregards performance. <code>erpc:call()</code> can utilize a message queue optimization which removes the need to scan the whole message queue which the combination <code>erpc:send_request()/erpc:receive_response()</code> cannot.</p><pre><code>my_call(Node, Module, Function, Args, Timeout) -&gt;
  RequestId = <a href="erpc.html#send_request/4">erpc:send_request(Node, Module, Function, Args)</a>,
  erpc:receive_response(RequestId, Timeout).</code></pre><p>If the <code>erpc</code> operation fails, but it is unknown if the function is/will be applied (that is, a timeout, or a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</p><p><code>erpc:receive_response()</code> will return or raise exceptions the same way as <a href="erpc.html#call/5"><code>erpc:call/5</code></a> does with the exception of <code>{erpc, badarg}</code>. An <code>{erpc, badarg}</code> exception will be raised if/when an invalid <code>RequestId</code> is detected or if an invalid <code>Timeout</code> is passed.</p>
  </section>
</section>
<section class="detail" id="receive_response/2">

  <div class="detail-header">
    <a href="#receive_response/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">receive_response/2</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>receive_response(RequestId, Timeout) -> Result
                    when
                        RequestId :: <a href="#t:request_id/0">request_id</a>(),
                        Timeout :: 0..4294967295 | infinity,
                        Result :: term().</pre>

      </div>


  </section>
</section>
<section class="detail" id="send_request/2">

  <div class="detail-header">
    <a href="#send_request/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">send_request/2</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>send_request(Node, Fun) -> RequestId
                when Node :: node(), Fun :: function(), RequestId :: <a href="#t:request_id/0">request_id</a>().</pre>

      </div>

<p>The same as calling <a href="erpc.html#send_request/4"><code>erpc:send_request(Node,erlang,apply,[Fun,[]])</code></a>.</p><p><code>erpc:send_request/2</code> fails with an <code>{erpc, badarg}</code> <code>error</code> exception if:</p><ul><li><p><code>Node</code> is not an atom.</p></li><li><p><code>Fun</code> is not a fun of zero arity.</p></li></ul><div class="note"><p>You cannot make <em>any</em> assumptions about the process that will perform the <code>apply()</code>. It may be a server, or a freshly spawned process.</p></div>
  </section>
</section>
<section class="detail" id="send_request/4">

  <div class="detail-header">
    <a href="#send_request/4" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">send_request/4</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>send_request(Node, Module, Function, Args) -> RequestId
                when
                    Node :: node(),
                    Module :: atom(),
                    Function :: atom(),
                    Args :: [term()],
                    RequestId :: <a href="#t:request_id/0">request_id</a>().</pre>

      </div>

<p>Send an asynchronous <code>call</code> request to the node <code>Node</code>. <code>erpc:send_request()</code> returns a request identifier that later is to be passed as argument to either <a href="erpc.html#receive_response/1"><code>erpc:receive_response()</code></a>, <a href="erpc.html#wait_response/1"><code>erpc:wait_response()</code></a>, or, <a href="erpc.html#check_response/2"><code>erpc:check_response()</code></a> in order to get the response of the call request.</p><p><code>erpc:send_request()</code> fails with an <code>{erpc, badarg}</code> <code>error</code> exception if:</p><ul><li><p><code>Node</code> is not an atom.</p></li><li><p><code>Module</code> is not an atom.</p></li><li><p><code>Function</code> is not an atom.</p></li><li><p><code>Args</code> is not a list. Note that the list is not verified to be a proper list at the client side.</p></li></ul>
  </section>
</section>
<section class="detail" id="wait_response/1">

  <div class="detail-header">
    <a href="#wait_response/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">wait_response/1</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>wait_response(RequestId) -> {response, Result} | no_response
                 when RequestId :: <a href="#t:request_id/0">request_id</a>(), Result :: term().</pre>

      </div>

<p>Wait or poll for a response message to a <code>call</code> request previously made by the calling process using <a href="erpc.html#send_request/4"><code>erpc:send_request/4</code></a>. <code>RequestId</code> should be the value returned from the previously made <code>erpc:send_request()</code> call, and the corresponding response should not already have been received and handled to completion by <a href="erpc.html#check_response/2"><code>erpc:check_response()</code></a>, <a href="erpc.html#receive_response/2"><code>erpc:receive_response()</code></a>, or <code>erpc:wait_response()</code>. <code>WaitTime</code> equals the time to wait in milliseconds (or the atom <code>infinity</code>) during the wait. <code>WaitTime</code> is an integer representing time to wait in milliseconds or the atom <code>infinity</code> which will cause <code>wait_response/2</code> to wait for a response until it appears regardless of how long time that is.</p><p>The call <code>erpc:wait_response(RequestId)</code> is equivalent to the call <code>erpc:wait_response(RequestId, 0)</code>. That is, poll for a response message to a <code>call</code> request previously made by the calling process.</p><p>If no response is received before <code>WaitTime</code> milliseconds, the atom <code>no_response</code> is returned. It is valid to continue waiting for a response as many times as needed up until a response has been received and completed by <code>erpc:check_response()</code>, <code>erpc:receive_response()</code>, or <code>erpc:wait_response()</code>. If a response is received, the <code>call</code> operation is completed and either the result is returned as <code>{response, Result}</code> where <code>Result</code> corresponds to the value returned from the applied function or an exception is raised. The exceptions that can be raised corresponds to the same exceptions as can be raised by <a href="erpc.html#call/4"><code>erpc:call/4</code></a>. That is, no <code>{erpc, timeout}</code> <code>error</code> exception can be raised. <code>erpc:wait_response()</code> will fail with an <code>{erpc, badarg}</code> exception if/when an invalid <code>RequestId</code> is detected or if an invalid <code>WaitTime</code> is passed.</p><p>If the <code>erpc</code> operation fails, but it is unknown if the function is/will be applied (that is, a too large wait time value, or a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</p>
  </section>
</section>
<section class="detail" id="wait_response/2">

  <div class="detail-header">
    <a href="#wait_response/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">wait_response/2</h1>


      <span class="note">(since OTP 23.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>wait_response(RequestId, WaitTime) -> {response, Result} | no_response
                 when
                     RequestId :: <a href="#t:request_id/0">request_id</a>(),
                     WaitTime :: 0..4294967295 | infinity,
                     Result :: term().</pre>

      </div>


  </section>
</section>

          </div>
        </section>

      <footer class="footer">

        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.25.1) for the
            <a href="https://elixir-lang.org" title="Elixir" target="_blank">Elixir programming language</a>.
          </span>
          <span class="line">
            Designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>

            <a href="api-reference.html" title="API reference" class="line footer-button">API Reference</a>

          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button display-quick-switch">
            Go to a HexDocs package
          </button>
          <button class="line footer-button tooltips-toggle">
            <span class="tooltips-option-disable">Disable tooltips</span>
            <span class="tooltips-option-enable">Enable tooltips</span>
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
