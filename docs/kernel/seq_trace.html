<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.25.1">
    <meta name="project" content="kernel v8.0.2">

    <title>seq_trace â€” kernel v8.0.2</title>
    <link rel="stylesheet" href="dist/erlang-951161c89561e05735a5.css" />

    <script src="dist/sidebar_items-69e02f009e.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-f97730d45ef67f3e6188.js"></script>


  </head>
  <body data-type="modules">
    <script>

      try {
        if (localStorage.getItem('night-mode') === 'true') {
          document.body.classList.add('night-mode');
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <span class="icon-search" aria-hidden="true" title="Submit search"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <span class="icon-cross" aria-hidden="true" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="api-reference.html" class="sidebar-projectName">
kernel
      </a>
      <strong class="sidebar-projectVersion">
        v8.0.2
      </strong>
    </div>

  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list-link" href="#full-list">Pages</a></li>

      <li><a id="modules-list-link" href="#full-list">Modules</a></li>


  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

      <h1>
seq_trace <small class="app-vsn">(kernel v8.0.2)</small>

      </h1>


        <section id="moduledoc">
<p>Sequential tracing makes it possible to trace information flows between processes resulting from one initial transfer of information. Sequential tracing is independent of the ordinary tracing in Erlang, which is controlled by the <code>erlang:trace/3</code> BIF. For more information about what sequential tracing is and how it can be used, see section <a href="#whatis">Sequential Tracing</a>.</p><p><code>seq_trace</code> provides functions that control all aspects of sequential tracing. There are functions for activation, deactivation, inspection, and for collection of the trace output.</p><h2 id="module-trace-messages-sent-to-the-system-tracer" class="section-heading">
  <a href="#module-trace-messages-sent-to-the-system-tracer" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Trace Messages Sent to the System Tracer
</h2>
<p>The format of the messages is one of the following, depending on if flag <code>timestamp</code> of the trace token is set to <code>true</code> or <code>false</code>:</p><pre><code type="none">{seq_trace, Label, SeqTraceInfo, TimeStamp}</code></pre><p>or</p><pre><code type="none">{seq_trace, Label, SeqTraceInfo}</code></pre><p>Where:</p><pre><code type="none">Label = int()
TimeStamp = {Seconds, Milliseconds, Microseconds}  
  Seconds = Milliseconds = Microseconds = int()</code></pre><p><code>SeqTraceInfo</code> can have the following formats:</p><dl><dt><code>{send, Serial, From, To, Message}</code></dt><dd><p>Used when a process <code>From</code> with its trace token flag <code>send</code> set to <code>true</code> has sent information. <code>To</code> may be a process identifier, a registered name on a node represented as <code>{NameAtom, NodeAtom}</code>, or a node name represented as an atom. <code>From</code> may be a process identifier or a node name represented as an atom. <code>Message</code> contains the information passed along in this information transfer. If the transfer is done via message passing, it is the actual message.</p></dd><dt><code>{'receive', Serial, From, To, Message}</code></dt><dd><p>Used when a process <code>To</code> receives information with a trace token that has flag <code>'receive'</code> set to <code>true</code>. <code>To</code> may be a process identifier, or a node name represented as an atom. <code>From</code> may be a process identifier or a node name represented as an atom. <code>Message</code> contains the information passed along in this information transfer. If the transfer is done via message passing, it is the actual message.</p></dd><dt><code>{print, Serial, From, _, Info}</code></dt><dd><p>Used when a process <code>From</code> has called <code>seq_trace:print(Label, TraceInfo)</code> and has a trace token with flag <code>print</code> set to <code>true</code>, and <code>label</code> set to <code>Label</code>.</p></dd></dl><p><code>Serial</code> is a tuple <code>{PreviousSerial, ThisSerial}</code>, where:</p><ul><li><p>Integer <code>PreviousSerial</code> denotes the serial counter passed in the last received information that carried a trace token. If the process is the first in a new sequential trace, <code>PreviousSerial</code> is set to the value of the process internal &quot;trace clock&quot;.</p></li><li><p>Integer <code>ThisSerial</code> is the serial counter that a process sets on outgoing messages. It is based on the process internal &quot;trace clock&quot;, which is incremented by one before it is attached to the trace token in the message.</p></li></ul><a id="whatis"></a><h2 id="module-sequential-tracing" class="section-heading">
  <a href="#module-sequential-tracing" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Sequential Tracing
</h2>
<p>Sequential tracing is a way to trace a sequence of information transfers between different local or remote processes, where the sequence is initiated by a single transfer. The typical information transfer is an ordinary Erlang message passed between two processes, but information is transferred also in other ways. In short, it works as follows:</p><p>Each process has a <em>trace token</em>, which can be empty or not empty. When not empty, the trace token can be seen as the tuple <code>{Label, Flags, Serial, From}</code>. The trace token is passed invisibly when information is passed between processes. In most cases the information is passed in ordinary messages between processes, but information is also passed between processes by other means. For example, by spawning a new process. An information transfer between two processes is represented by a send event and a receive event regardless of how it is passed.</p><p>To start a sequential trace, the user must explicitly set the trace token in the process that will send the first information in a sequence.</p><p>The trace token of a process is set each time the process receives information. This is typically when the process matches a message in a receive statement, according to the trace token carried by the received message, empty or not.</p><p>On each Erlang node, a process can be set as the <em>system tracer</em>. This process will receive trace messages each time information with a trace token is sent or received (if the trace token flag <code>send</code> or <code>'receive'</code> is set). The system tracer can then print each trace event, write it to a file, or whatever suitable.</p><div class="note"><p>The system tracer only receives those trace events that occur locally within the Erlang node. To get the whole picture of a sequential trace, involving processes on many Erlang nodes, the output from the system tracer on each involved node must be merged (offline).</p></div><p>The following sections describe sequential tracing and its most fundamental concepts.</p><h2 id="module-different-information-transfers" class="section-heading">
  <a href="#module-different-information-transfers" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Different Information Transfers
</h2>
<p>Information flows between processes in a lot of different ways. Not all flows of information will be covered by sequential tracing. One example is information passed via ETS tables. Below is a list of information paths that are covered by sequential tracing:</p><dl><dt>Message Passing</dt><dd><p>All ordinary messages passed between Erlang processes.</p></dd><dt>Exit signals</dt><dd><p>An exit signal is represented as an <code>{'EXIT', Pid, Reason}</code> tuple.</p></dd><dt>Process Spawn</dt><dd><p>A process spawn is represented as multiple information transfers. At least one spawn request and one spawn reply. The actual amount of information transfers depends on what type of spawn it is and may also change in future implementations. Note that this is more or less an internal protocol that you are peeking at. The spawn request will be represented as a tuple with the first element containing the atom <code>spawn_request</code>, but this is more or less all that you can depend on.</p></dd></dl><div class="note"><p>If you do ordinary <code>send</code> or <code>receive</code> trace on the system, you will only see ordinary message passing, not the other information transfers listed above.</p></div><div class="note"><p>When a send event and corresponding receive event do not both correspond to ordinary Erlang messages, the <code>Message</code> part of the trace messages may not be identical. This since all information not necessarily are available when generating the trace messages.</p></div><h2 id="module-trace-token" class="section-heading">
  <a href="#module-trace-token" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Trace Token
</h2>
<p>Each process has a current trace token which is &quot;invisibly&quot; passed from the parent process on creation of the process.</p><p>The current token of a process is set in one of the following two ways:</p><ul><li><p>Explicitly by the process itself, through a call to <code>seq_trace:set_token/1,2</code></p></li><li><p>When information is received. This is typically when a received message is matched out in a receive expression, but also when information is received in other ways.</p></li></ul><p>In both cases, the current token is set. In particular, if the token of a received message is empty, the current token of the process is set to empty.</p><p>A trace token contains a label and a set of flags. Both the label and the flags are set in both alternatives above.</p><h2 id="module-serial" class="section-heading">
  <a href="#module-serial" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Serial
</h2>
<p>The trace token contains a component called <code>serial</code>. It consists of two integers, <code>Previous</code> and <code>Current</code>. The purpose is to uniquely identify each traced event within a trace sequence, as well as to order the messages chronologically and in the different branches, if any.</p><p>The algorithm for updating <code>Serial</code> can be described as follows:</p><p>Let each process have two counters, <code>prev_cnt</code> and <code>curr_cnt</code>, both are set to <code>0</code> when a process is created outside of a trace sequence. The counters are updated at the following occasions:</p><ul><li><p><em>When the process is about to pass along information to another process and the trace token is not empty.</em> This typically occurs when sending a message, but also, for example, when spawning another process.</p><p>Let the serial of the trace token be <code>tprev</code> and <code>tcurr</code>.</p><pre><code class="makeup erlang"><span class="ss">curr_cnt</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="ss">curr_cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="ss">tprev</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="ss">prev_cnt</span><span class="w">
</span><span class="ss">tcurr</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="ss">curr_cnt</span></code></pre><p>The trace token with <code>tprev</code> and <code>tcurr</code> is then passed along with the information passed to the other process.</p></li><li><p><em>When the process calls</em> <code>seq_trace:print(Label, Info)</code>, <code>Label</code> <em>matches the label part of the trace token and the trace token print flag is <code>true</code>.</em></p><p>The algorithm is the same as for send above.</p></li><li><p><em>When information is received that also contains a non-empty trace token. For example, when a message is matched out in a receive expression, or when a new process is spawned.</em></p><p>The process trace token is set to the trace token from the message.</p><p>Let the serial of the trace token be <code>tprev</code> and <code>tcurr</code>.</p><pre><code class="makeup erlang"><span class="nf">if</span><span class="w"> </span><span class="p" data-group-id="7307888092-1">(</span><span class="ss">curr_cnt</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="ss">tcurr</span><span class="w"> </span><span class="p" data-group-id="7307888092-1">)</span><span class="w">
   </span><span class="ss">curr_cnt</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="ss">tcurr</span><span class="w">
</span><span class="ss">prev_cnt</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="ss">tcurr</span></code></pre></li></ul><p><code>curr_cnt</code> of a process is incremented each time the process is involved in a sequential trace. The counter can reach its limit (27 bits) if a process is very long-lived and is involved in much sequential tracing. If the counter overflows, the serial for ordering of the trace events cannot be used. To prevent the counter from overflowing in the middle of a sequential trace, function <code>seq_trace:reset_trace/0</code> can be called to reset <code>prev_cnt</code> and <code>curr_cnt</code> of all processes in the Erlang node. This function also sets all trace tokens in processes and their message queues to empty, and thus stops all ongoing sequential tracing.</p><h2 id="module-performance-considerations" class="section-heading">
  <a href="#module-performance-considerations" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Performance Considerations
</h2>
<p>The performance degradation for a system that is enabled for sequential tracing is negligible as long as no tracing is activated. When tracing is activated, there is an extra cost for each traced message, but all other messages are unaffected.</p><h2 id="module-ports" class="section-heading">
  <a href="#module-ports" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Ports
</h2>
<p>Sequential tracing is not performed across ports.</p><p>If the user for some reason wants to pass the trace token to a port, this must be done manually in the code of the port controlling process. The port controlling processes have to check the appropriate sequential trace settings (as obtained from <code>seq_trace:get_token/1</code>) and include trace information in the message data sent to their respective ports.</p><p>Similarly, for messages received from a port, a port controller has to retrieve trace-specific information, and set appropriate sequential trace flags through calls to <code>seq_trace:set_token/2</code>.</p><h2 id="module-distribution" class="section-heading">
  <a href="#module-distribution" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Distribution
</h2>
<p>Sequential tracing between nodes is performed transparently. This applies to C-nodes built with <code>Erl_Interface</code> too. A C-node built with <code>Erl_Interface</code> only maintains one trace token, which means that the C-node appears as one process from the sequential tracing point of view.</p><h2 id="module-example-of-use" class="section-heading">
  <a href="#module-example-of-use" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Example of Use
</h2>
<p>This example gives a rough idea of how the new primitives can be used and what kind of output it produces.</p><p>Assume that you have an initiating process with <code>Pid == &lt;0.30.0&gt;</code> like this:</p><pre><code type="none">-module(seqex).
-compile(export_all).

loop(Port) -&gt;
    receive 
        {Port,Message} -&gt;
            seq_trace:set_token(label,17),
            seq_trace:set_token('receive',true),
            seq_trace:set_token(print,true),
            seq_trace:print(17,&quot;**** Trace Started ****&quot;),
            call_server ! {self(),the_message};
        {ack,Ack} -&gt;
            ok
    end,
    loop(Port).</code></pre><p>And a registered process <code>call_server</code> with <code>Pid == &lt;0.31.0&gt;</code> like this:</p><pre><code type="none">loop() -&gt;
    receive
        {PortController,Message} -&gt;
            Ack = {received, Message},
            seq_trace:print(17,&quot;We are here now&quot;),
            PortController ! {ack,Ack}
    end,
    loop().</code></pre><p>A possible output from the system's <code>sequential_tracer</code> can be like this:</p><pre><code class="makeup erlang"><span class="mi">17</span><span class="p">:</span><span class="o">&lt;</span><span class="mf">0.30</span><span class="p">.</span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Info</span><span class="w"> </span><span class="p" data-group-id="7496874447-1">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="7496874447-1">}</span><span class="w"> </span><span class="n">WITH</span><span class="w">
</span><span class="s">&quot;**** Trace Started ****&quot;</span><span class="w">
</span><span class="mi">17</span><span class="p">:</span><span class="o">&lt;</span><span class="mf">0.31</span><span class="p">.</span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Received</span><span class="w"> </span><span class="p" data-group-id="7496874447-2">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="7496874447-2">}</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="o">&lt;</span><span class="mf">0.30</span><span class="p">.</span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="n">WITH</span><span class="w">
</span><span class="p" data-group-id="7496874447-3">{</span><span class="o">&lt;</span><span class="mf">0.30</span><span class="p">.</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span><span class="ss">the_message</span><span class="p" data-group-id="7496874447-3">}</span><span class="w">
</span><span class="mi">17</span><span class="p">:</span><span class="o">&lt;</span><span class="mf">0.31</span><span class="p">.</span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Info</span><span class="w"> </span><span class="p" data-group-id="7496874447-4">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="7496874447-4">}</span><span class="w"> </span><span class="n">WITH</span><span class="w">
</span><span class="s">&quot;We are here now&quot;</span><span class="w">
</span><span class="mi">17</span><span class="p">:</span><span class="o">&lt;</span><span class="mf">0.30</span><span class="p">.</span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Received</span><span class="w"> </span><span class="p" data-group-id="7496874447-5">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="7496874447-5">}</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="o">&lt;</span><span class="mf">0.31</span><span class="p">.</span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="n">WITH</span><span class="w">
</span><span class="p" data-group-id="7496874447-6">{</span><span class="ss">ack</span><span class="p">,</span><span class="p" data-group-id="7496874447-7">{</span><span class="ss">received</span><span class="p">,</span><span class="ss">the_message</span><span class="p" data-group-id="7496874447-7">}</span><span class="p" data-group-id="7496874447-6">}</span></code></pre><p>The implementation of a system tracer process that produces this printout can look like this:</p><pre><code type="none">tracer() -&gt;
    receive
        {seq_trace,Label,TraceInfo} -&gt;
           print_trace(Label,TraceInfo,false);
        {seq_trace,Label,TraceInfo,Ts} -&gt;
           print_trace(Label,TraceInfo,Ts);
        _Other -&gt; ignore
    end,
    tracer().

print_trace(Label,TraceInfo,false) -&gt;
    io:format(&quot;~p:&quot;,[Label]),
    print_trace(TraceInfo);
print_trace(Label,TraceInfo,Ts) -&gt;
    io:format(&quot;~p ~p:&quot;,[Label,Ts]),
    print_trace(TraceInfo).

print_trace({print,Serial,From,_,Info}) -&gt;
    io:format(&quot;~p Info ~p WITH~n~p~n&quot;, [From,Serial,Info]);
print_trace({'receive',Serial,From,To,Message}) -&gt;
    io:format(&quot;~p Received ~p FROM ~p WITH~n~p~n&quot;, 
              [To,Serial,From,Message]);
print_trace({send,Serial,From,To,Message}) -&gt;
    io:format(&quot;~p Sent ~p TO ~p WITH~n~p~n&quot;,
              [From,Serial,To,Message]).</code></pre><p>The code that creates a process that runs this tracer function and sets that process as the system tracer can look like this:</p><pre><code type="none">start() -&gt;
    Pid = spawn(?MODULE,tracer,[]),
    seq_trace:set_system_tracer(Pid), % set Pid as the system tracer 
    ok.</code></pre><p>With a function like <code>test/0</code>, the whole example can be started:</p><pre><code type="none">test() -&gt;
    P = spawn(?MODULE, loop, [port]),
    register(call_server, spawn(?MODULE, loop, [])),
    start(),
    P ! {port,message}.</code></pre>
        </section>


        <section id="summary" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#summary">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
            Summary
          </h1>

  <div class="summary-types summary">
    <h2>
      <a href="#types">Types</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:token/0">-type token() :: term().</a>

  </div>

    <div class="summary-synopsis"><p>An opaque term (a tuple) representing a trace token.</p></div>

</div>

  </div>

  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#get_system_tracer/0">get_system_tracer/0</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li name="tracer"></li></ul><p>Returns the pid, port identifier or tracer module of the current system tracer or <code>false</code> if no system tracer is activated.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#get_token/0">get_token/0</a>

  </div>

    <div class="summary-synopsis"><p>Returns the value of the trace token for the calling process. If <code>[]</code> is returned, it means that tracing is not active. Any other value returned is the value of an active trace token. The value returned can be used as input to the <code>set_token/1</code> function.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#get_token/1">get_token/1</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li name="component"></li><li name="flag"></li><li name="value"></li></ul><p>Returns the value of the trace token component <code>Component</code>. See <a href="#set_token/2">set_token/2</a> for possible values of <code>Component</code> and <code>Val</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#print/1">print/1</a>

  </div>

    <div class="summary-synopsis"><p>Puts the Erlang term <code>TraceInfo</code> into the sequential trace output if the calling process currently is executing within a sequential trace and the <code>print</code> flag of the trace token is set.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#print/2">print/2</a>

  </div>

    <div class="summary-synopsis"><p>Same as <code>print/1</code> with the additional condition that <code>TraceInfo</code> is output only if <code>Label</code> is equal to the label component of the trace token.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#reset_trace/0">reset_trace/0</a>

  </div>

    <div class="summary-synopsis"><p>Sets the trace token to empty for all processes on the local node. The process internal counters used to create the serial of the trace token is set to 0. The trace token is set to empty for all messages in message queues. Together this will effectively stop all ongoing sequential tracing in the local node.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#set_system_tracer/1">set_system_tracer/1</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li name="tracer"></li></ul><p>Sets the system tracer. The system tracer can be either a process, port or <a href="https://wojtekmach.pl/otp_docs/erts/erl_tracer.html">tracer module</a> denoted by <code>Tracer</code>. Returns the previous value (which can be <code>false</code> if no system tracer is active).</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#set_token/1">set_token/1</a>

  </div>

    <div class="summary-synopsis"><p>Sets the trace token for the calling process to <code>Token</code>. If <code>Token == []</code> then tracing is disabled, otherwise <code>Token</code> should be an Erlang term returned from <code>get_token/0</code> or <code>set_token/1</code>. <code>set_token/1</code> can be used to temporarily exclude message passing from the trace by setting the trace token to empty like this</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#set_token/2">set_token/2</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li name="component"></li><li name="flag"></li><li name="value"></li></ul><p>Sets the individual <code>Component</code> of the trace token to <code>Val</code>. Returns the previous value of the component.</p></div>

</div>

  </div>

        </section>


        <section id="types" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#types">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Types
          </h1>
          <div class="types-list">
<section class="detail" id="t:token/0">

  <div class="detail-header">
    <a href="#t:token/0" class="detail-link" title="Link to this type">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this type</span>
    </a>
    <h1 class="signature">-type token() :: term().</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>token() :: {integer(), boolean(), _, _, _}.</pre>

      </div>

<p>An opaque term (a tuple) representing a trace token.</p>
  </section>
</section>

          </div>
        </section>

        <section id="functions" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#functions">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Functions
          </h1>
          <div class="functions-list">
<section class="detail" id="get_system_tracer/0">

  <div class="detail-header">
    <a href="#get_system_tracer/0" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">get_system_tracer/0</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>get_system_tracer() -> Tracer when Tracer :: <a href="#t:tracer/0">tracer</a>().</pre>

      </div>

<ul class="types"><li name="tracer"></li></ul><p>Returns the pid, port identifier or tracer module of the current system tracer or <code>false</code> if no system tracer is activated.</p>
  </section>
</section>
<section class="detail" id="get_token/0">

  <div class="detail-header">
    <a href="#get_token/0" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">get_token/0</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>get_token() -> [] | <a href="#t:token/0">token</a>().</pre>

      </div>

<p>Returns the value of the trace token for the calling process. If <code>[]</code> is returned, it means that tracing is not active. Any other value returned is the value of an active trace token. The value returned can be used as input to the <code>set_token/1</code> function.</p>
  </section>
</section>
<section class="detail" id="get_token/1">

  <div class="detail-header">
    <a href="#get_token/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">get_token/1</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>get_token(Component) -> {Component, Val} when Component :: <a href="#t:component/0">component</a>(), Val :: <a href="#t:value/0">value</a>().</pre>

      </div>

<ul class="types"><li name="component"></li><li name="flag"></li><li name="value"></li></ul><p>Returns the value of the trace token component <code>Component</code>. See <a href="#set_token/2">set_token/2</a> for possible values of <code>Component</code> and <code>Val</code>.</p>
  </section>
</section>
<section class="detail" id="print/1">

  <div class="detail-header">
    <a href="#print/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">print/1</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>print(TraceInfo) -> ok when TraceInfo :: term().</pre>

      </div>

<p>Puts the Erlang term <code>TraceInfo</code> into the sequential trace output if the calling process currently is executing within a sequential trace and the <code>print</code> flag of the trace token is set.</p>
  </section>
</section>
<section class="detail" id="print/2">

  <div class="detail-header">
    <a href="#print/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">print/2</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>print(Label, TraceInfo) -> ok when Label :: integer(), TraceInfo :: term().</pre>

      </div>

<p>Same as <code>print/1</code> with the additional condition that <code>TraceInfo</code> is output only if <code>Label</code> is equal to the label component of the trace token.</p>
  </section>
</section>
<section class="detail" id="reset_trace/0">

  <div class="detail-header">
    <a href="#reset_trace/0" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">reset_trace/0</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>reset_trace() -> true.</pre>

      </div>

<p>Sets the trace token to empty for all processes on the local node. The process internal counters used to create the serial of the trace token is set to 0. The trace token is set to empty for all messages in message queues. Together this will effectively stop all ongoing sequential tracing in the local node.</p>
  </section>
</section>
<section class="detail" id="set_system_tracer/1">

  <div class="detail-header">
    <a href="#set_system_tracer/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">set_system_tracer/1</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>set_system_tracer(Tracer) -> OldTracer when Tracer :: <a href="#t:tracer/0">tracer</a>(), OldTracer :: <a href="#t:tracer/0">tracer</a>().</pre>

      </div>

<ul class="types"><li name="tracer"></li></ul><p>Sets the system tracer. The system tracer can be either a process, port or <a href="https://wojtekmach.pl/otp_docs/erts/erl_tracer.html">tracer module</a> denoted by <code>Tracer</code>. Returns the previous value (which can be <code>false</code> if no system tracer is active).</p><p>Failure: <code>{badarg, Info}}</code> if <code>Pid</code> is not an existing local pid.</p>
  </section>
</section>
<section class="detail" id="set_token/1">

  <div class="detail-header">
    <a href="#set_token/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">set_token/1</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>set_token(Token) -> PreviousToken | ok when Token :: [] | <a href="#t:token/0">token</a>(), PreviousToken :: [] | <a href="#t:token/0">token</a>().</pre>

      </div>

<p>Sets the trace token for the calling process to <code>Token</code>. If <code>Token == []</code> then tracing is disabled, otherwise <code>Token</code> should be an Erlang term returned from <code>get_token/0</code> or <code>set_token/1</code>. <code>set_token/1</code> can be used to temporarily exclude message passing from the trace by setting the trace token to empty like this:</p><pre><code type="none">OldToken = seq_trace:set_token([]), % set to empty and save 
                                    % old value
% do something that should not be part of the trace
io:format(&quot;Exclude the signalling caused by this~n&quot;),
seq_trace:set_token(OldToken), % activate the trace token again
...  </code></pre><p>Returns the previous value of the trace token.</p>
  </section>
</section>
<section class="detail" id="set_token/2">

  <div class="detail-header">
    <a href="#set_token/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">set_token/2</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>set_token(Component, Val) -> OldVal
             when Component :: <a href="#t:component/0">component</a>(), Val :: <a href="#t:value/0">value</a>(), OldVal :: <a href="#t:value/0">value</a>().</pre>

      </div>

<ul class="types"><li name="component"></li><li name="flag"></li><li name="value"></li></ul><p>Sets the individual <code>Component</code> of the trace token to <code>Val</code>. Returns the previous value of the component.</p><dl><dt><code>set_token(label, Label)</code></dt><dd><p>The <code>label</code> component is a term which identifies all events belonging to the same sequential trace. If several sequential traces can be active simultaneously, <code>label</code> is used to identify the separate traces. Default is 0.</p><div class="warning"><p>Labels were restricted to small signed integers (28 bits) prior to OTP 21. The trace token will be silenty dropped if it crosses over to a node that does not support the label.</p></div></dd><dt><code>set_token(serial, SerialValue)</code></dt><dd><p><code>SerialValue = {Previous, Current}</code>. The <code>serial</code> component contains counters which enables the traced messages to be sorted, should never be set explicitly by the user as these counters are updated automatically. Default is <code>{0, 0}</code>.</p></dd><dt><code>set_token(send, Bool)</code></dt><dd><p>A trace token flag (<code>true | false</code>) which enables/disables tracing on information sending. Default is <code>false</code>.</p></dd><dt><code>set_token('receive', Bool)</code></dt><dd><p>A trace token flag (<code>true | false</code>) which enables/disables tracing on information reception. Default is <code>false</code>.</p></dd><dt><code>set_token(print, Bool)</code></dt><dd><p>A trace token flag (<code>true | false</code>) which enables/disables tracing on explicit calls to <code>seq_trace:print/1</code>. Default is <code>false</code>.</p></dd><dt><code>set_token(timestamp, Bool)</code></dt><dd><p>A trace token flag (<code>true | false</code>) which enables/disables a timestamp to be generated for each traced event. Default is <code>false</code>.</p></dd><dt><code>set_token(strict_monotonic_timestamp, Bool)</code></dt><dd><p>A trace token flag (<code>true | false</code>) which enables/disables a strict monotonic timestamp to be generated for each traced event. Default is <code>false</code>. Timestamps will consist of Erlang monotonic time and a monotonically increasing integer. The time-stamp has the same format and value as produced by <code>{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}</code>.</p></dd><dt><code>set_token(monotonic_timestamp, Bool)</code></dt><dd><p>A trace token flag (<code>true | false</code>) which enables/disables a strict monotonic timestamp to be generated for each traced event. Default is <code>false</code>. Timestamps will use Erlang monotonic time. The time-stamp has the same format and value as produced by <code>erlang:monotonic_time(nanosecond)</code>.</p></dd></dl><p>If multiple timestamp flags are passed, <code>timestamp</code> has precedence over <code>strict_monotonic_timestamp</code> which in turn has precedence over <code>monotonic_timestamp</code>. All timestamp flags are remembered, so if two are passed and the one with highest precedence later is disabled the other one will become active.</p>
  </section>
</section>

          </div>
        </section>

      <footer class="footer">

        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.25.1) for the
            <a href="https://elixir-lang.org" title="Elixir" target="_blank">Elixir programming language</a>.
          </span>
          <span class="line">
            Designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>

            <a href="api-reference.html" title="API reference" class="line footer-button">API Reference</a>

          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button display-quick-switch">
            Go to a HexDocs package
          </button>
          <button class="line footer-button tooltips-toggle">
            <span class="tooltips-option-disable">Disable tooltips</span>
            <span class="tooltips-option-enable">Enable tooltips</span>
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
