searchNodes=[{"doc":"Functional, extendible arrays. Arrays can have fixed size, or can grow automatically as needed. A default value is used for entries that have not been explicitly set. Arrays uses zero -based indexing. This is a deliberate design choice and differs from other Erlang data structures, for example, tuples. Unless specified by the user when the array is created, the default value is the atom undefined . There is no difference between an unset entry and an entry that has been explicitly set to the same value as the default one (compare reset/2 ). If you need to differentiate between unset and set entries, ensure that the default value cannot be confused with the values of set entries. The array never shrinks automatically. If an index I has been used to set an entry successfully, all indices in the range [0, I ] stay accessible unless the array size is explicitly changed by calling resize/2 . Examples: Create a fixed-size array with entries 0-9 set to undefined : A0 = array : new ( 10 ) . 10 = array : size ( A0 ) . Create an extendible array and set entry 17 to true , causing the array to grow automatically: A1 = array : set ( 17 , true , array : new ( ) ) . 18 = array : size ( A1 ) . Read back a stored value: true = array : get ( 17 , A1 ) . Accessing an unset entry returns default value: undefined = array : get ( 3 , A1 ) Accessing an entry beyond the last set entry also returns the default value, if the array does not have fixed size: undefined = array : get ( 18 , A1 ) . &quot;Sparse&quot; functions ignore default-valued entries: A2 = array : set ( 4 , false , A1 ) . [ { 4 , false } , { 17 , true } ] = array : sparse_to_orddict ( A2 ) . An extendible array can be made fixed-size later: A3 = array : fix ( A2 ) . A fixed-size array does not grow automatically and does not allow accesses beyond the last set entry: { &#39;EXIT&#39; , { badarg , _ } } = ( catch array : set ( 18 , true , A3 ) ) . { &#39;EXIT&#39; , { badarg , _ } } = ( catch array : get ( 18 , A3 ) ) .","ref":"array.html","title":"array","type":"module"},{"doc":"Gets the value used for uninitialized entries. See also new/2 .","ref":"array.html#default/1","title":"array.default/1","type":"function"},{"doc":"Fixes the array size. This prevents it from growing automatically upon insertion. See also set/3 and relax/1 .","ref":"array.html#fix/1","title":"array.fix/1","type":"function"},{"doc":"Folds the array elements using the specified function and initial accumulator value. The elements are visited in order from the lowest index to the highest. If Function is not a function, the call fails with reason badarg . See also foldr/3 , map/2 , sparse_foldl/3 .","ref":"array.html#foldl/3","title":"array.foldl/3","type":"function"},{"doc":"Folds the array elements right-to-left using the specified function and initial accumulator value. The elements are visited in order from the highest index to the lowest. If Function is not a function, the call fails with reason badarg . See also foldl/3 , map/2 .","ref":"array.html#foldr/3","title":"array.foldr/3","type":"function"},{"doc":"Equivalent to from_list(List, undefined) .","ref":"array.html#from_list/1","title":"array.from_list/1","type":"function"},{"doc":"Converts a list to an extendible array. Default is used as the value for uninitialized entries of the array. If List is not a proper list, the call fails with reason badarg . See also new/2 , to_list/1 .","ref":"array.html#from_list/2","title":"array.from_list/2","type":"function"},{"doc":"Equivalent to from_orddict(Orddict, undefined) .","ref":"array.html#from_orddict/1","title":"array.from_orddict/1","type":"function"},{"doc":"Converts an ordered list of pairs {Index, Value} to a corresponding extendible array. Default is used as the value for uninitialized entries of the array. If Orddict is not a proper, ordered list of pairs whose first elements are non-negative integers, the call fails with reason badarg . See also new/2 , to_orddict/1 .","ref":"array.html#from_orddict/2","title":"array.from_orddict/2","type":"function"},{"doc":"Gets the value of entry I . If I is not a non-negative integer, or if the array has fixed size and I is larger than the maximum index, the call fails with reason badarg . If the array does not have fixed size, the default value for any index I greater than size(Array)-1 is returned. See also set/3 .","ref":"array.html#get/2","title":"array.get/2","type":"function"},{"doc":"Returns true if X is an array, otherwise false . Notice that the check is only shallow, as there is no guarantee that X is a well-formed array representation even if this function returns true .","ref":"array.html#is_array/1","title":"array.is_array/1","type":"function"},{"doc":"Checks if the array has fixed size. Returns true if the array is fixed, otherwise false . See also fix/1 .","ref":"array.html#is_fix/1","title":"array.is_fix/1","type":"function"},{"doc":"Maps the specified function onto each array element. The elements are visited in order from the lowest index to the highest. If Function is not a function, the call fails with reason badarg . See also foldl/3 , foldr/3 , sparse_map/2 .","ref":"array.html#map/2","title":"array.map/2","type":"function"},{"doc":"Creates a new, extendible array with initial size zero. See also new/1 , new/2 .","ref":"array.html#new/0","title":"array.new/0","type":"function"},{"doc":"Creates a new array according to the specified options. By default, the array is extendible and has initial size zero. Array indices start at 0 . Options is a single term or a list of terms, selected from the following: N::integer() &gt;= 0 or {size, N::integer() &gt;= 0} Specifies the initial array size; this also implies {fixed, true} . If N is not a non-negative integer, the call fails with reason badarg . fixed or {fixed, true} Creates a fixed-size array. See also fix/1 . {fixed, false} Creates an extendible (non-fixed-size) array. {default, Value} Sets the default value for the array to Value . Options are processed in the order they occur in the list, that is, later options have higher precedence. The default value is used as the value of uninitialized entries, and cannot be changed once the array has been created. Examples: array : new ( 100 ) creates a fixed-size array of size 100. array : new ( { default , 0 } ) creates an empty, extendible array whose default value is 0 . array : new ( [ { size , 10 } , { fixed , false } , { default , - 1 } ] ) creates an extendible array with initial size 10 whose default value is -1 . See also fix/1 , from_list/2 , get/2 , new/0 , new/2 , set/3 .","ref":"array.html#new/1","title":"array.new/1","type":"function"},{"doc":"Creates a new array according to the specified size and options. If Size is not a non-negative integer, the call fails with reason badarg . By default, the array has fixed size. Notice that any size specifications in Options override parameter Size . If Options is a list, this is equivalent to new([{size, Size} | Options]) , otherwise it is equivalent to new([{size, Size} | [Options]]) . However, using this function directly is more efficient. Example: array : new ( 100 , { default , 0 } ) creates a fixed-size array of size 100, whose default value is 0 . See also new/1 .","ref":"array.html#new/2","title":"array.new/2","type":"function"},{"doc":"Makes the array resizable. (Reverses the effects of fix/1 .) See also fix/1 .","ref":"array.html#relax/1","title":"array.relax/1","type":"function"},{"doc":"Resets entry I to the default value for the array. If the value of entry I is the default value, the array is returned unchanged. Reset never changes the array size. Shrinking can be done explicitly by calling resize/2 . If I is not a non-negative integer, or if the array has fixed size and I is larger than the maximum index, the call fails with reason badarg ; compare set/3 See also new/2 , set/3 .","ref":"array.html#reset/2","title":"array.reset/2","type":"function"},{"doc":"Changes the array size to that reported by sparse_size/1 . If the specified array has fixed size, also the resulting array has fixed size. See also resize/2 , sparse_size/1 .","ref":"array.html#resize/1","title":"array.resize/1","type":"function"},{"doc":"Change the array size. If Size is not a non-negative integer, the call fails with reason badarg . If the specified array has fixed size, also the resulting array has fixed size.","ref":"array.html#resize/2","title":"array.resize/2","type":"function"},{"doc":"Sets entry I of the array to Value . If I is not a non-negative integer, or if the array has fixed size and I is larger than the maximum index, the call fails with reason badarg . If the array does not have fixed size, and I is greater than size(Array)-1 , the array grows to size I+1 . See also get/2 , reset/2 .","ref":"array.html#set/3","title":"array.set/3","type":"function"},{"doc":"Gets the number of entries in the array. Entries are numbered from 0 to size(Array)-1 . Hence, this is also the index of the first entry that is guaranteed to not have been previously set. See also set/3 , sparse_size/1 .","ref":"array.html#size/1","title":"array.size/1","type":"function"},{"doc":"Folds the array elements using the specified function and initial accumulator value, skipping default-valued entries. The elements are visited in order from the lowest index to the highest. If Function is not a function, the call fails with reason badarg . See also foldl/3 , sparse_foldr/3 .","ref":"array.html#sparse_foldl/3","title":"array.sparse_foldl/3","type":"function"},{"doc":"Folds the array elements right-to-left using the specified function and initial accumulator value, skipping default-valued entries. The elements are visited in order from the highest index to the lowest. If Function is not a function, the call fails with reason badarg . See also foldr/3 , sparse_foldl/3 .","ref":"array.html#sparse_foldr/3","title":"array.sparse_foldr/3","type":"function"},{"doc":"Maps the specified function onto each array element, skipping default-valued entries. The elements are visited in order from the lowest index to the highest. If Function is not a function, the call fails with reason badarg . See also map/2 .","ref":"array.html#sparse_map/2","title":"array.sparse_map/2","type":"function"},{"doc":"Gets the number of entries in the array up until the last non-default-valued entry. That is, returns I+1 if I is the last non-default-valued entry in the array, or zero if no such entry exists. See also resize/1 , size/1 .","ref":"array.html#sparse_size/1","title":"array.sparse_size/1","type":"function"},{"doc":"Converts the array to a list, skipping default-valued entries. See also to_list/1 .","ref":"array.html#sparse_to_list/1","title":"array.sparse_to_list/1","type":"function"},{"doc":"Converts the array to an ordered list of pairs {Index, Value} , skipping default-valued entries. See also to_orddict/1 .","ref":"array.html#sparse_to_orddict/1","title":"array.sparse_to_orddict/1","type":"function"},{"doc":"Converts the array to a list. See also from_list/2 , sparse_to_list/1 .","ref":"array.html#to_list/1","title":"array.to_list/1","type":"function"},{"doc":"Converts the array to an ordered list of pairs {Index, Value} . See also from_orddict/2 , sparse_to_orddict/1 .","ref":"array.html#to_orddict/1","title":"array.to_orddict/1","type":"function"},{"doc":"","ref":"array.html#t:array/0","title":"array.array/0","type":"type"},{"doc":"A functional, extendible array. The representation is not documented and is subject to change without notice. Notice that arrays cannot be directly compared for equality.","ref":"array.html#t:array/1","title":"array.array/1","type":"opaque"},{"doc":"","ref":"array.html#t:array_indx/0","title":"array.array_indx/0","type":"type"},{"doc":"","ref":"array.html#t:array_opt/0","title":"array.array_opt/0","type":"type"},{"doc":"","ref":"array.html#t:array_opts/0","title":"array.array_opts/0","type":"type"},{"doc":"","ref":"array.html#t:indx_pair/1","title":"array.indx_pair/1","type":"type"},{"doc":"","ref":"array.html#t:indx_pairs/1","title":"array.indx_pairs/1","type":"type"},{"doc":"Provides base64 encode and decode, see RFC 2045 .","ref":"base64.html","title":"base64","type":"module"},{"doc":"Decodes a base64-encoded string to plain ASCII. See RFC 4648 . mime_decode/1 and mime_decode_to_string/1 strip away illegal characters, while decode/1 and decode_to_string/1 only strip away whitespace characters.","ref":"base64.html#decode/1","title":"base64.decode/1","type":"function"},{"doc":"","ref":"base64.html#decode_to_string/1","title":"base64.decode_to_string/1","type":"function"},{"doc":"Encodes a plain ASCII string into base64. The result is 33% larger than the data.","ref":"base64.html#encode/1","title":"base64.encode/1","type":"function"},{"doc":"","ref":"base64.html#encode_to_string/1","title":"base64.encode_to_string/1","type":"function"},{"doc":"","ref":"base64.html#mime_decode/1","title":"base64.mime_decode/1","type":"function"},{"doc":"","ref":"base64.html#mime_decode_to_string/1","title":"base64.mime_decode_to_string/1","type":"function"},{"doc":"Base 64 Encoding alphabet, see RFC 4648 .","ref":"base64.html#t:base64_alphabet/0","title":"base64.base64_alphabet/0","type":"type"},{"doc":"Base 64 encoded binary.","ref":"base64.html#t:base64_binary/0","title":"base64.base64_binary/0","type":"type"},{"doc":"Base 64 encoded string.","ref":"base64.html#t:base64_string/0","title":"base64.base64_string/0","type":"type"},{"doc":"Arbitrary sequences of octets.","ref":"base64.html#t:byte_string/0","title":"base64.byte_string/0","type":"type"},{"doc":"This module provides an interface to files created by the BEAM Compiler (&quot;BEAM files&quot;). The format used, a variant of &quot;EA IFF 1985&quot; Standard for Interchange Format Files, divides data into chunks. Chunk data can be returned as binaries or as compound terms. Compound terms are returned when chunks are referenced by names (atoms) rather than identifiers (strings). The recognized names and the corresponding identifiers are as follows: atoms (&quot;Atom&quot;) attributes (&quot;Attr&quot;) compile_info (&quot;CInf&quot;) debug_info (&quot;Dbgi&quot;) exports (&quot;ExpT&quot;) imports (&quot;ImpT&quot;) indexed_imports (&quot;ImpT&quot;) labeled_exports (&quot;ExpT&quot;) labeled_locals (&quot;LocT&quot;) locals (&quot;LocT&quot;) Debug Information/Abstract Code Option debug_info can be specified to the Compiler (see compile(3) ) to have debug information, such as Erlang Abstract Format, stored in the debug_info chunk. Tools such as Debugger and Xref require the debug information to be included. Source code can be reconstructed from the debug information. To prevent this, use encrypted debug information (see below). The debug information can also be removed from BEAM files using strip/1 , strip_files/1 , and/or strip_release/1 . Reconstruct Source Code The following example shows how to reconstruct Erlang source code from the debug information in a BEAM file Beam : {ok,{_,[{abstract_code,{_,AC}}]}} = beam_lib:chunks(Beam,[abstract_code]). io:fwrite(&quot;~s~n&quot;, [erl_prettypr:format(erl_syntax:form_list(AC))]). Encrypted Debug Information The debug information can be encrypted to keep the source code secret, but still be able to use tools such as Debugger or Xref. To use encrypted debug information, a key must be provided to the compiler and beam_lib . The key is specified as a string. It is recommended that the string contains at least 32 characters and that both upper and lower case letters as well as digits and special characters are used. The default type (and currently the only type) of crypto algorithm is des3_cbc , three rounds of DES. The key string is scrambled using erlang:md5/1 to generate the keys used for des3_cbc . As far as we know by the time of writing, it is infeasible to break des3_cbc encryption without any knowledge of the key. Therefore, as long as the key is kept safe and is unguessable, the encrypted debug information should be safe from intruders. The key can be provided in the following two ways: Use Compiler option {debug_info_key,Key} , see compile(3) and function crypto_key_fun/1 to register a fun that returns the key whenever beam_lib must decrypt the debug information. If no such fun is registered, beam_lib instead searches for an .erlang.crypt file, see the next section. Store the key in a text file named .erlang.crypt . In this case, Compiler option encrypt_debug_info can be used, see compile(3) . .erlang.crypt beam_lib searches for .erlang.crypt in the current directory and then the home directory for the current user. If the file is found and contains a key, beam_lib implicitly creates a crypto key fun and registers it. File .erlang.crypt is to contain a single list of tuples: {debug_info, Mode, Module, Key} Mode is the type of crypto algorithm; currently, the only allowed value is des3_cbc . Module is either an atom, in which case Key is only used for the module Module , or [] , in which case Key is used for all modules. Key is the non-empty key string. Key in the first tuple where both Mode and Module match is used. The following is an example of an .erlang.crypt file that returns the same key for all modules: [{debug_info, des3_cbc, [], &quot;%&gt;7}|pc/DM6Cga*68$Mw]L#&amp;_Gejr]G^&quot;}]. The following is a slightly more complicated example of an .erlang.crypt providing one key for module t and another key for all other modules: [{debug_info, des3_cbc, t, &quot;My KEY&quot;}, {debug_info, des3_cbc, [], &quot;%&gt;7}|pc/DM6Cga*68$Mw]L#&amp;_Gejr]G^&quot;}]. Do not use any of the keys in these examples. Use your own keys.","ref":"beam_lib.html","title":"beam_lib","type":"module"},{"doc":"Reads chunk data for all chunks.","ref":"beam_lib.html#all_chunks/1","title":"beam_lib.all_chunks/1","type":"function"},{"doc":"Builds a BEAM module (as a binary) from a list of chunks.","ref":"beam_lib.html#build_module/1","title":"beam_lib.build_module/1","type":"function"},{"doc":"Reads chunk data for selected chunks references. The order of the returned list of chunk data is determined by the order of the list of chunks references.","ref":"beam_lib.html#chunks/2","title":"beam_lib.chunks/2","type":"function"},{"doc":"Reads chunk data for selected chunks references. The order of the returned list of chunk data is determined by the order of the list of chunks references. By default, if any requested chunk is missing in Beam , an error tuple is returned. However, if option allow_missing_chunks is specified, a result is returned even if chunks are missing. In the result list, any missing chunks are represented as {ChunkRef,missing_chunk} . Notice however that if chunk &quot;Atom&quot; is missing, that is considered a fatal error and the return value is an error tuple.","ref":"beam_lib.html#chunks/3","title":"beam_lib.chunks/3","type":"function"},{"doc":"Unregisters the crypto key fun and terminates the process holding it, started by crypto_key_fun/1 . Returns either {ok, undefined} if no crypto key fun is registered, or {ok, Term} , where Term is the return value from CryptoKeyFun(clear) , see crypto_key_fun/1 .","ref":"beam_lib.html#clear_crypto_key_fun/0","title":"beam_lib.clear_crypto_key_fun/0","type":"function"},{"doc":"Compares the contents of two BEAM files. If the module names are the same, and all chunks except for chunk &quot;CInf&quot; (the chunk containing the compilation information that is returned by Module:module_info(compile) ) have the same contents in both files, ok is returned. Otherwise an error message is returned.","ref":"beam_lib.html#cmp/2","title":"beam_lib.cmp/2","type":"function"},{"doc":"Compares the BEAM files in two directories. Only files with extension &quot;.beam&quot; are compared. BEAM files that exist only in directory Dir1 ( Dir2 ) are returned in Only1 ( Only2 ). BEAM files that exist in both directories but are considered different by cmp/2 are returned as pairs { Filename1 , Filename2 }, where Filename1 ( Filename2 ) exists in directory Dir1 ( Dir2 ).","ref":"beam_lib.html#cmp_dirs/2","title":"beam_lib.cmp_dirs/2","type":"function"},{"doc":"Registers an unary fun that is called if beam_lib must read an debug_info chunk that has been encrypted. The fun is held in a process that is started by the function. If a fun is already registered when attempting to register a fun, {error, exists} is returned. The fun must handle the following arguments: CryptoKeyFun(init) -&gt; ok | {ok, NewCryptoKeyFun} | {error, Term} Called when the fun is registered, in the process that holds the fun. Here the crypto key fun can do any necessary initializations. If {ok, NewCryptoKeyFun} is returned, NewCryptoKeyFun is registered instead of CryptoKeyFun . If {error, Term} is returned, the registration is aborted and crypto_key_fun/1 also returns {error, Term} . CryptoKeyFun({debug_info, Mode, Module, Filename}) -&gt; Key Called when the key is needed for module Module in the file named Filename . Mode is the type of crypto algorithm; currently, the only possible value is des3_cbc . The call is to fail (raise an exception) if no key is available. CryptoKeyFun(clear) -&gt; term() Called before the fun is unregistered. Here any cleaning up can be done. The return value is not important, but is passed back to the caller of clear_crypto_key_fun/0 as part of its return value.","ref":"beam_lib.html#crypto_key_fun/1","title":"beam_lib.crypto_key_fun/1","type":"function"},{"doc":"Compares the BEAM files in two directories as cmp_dirs/2 , but the names of files that exist in only one directory or are different are presented on standard output.","ref":"beam_lib.html#diff_dirs/2","title":"beam_lib.diff_dirs/2","type":"function"},{"doc":"For a specified error returned by any function in this module, this function returns a descriptive string of the error in English. For file errors, function file:format_error(Posix) is to be called.","ref":"beam_lib.html#format_error/1","title":"beam_lib.format_error/1","type":"function"},{"doc":"Returns a list containing some information about a BEAM file as tuples {Item, Info} : {file, Filename} | {binary, Binary} The name (string) of the BEAM file, or the binary from which the information was extracted. {module, Module} The name (atom) of the module. {chunks, [{ChunkId, Pos, Size}]} For each chunk, the identifier (string) and the position and size of the chunk data, in bytes.","ref":"beam_lib.html#info/1","title":"beam_lib.info/1","type":"function"},{"doc":"Calculates an MD5 redundancy check for the code of the module (compilation date and other attributes are not included).","ref":"beam_lib.html#md5/1","title":"beam_lib.md5/1","type":"function"},{"doc":"Removes all chunks from a BEAM file except those needed by the loader. In particular, the debug information (chunk debug_info and abstract_code ) is removed.","ref":"beam_lib.html#strip/1","title":"beam_lib.strip/1","type":"function"},{"doc":"Removes all chunks from a BEAM file except those needed by the loader or passed in. In particular, the debug information (chunk debug_info and abstract_code ) is removed.","ref":"beam_lib.html#strip/2","title":"beam_lib.strip/2","type":"function"},{"doc":"Removes all chunks except those needed by the loader from BEAM files. In particular, the debug information (chunk debug_info and abstract_code ) is removed. The returned list contains one element for each specified filename, in the same order as in Files .","ref":"beam_lib.html#strip_files/1","title":"beam_lib.strip_files/1","type":"function"},{"doc":"Removes all chunks except those needed by the loader or passed in from BEAM files. In particular, the debug information (chunk debug_info and abstract_code ) is removed. The returned list contains one element for each specified filename, in the same order as in Files .","ref":"beam_lib.html#strip_files/2","title":"beam_lib.strip_files/2","type":"function"},{"doc":"Removes all chunks except those needed by the loader from the BEAM files of a release. Dir is to be the installation root directory. For example, the current OTP release can be stripped with the call beam_lib:strip_release(code:root_dir()) .","ref":"beam_lib.html#strip_release/1","title":"beam_lib.strip_release/1","type":"function"},{"doc":"Removes all chunks except those needed by the loader or passed in from the BEAM files of a release. Dir is to be the installation root directory. For example, the current OTP release can be stripped with the call beam_lib:strip_release(code:root_dir()) .","ref":"beam_lib.html#strip_release/2","title":"beam_lib.strip_release/2","type":"function"},{"doc":"Returns the module version or versions. A version is defined by module attribute -vsn(Vsn) . If this attribute is not specified, the version defaults to the checksum of the module. Notice that if version Vsn is not a list, it is made into one, that is {ok,{Module,[Vsn]}} is returned. If there are many -vsn module attributes, the result is the concatenated list of versions. Examples: 1 &gt; beam_lib : version ( a ) . % -vsn(1). { ok , { a , [ 1 ] } } 2 &gt; beam_lib : version ( b ) . % -vsn([1]). { ok , { b , [ 1 ] } } 3 &gt; beam_lib : version ( c ) . % -vsn([1]). -vsn(2). { ok , { c , [ 1 , 2 ] } } 4 &gt; beam_lib : version ( d ) . % no -vsn attribute { ok , { d , [ 275613208176997377698094100858909383631 ] } }","ref":"beam_lib.html#version/1","title":"beam_lib.version/1","type":"function"},{"doc":"It is not checked that the forms conform to the abstract format indicated by AbstVersion . no_abstract_code means that chunk &quot;Abst&quot; is present, but empty. For modules compiled with OTP 20 onwards, the abst_code chunk is automatically computed from the debug_info chunk.","ref":"beam_lib.html#t:abst_code/0","title":"beam_lib.abst_code/0","type":"type"},{"doc":"","ref":"beam_lib.html#t:attrib_entry/0","title":"beam_lib.attrib_entry/0","type":"type"},{"doc":"Each of the functions described below accept either the filename (as a string) or a binary containing the BEAM module.","ref":"beam_lib.html#t:beam/0","title":"beam_lib.beam/0","type":"type"},{"doc":"","ref":"beam_lib.html#t:chnk_rsn/0","title":"beam_lib.chnk_rsn/0","type":"type"},{"doc":"The list of attributes is sorted on Attribute (in attrib_entry() ) and each attribute name occurs once in the list. The attribute values occur in the same order as in the file. The lists of functions are also sorted.","ref":"beam_lib.html#t:chunkdata/0","title":"beam_lib.chunkdata/0","type":"type"},{"doc":"&quot;Attr&quot; | &quot;CInf&quot; | &quot;Dbgi&quot; | &quot;ExpT&quot; | &quot;ImpT&quot; | &quot;LocT&quot; | &quot;AtU8&quot;","ref":"beam_lib.html#t:chunkid/0","title":"beam_lib.chunkid/0","type":"type"},{"doc":"","ref":"beam_lib.html#t:chunkname/0","title":"beam_lib.chunkname/0","type":"type"},{"doc":"","ref":"beam_lib.html#t:chunkref/0","title":"beam_lib.chunkref/0","type":"type"},{"doc":"","ref":"beam_lib.html#t:compinfo_entry/0","title":"beam_lib.compinfo_entry/0","type":"type"},{"doc":"","ref":"beam_lib.html#t:dataB/0","title":"beam_lib.dataB/0","type":"type"},{"doc":"The format stored in the debug_info chunk. To retrieve particular code representation from the backend, Backend:debug_info(Format, Module, Data, Opts) must be invoked. Format is an atom, such as erlang_v1 for the Erlang Abstract Format or core_v1 for Core Erlang. Module is the module represented by the beam file and Data is the value stored in the debug info chunk. Opts is any list of values supported by the Backend . Backend:debug_info/4 must return {ok, Code} or {error, Term} . Developers must always invoke the debug_info/4 function and never rely on the Data stored in the debug_info chunk, as it is opaque and may change at any moment. no_debug_info means that chunk &quot;Dbgi&quot; is present, but empty.","ref":"beam_lib.html#t:debug_info/0","title":"beam_lib.debug_info/0","type":"type"},{"doc":"","ref":"beam_lib.html#t:forms/0","title":"beam_lib.forms/0","type":"type"},{"doc":"","ref":"beam_lib.html#t:index/0","title":"beam_lib.index/0","type":"type"},{"doc":"","ref":"beam_lib.html#t:info_rsn/0","title":"beam_lib.info_rsn/0","type":"type"},{"doc":"","ref":"beam_lib.html#t:label/0","title":"beam_lib.label/0","type":"type"},{"doc":"","ref":"beam_lib.html#t:labeled_entry/0","title":"beam_lib.labeled_entry/0","type":"type"},{"doc":"This module contains functions for manipulating byte-oriented binaries. Although the majority of functions could be provided using bit-syntax, the functions in this library are highly optimized and are expected to either execute faster or consume less memory, or both, than a counterpart written in pure Erlang. The module is provided according to Erlang Enhancement Proposal (EEP) 31. The library handles byte-oriented data. For bitstrings that are not binaries (does not contain whole octets of bits) a badarg exception is thrown from any of the functions in this module.","ref":"binary.html","title":"binary","type":"module"},{"doc":"Returns the byte at position Pos (zero-based) in binary Subject as an integer. If Pos &gt;= byte_size(Subject) , a badarg exception is raised.","ref":"binary.html#at/2","title":"binary.at/2","type":"function"},{"doc":"Same as bin_to_list(Subject, {0,byte_size(Subject)}) .","ref":"binary.html#bin_to_list/1","title":"binary.bin_to_list/1","type":"function"},{"doc":"Converts Subject to a list of byte() s, each representing the value of one byte. part() denotes which part of the binary() to convert. Example: 1 &gt; binary : bin_to_list ( &lt;&lt; &quot;erlang&quot; &gt;&gt; , { 1 , 3 } ) . &quot;rla&quot; %% or [114,108,97] in list notation. If PosLen in any way references outside the binary, a badarg exception is raised.","ref":"binary.html#bin_to_list/2","title":"binary.bin_to_list/2","type":"function"},{"doc":"Same as bin_to_list(Subject, {Pos, Len}) .","ref":"binary.html#bin_to_list/3","title":"binary.bin_to_list/3","type":"function"},{"doc":"Builds an internal structure representing a compilation of a search pattern, later to be used in functions match/3 , matches/3 , split/3 , or replace/4 . The cp() returned is guaranteed to be a tuple() to allow programs to distinguish it from non-precompiled search patterns. When a list of binaries is specified, it denotes a set of alternative binaries to search for. For example, if [&lt;&lt;&quot;functional&quot;&gt;&gt;,&lt;&lt;&quot;programming&quot;&gt;&gt;] is specified as Pattern , this means either &lt;&lt;&quot;functional&quot;&gt;&gt; or &lt;&lt;&quot;programming&quot;&gt;&gt; &quot;. The pattern is a set of alternatives; when only a single binary is specified, the set has only one element. The order of alternatives in a pattern is not significant. The list of binaries used for search alternatives must be flat and proper. If Pattern is not a binary or a flat proper list of binaries with length &gt; 0, a badarg exception is raised.","ref":"binary.html#compile_pattern/1","title":"binary.compile_pattern/1","type":"function"},{"doc":"Same as copy(Subject, 1) .","ref":"binary.html#copy/1","title":"binary.copy/1","type":"function"},{"doc":"Creates a binary with the content of Subject duplicated N times. This function always creates a new binary, even if N = 1 . By using copy/1 on a binary referencing a larger binary, one can free up the larger binary for garbage collection. By deliberately copying a single binary to avoid referencing a larger binary, one can, instead of freeing up the larger binary for later garbage collection, create much more binary data than needed. Sharing binary data is usually good. Only in special cases, when small parts reference large binaries and the large binaries are no longer used in any process, deliberate copying can be a good idea. If N &lt; 0 , a badarg exception is raised.","ref":"binary.html#copy/2","title":"binary.copy/2","type":"function"},{"doc":"Decodes a hex encoded binary into a binary. Example 1 &gt; binary : decode_hex ( &lt;&lt; &quot;66&quot; &gt;&gt; ) . &lt;&lt; &quot;f&quot; &gt;&gt;","ref":"binary.html#decode_hex/1","title":"binary.decode_hex/1","type":"function"},{"doc":"Same as decode_unsigned(Subject, big) .","ref":"binary.html#decode_unsigned/1","title":"binary.decode_unsigned/1","type":"function"},{"doc":"Converts the binary digit representation, in big endian or little endian, of a positive integer in Subject to an Erlang integer() . Example: 1 &gt; binary : decode_unsigned ( &lt;&lt; 169 , 138 , 199 &gt;&gt; , big ) . 11111111","ref":"binary.html#decode_unsigned/2","title":"binary.decode_unsigned/2","type":"function"},{"doc":"Encodes a binary into a hex encoded binary. Example: 1 &gt; binary : encode_hex ( &lt;&lt; &quot;f&quot; &gt;&gt; ) . &lt;&lt; &quot;66&quot; &gt;&gt;","ref":"binary.html#encode_hex/1","title":"binary.encode_hex/1","type":"function"},{"doc":"Same as encode_unsigned(Unsigned, big) .","ref":"binary.html#encode_unsigned/1","title":"binary.encode_unsigned/1","type":"function"},{"doc":"Converts a positive integer to the smallest possible representation in a binary digit representation, either big endian or little endian. Example: 1 &gt; binary : encode_unsigned ( 11111111 , big ) . &lt;&lt; 169 , 138 , 199 &gt;&gt;","ref":"binary.html#encode_unsigned/2","title":"binary.encode_unsigned/2","type":"function"},{"doc":"Returns the first byte of binary Subject as an integer. If the size of Subject is zero, a badarg exception is raised.","ref":"binary.html#first/1","title":"binary.first/1","type":"function"},{"doc":"Returns the last byte of binary Subject as an integer. If the size of Subject is zero, a badarg exception is raised.","ref":"binary.html#last/1","title":"binary.last/1","type":"function"},{"doc":"Works exactly as erlang:list_to_binary/1 , added for completeness.","ref":"binary.html#list_to_bin/1","title":"binary.list_to_bin/1","type":"function"},{"doc":"Returns the length of the longest common prefix of the binaries in list Binaries . Example: 1 &gt; binary : longest_common_prefix ( [ &lt;&lt; &quot;erlang&quot; &gt;&gt; , &lt;&lt; &quot;ergonomy&quot; &gt;&gt; ] ) . 2 2 &gt; binary : longest_common_prefix ( [ &lt;&lt; &quot;erlang&quot; &gt;&gt; , &lt;&lt; &quot;perl&quot; &gt;&gt; ] ) . 0 If Binaries is not a flat list of binaries, a badarg exception is raised.","ref":"binary.html#longest_common_prefix/1","title":"binary.longest_common_prefix/1","type":"function"},{"doc":"Returns the length of the longest common suffix of the binaries in list Binaries . Example: 1 &gt; binary : longest_common_suffix ( [ &lt;&lt; &quot;erlang&quot; &gt;&gt; , &lt;&lt; &quot;fang&quot; &gt;&gt; ] ) . 3 2 &gt; binary : longest_common_suffix ( [ &lt;&lt; &quot;erlang&quot; &gt;&gt; , &lt;&lt; &quot;perl&quot; &gt;&gt; ] ) . 0 If Binaries is not a flat list of binaries, a badarg exception is raised.","ref":"binary.html#longest_common_suffix/1","title":"binary.longest_common_suffix/1","type":"function"},{"doc":"Same as match(Subject, Pattern, []) .","ref":"binary.html#match/2","title":"binary.match/2","type":"function"},{"doc":"Searches for the first occurrence of Pattern in Subject and returns the position and length. The function returns {Pos, Length} for the binary in Pattern , starting at the lowest position in Subject . Example: 1 &gt; binary : match ( &lt;&lt; &quot;abcde&quot; &gt;&gt; , [ &lt;&lt; &quot;bcde&quot; &gt;&gt; , &lt;&lt; &quot;cd&quot; &gt;&gt; ] , [ ] ) . { 1 , 4 } Even though &lt;&lt;&quot;cd&quot;&gt;&gt; ends before &lt;&lt;&quot;bcde&quot;&gt;&gt; , &lt;&lt;&quot;bcde&quot;&gt;&gt; begins first and is therefore the first match. If two overlapping matches begin at the same position, the longest is returned. Summary of the options: {scope, {Start, Length}} Only the specified part is searched. Return values still have offsets from the beginning of Subject . A negative Length is allowed as described in section Data Types in this manual. If none of the strings in Pattern is found, the atom nomatch is returned. For a description of Pattern , see function compile_pattern/1 . If {scope, {Start,Length}} is specified in the options such that Start &gt; size of Subject , Start + Length &lt; 0 or Start + Length &gt; size of Subject , a badarg exception is raised.","ref":"binary.html#match/3","title":"binary.match/3","type":"function"},{"doc":"Same as matches(Subject, Pattern, []) .","ref":"binary.html#matches/2","title":"binary.matches/2","type":"function"},{"doc":"As match/2 , but Subject is searched until exhausted and a list of all non-overlapping parts matching Pattern is returned (in order). The first and longest match is preferred to a shorter, which is illustrated by the following example: 1 &gt; binary : matches ( &lt;&lt; &quot;abcde&quot; &gt;&gt; , [ &lt;&lt; &quot;bcde&quot; &gt;&gt; , &lt;&lt; &quot;bc&quot; &gt;&gt; , &lt;&lt; &quot;de&quot; &gt;&gt; ] , [ ] ) . [ { 1 , 4 } ] The result shows that &lt;&lt;&quot;bcde&quot;&gt;&gt; is selected instead of the shorter match &lt;&lt;&quot;bc&quot;&gt;&gt; (which would have given raise to one more match, &lt;&lt;&quot;de&quot;&gt;&gt;). This corresponds to the behavior of POSIX regular expressions (and programs like awk), but is not consistent with alternative matches in re (and Perl), where instead lexical ordering in the search pattern selects which string matches. If none of the strings in a pattern is found, an empty list is returned. For a description of Pattern , see compile_pattern/1 . For a description of available options, see match/3 . If {scope, {Start,Length}} is specified in the options such that Start &gt; size of Subject , Start + Length &lt; 0 or Start + Length is &gt; size of Subject , a badarg exception is raised.","ref":"binary.html#matches/3","title":"binary.matches/3","type":"function"},{"doc":"Extracts the part of binary Subject described by PosLen . A negative length can be used to extract bytes at the end of a binary: 1 &gt; Bin = &lt;&lt; 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 &gt;&gt; . 2 &gt; binary : part ( Bin , { byte_size ( Bin ) , - 5 } ) . &lt;&lt; 6 , 7 , 8 , 9 , 10 &gt;&gt; part/2 and part/3 are also available in the erlang module under the names binary_part/2 and binary_part/3 . Those BIFs are allowed in guard tests. If PosLen in any way references outside the binary, a badarg exception is raised.","ref":"binary.html#part/2","title":"binary.part/2","type":"function"},{"doc":"Same as part(Subject, {Pos, Len}) .","ref":"binary.html#part/3","title":"binary.part/3","type":"function"},{"doc":"If a binary references a larger binary (often described as being a subbinary), it can be useful to get the size of the referenced binary. This function can be used in a program to trigger the use of copy/1 . By copying a binary, one can dereference the original, possibly large, binary that a smaller binary is a reference to. Example: store ( Binary , GBSet ) -&gt; NewBin = case binary : referenced_byte_size ( Binary ) of Large when Large &gt; 2 * byte_size ( Binary ) -&gt; binary : copy ( Binary ) ; _ -&gt; Binary end , gb_sets : insert ( NewBin , GBSet ) . In this example, we chose to copy the binary content before inserting it in gb_sets:set() if it references a binary more than twice the data size we want to keep. Of course, different rules apply when copying to different programs. Binary sharing occurs whenever binaries are taken apart. This is the fundamental reason why binaries are fast, decomposition can always be done with O(1) complexity. In rare circumstances this data sharing is however undesirable, why this function together with copy/1 can be useful when optimizing for memory use. Example of binary sharing: 1 &gt; A = binary : copy ( &lt;&lt; 1 &gt;&gt; , 100 ) . &lt;&lt; 1 , 1 , 1 , 1 , 1 . . . 2 &gt; byte_size ( A ) . 100 3 &gt; binary : referenced_byte_size ( A ) . 100 4 &gt; &lt;&lt; B : 10 / binary , C : 90 / binary &gt;&gt; = A . &lt;&lt; 1 , 1 , 1 , 1 , 1 . . . 5 &gt; { byte_size ( B ) , binary : referenced_byte_size ( B ) } . { 10 , 10 } 6 &gt; { byte_size ( C ) , binary : referenced_byte_size ( C ) } . { 90 , 100 } In the above example, the small binary B was copied while the larger binary C references binary A . Binary data is shared among processes. If another process still references the larger binary, copying the part this process uses only consumes more memory and does not free up the larger binary for garbage collection. Use this kind of intrusive functions with extreme care and only if a real problem is detected.","ref":"binary.html#referenced_byte_size/1","title":"binary.referenced_byte_size/1","type":"function"},{"doc":"Same as replace(Subject, Pattern, Replacement,[]) .","ref":"binary.html#replace/3","title":"binary.replace/3","type":"function"},{"doc":"Constructs a new binary by replacing the parts in Subject matching Pattern with the content of Replacement . If the matching subpart of Subject giving raise to the replacement is to be inserted in the result, option {insert_replaced, InsPos} inserts the matching part into Replacement at the specified position (or positions) before inserting Replacement into Subject . Example: 1 &gt; binary : replace ( &lt;&lt; &quot;abcde&quot; &gt;&gt; , &lt;&lt; &quot;b&quot; &gt;&gt; , &lt;&lt; &quot;[]&quot; &gt;&gt; , [ { insert_replaced , 1 } ] ) . &lt;&lt; &quot;a[b]cde&quot; &gt;&gt; 2 &gt; binary : replace ( &lt;&lt; &quot;abcde&quot; &gt;&gt; , [ &lt;&lt; &quot;b&quot; &gt;&gt; , &lt;&lt; &quot;d&quot; &gt;&gt; ] , &lt;&lt; &quot;[]&quot; &gt;&gt; , [ global , { insert_replaced , 1 } ] ) . &lt;&lt; &quot;a[b]c[d]e&quot; &gt;&gt; 3 &gt; binary : replace ( &lt;&lt; &quot;abcde&quot; &gt;&gt; , [ &lt;&lt; &quot;b&quot; &gt;&gt; , &lt;&lt; &quot;d&quot; &gt;&gt; ] , &lt;&lt; &quot;[]&quot; &gt;&gt; , [ global , { insert_replaced , [ 1 , 1 ] } ] ) . &lt;&lt; &quot;a[bb]c[dd]e&quot; &gt;&gt; 4 &gt; binary : replace ( &lt;&lt; &quot;abcde&quot; &gt;&gt; , [ &lt;&lt; &quot;b&quot; &gt;&gt; , &lt;&lt; &quot;d&quot; &gt;&gt; ] , &lt;&lt; &quot;[-]&quot; &gt;&gt; , [ global , { insert_replaced , [ 1 , 2 ] } ] ) . &lt;&lt; &quot;a[b-b]c[d-d]e&quot; &gt;&gt; If any position specified in InsPos &gt; size of the replacement binary, a badarg exception is raised. Options global and {scope, part()} work as for split/3 . The return type is always a binary() . For a description of Pattern , see compile_pattern/1 .","ref":"binary.html#replace/4","title":"binary.replace/4","type":"function"},{"doc":"Same as split(Subject, Pattern, []) .","ref":"binary.html#split/2","title":"binary.split/2","type":"function"},{"doc":"Splits Subject into a list of binaries based on Pattern . If option global is not specified, only the first occurrence of Pattern in Subject gives rise to a split. The parts of Pattern found in Subject are not included in the result. Example: 1 &gt; binary : split ( &lt;&lt; 1 , 255 , 4 , 0 , 0 , 0 , 2 , 3 &gt;&gt; , [ &lt;&lt; 0 , 0 , 0 &gt;&gt; , &lt;&lt; 2 &gt;&gt; ] , [ ] ) . [ &lt;&lt; 1 , 255 , 4 &gt;&gt; , &lt;&lt; 2 , 3 &gt;&gt; ] 2 &gt; binary : split ( &lt;&lt; 0 , 1 , 0 , 0 , 4 , 255 , 255 , 9 &gt;&gt; , [ &lt;&lt; 0 , 0 &gt;&gt; , &lt;&lt; 255 , 255 &gt;&gt; ] , [ global ] ) . [ &lt;&lt; 0 , 1 &gt;&gt; , &lt;&lt; 4 &gt;&gt; , &lt;&lt; 9 &gt;&gt; ] Summary of options: {scope, part()} Works as in match/3 and matches/3 . Notice that this only defines the scope of the search for matching strings, it does not cut the binary before splitting. The bytes before and after the scope are kept in the result. See the example below. trim Removes trailing empty parts of the result (as does trim in re:split/3 . trim_all Removes all empty parts of the result. global Repeats the split until Subject is exhausted. Conceptually option global makes split work on the positions returned by matches/3 , while it normally works on the position returned by match/3 . Example of the difference between a scope and taking the binary apart before splitting: 1 &gt; binary : split ( &lt;&lt; &quot;banana&quot; &gt;&gt; , [ &lt;&lt; &quot;a&quot; &gt;&gt; ] , [ { scope , { 2 , 3 } } ] ) . [ &lt;&lt; &quot;ban&quot; &gt;&gt; , &lt;&lt; &quot;na&quot; &gt;&gt; ] 2 &gt; binary : split ( binary : part ( &lt;&lt; &quot;banana&quot; &gt;&gt; , { 2 , 3 } ) , [ &lt;&lt; &quot;a&quot; &gt;&gt; ] , [ ] ) . [ &lt;&lt; &quot;n&quot; &gt;&gt; , &lt;&lt; &quot;n&quot; &gt;&gt; ] The return type is always a list of binaries that are all referencing Subject . This means that the data in Subject is not copied to new binaries, and that Subject cannot be garbage collected until the results of the split are no longer referenced. For a description of Pattern , see compile_pattern/1 .","ref":"binary.html#split/3","title":"binary.split/3","type":"function"},{"doc":"Opaque data type representing a compiled search pattern. Guaranteed to be a tuple() to allow programs to distinguish it from non-precompiled search patterns.","ref":"binary.html#t:cp/0","title":"binary.cp/0","type":"opaque"},{"doc":"A representation of a part (or range) in a binary. Start is a zero-based offset into a binary() and Length is the length of that part. As input to functions in this module, a reverse part specification is allowed, constructed with a negative Length , so that the part of the binary begins at Start + Length and is - Length long. This is useful for referencing the last N bytes of a binary as {size(Binary), -N} . The functions in this module always return part() s with positive Length .","ref":"binary.html#t:part/0","title":"binary.part/0","type":"type"},{"doc":"This module enables users to enter the short form of some commonly used commands. These functions are intended for interactive use in the Erlang shell only. The module prefix can be omitted. See Also filename(3) , compile(3) , erlang(3) , yecc(3) , xref(3)","ref":"c.html","title":"c","type":"module"},{"doc":"Stack backtrace for a process. Equivalent to erlang:process_display(Pid, backtrace) .","ref":"c.html#bt/1","title":"c.bt/1","type":"function"},{"doc":"Works like c(Module, []) .","ref":"c.html#c/1","title":"c.c/1","type":"function"},{"doc":"Compiles and then purges and loads the code for a module. Module can be either a module name or a source file path, with or without .erl extension. If Module is a string, it is assumed to be a source file path, and the compiler will attempt to compile the source file with the options Options . If compilation fails, the old object file (if any) is deleted. If Module is an atom, a source file with that exact name or with .erl extension will be looked for. If found, the source file is compiled with the options Options . If compilation fails, the old object file (if any) is deleted. If Module is an atom and is not the path of a source file, then the code path is searched to locate the object file for the module and extract its original compiler options and source path. If the source file is not found in the original location, filelib:find_source/1 is used to search for it relative to the directory of the object file. The source file is compiled with the the original options appended to the given Options , the output replacing the old object file if and only if compilation succeeds. Notice that purging the code means that any processes lingering in old code for the module are killed without warning. For more information, see the code module.","ref":"c.html#c/2","title":"c.c/2","type":"function"},{"doc":"Compiles and then purges and loads the code for module Module , which must be an atom. The code path is searched to locate the object file for module Module and extract its original compiler options and source path. If the source file is not found in the original location, filelib:find_source/1 is used to search for it relative to the directory of the object file. The source file is compiled with the the original options appended to the given Options , the output replacing the old object file if and only if compilation succeeds. The function Filter specifies which elements to remove from the original compiler options before the new options are added. The Filter fun should return true for options to keep, and false for options to remove. Notice that purging the code means that any processes lingering in old code for the module are killed without warning. For more information, see the code module.","ref":"c.html#c/3","title":"c.c/3","type":"function"},{"doc":"Changes working directory to Dir , which can be a relative name, and then prints the name of the new working directory. Example: 2 &gt; cd ( &quot;../erlang&quot; ) . / home / ron / erlang","ref":"c.html#cd/1","title":"c.cd/1","type":"function"},{"doc":"Search PathList and load .erlang resource file if found.","ref":"c.html#erlangrc/1","title":"c.erlangrc/1","type":"function"},{"doc":"Flushes any messages sent to the shell.","ref":"c.html#flush/0","title":"c.flush/0","type":"function"},{"doc":"Print the documentation for Module","ref":"c.html#h/1","title":"c.h/1","type":"function"},{"doc":"Print the documentation for all Module:Function s (regardless of arity).","ref":"c.html#h/2","title":"c.h/2","type":"function"},{"doc":"Print the documentation for Module:Function/Arity .","ref":"c.html#h/3","title":"c.h/3","type":"function"},{"doc":"Displays help information: all valid shell internal commands, and commands in this module.","ref":"c.html#help/0","title":"c.help/0","type":"function"},{"doc":"Print the type documentation for Module","ref":"c.html#ht/1","title":"c.ht/1","type":"function"},{"doc":"Print the type documentation for Type in Module regardless of arity.","ref":"c.html#ht/2","title":"c.ht/2","type":"function"},{"doc":"Print the type documentation for Type/Arity in Module .","ref":"c.html#ht/3","title":"c.ht/3","type":"function"},{"doc":"i/0 displays system information, listing information about all processes. ni/0 does the same, but for all nodes the network.","ref":"c.html#i/0","title":"c.i/0","type":"function"},{"doc":"Displays information about a process, Equivalent to process_info(pid(X, Y, Z)) , but location transparent.","ref":"c.html#i/3","title":"c.i/3","type":"function"},{"doc":"Purges and loads, or reloads, a module by calling code:purge(Module) followed by code:load_file(Module) . Notice that purging the code means that any processes lingering in old code for the module are killed without warning. For more information, see code/3 .","ref":"c.html#l/1","title":"c.l/1","type":"function"},{"doc":"Files = [File] File Compiles a list of files by calling compile:file(File, [report_errors, report_warnings]) for each File in Files . For information about File , see file:filename() .","ref":"c.html#lc/1","title":"c.lc/1","type":"function"},{"doc":"Reloads all currently loaded modules that have changed on disk (see mm() ). Returns the list of results from calling l(M) for each such M .","ref":"c.html#lm/0","title":"c.lm/0","type":"function"},{"doc":"Lists files in the current directory.","ref":"c.html#ls/0","title":"c.ls/0","type":"function"},{"doc":"Lists files in directory Dir or, if Dir is a file, only lists it.","ref":"c.html#ls/1","title":"c.ls/1","type":"function"},{"doc":"Displays information about the loaded modules, including the files from which they have been loaded.","ref":"c.html#m/0","title":"c.m/0","type":"function"},{"doc":"Displays information about Module .","ref":"c.html#m/1","title":"c.m/1","type":"function"},{"doc":"Memory allocation information. Equivalent to erlang:memory/0 .","ref":"c.html#memory/0","title":"c.memory/0","type":"function"},{"doc":"Memory allocation information. Equivalent to erlang:memory/1 .","ref":"c.html#memory/1","title":"c.memory/1","type":"function"},{"doc":"Lists all modified modules. Shorthand for code:modified_modules/0 .","ref":"c.html#mm/0","title":"c.mm/0","type":"function"},{"doc":"Compiles and then loads the code for a file on all nodes. Options defaults to [] . Compilation is equivalent to: compile:file(File, Options ++ [report_errors, report_warnings])","ref":"c.html#nc/1","title":"c.nc/1","type":"function"},{"doc":"","ref":"c.html#nc/2","title":"c.nc/2","type":"function"},{"doc":"","ref":"c.html#ni/0","title":"c.ni/0","type":"function"},{"doc":"Loads Module on all nodes.","ref":"c.html#nl/1","title":"c.nl/1","type":"function"},{"doc":"regs/0 displays information about all registered processes. nregs/0 does the same, but for all nodes in the network.","ref":"c.html#nregs/0","title":"c.nregs/0","type":"function"},{"doc":"Converts X , Y , Z to pid &lt;X.Y.Z&gt; . This function is only to be used when debugging.","ref":"c.html#pid/3","title":"c.pid/3","type":"function"},{"doc":"Prints the name of the working directory.","ref":"c.html#pwd/0","title":"c.pwd/0","type":"function"},{"doc":"This function is shorthand for init:stop() , that is, it causes the node to stop in a controlled fashion.","ref":"c.html#q/0","title":"c.q/0","type":"function"},{"doc":"","ref":"c.html#regs/0","title":"c.regs/0","type":"function"},{"doc":"Prints the node uptime (as specified by erlang:statistics(wall_clock) ) in human-readable form.","ref":"c.html#uptime/0","title":"c.uptime/0","type":"function"},{"doc":"ModSpec = Module | Filename  Module = atom()  Filename = string() Finds undefined functions, unused functions, and calls to deprecated functions in a module by calling xref:m/1 .","ref":"c.html#xm/1","title":"c.xm/1","type":"function"},{"doc":"File = name() YeccRet Generates an LALR-1 parser. Equivalent to: yecc:file(File) For information about File = name() , see filename(3) . For information about YeccRet , see yecc:file/2 .","ref":"c.html#y/1","title":"c.y/1","type":"function"},{"doc":"File = name() Options, YeccRet Generates an LALR-1 parser. Equivalent to: yecc:file(File, Options) For information about File = name() , see filename(3) . For information about Options and YeccRet , see yecc:file/2 .","ref":"c.html#y/2","title":"c.y/2","type":"function"},{"doc":"This module provides computation of local and universal time, day of the week, and many time conversion functions. Time is local when it is adjusted in accordance with the current time zone and daylight saving. Time is universal when it reflects the time at longitude zero, without any adjustment for daylight saving. Universal Coordinated Time (UTC) time is also called Greenwich Mean Time (GMT). The time functions local_time/0 and universal_time/0 in this module both return date and time. This is because separate functions for date and time can result in a date/time combination that is displaced by 24 hours. This occurs if one of the functions is called before midnight, and the other after midnight. This problem also applies to the Erlang BIFs date/0 and time/0 , and their use is strongly discouraged if a reliable date/time stamp is required. All dates conform to the Gregorian calendar. This calendar was introduced by Pope Gregory XIII in 1582 and was used in all Catholic countries from this year. Protestant parts of Germany and the Netherlands adopted it in 1698, England followed in 1752, and Russia in 1918 (the October revolution of 1917 took place in November according to the Gregorian calendar). The Gregorian calendar in this module is extended back to year 0. For a given date, the gregorian days is the number of days up to and including the date specified. Similarly, the gregorian seconds for a specified date and time is the number of seconds up to and including the specified date and time. For computing differences between epochs in time, use the functions counting gregorian days or seconds. If epochs are specified as local time, they must be converted to universal time to get the correct value of the elapsed time between epochs. Use of function time_difference/2 is discouraged. Different definitions exist for the week of the year. This module contains a week of the year implementation conforming to the ISO 8601 standard. As the week number for a specified date can fall on the previous, the current, or on the next year, it is important to specify both the year and the week number. Functions iso_week_number/0 and iso_week_number/1 return a tuple of the year and the week number. Leap Years The notion that every fourth year is a leap year is not completely true. By the Gregorian rule, a year Y is a leap year if one of the following rules is valid: Y is divisible by 4, but not by 100. Y is divisible by 400. Hence, 1996 is a leap year, 1900 is not, but 2000 is. Date and Time Source Local time is obtained from the Erlang BIF localtime/0 . Universal time is computed from the BIF universaltime/0 . The following apply: There are 86400 seconds in a day. There are 365 days in an ordinary year. There are 366 days in a leap year. There are 1461 days in a 4 year period. There are 36524 days in a 100 year period. There are 146097 days in a 400 year period. There are 719528 days between Jan 1, 0 and Jan 1, 1970.","ref":"calendar.html","title":"calendar","type":"module"},{"doc":"Computes the number of gregorian days starting with year 0 and ending at the specified date.","ref":"calendar.html#date_to_gregorian_days/1","title":"calendar.date_to_gregorian_days/1","type":"function"},{"doc":"","ref":"calendar.html#date_to_gregorian_days/3","title":"calendar.date_to_gregorian_days/3","type":"function"},{"doc":"Computes the number of gregorian seconds starting with year 0 and ending at the specified date and time.","ref":"calendar.html#datetime_to_gregorian_seconds/1","title":"calendar.datetime_to_gregorian_seconds/1","type":"function"},{"doc":"Computes the day of the week from the specified Year , Month , and Day . Returns the day of the week as 1 : Monday, 2 : Tuesday, and so on.","ref":"calendar.html#day_of_the_week/1","title":"calendar.day_of_the_week/1","type":"function"},{"doc":"","ref":"calendar.html#day_of_the_week/3","title":"calendar.day_of_the_week/3","type":"function"},{"doc":"Computes the date from the specified number of gregorian days.","ref":"calendar.html#gregorian_days_to_date/1","title":"calendar.gregorian_days_to_date/1","type":"function"},{"doc":"Computes the date and time from the specified number of gregorian seconds.","ref":"calendar.html#gregorian_seconds_to_datetime/1","title":"calendar.gregorian_seconds_to_datetime/1","type":"function"},{"doc":"Checks if the specified year is a leap year.","ref":"calendar.html#is_leap_year/1","title":"calendar.is_leap_year/1","type":"function"},{"doc":"Returns tuple {Year, WeekNum} representing the ISO week number for the actual date. To determine the actual date, use function local_time/0 .","ref":"calendar.html#iso_week_number/0","title":"calendar.iso_week_number/0","type":"function"},{"doc":"Returns tuple {Year, WeekNum} representing the ISO week number for the specified date.","ref":"calendar.html#iso_week_number/1","title":"calendar.iso_week_number/1","type":"function"},{"doc":"Computes the number of days in a month.","ref":"calendar.html#last_day_of_the_month/2","title":"calendar.last_day_of_the_month/2","type":"function"},{"doc":"Returns the local time reported by the underlying operating system.","ref":"calendar.html#local_time/0","title":"calendar.local_time/0","type":"function"},{"doc":"Converts from local time to Universal Coordinated Time (UTC). DateTime1 must refer to a local date after Jan 1, 1970. This function is deprecated. Use local_time_to_universal_time_dst/1 instead, as it gives a more correct and complete result. Especially for the period that does not exist, as it is skipped during the switch to daylight saving time, this function still returns a result.","ref":"calendar.html#local_time_to_universal_time/1","title":"calendar.local_time_to_universal_time/1","type":"function"},{"doc":"Converts from local time to Universal Coordinated Time (UTC). DateTime1 must refer to a local date after Jan 1, 1970. The return value is a list of 0, 1, or 2 possible UTC times: [] For a local {Date1, Time1} during the period that is skipped when switching to daylight saving time, there is no corresponding UTC, as the local time is illegal (it has never occured). [DstDateTimeUTC, DateTimeUTC] For a local {Date1, Time1} during the period that is repeated when switching from daylight saving time, two corresponding UTCs exist; one for the first instance of the period when daylight saving time is still active, and one for the second instance. [DateTimeUTC] For all other local times only one corresponding UTC exists.","ref":"calendar.html#local_time_to_universal_time_dst/1","title":"calendar.local_time_to_universal_time_dst/1","type":"function"},{"doc":"Returns Universal Coordinated Time (UTC) converted from the return value from erlang:timestamp/0 .","ref":"calendar.html#now_to_datetime/1","title":"calendar.now_to_datetime/1","type":"function"},{"doc":"Returns local date and time converted from the return value from erlang:timestamp/0 .","ref":"calendar.html#now_to_local_time/1","title":"calendar.now_to_local_time/1","type":"function"},{"doc":"Returns Universal Coordinated Time (UTC) converted from the return value from erlang:timestamp/0 .","ref":"calendar.html#now_to_universal_time/1","title":"calendar.now_to_universal_time/1","type":"function"},{"doc":"Converts an RFC 3339 timestamp into system time. The data format of RFC 3339 timestamps is described by RFC 3339 . Valid option: {unit, Unit} The time unit of the return value. The default is second . 1 &gt; calendar : rfc3339_to_system_time ( &quot;2018-02-01T16:17:58+01:00&quot; ) . 1517498278 2 &gt; calendar : rfc3339_to_system_time ( &quot;2018-02-01 15:18:02.088Z&quot; , [ { unit , nanosecond } ] ) . 1517498282088000000","ref":"calendar.html#rfc3339_to_system_time/1","title":"calendar.rfc3339_to_system_time/1","type":"function"},{"doc":"","ref":"calendar.html#rfc3339_to_system_time/2","title":"calendar.rfc3339_to_system_time/2","type":"function"},{"doc":"Converts a specified number of seconds into days, hours, minutes, and seconds. Time is always non-negative, but Days is negative if argument Seconds is.","ref":"calendar.html#seconds_to_daystime/1","title":"calendar.seconds_to_daystime/1","type":"function"},{"doc":"Computes the time from the specified number of seconds. Seconds must be less than the number of seconds per day (86400).","ref":"calendar.html#seconds_to_time/1","title":"calendar.seconds_to_time/1","type":"function"},{"doc":"Converts a specified system time into local date and time.","ref":"calendar.html#system_time_to_local_time/2","title":"calendar.system_time_to_local_time/2","type":"function"},{"doc":"Converts a system time into an RFC 3339 timestamp. The data format of RFC 3339 timestamps is described by RFC 3339 . The data format of offsets is also described by RFC 3339. Valid options: {offset, Offset} The offset, either a string or an integer, to be included in the formatted string. An empty string, which is the default, is interpreted as local time. A non-empty string is included as is. The time unit of the integer is the same as the one of Time . {time_designator, Character} The character used as time designator, that is, the date and time separator. The default is $T . {unit, Unit} The time unit of Time . The default is second . If some other unit is given ( millisecond , microsecond , or nanosecond ), the formatted string includes a fraction of a second. The number of fractional second digits is three, six, or nine depending on what time unit is chosen. Notice that trailing zeros are not removed from the fraction. 1 &gt; calendar : system_time_to_rfc3339 ( erlang : system_time ( second ) ) . &quot;2018-04-23T14:56:28+02:00&quot; 2 &gt; calendar : system_time_to_rfc3339 ( erlang : system_time ( second ) , [ { offset , &quot;-02:00&quot; } ] ) . &quot;2018-04-23T10:56:52-02:00&quot; 3 &gt; calendar : system_time_to_rfc3339 ( erlang : system_time ( second ) , [ { offset , - 7200 } ] ) . &quot;2018-04-23T10:57:05-02:00&quot; 4 &gt; calendar : system_time_to_rfc3339 ( erlang : system_time ( millisecond ) , [ { unit , millisecond } , { time_designator , $\\ s } , { offset , &quot;Z&quot; } ] ) . &quot;2018-04-23 12:57:20.482Z&quot;","ref":"calendar.html#system_time_to_rfc3339/1","title":"calendar.system_time_to_rfc3339/1","type":"function"},{"doc":"","ref":"calendar.html#system_time_to_rfc3339/2","title":"calendar.system_time_to_rfc3339/2","type":"function"},{"doc":"Converts a specified system time into universal date and time.","ref":"calendar.html#system_time_to_universal_time/2","title":"calendar.system_time_to_universal_time/2","type":"function"},{"doc":"Returns the difference between two {Date, Time} tuples. T2 is to refer to an epoch later than T1 . This function is obsolete. Use the conversion functions for gregorian days and seconds instead.","ref":"calendar.html#time_difference/2","title":"calendar.time_difference/2","type":"function"},{"doc":"Returns the number of seconds since midnight up to the specified time.","ref":"calendar.html#time_to_seconds/1","title":"calendar.time_to_seconds/1","type":"function"},{"doc":"Returns the Universal Coordinated Time (UTC) reported by the underlying operating system. Returns local time if universal time is unavailable.","ref":"calendar.html#universal_time/0","title":"calendar.universal_time/0","type":"function"},{"doc":"Converts from Universal Coordinated Time (UTC) to local time. DateTime must refer to a date after Jan 1, 1970.","ref":"calendar.html#universal_time_to_local_time/1","title":"calendar.universal_time_to_local_time/1","type":"function"},{"doc":"This function checks if a date is a valid.","ref":"calendar.html#valid_date/1","title":"calendar.valid_date/1","type":"function"},{"doc":"","ref":"calendar.html#valid_date/3","title":"calendar.valid_date/3","type":"function"},{"doc":"","ref":"calendar.html#t:date/0","title":"calendar.date/0","type":"type"},{"doc":"","ref":"calendar.html#t:datetime/0","title":"calendar.datetime/0","type":"type"},{"doc":"","ref":"calendar.html#t:datetime1970/0","title":"calendar.datetime1970/0","type":"type"},{"doc":"","ref":"calendar.html#t:day/0","title":"calendar.day/0","type":"type"},{"doc":"","ref":"calendar.html#t:daynum/0","title":"calendar.daynum/0","type":"type"},{"doc":"","ref":"calendar.html#t:hour/0","title":"calendar.hour/0","type":"type"},{"doc":"","ref":"calendar.html#t:ldom/0","title":"calendar.ldom/0","type":"type"},{"doc":"","ref":"calendar.html#t:minute/0","title":"calendar.minute/0","type":"type"},{"doc":"","ref":"calendar.html#t:month/0","title":"calendar.month/0","type":"type"},{"doc":"","ref":"calendar.html#t:second/0","title":"calendar.second/0","type":"type"},{"doc":"","ref":"calendar.html#t:time/0","title":"calendar.time/0","type":"type"},{"doc":"","ref":"calendar.html#t:weeknum/0","title":"calendar.weeknum/0","type":"type"},{"doc":"Year cannot be abbreviated. For example, 93 denotes year 93, not 1993. The valid range depends on the underlying operating system. The date tuple must denote a valid date.","ref":"calendar.html#t:year/0","title":"calendar.year/0","type":"type"},{"doc":"","ref":"calendar.html#t:year1970/0","title":"calendar.year1970/0","type":"type"},{"doc":"","ref":"calendar.html#t:yearweeknum/0","title":"calendar.yearweeknum/0","type":"type"},{"doc":"This module provides a term storage on file. The stored terms, in this module called objects , are tuples such that one element is defined to be the key. A Dets table is a collection of objects with the key at the same position stored on a file. This module is used by the Mnesia application, and is provided &quot;as is&quot; for users who are interested in efficient storage of Erlang terms on disk only. Many applications only need to store some terms in a file. Mnesia adds transactions, queries, and distribution. The size of Dets files cannot exceed 2 GB. If larger tables are needed, table fragmentation in Mnesia can be used. Three types of Dets tables exist: set . A table of this type has at most one object with a given key. If an object with a key already present in the table is inserted, the existing object is overwritten by the new object. bag . A table of this type has zero or more different objects with a given key. duplicate_bag . A table of this type has zero or more possibly matching objects with a given key. Dets tables must be opened before they can be updated or read, and when finished they must be properly closed. If a table is not properly closed, Dets automatically repairs the table. This can take a substantial time if the table is large. A Dets table is closed when the process which opened the table terminates. If many Erlang processes (users) open the same Dets table, they share the table. The table is properly closed when all users have either terminated or closed the table. Dets tables are not properly closed if the Erlang runtime system terminates abnormally. A ^C command abnormally terminates an Erlang runtime system in a Unix environment with a break-handler. As all operations performed by Dets are disk operations, it is important to realize that a single look-up operation involves a series of disk seek and read operations. The Dets functions are therefore much slower than the corresponding ets(3) functions, although Dets exports a similar interface. Dets organizes data as a linear hash list and the hash list grows gracefully as more data is inserted into the table. Space management on the file is performed by what is called a buddy system. The current implementation keeps the entire buddy system in RAM, which implies that if the table gets heavily fragmented, quite some memory can be used up. The only way to defragment a table is to close it and then open it again with option repair set to force . Notice that type ordered_set in Ets is not yet provided by Dets, neither is the limited support for concurrent updates that makes a sequence of first and next calls safe to use on fixed ETS tables. Both these features may be provided by Dets in a future release of Erlang/OTP. Until then, the Mnesia application (or some user-implemented method for locking) must be used to implement safe concurrency. Currently, no Erlang/OTP library has support for ordered disk-based term storage. All Dets functions return {error, Reason} if an error occurs ( first/1 and next/2 are exceptions, they exit the process with the error tuple). If badly formed arguments are specified, all functions exit the process with a badarg message. See Also ets(3) , mnesia(3) , qlc(3)","ref":"dets.html","title":"dets","type":"module"},{"doc":"Returns a list of the names of all open tables on this node.","ref":"dets.html#all/0","title":"dets.all/0","type":"function"},{"doc":"Returns a list of objects stored in a table. The exact representation of the returned objects is not public. The lists of data can be used for initializing a table by specifying value bchunk to option format of function init_table/3 The Mnesia application uses this function for copying open tables. Unless the table is protected using safe_fixtable/2 , calls to bchunk/2 do possibly not work as expected if concurrent updates are made to the table. The first time bchunk/2 is called, an initial continuation, the atom start , must be provided. bchunk/2 returns a tuple {Continuation2, Data} , where Data is a list of objects. Continuation2 is another continuation that is to be passed on to a subsequent call to bchunk/2 . With a series of calls to bchunk/2 , all table objects can be extracted. bchunk/2 returns '$end_of_table' when all objects are returned, or {error, Reason} if an error occurs.","ref":"dets.html#bchunk/2","title":"dets.bchunk/2","type":"function"},{"doc":"Closes a table. Only processes that have opened a table are allowed to close it. All open tables must be closed before the system is stopped. If an attempt is made to open a table that is not properly closed, Dets automatically tries to repair it.","ref":"dets.html#close/1","title":"dets.close/1","type":"function"},{"doc":"Deletes all objects with key Key from table Name .","ref":"dets.html#delete/2","title":"dets.delete/2","type":"function"},{"doc":"Deletes all objects from a table in almost constant time. However, if the table if fixed, delete_all_objects(T) is equivalent to match_delete(T, '_') .","ref":"dets.html#delete_all_objects/1","title":"dets.delete_all_objects/1","type":"function"},{"doc":"Deletes all instances of a specified object from a table. If a table is of type bag or duplicate_bag , this function can be used to delete only some of the objects with a specified key.","ref":"dets.html#delete_object/2","title":"dets.delete_object/2","type":"function"},{"doc":"Returns the first key stored in table Name according to the internal order of the table, or '$end_of_table' if the table is empty. Unless the table is protected using safe_fixtable/2 , subsequent calls to next/2 do possibly not work as expected if concurrent updates are made to the table. If an error occurs, the process is exited with an error tuple {error, Reason} . The error tuple is not returned, as it cannot be distinguished from a key. There are two reasons why first/1 and next/2 are not to be used: they are not efficient, and they prevent the use of key '$end_of_table' , as this atom is used to indicate the end of the table. If possible, use functions match , match_object , and select for traversing tables.","ref":"dets.html#first/1","title":"dets.first/1","type":"function"},{"doc":"Calls Function on successive elements of table Name together with an extra argument AccIn . The table elements are traversed in unspecified order. Function must return a new accumulator that is passed to the next call. Acc0 is returned if the table is empty.","ref":"dets.html#foldl/3","title":"dets.foldl/3","type":"function"},{"doc":"","ref":"dets.html#foldr/3","title":"dets.foldr/3","type":"function"},{"doc":"Deletes all objects of table Name and then inserts all the objects of the ETS table EtsTab . The objects are inserted in unspecified order. As ets:safe_fixtable/2 is called, the ETS table must be public or owned by the calling process.","ref":"dets.html#from_ets/2","title":"dets.from_ets/2","type":"function"},{"doc":"Returns information about table Name as a list of tuples: {file_size, integer() &gt;= 0}} - The file size, in bytes. {filename, file:name() } - The name of the file where objects are stored. {keypos, keypos() } - The key position. {size, integer() &gt;= 0} - The number of objects stored in the table. {type, type() } - The table type.","ref":"dets.html#info/1","title":"dets.info/1","type":"function"},{"doc":"Returns the information associated with Item for table Name . In addition to the {Item, Value} pairs defined for info/1 , the following items are allowed: {access, access() } - The access mode. {auto_save, auto_save() } - The autosave interval. {bchunk_format, binary()} - An opaque binary describing the format of the objects returned by bchunk/2 . The binary can be used as argument to is_compatible_chunk_format/2 . {hash, Hash} - Describes which BIF is used to calculate the hash values of the objects stored in the Dets table. Possible values of Hash : phash - Implies that the erlang:phash/2 BIF is used. phash2 - Implies that the erlang:phash2/1 BIF is used. {memory, integer() &gt;= 0} - The file size, in bytes. The same value is associated with item file_size . {no_keys, integer &gt;= 0()} - The number of different keys stored in the table. {no_objects, integer &gt;= 0()} - The number of objects stored in the table. {no_slots, {Min, Used, Max}} - The number of slots of the table. Min is the minimum number of slots, Used is the number of currently used slots, and Max is the maximum number of slots. {owner, pid()} - The pid of the process that handles requests to the Dets table. {ram_file, boolean()} - Whether the table is kept in RAM. {safe_fixed_monotonic_time, SafeFixed} - If the table is fixed, SafeFixed is a tuple {FixedAtTime, [{Pid,RefCount}]} . FixedAtTime is the time when the table was first fixed, and Pid is the pid of the process that fixes the table RefCount times. There can be any number of processes in the list. If the table is not fixed, SafeFixed is the atom false . FixedAtTime corresponds to the result returned by erlang:monotonic_time/0 at the time of fixation. The use of safe_fixed_monotonic_time is time warp safe. {safe_fixed, SafeFixed} - The same as {safe_fixed_monotonic_time, SafeFixed} except the format and value of FixedAtTime . FixedAtTime corresponds to the result returned by erlang:timestamp/0 at the time of fixation. Notice that when the system uses single or multi time warp modes, this can produce strange results. This is because the use of safe_fixed is not time warp safe. Time warp safe code must use safe_fixed_monotonic_time instead.","ref":"dets.html#info/2","title":"dets.info/2","type":"function"},{"doc":"Replaces the existing objects of table Name with objects created by calling the input function InitFun , see below. The reason for using this function rather than calling insert/2 is that of efficiency. Notice that the input functions are called by the process that handles requests to the Dets table, not by the calling process. When called with argument read , function InitFun is assumed to return end_of_input when there is no more input, or {Objects, Fun} , where Objects is a list of objects and Fun is a new input function. Any other value Value is returned as an error {error, {init_fun, Value}} . Each input function is called exactly once, and if an error occurs, the last function is called with argument close , the reply of which is ignored. If the table type is set and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. Avoid duplicate keys, otherwise the file becomes unnecessarily fragmented. This holds also for duplicated objects stored in tables of type bag . It is important that the table has a sufficient number of slots for the objects. If not, the hash list starts to grow when init_table/2 returns, which significantly slows down access to the table for a period of time. The minimum number of slots is set by the open_file/2 option min_no_slots and returned by the info/2 item no_slots . See also option min_no_slots below. Argument Options is a list of {Key, Val} tuples, where the following values are allowed: {min_no_slots, no_slots()} - Specifies the estimated number of different keys to be stored in the table. The open_file/2 option with the same name is ignored, unless the table is created, in which case performance can be enhanced by supplying an estimate when initializing the table. {format, Format} - Specifies the format of the objects returned by function InitFun . If Format is term (the default), InitFun is assumed to return a list of tuples. If Format is bchunk , InitFun is assumed to return Data as returned by bchunk/2 . This option overrides option min_no_slots .","ref":"dets.html#init_table/2","title":"dets.init_table/2","type":"function"},{"doc":"","ref":"dets.html#init_table/3","title":"dets.init_table/3","type":"function"},{"doc":"Inserts one or more objects into the table Name . If there already exists an object with a key matching the key of some of the given objects and the table type is set , the old object will be replaced.","ref":"dets.html#insert/2","title":"dets.insert/2","type":"function"},{"doc":"Inserts one or more objects into table Name . If there already exists some object with a key matching the key of any of the specified objects, the table is not updated and false is returned. Otherwise the objects are inserted and true returned.","ref":"dets.html#insert_new/2","title":"dets.insert_new/2","type":"function"},{"doc":"Returns true if it would be possible to initialize table Name , using init_table/3 with option {format, bchunk} , with objects read with bchunk/2 from some table T , such that calling info(T, bchunk_format) returns BchunkFormat .","ref":"dets.html#is_compatible_bchunk_format/2","title":"dets.is_compatible_bchunk_format/2","type":"function"},{"doc":"Returns true if file Filename is a Dets table, otherwise false .","ref":"dets.html#is_dets_file/1","title":"dets.is_dets_file/1","type":"function"},{"doc":"Returns a list of all objects with key Key stored in table Name , for example: 2 &gt; dets : open_file ( abc , [ { type , bag } ] ) . { ok , abc } 3 &gt; dets : insert ( abc , { 1 , 2 , 3 } ) . ok 4 &gt; dets : insert ( abc , { 1 , 3 , 4 } ) . ok 5 &gt; dets : lookup ( abc , 1 ) . [ { 1 , 2 , 3 } , { 1 , 3 , 4 } ] If the table type is set , the function returns either the empty list or a list with one object, as there cannot be more than one object with a given key. If the table type is bag or duplicate_bag , the function returns a list of arbitrary length. Notice that the order of objects returned is unspecified. In particular, the order in which objects were inserted is not reflected.","ref":"dets.html#lookup/2","title":"dets.lookup/2","type":"function"},{"doc":"Matches some objects stored in a table and returns a non-empty list of the bindings matching a specified pattern in some unspecified order. The table, the pattern, and the number of objects that are matched are all defined by Continuation , which has been returned by a previous call to match/1 or match/3 . When all table objects are matched, '$end_of_table' is returned.","ref":"dets.html#match/1","title":"dets.match/1","type":"function"},{"doc":"Returns for each object of table Name that matches Pattern a list of bindings in some unspecified order. For a description of patterns, see ets:match/2 . If the keypos'th element of Pattern is unbound, all table objects are matched. If the keypos'th element is bound, only the objects with the correct key are matched.","ref":"dets.html#match/2","title":"dets.match/2","type":"function"},{"doc":"Matches some or all objects of table Name and returns a non-empty list of the bindings that match Pattern in some unspecified order. For a description of patterns, see ets:match/2 . A tuple of the bindings and a continuation is returned, unless the table is empty, in which case '$end_of_table' is returned. The continuation is to be used when matching further objects by calling match/1 . If the keypos'th element of Pattern is bound, all table objects are matched. If the keypos'th element is unbound, all table objects are matched, N objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving N the value default , is to let the number of objects vary depending on the sizes of the objects. All objects with the same key are always matched at the same time, which implies that more than N objects can sometimes be matched. The table is always to be protected using safe_fixtable/2 before calling match/3 , otherwise errors can occur when calling match/1 .","ref":"dets.html#match/3","title":"dets.match/3","type":"function"},{"doc":"Deletes all objects that match Pattern from table Name . For a description of patterns, see ets:match/2 . If the keypos'th element of Pattern is bound, only the objects with the correct key are matched.","ref":"dets.html#match_delete/2","title":"dets.match_delete/2","type":"function"},{"doc":"Returns a non-empty list of some objects stored in a table that match a given pattern in some unspecified order. The table, the pattern, and the number of objects that are matched are all defined by Continuation , which has been returned by a previous call to match_object/1 or match_object/3 . When all table objects are matched, '$end_of_table' is returned.","ref":"dets.html#match_object/1","title":"dets.match_object/1","type":"function"},{"doc":"Returns a list of all objects of table Name that match Pattern in some unspecified order. For a description of patterns, see ets:match/2 . If the keypos'th element of Pattern is unbound, all table objects are matched. If the keypos'th element of Pattern is bound, only the objects with the correct key are matched. Using the match_object functions for traversing all table objects is more efficient than calling first/1 and next/2 or slot/2 .","ref":"dets.html#match_object/2","title":"dets.match_object/2","type":"function"},{"doc":"Matches some or all objects stored in table Name and returns a non-empty list of the objects that match Pattern in some unspecified order. For a description of patterns, see ets:match/2 . A list of objects and a continuation is returned, unless the table is empty, in which case '$end_of_table' is returned. The continuation is to be used when matching further objects by calling match_object/1 . If the keypos'th element of Pattern is bound, all table objects are matched. If the keypos'th element is unbound, all table objects are matched, N objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving N the value default , is to let the number of objects vary depending on the sizes of the objects. All matching objects with the same key are always returned in the same reply, which implies that more than N objects can sometimes be returned. The table is always to be protected using safe_fixtable/2 before calling match_object/3 , otherwise errors can occur when calling match_object/1 .","ref":"dets.html#match_object/3","title":"dets.match_object/3","type":"function"},{"doc":"Works like lookup/2 , but does not return the objects. Returns true if one or more table elements has key Key , otherwise false .","ref":"dets.html#member/2","title":"dets.member/2","type":"function"},{"doc":"Returns either the key following Key1 in table Name according to the internal order of the table, or '$end_of_table' if there is no next key. If an error occurs, the process is exited with an error tuple {error, Reason} . To find the first key in the table, use first/1 .","ref":"dets.html#next/2","title":"dets.next/2","type":"function"},{"doc":"Opens an existing table. If the table is not properly closed, it is repaired. The returned reference is to be used as the table name. This function is most useful for debugging purposes.","ref":"dets.html#open_file/1","title":"dets.open_file/1","type":"function"},{"doc":"Opens a table. An empty Dets table is created if no file exists. The atom Name is the table name. The table name must be provided in all subsequent operations on the table. The name can be used by other processes as well, and many processes can share one table. If two processes open the same table by giving the same name and arguments, the table has two users. If one user closes the table, it remains open until the second user closes it. Argument Args is a list of {Key, Val} tuples, where the following values are allowed: {access, access() } - Existing tables can be opened in read-only mode. A table that is opened in read-only mode is not subjected to the automatic file reparation algorithm if it is later opened after a crash. Defaults to read_write . {auto_save, auto_save() } - The autosave interval. If the interval is an integer Time , the table is flushed to disk whenever it is not accessed for Time milliseconds. A table that has been flushed requires no reparation when reopened after an uncontrolled emulator halt. If the interval is the atom infinity , autosave is disabled. Defaults to 180000 (3 minutes). {estimated_no_objects, no_slots() } - Equivalent to option min_no_slots . {file, file:name() } - The name of the file to be opened. Defaults to the table name. {max_no_slots, no_slots() } - The maximum number of slots to be used. Defaults to 32 M, which is the maximal value. Notice that a higher value can increase the table fragmentation, and a smaller value can decrease the fragmentation, at the expense of execution time. {min_no_slots, no_slots() } - Application performance can be enhanced with this flag by specifying, when the table is created, the estimated number of different keys to be stored in the table. Defaults to 256, which is the minimum value. {keypos, keypos() } - The position of the element of each object to be used as key. Defaults to 1. The ability to explicitly state the key position is most convenient when we want to store Erlang records in which the first position of the record is the name of the record type. {ram_file, boolean()} - Whether the table is to be kept in RAM. Keeping the table in RAM can sound like an anomaly, but can enhance the performance of applications that open a table, insert a set of objects, and then close the table. When the table is closed, its contents are written to the disk file. Defaults to false . {repair, Value} - Value can be either a boolean() or the atom force . The flag specifies if the Dets server is to invoke the automatic file reparation algorithm. Defaults to true . If false is specified, no attempt is made to repair the file, and {error, {needs_repair, FileName}} is returned if the table must be repaired. Value force means that a reparation is made even if the table is properly closed. This is a seldom needed option. Option repair is ignored if the table is already open. {type, type() } - The table type. Defaults to set .","ref":"dets.html#open_file/2","title":"dets.open_file/2","type":"function"},{"doc":"Returns the table name given the pid of a process that handles requests to a table, or undefined if there is no such table. This function is meant to be used for debugging only.","ref":"dets.html#pid2name/1","title":"dets.pid2name/1","type":"function"},{"doc":"This function can be used to restore an opaque continuation returned by select/3 or select/1 if the continuation has passed through external term format (been sent between nodes or stored on disk). The reason for this function is that continuation terms contain compiled match specifications and therefore are invalidated if converted to external term format. Given that the original match specification is kept intact, the continuation can be restored, meaning it can once again be used in subsequent select/1 calls even though it has been stored on disk or on another node. For more information and examples, see the ets(3) module. This function is rarely needed in application code. It is used by application Mnesia to provide distributed select/3 and select/1 sequences. A normal application would either use Mnesia or keep the continuation from being converted to external format. The reason for not having an external representation of compiled match specifications is performance. It can be subject to change in future releases, while this interface remains for backward compatibility.","ref":"dets.html#repair_continuation/2","title":"dets.repair_continuation/2","type":"function"},{"doc":"If Fix is true , table Name is fixed (once more) by the calling process, otherwise the table is released. The table is also released when a fixing process terminates. If many processes fix a table, the table remains fixed until all processes have released it or terminated. A reference counter is kept on a per process basis, and N consecutive fixes require N releases to release the table. It is not guaranteed that calls to first/1 , next/2 , or select and match functions work as expected even if the table is fixed; the limited support for concurrency provided by the ets(3) module is not yet provided by Dets. Fixing a table currently only disables resizing of the hash list of the table. If objects have been added while the table was fixed, the hash list starts to grow when the table is released, which significantly slows down access to the table for a period of time.","ref":"dets.html#safe_fixtable/2","title":"dets.safe_fixtable/2","type":"function"},{"doc":"Applies a match specification to some objects stored in a table and returns a non-empty list of the results. The table, the match specification, and the number of objects that are matched are all defined by Continuation , which is returned by a previous call to select/1 or select/3 . When all objects of the table have been matched, '$end_of_table' is returned.","ref":"dets.html#select/1","title":"dets.select/1","type":"function"},{"doc":"Returns the results of applying match specification MatchSpec to all or some objects stored in table Name . The order of the objects is not specified. For a description of match specifications, see the ERTS User's Guide. If the keypos'th element of MatchSpec is unbound, the match specification is applied to all objects of the table. If the keypos'th element is bound, the match specification is applied to the objects with the correct key(s) only. Using the select functions for traversing all objects of a table is more efficient than calling first/1 and next/2 or slot/2 .","ref":"dets.html#select/2","title":"dets.select/2","type":"function"},{"doc":"Returns the results of applying match specification MatchSpec to some or all objects stored in table Name . The order of the objects is not specified. For a description of match specifications, see the ERTS User's Guide. A tuple of the results of applying the match specification and a continuation is returned, unless the table is empty, in which case '$end_of_table' is returned. The continuation is to be used when matching more objects by calling select/1 . If the keypos'th element of MatchSpec is bound, the match specification is applied to all objects of the table with the correct key(s). If the keypos'th element of MatchSpec is unbound, the match specification is applied to all objects of the table, N objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving N the value default , is to let the number of objects vary depending on the sizes of the objects. All objects with the same key are always handled at the same time, which implies that the match specification can be applied to more than N objects. The table is always to be protected using safe_fixtable/2 before calling select/3 , otherwise errors can occur when calling select/1 .","ref":"dets.html#select/3","title":"dets.select/3","type":"function"},{"doc":"Deletes each object from table Name such that applying match specification MatchSpec to the object returns value true . For a description of match specifications, see the ERTS User's Guide. Returns the number of deleted objects. If the keypos'th element of MatchSpec is bound, the match specification is applied to the objects with the correct key(s) only.","ref":"dets.html#select_delete/2","title":"dets.select_delete/2","type":"function"},{"doc":"The objects of a table are distributed among slots, starting with slot 0 and ending with slot n . Returns the list of objects associated with slot I . If I &gt; n , '$end_of_table' is returned.","ref":"dets.html#slot/2","title":"dets.slot/2","type":"function"},{"doc":"Ensures that all updates made to table Name are written to disk. This also applies to tables that have been opened with flag ram_file set to true . In this case, the contents of the RAM file are flushed to disk. Notice that the space management data structures kept in RAM, the buddy system, is also written to the disk. This can take some time if the table is fragmented.","ref":"dets.html#sync/1","title":"dets.sync/1","type":"function"},{"doc":"Returns a Query List Comprehension (QLC) query handle. The qlc(3) module provides a query language aimed mainly for Mnesia, but ETS tables, Dets tables, and lists are also recognized by qlc as sources of data. Calling dets:table/1,2 is the means to make Dets table Name usable to qlc . When there are only simple restrictions on the key position, qlc uses dets:lookup/2 to look up the keys. When that is not possible, the whole table is traversed. Option traverse determines how this is done: first_next - The table is traversed one key at a time by calling dets:first/1 and dets:next/2 . select - The table is traversed by calling dets:select/3 and dets:select/1 . Option n_objects determines the number of objects returned (the third argument of select/3 ). The match specification (the second argument of select/3 ) is assembled by qlc : Simple filters are translated into equivalent match specifications. More complicated filters must be applied to all objects returned by select/3 given a match specification that matches all objects. {select, match_spec() } - As for select , the table is traversed by calling dets:select/3 and dets:select/1 . The difference is that the match specification is specified explicitly. This is how to state match specifications that cannot easily be expressed within the syntax provided by qlc . The following example uses an explicit match specification to traverse the table: 1 &gt; dets : open_file ( t , [ ] ) , ok = dets : insert ( t , [ { 1 , a } , { 2 , b } , { 3 , c } , { 4 , d } ] ) , MS = ets : fun2ms ( fun ( { X , Y } ) when ( X &gt; 1 ) or ( X &lt; 5 ) -&gt; { Y } end ) , QH1 = dets : table ( t , [ { traverse , { select , MS } } ] ) . An example with implicit match specification: 2 &gt; QH2 = qlc : q ( [ { Y } || { X , Y } &lt;- dets : table ( t ) , ( X &gt; 1 ) or ( X &lt; 5 ) ] ) . The latter example is equivalent to the former, which can be verified using function qlc:info/1 : 3 &gt; qlc : info ( QH1 ) =:= qlc : info ( QH2 ) . true qlc:info/1 returns information about a query handle. In this case identical information is returned for the two query handles.","ref":"dets.html#table/1","title":"dets.table/1","type":"function"},{"doc":"","ref":"dets.html#table/2","title":"dets.table/2","type":"function"},{"doc":"Inserts the objects of the Dets table Name into the ETS table EtsTab . The order in which the objects are inserted is not specified. The existing objects of the ETS table are kept unless overwritten.","ref":"dets.html#to_ets/2","title":"dets.to_ets/2","type":"function"},{"doc":"Applies Fun to each object stored in table Name in some unspecified order. Different actions are taken depending on the return value of Fun . The following Fun return values are allowed: continue Continue to perform the traversal. For example, the following function can be used to print the contents of a table: fun ( X ) -&gt; io : format ( &quot; ~p ~n &quot; , [ X ] ) , continue end . {continue, Val} Continue the traversal and accumulate Val . The following function is supplied to collect all objects of a table in a list: fun ( X ) -&gt; { continue , X } end . {done, Value} Terminate the traversal and return [Value | Acc] . Any other value OtherValue returned by Fun terminates the traversal and is returned immediately.","ref":"dets.html#traverse/2","title":"dets.traverse/2","type":"function"},{"doc":"Updates the object with key Key stored in table Name of type set by adding Incr to the element at the Pos :th position. The new counter value is returned. If no position is specified, the element directly following the key is updated. This functions provides a way of updating a counter, without having to look up an object, update the object by incrementing an element, and insert the resulting object into the table again.","ref":"dets.html#update_counter/3","title":"dets.update_counter/3","type":"function"},{"doc":"","ref":"dets.html#t:access/0","title":"dets.access/0","type":"type"},{"doc":"","ref":"dets.html#t:auto_save/0","title":"dets.auto_save/0","type":"type"},{"doc":"Opaque continuation used by match/1 and match/3 .","ref":"dets.html#t:bindings_cont/0","title":"dets.bindings_cont/0","type":"opaque"},{"doc":"Opaque continuation used by bchunk/2 .","ref":"dets.html#t:cont/0","title":"dets.cont/0","type":"opaque"},{"doc":"","ref":"dets.html#t:keypos/0","title":"dets.keypos/0","type":"type"},{"doc":"Match specifications, see section Match Specification in Erlang in ERTS User's Guide and the ms_transform(3) module.","ref":"dets.html#t:match_spec/0","title":"dets.match_spec/0","type":"type"},{"doc":"","ref":"dets.html#t:no_slots/0","title":"dets.no_slots/0","type":"type"},{"doc":"","ref":"dets.html#t:object/0","title":"dets.object/0","type":"type"},{"doc":"Opaque continuation used by match_object/1 and match_object/3 .","ref":"dets.html#t:object_cont/0","title":"dets.object_cont/0","type":"opaque"},{"doc":"For a description of patterns, see ets:match/2 .","ref":"dets.html#t:pattern/0","title":"dets.pattern/0","type":"type"},{"doc":"Opaque continuation used by select/1 and select/3 .","ref":"dets.html#t:select_cont/0","title":"dets.select_cont/0","type":"opaque"},{"doc":"","ref":"dets.html#t:tab_name/0","title":"dets.tab_name/0","type":"type"},{"doc":"","ref":"dets.html#t:type/0","title":"dets.type/0","type":"type"},{"doc":"This module provides a Key - Value dictionary. The representation of a dictionary is not defined. This module provides the same interface as the orddict(3) module. One difference is that while this module considers two keys as different if they do not match ( =:= ), orddict considers two keys as different if and only if they do not compare equal ( == ). Notes Functions append and append_list are included so that keyed values can be stored in a list accumulator , for example: &gt; D0 = dict : new ( ) , D1 = dict : store ( files , [ ] , D0 ) , D2 = dict : append ( files , f1 , D1 ) , D3 = dict : append ( files , f2 , D2 ) , D4 = dict : append ( files , f3 , D3 ) , dict : fetch ( files , D4 ) . [ f1 , f2 , f3 ] This saves the trouble of first fetching a keyed value, appending a new value to the list of stored values, and storing the result. Function fetch is to be used if the key is known to be in the dictionary, otherwise function find . See Also gb_trees(3) , orddict(3)","ref":"dict.html","title":"dict","type":"module"},{"doc":"Appends a new Value to the current list of values associated with Key . See also section Notes .","ref":"dict.html#append/3","title":"dict.append/3","type":"function"},{"doc":"Appends a list of values ValList to the current list of values associated with Key . An exception is generated if the initial value associated with Key is not a list of values. See also section Notes .","ref":"dict.html#append_list/3","title":"dict.append_list/3","type":"function"},{"doc":"Erases all items with a given key from a dictionary.","ref":"dict.html#erase/2","title":"dict.erase/2","type":"function"},{"doc":"Returns the value associated with Key in dictionary Dict . This function assumes that Key is present in dictionary Dict , and an exception is generated if Key is not in the dictionary. See also section Notes .","ref":"dict.html#fetch/2","title":"dict.fetch/2","type":"function"},{"doc":"Returns a list of all keys in dictionary Dict .","ref":"dict.html#fetch_keys/1","title":"dict.fetch_keys/1","type":"function"},{"doc":"Dict2 is a dictionary of all keys and values in Dict1 for which Pred(Key, Value) is true .","ref":"dict.html#filter/2","title":"dict.filter/2","type":"function"},{"doc":"Searches for a key in dictionary Dict . Returns {ok, Value} , where Value is the value associated with Key , or error if the key is not present in the dictionary. See also section Notes .","ref":"dict.html#find/2","title":"dict.find/2","type":"function"},{"doc":"Calls Fun on successive keys and values of dictionary Dict together with an extra argument Acc (short for accumulator). Fun must return a new accumulator that is passed to the next call. Acc0 is returned if the dictionary is empty. The evaluation order is undefined.","ref":"dict.html#fold/3","title":"dict.fold/3","type":"function"},{"doc":"Converts the Key - Value list List to dictionary Dict .","ref":"dict.html#from_list/1","title":"dict.from_list/1","type":"function"},{"doc":"Returns true if dictionary Dict has no elements, otherwise false .","ref":"dict.html#is_empty/1","title":"dict.is_empty/1","type":"function"},{"doc":"Tests if Key is contained in dictionary Dict .","ref":"dict.html#is_key/2","title":"dict.is_key/2","type":"function"},{"doc":"Calls Fun on successive keys and values of dictionary Dict1 to return a new value for each key. The evaluation order is undefined.","ref":"dict.html#map/2","title":"dict.map/2","type":"function"},{"doc":"Merges two dictionaries, Dict1 and Dict2 , to create a new dictionary. All the Key - Value pairs from both dictionaries are included in the new dictionary. If a key occurs in both dictionaries, Fun is called with the key and both values to return a new value. merge can be defined as follows, but is faster: merge(Fun, D1, D2) -&gt; fold(fun (K, V1, D) -&gt; update(K, fun (V2) -&gt; Fun(K, V1, V2) end, V1, D) end, D2, D1).","ref":"dict.html#merge/3","title":"dict.merge/3","type":"function"},{"doc":"Creates a new dictionary.","ref":"dict.html#new/0","title":"dict.new/0","type":"function"},{"doc":"Returns the number of elements in dictionary Dict .","ref":"dict.html#size/1","title":"dict.size/1","type":"function"},{"doc":"Stores a Key - Value pair in dictionary Dict2 . If Key already exists in Dict1 , the associated value is replaced by Value .","ref":"dict.html#store/3","title":"dict.store/3","type":"function"},{"doc":"This function returns value from dictionary and a new dictionary without this value. Returns error if the key is not present in the dictionary.","ref":"dict.html#take/2","title":"dict.take/2","type":"function"},{"doc":"Converts dictionary Dict to a list representation.","ref":"dict.html#to_list/1","title":"dict.to_list/1","type":"function"},{"doc":"Updates a value in a dictionary by calling Fun on the value to get a new value. An exception is generated if Key is not present in the dictionary.","ref":"dict.html#update/3","title":"dict.update/3","type":"function"},{"doc":"Updates a value in a dictionary by calling Fun on the value to get a new value. If Key is not present in the dictionary, Initial is stored as the first value. For example, append/3 can be defined as: append(Key, Val, D) -&gt; update(Key, fun (Old) -&gt; Old ++ [Val] end, [Val], D).","ref":"dict.html#update/4","title":"dict.update/4","type":"function"},{"doc":"Adds Increment to the value associated with Key and stores this value. If Key is not present in the dictionary, Increment is stored as the first value. This can be defined as follows, but is faster: update_counter(Key, Incr, D) -&gt; update(Key, fun (Old) -&gt; Old + Incr end, Incr, D).","ref":"dict.html#update_counter/3","title":"dict.update_counter/3","type":"function"},{"doc":"","ref":"dict.html#t:dict/0","title":"dict.dict/0","type":"type"},{"doc":"Dictionary as returned by new/0 .","ref":"dict.html#t:dict/2","title":"dict.dict/2","type":"opaque"},{"doc":"This module provides a version of labeled directed graphs (&quot;digraphs&quot;). The digraphs managed by this module are stored in ETS tables . That implies the following: Only the process that created the digraph is allowed to update it. Digraphs will not be garbage collected. The ETS tables used for a digraph will only be deleted when delete/1 is called or the process that created the digraph terminates. A digraph is a mutable data structure. What makes the graphs provided here non-proper directed graphs is that multiple edges between vertices are allowed. However, the customary definition of directed graphs is used here. A directed graph (or just &quot;digraph&quot;) is a pair (V, E) of a finite set V of vertices and a finite set E of directed edges (or just &quot;edges&quot;). The set of edges E is a subset of V × V (the Cartesian product of V with itself). In this module, V is allowed to be empty. The so obtained unique digraph is called the empty digraph . Both vertices and edges are represented by unique Erlang terms. Digraphs can be annotated with more information. Such information can be attached to the vertices and to the edges of the digraph. An annotated digraph is called a labeled digraph , and the information attached to a vertex or an edge is called a label . Labels are Erlang terms. An edge e = (v, w) is said to emanate from vertex v and to be incident on vertex w. The out-degree of a vertex is the number of edges emanating from that vertex. The in-degree of a vertex is the number of edges incident on that vertex. If an edge is emanating from v and incident on w, then w is said to be an out-neighbor of v, and v is said to be an in-neighbor of w. A path P from v[1] to v[k] in a digraph (V, E) is a non-empty sequence v[1], v[2], ..., v[k] of vertices in V such that there is an edge (v[i],v[i+1]) in E for 1 &lt;= i &lt; k. The length of path P is k-1. Path P is simple if all vertices are distinct, except that the first and the last vertices can be the same. Path P is a cycle if the length of P is not zero and v[1] = v[k]. A loop is a cycle of length one. A simple cycle is a path that is both a cycle and simple. An acyclic digraph is a digraph without cycles. See Also digraph_utils(3) , ets(3)","ref":"digraph.html","title":"digraph","type":"module"},{"doc":"add_edge/5 creates (or modifies) edge E of digraph G , using Label as the (new) label of the edge. The edge is emanating from V1 and incident on V2 . Returns E . add_edge(G, V1, V2, Label) is equivalent to add_edge(G, E, V1, V2, Label) , where E is a created edge. The created edge is represented by term ['$e' | N] , where N is an integer &gt;= 0. add_edge(G, V1, V2) is equivalent to add_edge(G, V1, V2, []) . If the edge would create a cycle in an acyclic digraph , {error, {bad_edge, Path}} is returned. If G already has an edge with value E connecting a different pair of vertices, {error, {bad_edge, [V1, V2]}} is returned. If either of V1 or V2 is not a vertex of digraph G , {error, {bad_vertex,  V }} is returned, V =  V1 or V =  V2 .","ref":"digraph.html#add_edge/3","title":"digraph.add_edge/3","type":"function"},{"doc":"","ref":"digraph.html#add_edge/4","title":"digraph.add_edge/4","type":"function"},{"doc":"","ref":"digraph.html#add_edge/5","title":"digraph.add_edge/5","type":"function"},{"doc":"add_vertex/3 creates (or modifies) vertex V of digraph G , using Label as the (new) label of the vertex. Returns V . add_vertex(G, V) is equivalent to add_vertex(G, V, []) . add_vertex/1 creates a vertex using the empty list as label, and returns the created vertex. The created vertex is represented by term ['$v' | N] , where N is an integer &gt;= 0.","ref":"digraph.html#add_vertex/1","title":"digraph.add_vertex/1","type":"function"},{"doc":"","ref":"digraph.html#add_vertex/2","title":"digraph.add_vertex/2","type":"function"},{"doc":"","ref":"digraph.html#add_vertex/3","title":"digraph.add_vertex/3","type":"function"},{"doc":"Deletes edge E from digraph G .","ref":"digraph.html#del_edge/2","title":"digraph.del_edge/2","type":"function"},{"doc":"Deletes the edges in list Edges from digraph G .","ref":"digraph.html#del_edges/2","title":"digraph.del_edges/2","type":"function"},{"doc":"Deletes edges from digraph G until there are no paths from vertex V1 to vertex V2 . A sketch of the procedure employed: Find an arbitrary simple path v[1], v[2], ..., v[k] from V1 to V2 in G . Remove all edges of G emanating from v[i] and incident to v[i+1] for 1 &lt;= i &lt; k (including multiple edges). Repeat until there is no path between V1 and V2 .","ref":"digraph.html#del_path/3","title":"digraph.del_path/3","type":"function"},{"doc":"Deletes vertex V from digraph G . Any edges emanating from V or incident on V are also deleted.","ref":"digraph.html#del_vertex/2","title":"digraph.del_vertex/2","type":"function"},{"doc":"Deletes the vertices in list Vertices from digraph G .","ref":"digraph.html#del_vertices/2","title":"digraph.del_vertices/2","type":"function"},{"doc":"Deletes digraph G . This call is important as digraphs are implemented with ETS. There is no garbage collection of ETS tables. However, the digraph is deleted if the process that created the digraph terminates.","ref":"digraph.html#delete/1","title":"digraph.delete/1","type":"function"},{"doc":"Returns {E, V1, V2, Label} , where Label is the label of edge E emanating from V1 and incident on V2 of digraph G . If no edge E of digraph G exists, false is returned.","ref":"digraph.html#edge/2","title":"digraph.edge/2","type":"function"},{"doc":"Returns a list of all edges of digraph G , in some unspecified order.","ref":"digraph.html#edges/1","title":"digraph.edges/1","type":"function"},{"doc":"Returns a list of all edges emanating from or incident on V of digraph G , in some unspecified order.","ref":"digraph.html#edges/2","title":"digraph.edges/2","type":"function"},{"doc":"If a simple cycle of length two or more exists through vertex V , the cycle is returned as a list [V, ..., V] of vertices. If a loop through V exists, the loop is returned as a list [V] . If no cycles through V exist, false is returned. get_path/3 is used for finding a simple cycle through V .","ref":"digraph.html#get_cycle/2","title":"digraph.get_cycle/2","type":"function"},{"doc":"Tries to find a simple path from vertex V1 to vertex V2 of digraph G . Returns the path as a list [V1, ..., V2] of vertices, or false if no simple path from V1 to V2 of length one or more exists. Digraph G is traversed in a depth-first manner, and the first found path is returned.","ref":"digraph.html#get_path/3","title":"digraph.get_path/3","type":"function"},{"doc":"Tries to find an as short as possible simple cycle through vertex V of digraph G . Returns the cycle as a list [V, ..., V] of vertices, or false if no simple cycle through V exists. Notice that a loop through V is returned as list [V, V] . get_short_path/3 is used for finding a simple cycle through V .","ref":"digraph.html#get_short_cycle/2","title":"digraph.get_short_cycle/2","type":"function"},{"doc":"Tries to find an as short as possible simple path from vertex V1 to vertex V2 of digraph G . Returns the path as a list [V1, ..., V2] of vertices, or false if no simple path from V1 to V2 of length one or more exists. Digraph G is traversed in a breadth-first manner, and the first found path is returned.","ref":"digraph.html#get_short_path/3","title":"digraph.get_short_path/3","type":"function"},{"doc":"Returns the in-degree of vertex V of digraph G .","ref":"digraph.html#in_degree/2","title":"digraph.in_degree/2","type":"function"},{"doc":"Returns a list of all edges incident on V of digraph G , in some unspecified order.","ref":"digraph.html#in_edges/2","title":"digraph.in_edges/2","type":"function"},{"doc":"Returns a list of all in-neighbors of V of digraph G , in some unspecified order.","ref":"digraph.html#in_neighbours/2","title":"digraph.in_neighbours/2","type":"function"},{"doc":"Returns a list of {Tag, Value} pairs describing digraph G . The following pairs are returned: {cyclicity, Cyclicity} , where Cyclicity is cyclic or acyclic , according to the options given to new . {memory, NoWords} , where NoWords is the number of words allocated to the ETS tables. {protection, Protection} , where Protection is protected or private , according to the options given to new .","ref":"digraph.html#info/1","title":"digraph.info/1","type":"function"},{"doc":"Equivalent to new([]) .","ref":"digraph.html#new/0","title":"digraph.new/0","type":"function"},{"doc":"Returns an empty digraph with properties according to the options in Type : cyclic Allows cycles in the digraph (default). acyclic The digraph is to be kept acyclic . protected Other processes can read the digraph (default). private The digraph can be read and modified by the creating process only. If an unrecognized type option T is specified or Type is not a proper list, a badarg exception is raised.","ref":"digraph.html#new/1","title":"digraph.new/1","type":"function"},{"doc":"Returns the number of edges of digraph G .","ref":"digraph.html#no_edges/1","title":"digraph.no_edges/1","type":"function"},{"doc":"Returns the number of vertices of digraph G .","ref":"digraph.html#no_vertices/1","title":"digraph.no_vertices/1","type":"function"},{"doc":"Returns the out-degree of vertex V of digraph G .","ref":"digraph.html#out_degree/2","title":"digraph.out_degree/2","type":"function"},{"doc":"Returns a list of all edges emanating from V of digraph G , in some unspecified order.","ref":"digraph.html#out_edges/2","title":"digraph.out_edges/2","type":"function"},{"doc":"Returns a list of all out-neighbors of V of digraph G , in some unspecified order.","ref":"digraph.html#out_neighbours/2","title":"digraph.out_neighbours/2","type":"function"},{"doc":"Returns {V, Label} , where Label is the label of the vertex V of digraph G , or false if no vertex V of digraph G exists.","ref":"digraph.html#vertex/2","title":"digraph.vertex/2","type":"function"},{"doc":"Returns a list of all vertices of digraph G , in some unspecified order.","ref":"digraph.html#vertices/1","title":"digraph.vertices/1","type":"function"},{"doc":"","ref":"digraph.html#t:d_cyclicity/0","title":"digraph.d_cyclicity/0","type":"type"},{"doc":"","ref":"digraph.html#t:d_protection/0","title":"digraph.d_protection/0","type":"type"},{"doc":"","ref":"digraph.html#t:d_type/0","title":"digraph.d_type/0","type":"type"},{"doc":"","ref":"digraph.html#t:edge/0","title":"digraph.edge/0","type":"type"},{"doc":"A digraph as returned by new/0,1 .","ref":"digraph.html#t:graph/0","title":"digraph.graph/0","type":"opaque"},{"doc":"","ref":"digraph.html#t:label/0","title":"digraph.label/0","type":"type"},{"doc":"","ref":"digraph.html#t:vertex/0","title":"digraph.vertex/0","type":"type"},{"doc":"This module provides algorithms based on depth-first traversal of directed graphs. For basic functions on directed graphs, see the digraph(3) module. A directed graph (or just &quot;digraph&quot;) is a pair (V, E) of a finite set V of vertices and a finite set E of directed edges (or just &quot;edges&quot;). The set of edges E is a subset of V × V (the Cartesian product of V with itself). Digraphs can be annotated with more information. Such information can be attached to the vertices and to the edges of the digraph. An annotated digraph is called a labeled digraph , and the information attached to a vertex or an edge is called a label . An edge e = (v, w) is said to emanate from vertex v and to be incident on vertex w. If an edge is emanating from v and incident on w, then w is said to be an out-neighbor of v, and v is said to be an in-neighbor of w. A path P from v[1] to v[k] in a digraph (V, E) is a non-empty sequence v[1], v[2], ..., v[k] of vertices in V such that there is an edge (v[i],v[i+1]) in E for 1 &lt;= i &lt; k. The length of path P is k-1. Path P is a cycle if the length of P is not zero and v[1] = v[k]. A loop is a cycle of length one. An acyclic digraph is a digraph without cycles. A depth-first traversal of a directed digraph can be viewed as a process that visits all vertices of the digraph. Initially, all vertices are marked as unvisited. The traversal starts with an arbitrarily chosen vertex, which is marked as visited, and follows an edge to an unmarked vertex, marking that vertex. The search then proceeds from that vertex in the same fashion, until there is no edge leading to an unvisited vertex. At that point the process backtracks, and the traversal continues as long as there are unexamined edges. If unvisited vertices remain when all edges from the first vertex have been examined, some so far unvisited vertex is chosen, and the process is repeated. A partial ordering of a set S is a transitive, antisymmetric, and reflexive relation between the objects of S. The problem of topological sorting is to find a total ordering of S that is a superset of the partial ordering. A digraph G = (V, E) is equivalent to a relation E on V (we neglect that the version of directed graphs provided by the digraph module allows multiple edges between vertices). If the digraph has no cycles of length two or more, the reflexive and transitive closure of E is a partial ordering. A subgraph G' of G is a digraph whose vertices and edges form subsets of the vertices and edges of G. G' is maximal with respect to a property P if all other subgraphs that include the vertices of G' do not have property P. A strongly connected component is a maximal subgraph such that there is a path between each pair of vertices. A connected component is a maximal subgraph such that there is a path between each pair of vertices, considering all edges undirected. An arborescence is an acyclic digraph with a vertex V, the root , such that there is a unique path from V to every other vertex of G. A tree is an acyclic non-empty digraph such that there is a unique path between every pair of vertices, considering all edges undirected. See Also digraph(3)","ref":"digraph_utils.html","title":"digraph_utils","type":"module"},{"doc":"Returns {yes, Root} if Root is the root of the arborescence Digraph , otherwise no .","ref":"digraph_utils.html#arborescence_root/1","title":"digraph_utils.arborescence_root/1","type":"function"},{"doc":"Returns a list of connected components . Each component is represented by its vertices. The order of the vertices and the order of the components are arbitrary. Each vertex of digraph Digraph occurs in exactly one component.","ref":"digraph_utils.html#components/1","title":"digraph_utils.components/1","type":"function"},{"doc":"Creates a digraph where the vertices are the strongly connected components of Digraph as returned by strong_components/1 . If X and Y are two different strongly connected components, and vertices x and y exist in X and Y, respectively, such that there is an edge emanating from x and incident on y, then an edge emanating from X and incident on Y is created. The created digraph has the same type as Digraph . All vertices and edges have the default label [] . Each cycle is included in some strongly connected component, which implies that a topological ordering of the created digraph always exists.","ref":"digraph_utils.html#condensation/1","title":"digraph_utils.condensation/1","type":"function"},{"doc":"Returns a list of strongly connected components . Each strongly component is represented by its vertices. The order of the vertices and the order of the components are arbitrary. Only vertices that are included in some cycle in Digraph are returned, otherwise the returned list is equal to that returned by strong_components/1 .","ref":"digraph_utils.html#cyclic_strong_components/1","title":"digraph_utils.cyclic_strong_components/1","type":"function"},{"doc":"Returns true if and only if digraph Digraph is acyclic .","ref":"digraph_utils.html#is_acyclic/1","title":"digraph_utils.is_acyclic/1","type":"function"},{"doc":"Returns true if and only if digraph Digraph is an arborescence .","ref":"digraph_utils.html#is_arborescence/1","title":"digraph_utils.is_arborescence/1","type":"function"},{"doc":"Returns true if and only if digraph Digraph is a tree .","ref":"digraph_utils.html#is_tree/1","title":"digraph_utils.is_tree/1","type":"function"},{"doc":"Returns a list of all vertices of Digraph that are included in some loop .","ref":"digraph_utils.html#loop_vertices/1","title":"digraph_utils.loop_vertices/1","type":"function"},{"doc":"Returns all vertices of digraph Digraph . The order is given by a depth-first traversal of the digraph, collecting visited vertices in postorder. More precisely, the vertices visited while searching from an arbitrarily chosen vertex are collected in postorder, and all those collected vertices are placed before the subsequently visited vertices.","ref":"digraph_utils.html#postorder/1","title":"digraph_utils.postorder/1","type":"function"},{"doc":"Returns all vertices of digraph Digraph . The order is given by a depth-first traversal of the digraph, collecting visited vertices in preorder.","ref":"digraph_utils.html#preorder/1","title":"digraph_utils.preorder/1","type":"function"},{"doc":"Returns an unsorted list of digraph vertices such that for each vertex in the list, there is a path in Digraph from some vertex of Vertices to the vertex. In particular, as paths can have length zero, the vertices of Vertices are included in the returned list.","ref":"digraph_utils.html#reachable/2","title":"digraph_utils.reachable/2","type":"function"},{"doc":"Returns an unsorted list of digraph vertices such that for each vertex in the list, there is a path in Digraph of length one or more from some vertex of Vertices to the vertex. As a consequence, only those vertices of Vertices that are included in some cycle are returned.","ref":"digraph_utils.html#reachable_neighbours/2","title":"digraph_utils.reachable_neighbours/2","type":"function"},{"doc":"Returns an unsorted list of digraph vertices such that for each vertex in the list, there is a path from the vertex to some vertex of Vertices . In particular, as paths can have length zero, the vertices of Vertices are included in the returned list.","ref":"digraph_utils.html#reaching/2","title":"digraph_utils.reaching/2","type":"function"},{"doc":"Returns an unsorted list of digraph vertices such that for each vertex in the list, there is a path of length one or more from the vertex to some vertex of Vertices . Therefore only those vertices of Vertices that are included in some cycle are returned.","ref":"digraph_utils.html#reaching_neighbours/2","title":"digraph_utils.reaching_neighbours/2","type":"function"},{"doc":"Returns a list of strongly connected components . Each strongly component is represented by its vertices. The order of the vertices and the order of the components are arbitrary. Each vertex of digraph Digraph occurs in exactly one strong component.","ref":"digraph_utils.html#strong_components/1","title":"digraph_utils.strong_components/1","type":"function"},{"doc":"Creates a maximal subgraph of Digraph having as vertices those vertices of Digraph that are mentioned in Vertices . If the value of option type is inherit , which is the default, the type of Digraph is used for the subgraph as well. Otherwise the option value of type is used as argument to digraph:new/1 . If the value of option keep_labels is true , which is the default, the labels of vertices and edges of Digraph are used for the subgraph as well. If the value is false , default label [] is used for the vertices and edges of the subgroup. subgraph(Digraph, Vertices) is equivalent to subgraph(Digraph, Vertices, []) . If any of the arguments are invalid, a badarg exception is raised.","ref":"digraph_utils.html#subgraph/2","title":"digraph_utils.subgraph/2","type":"function"},{"doc":"","ref":"digraph_utils.html#subgraph/3","title":"digraph_utils.subgraph/3","type":"function"},{"doc":"Returns a topological ordering of the vertices of digraph Digraph if such an ordering exists, otherwise false . For each vertex in the returned list, no out-neighbors occur earlier in the list.","ref":"digraph_utils.html#topsort/1","title":"digraph_utils.topsort/1","type":"function"},{"doc":"The Erlang code preprocessor includes functions that are used by the compile module to preprocess macros and include files before the parsing takes place. The Erlang source file encoding is selected by a comment in one of the first two lines of the source file. The first string matching the regular expression coding\\s*[:=]\\s*([-a-zA-Z0-9])+ selects the encoding. If the matching string is not a valid encoding, it is ignored. The valid encodings are Latin-1 and UTF-8 , where the case of the characters can be chosen freely. Examples: %% coding: utf-8 %% For this file we have chosen encoding = Latin-1 %% -*- coding: latin-1 -*- Error Information ErrorInfo is the standard ErrorInfo structure that is returned from all I/O modules. The format is as follows: {ErrorLine, Module, ErrorDescriptor} A string describing the error is obtained with the following call: Module:format_error(ErrorDescriptor) See Also erl_parse(3)","ref":"epp.html","title":"epp","type":"module"},{"doc":"Closes the preprocessing of a file.","ref":"epp.html#close/1","title":"epp.close/1","type":"function"},{"doc":"Returns the default encoding of Erlang source files.","ref":"epp.html#default_encoding/0","title":"epp.default_encoding/0","type":"function"},{"doc":"Returns a string representation of an encoding. The string is recognized by read_encoding/1,2 , read_encoding_from_binary/1,2 , and set_encoding/1,2 as a valid encoding.","ref":"epp.html#encoding_to_string/1","title":"epp.encoding_to_string/1","type":"function"},{"doc":"Takes an ErrorDescriptor and returns a string that describes the error or warning. This function is usually called implicitly when processing an ErrorInfo structure (see section Error Information ).","ref":"epp.html#format_error/1","title":"epp.format_error/1","type":"function"},{"doc":"Opens a file for preprocessing. If you want to change the file name of the implicit -file() attributes inserted during preprocessing, you can do with {source_name, SourceName} . If unset it will default to the name of the opened file. If extra is specified in Options , the return value is {ok, Epp, Extra} instead of {ok, Epp} . The option location is forwarded to the Erlang token scanner, see erl_scan:tokens/3,4 .","ref":"epp.html#open/1","title":"epp.open/1","type":"function"},{"doc":"Equivalent to epp:open([{name, FileName}, {includes, IncludePath}]) .","ref":"epp.html#open/2","title":"epp.open/2","type":"function"},{"doc":"Equivalent to epp:open([{name, FileName}, {includes, IncludePath}, {macros, PredefMacros}]) .","ref":"epp.html#open/3","title":"epp.open/3","type":"function"},{"doc":"Returns the next Erlang form from the opened Erlang source file. Tuple {eof, Location} is returned at the end of the file. The first form corresponds to an implicit attribute -file(File,1). , where File is the file name.","ref":"epp.html#parse_erl_form/1","title":"epp.parse_erl_form/1","type":"function"},{"doc":"Preprocesses and parses an Erlang source file. Notice that tuple {eof, Location} returned at the end of the file is included as a &quot;form&quot;. If you want to change the file name of the implicit -file() attributes inserted during preprocessing, you can do with {source_name, SourceName} . If unset it will default to the name of the opened file. If extra is specified in Options , the return value is {ok, [Form], Extra} instead of {ok, [Form]} . The option location is forwarded to the Erlang token scanner, see erl_scan:tokens/3,4 .","ref":"epp.html#parse_file/2","title":"epp.parse_file/2","type":"function"},{"doc":"Equivalent to epp:parse_file(FileName, [{includes, IncludePath}, {macros, PredefMacros}]) .","ref":"epp.html#parse_file/3","title":"epp.parse_file/3","type":"function"},{"doc":"Read the encoding from a file. Returns the read encoding, or none if no valid encoding is found. Option in_comment_only is true by default, which is correct for Erlang source files. If set to false , the encoding string does not necessarily have to occur in a comment.","ref":"epp.html#read_encoding/1","title":"epp.read_encoding/1","type":"function"},{"doc":"","ref":"epp.html#read_encoding/2","title":"epp.read_encoding/2","type":"function"},{"doc":"Read the encoding from a binary. Returns the read encoding, or none if no valid encoding is found. Option in_comment_only is true by default, which is correct for Erlang source files. If set to false , the encoding string does not necessarily have to occur in a comment.","ref":"epp.html#read_encoding_from_binary/1","title":"epp.read_encoding_from_binary/1","type":"function"},{"doc":"","ref":"epp.html#read_encoding_from_binary/2","title":"epp.read_encoding_from_binary/2","type":"function"},{"doc":"Returns the raw tokens of the next Erlang form from the opened Erlang source file. A tuple {eof, Line} is returned at the end of the file. The first form corresponds to an implicit attribute -file(File,1). , where File is the file name.","ref":"epp.html#scan_erl_form/1","title":"epp.scan_erl_form/1","type":"function"},{"doc":"Preprocesses an Erlang source file returning a list of the lists of raw tokens of each form. Notice that the tuple {eof, Line} returned at the end of the file is included as a &quot;form&quot;, and any failures to scan a form are included in the list as tuples {error, ErrorInfo} .","ref":"epp.html#scan_file/2","title":"epp.scan_file/2","type":"function"},{"doc":"Reads the encoding from an I/O device and sets the encoding of the device accordingly. The position of the I/O device referenced by File is not affected. If no valid encoding can be read from the I/O device, the encoding of the I/O device is set to the default encoding. Returns the read encoding, or none if no valid encoding is found.","ref":"epp.html#set_encoding/1","title":"epp.set_encoding/1","type":"function"},{"doc":"Reads the encoding from an I/O device and sets the encoding of the device accordingly. The position of the I/O device referenced by File is not affected. If no valid encoding can be read from the I/O device, the encoding of the I/O device is set to the encoding specified by Default . Returns the read encoding, or none if no valid encoding is found.","ref":"epp.html#set_encoding/2","title":"epp.set_encoding/2","type":"function"},{"doc":"Handle to the epp server.","ref":"epp.html#t:epp_handle/0","title":"epp.epp_handle/0","type":"type"},{"doc":"","ref":"epp.html#t:macros/0","title":"epp.macros/0","type":"type"},{"doc":"","ref":"epp.html#t:source_encoding/0","title":"epp.source_encoding/0","type":"type"},{"doc":"","ref":"epp.html#t:warning_info/0","title":"epp.warning_info/0","type":"type"},{"doc":"This module provides an abstract type that is used by the Erlang Compiler and its helper modules for holding data such as column, line number, and text. The data type is a collection of annotations as described in the following. The Erlang Token Scanner returns tokens with a subset of the following annotations, depending on the options: column The column where the token begins. location The line and column where the token begins, or just the line if the column is unknown. text The token's text. From this, the following annotation is derived: line The line where the token begins. This module also supports the following annotations, which are used by various modules: file A filename. generated A Boolean indicating if the abstract code is compiler-generated. The Erlang Compiler does not emit warnings for such code. record A Boolean indicating if the origin of the abstract code is a record. Used by Dialyzer to assign types to tuple elements. The functions column() , end_location() , line() , location() , and text() in the erl_scan module can be used for inspecting annotations in tokens. The functions anno_from_term() , anno_to_term() , fold_anno() , map_anno() , mapfold_anno() , and new_anno() , in the erl_parse module can be used for manipulating annotations in abstract code. See Also erl_parse(3) , erl_scan(3)","ref":"erl_anno.html","title":"erl_anno","type":"module"},{"doc":"Returns the column of the annotations Anno.","ref":"erl_anno.html#column/1","title":"erl_anno.column/1","type":"function"},{"doc":"Returns the end location of the text of the annotations Anno. If there is no text, undefined is returned.","ref":"erl_anno.html#end_location/1","title":"erl_anno.end_location/1","type":"function"},{"doc":"Returns the filename of the annotations Anno. If there is no filename, undefined is returned.","ref":"erl_anno.html#file/1","title":"erl_anno.file/1","type":"function"},{"doc":"Returns annotations with representation Term. See also to_term() .","ref":"erl_anno.html#from_term/1","title":"erl_anno.from_term/1","type":"function"},{"doc":"Returns true if annotations Anno is marked as generated. The default is to return false .","ref":"erl_anno.html#generated/1","title":"erl_anno.generated/1","type":"function"},{"doc":"Returns true if Term is a collection of annotations, otherwise false .","ref":"erl_anno.html#is_anno/1","title":"erl_anno.is_anno/1","type":"function"},{"doc":"Returns the line of the annotations Anno.","ref":"erl_anno.html#line/1","title":"erl_anno.line/1","type":"function"},{"doc":"Returns the location of the annotations Anno.","ref":"erl_anno.html#location/1","title":"erl_anno.location/1","type":"function"},{"doc":"Creates a new collection of annotations given a location.","ref":"erl_anno.html#new/1","title":"erl_anno.new/1","type":"function"},{"doc":"Modifies the filename of the annotations Anno.","ref":"erl_anno.html#set_file/2","title":"erl_anno.set_file/2","type":"function"},{"doc":"Modifies the generated marker of the annotations Anno.","ref":"erl_anno.html#set_generated/2","title":"erl_anno.set_generated/2","type":"function"},{"doc":"Modifies the line of the annotations Anno.","ref":"erl_anno.html#set_line/2","title":"erl_anno.set_line/2","type":"function"},{"doc":"Modifies the location of the annotations Anno.","ref":"erl_anno.html#set_location/2","title":"erl_anno.set_location/2","type":"function"},{"doc":"Modifies the record marker of the annotations Anno.","ref":"erl_anno.html#set_record/2","title":"erl_anno.set_record/2","type":"function"},{"doc":"Modifies the text of the annotations Anno.","ref":"erl_anno.html#set_text/2","title":"erl_anno.set_text/2","type":"function"},{"doc":"Returns the text of the annotations Anno. If there is no text, undefined is returned.","ref":"erl_anno.html#text/1","title":"erl_anno.text/1","type":"function"},{"doc":"Returns the term representing the annotations Anno. See also from_term() .","ref":"erl_anno.html#to_term/1","title":"erl_anno.to_term/1","type":"function"},{"doc":"A collection of annotations.","ref":"erl_anno.html#t:anno/0","title":"erl_anno.anno/0","type":"opaque"},{"doc":"The term representing a collection of annotations. It is either a location() or a list of key-value pairs.","ref":"erl_anno.html#t:anno_term/0","title":"erl_anno.anno_term/0","type":"type"},{"doc":"","ref":"erl_anno.html#t:column/0","title":"erl_anno.column/0","type":"type"},{"doc":"","ref":"erl_anno.html#t:line/0","title":"erl_anno.line/0","type":"type"},{"doc":"","ref":"erl_anno.html#t:location/0","title":"erl_anno.location/0","type":"type"},{"doc":"","ref":"erl_anno.html#t:text/0","title":"erl_anno.text/0","type":"type"},{"doc":"This module provides functions for pretty-printing errors and exceptions. It is used by both the shell and by proc_lib to print exceptions. It is possible for the module raising an error to provide additional information by calling error/3 with extra error information. More details about this mechanism is described in EEP-54 . Callback Functions The following functions are to be exported from an Error Info handler.","ref":"erl_error.html","title":"erl_error","type":"module"},{"doc":"Format the error reason and stack back-trace caught using try ... catch in the same style as the shell formats them. Example: try do_something() catch C:R:Stk -&gt; Message = erl_error:format_exception(C, R, Stk), io:format(LogFile, &quot;~ts\\n&quot;, [Message]) end If error_info is provided with the exception, format_exception will use that information to provide additional information about the exception. Example: try erlang:raise(badarg,[],[{error_info,\#{}}]) catch C:R:Stk -&gt; Message = erl_error:format_exception(C, R, Stk), io:format(LogFile, &quot;~ts\\n&quot;, [Message]) end See erlang:error/3 for details on how to raise an exception with error_info included.","ref":"erl_error.html#format_exception/3","title":"erl_error.format_exception/3","type":"function"},{"doc":"","ref":"erl_error.html#format_exception/4","title":"erl_error.format_exception/4","type":"function"},{"doc":"Start column number. Default is 1.","ref":"erl_error.html#t:column/0","title":"erl_error.column/0","type":"type"},{"doc":"A fun used to format function arguments for BIF and function calls. By default the following fun will be used: fun ( Term , I ) -&gt; io_lib : print ( Term , I , 80 , 30 ) end","ref":"erl_error.html#t:format_fun/0","title":"erl_error.format_fun/0","type":"type"},{"doc":"A map with formatting options.","ref":"erl_error.html#t:format_options/0","title":"erl_error.format_options/0","type":"type"},{"doc":"A fun used to trim the end of the stacktrace. It is called with module, function, and arity from an entry from the stacktrace. The fun is to return true if the entry should be trimmed, and false otherwise. The default value is: fun ( _ , _ , _ ) -&gt; false end","ref":"erl_error.html#t:stack_trim_fun/0","title":"erl_error.stack_trim_fun/0","type":"type"},{"doc":"This module provides an interpreter for Erlang expressions. The expressions are in the abstract syntax as returned by erl_parse , the Erlang parser, or io . Local Function Handler During evaluation of a function, no calls can be made to local functions. An undefined function error would be generated. However, the optional argument LocalFunctionHandler can be used to define a function that is called when there is a call to a local function. The argument can have the following formats: {value,Func} This defines a local function handler that is called with: Func(Name, Arguments) Name is the name of the local function (an atom) and Arguments is a list of the evaluated arguments. The function handler returns the value of the local function. In this case, the current bindings cannot be accessed. To signal an error, the function handler calls exit/1 with a suitable exit value. {eval,Func} This defines a local function handler that is called with: Func(Name, Arguments, Bindings) Name is the name of the local function (an atom), Arguments is a list of the unevaluated arguments, and Bindings are the current variable bindings. The function handler returns: {value,Value,NewBindings} Value is the value of the local function and NewBindings are the updated variable bindings. In this case, the function handler must itself evaluate all the function arguments and manage the bindings. To signal an error, the function handler calls exit/1 with a suitable exit value. none There is no local function handler. Non-Local Function Handler The optional argument NonLocalFunctionHandler can be used to define a function that is called in the following cases: A functional object (fun) is called. A built-in function is called. A function is called using the M:F syntax, where M and F are atoms or expressions. An operator Op/A is called (this is handled as a call to function erlang:Op/A ). Exceptions are calls to erlang:apply/2,3 ; neither of the function handlers are called for such calls. The argument can have the following formats: {value,Func} This defines a non-local function handler that is called with: Func(FuncSpec, Arguments) FuncSpec is the name of the function on the form {Module,Function} or a fun, and Arguments is a list of the evaluated arguments. The function handler returns the value of the function. To signal an error, the function handler calls exit/1 with a suitable exit value. none There is no non-local function handler. For calls such as erlang:apply(Fun, Args) or erlang:apply(Module, Function, Args) , the call of the non-local function handler corresponding to the call to erlang:apply/2,3 itself ( Func({erlang, apply}, [Fun, Args]) or Func({erlang, apply}, [Module, Function, Args]) ) never takes place. The non-local function handler is however called with the evaluated arguments of the call to erlang:apply/2,3 : Func(Fun, Args) or Func({Module, Function}, Args) (assuming that {Module, Function} is not {erlang, apply} ). Calls to functions defined by evaluating fun expressions &quot;fun ... end&quot; are also hidden from non-local function handlers. The non-local function handler argument is probably not used as frequently as the local function handler argument. A possible use is to call exit/1 on calls to functions that for some reason are not allowed to be called. Known Limitation Undocumented functions in this module are not to be used.","ref":"erl_eval.html","title":"erl_eval","type":"module"},{"doc":"Adds binding Name=Value to BindingStruct . Returns an updated binding structure.","ref":"erl_eval.html#add_binding/3","title":"erl_eval.add_binding/3","type":"function"},{"doc":"Returns the binding of Name in BindingStruct .","ref":"erl_eval.html#binding/2","title":"erl_eval.binding/2","type":"function"},{"doc":"Returns the list of bindings contained in the binding structure.","ref":"erl_eval.html#bindings/1","title":"erl_eval.bindings/1","type":"function"},{"doc":"Removes the binding of Name in BindingStruct . Returns an updated binding structure.","ref":"erl_eval.html#del_binding/2","title":"erl_eval.del_binding/2","type":"function"},{"doc":"Evaluates Expression with the set of bindings Bindings . Expression is an expression in abstract syntax. For an explanation of when and how to use arguments LocalFunctionHandler and NonLocalFunctionHandler , see sections Local Function Handler and Non-Local Function Handler in this module. Returns {value, Value, NewBindings} by default. If ReturnFormat is value , only Value is returned.","ref":"erl_eval.html#expr/2","title":"erl_eval.expr/2","type":"function"},{"doc":"","ref":"erl_eval.html#expr/3","title":"erl_eval.expr/3","type":"function"},{"doc":"","ref":"erl_eval.html#expr/4","title":"erl_eval.expr/4","type":"function"},{"doc":"","ref":"erl_eval.html#expr/5","title":"erl_eval.expr/5","type":"function"},{"doc":"Evaluates a list of expressions in parallel, using the same initial bindings for each expression. Attempts are made to merge the bindings returned from each evaluation. This function is useful in LocalFunctionHandler , see section Local Function Handler in this module. Returns {ValueList, NewBindings} .","ref":"erl_eval.html#expr_list/2","title":"erl_eval.expr_list/2","type":"function"},{"doc":"","ref":"erl_eval.html#expr_list/3","title":"erl_eval.expr_list/3","type":"function"},{"doc":"","ref":"erl_eval.html#expr_list/4","title":"erl_eval.expr_list/4","type":"function"},{"doc":"Evaluates Expressions with the set of bindings Bindings , where Expressions is a sequence of expressions (in abstract syntax) of a type that can be returned by io:parse_erl_exprs/2 . For an explanation of when and how to use arguments LocalFunctionHandler and NonLocalFunctionHandler , see sections Local Function Handler and Non-Local Function Handler in this module. Returns {value, Value, NewBindings}","ref":"erl_eval.html#exprs/2","title":"erl_eval.exprs/2","type":"function"},{"doc":"","ref":"erl_eval.html#exprs/3","title":"erl_eval.exprs/3","type":"function"},{"doc":"","ref":"erl_eval.html#exprs/4","title":"erl_eval.exprs/4","type":"function"},{"doc":"Returns an empty binding structure.","ref":"erl_eval.html#new_bindings/0","title":"erl_eval.new_bindings/0","type":"function"},{"doc":"A binding structure. It is either a map or an orddict . erl_eval will always return the same type as the one given.","ref":"erl_eval.html#t:binding_struct/0","title":"erl_eval.binding_struct/0","type":"type"},{"doc":"","ref":"erl_eval.html#t:bindings/0","title":"erl_eval.bindings/0","type":"type"},{"doc":"","ref":"erl_eval.html#t:expression/0","title":"erl_eval.expression/0","type":"type"},{"doc":"","ref":"erl_eval.html#t:expression_list/0","title":"erl_eval.expression_list/0","type":"type"},{"doc":"As returned by erl_parse:parse_exprs/1 or io:parse_erl_exprs/2 .","ref":"erl_eval.html#t:expressions/0","title":"erl_eval.expressions/0","type":"type"},{"doc":"","ref":"erl_eval.html#t:func_spec/0","title":"erl_eval.func_spec/0","type":"type"},{"doc":"","ref":"erl_eval.html#t:lfun_eval_handler/0","title":"erl_eval.lfun_eval_handler/0","type":"type"},{"doc":"","ref":"erl_eval.html#t:lfun_value_handler/0","title":"erl_eval.lfun_value_handler/0","type":"type"},{"doc":"Further described in section Local Function Handler in this module","ref":"erl_eval.html#t:local_function_handler/0","title":"erl_eval.local_function_handler/0","type":"type"},{"doc":"","ref":"erl_eval.html#t:name/0","title":"erl_eval.name/0","type":"type"},{"doc":"","ref":"erl_eval.html#t:nlfun_handler/0","title":"erl_eval.nlfun_handler/0","type":"type"},{"doc":"Further described in section Non-Local Function Handler in this module.","ref":"erl_eval.html#t:non_local_function_handler/0","title":"erl_eval.non_local_function_handler/0","type":"type"},{"doc":"","ref":"erl_eval.html#t:value/0","title":"erl_eval.value/0","type":"type"},{"doc":"This module expands records in a module. See Also Section The Abstract Format in ERTS User's Guide.","ref":"erl_expand_records.html","title":"erl_expand_records","type":"module"},{"doc":"Expands all records in a module to use explicit tuple operations and adds explicit module names to calls to BIFs and imported functions. The returned module has no references to records, attributes, or code.","ref":"erl_expand_records.html#module/2","title":"erl_expand_records.module/2","type":"function"},{"doc":"This module defines Erlang BIFs, guard tests, and operators. This module is only of interest to programmers who manipulate Erlang code.","ref":"erl_internal.html","title":"erl_internal","type":"module"},{"doc":"Adds to Forms the code for the standard pre-defined functions (such as module_info/0 ) that are to be included in every module.","ref":"erl_internal.html#add_predefined_functions/1","title":"erl_internal.add_predefined_functions/1","type":"function"},{"doc":"Returns true if OpName/Arity is an arithmetic operator, otherwise false .","ref":"erl_internal.html#arith_op/2","title":"erl_internal.arith_op/2","type":"function"},{"doc":"Returns true if Name/Arity is an Erlang BIF that is automatically recognized by the compiler, otherwise false .","ref":"erl_internal.html#bif/2","title":"erl_internal.bif/2","type":"function"},{"doc":"Returns true if OpName/Arity is a Boolean operator, otherwise false .","ref":"erl_internal.html#bool_op/2","title":"erl_internal.bool_op/2","type":"function"},{"doc":"Returns true if OpName/Arity is a comparison operator, otherwise false .","ref":"erl_internal.html#comp_op/2","title":"erl_internal.comp_op/2","type":"function"},{"doc":"Returns true if Name/Arity is an Erlang BIF that is allowed in guards, otherwise false .","ref":"erl_internal.html#guard_bif/2","title":"erl_internal.guard_bif/2","type":"function"},{"doc":"Returns true if OpName/Arity is a list operator, otherwise false .","ref":"erl_internal.html#list_op/2","title":"erl_internal.list_op/2","type":"function"},{"doc":"Returns the Type of operator that OpName/Arity belongs to, or generates a function_clause error if it is not an operator.","ref":"erl_internal.html#op_type/2","title":"erl_internal.op_type/2","type":"function"},{"doc":"Returns true if OpName/Arity is a send operator, otherwise false .","ref":"erl_internal.html#send_op/2","title":"erl_internal.send_op/2","type":"function"},{"doc":"Returns true if Name/Arity is a valid Erlang type test, otherwise false .","ref":"erl_internal.html#type_test/2","title":"erl_internal.type_test/2","type":"function"},{"doc":"This module is used to check Erlang code for illegal syntax and other bugs. It also warns against coding practices that are not recommended. The errors detected include: Redefined and undefined functions Unbound and unsafe variables Illegal record use The warnings detected include: Unused functions and imports Unused variables Variables imported into matches Variables exported from if / case / receive Variables shadowed in funs and list comprehensions Some of the warnings are optional, and can be turned on by specifying the appropriate option, described below. The functions in this module are invoked automatically by the Erlang compiler. There is no reason to invoke these functions separately unless you have written your own Erlang compiler. Error Information ErrorInfo is the standard ErrorInfo structure that is returned from all I/O modules. The format is as follows: {ErrorLine, Module, ErrorDescriptor} A string describing the error is obtained with the following call: Module:format_error(ErrorDescriptor) See Also epp(3) , erl_parse(3)","ref":"erl_lint.html","title":"erl_lint","type":"module"},{"doc":"Takes an ErrorDescriptor and returns a string that describes the error or warning. This function is usually called implicitly when processing an ErrorInfo structure (see section Error Information ).","ref":"erl_lint.html#format_error/1","title":"erl_lint.format_error/1","type":"function"},{"doc":"Tests if Expr is a legal guard test. Expr is an Erlang term representing the abstract form for the expression. erl_parse:parse_exprs(Tokens) can be used to generate a list of Expr .","ref":"erl_lint.html#is_guard_test/1","title":"erl_lint.is_guard_test/1","type":"function"},{"doc":"Checks all the forms in a module for errors. It returns: {ok,Warnings} There are no errors in the module. {error,Errors,Warnings} There are errors in the module. As this module is of interest only to the maintainers of the compiler, and to avoid the same description in two places, the elements of Options that control the warnings are only described in the compile(3) module. AbsForms of a module, which comes from a file that is read through epp , the Erlang preprocessor, can come from many files. This means that any references to errors must include the filename, see the epp(3) module or parser (see the erl_parse(3) module). The returned errors and warnings have the following format: [{SourceFile,[ErrorInfo]}] The errors and warnings are listed in the order in which they are encountered in the forms. The errors from one file can therefore be split into different entries in the list of errors.","ref":"erl_lint.html#module/1","title":"erl_lint.module/1","type":"function"},{"doc":"","ref":"erl_lint.html#module/2","title":"erl_lint.module/2","type":"function"},{"doc":"","ref":"erl_lint.html#module/3","title":"erl_lint.module/3","type":"function"},{"doc":"","ref":"erl_lint.html#t:error_description/0","title":"erl_lint.error_description/0","type":"type"},{"doc":"","ref":"erl_lint.html#t:error_info/0","title":"erl_lint.error_info/0","type":"type"},{"doc":"This module is the basic Erlang parser that converts tokens into the abstract form of either forms (that is, top-level constructs), expressions, or terms. The Abstract Format is described in the ERTS User's Guide. Notice that a token list must end with the dot token to be acceptable to the parse functions (see the erl_scan(3) ) module. Error Information ErrorInfo is the standard ErrorInfo structure that is returned from all I/O modules. The format is as follows: {ErrorLine, Module, ErrorDescriptor} A string describing the error is obtained with the following call: Module:format_error(ErrorDescriptor) See Also erl_anno(3) , erl_scan(3) , io(3) , section The Abstract Format in the ERTS User's Guide","ref":"erl_parse.html","title":"erl_parse","type":"module"},{"doc":"Converts the Erlang data structure Data into an abstract form of type AbsTerm . This function is the inverse of normalise/1 . erl_parse:abstract(T) is equivalent to erl_parse:abstract(T, 0) .","ref":"erl_parse.html#abstract/1","title":"erl_parse.abstract/1","type":"function"},{"doc":"Converts the Erlang data structure Data into an abstract form of type AbsTerm . Each node of AbsTerm is assigned an annotation, see erl_anno(3) . The annotation contains the location given by option location or by option line . Option location overrides option line . If neither option location nor option line is given, 0 is used as location. Option Encoding is used for selecting which integer lists to be considered as strings. The default is to use the encoding returned by function epp:default_encoding/0 . Value none means that no integer lists are considered as strings. encoding_func() is called with one integer of a list at a time; if it returns true for every integer, the list is considered a string.","ref":"erl_parse.html#abstract/2","title":"erl_parse.abstract/2","type":"function"},{"doc":"Assumes that Term is a term with the same structure as a erl_parse tree, but with terms, say T , where a erl_parse tree has collections of annotations. Returns a erl_parse tree where each term T is replaced by the value returned by erl_anno:from_term(T) . The term Term is traversed in a depth-first, left-to-right fashion.","ref":"erl_parse.html#anno_from_term/1","title":"erl_parse.anno_from_term/1","type":"function"},{"doc":"Returns a term where each collection of annotations Anno of the nodes of the erl_parse tree Abstr is replaced by the term returned by erl_anno:to_term(Anno) . The erl_parse tree is traversed in a depth-first, left-to-right fashion.","ref":"erl_parse.html#anno_to_term/1","title":"erl_parse.anno_to_term/1","type":"function"},{"doc":"Updates an accumulator by applying Fun on each collection of annotations of the erl_parse tree Abstr . The first call to Fun has AccIn as argument, the returned accumulator AccOut is passed to the next call, and so on. The final value of the accumulator is returned. The erl_parse tree is traversed in a depth-first, left-to-right fashion.","ref":"erl_parse.html#fold_anno/3","title":"erl_parse.fold_anno/3","type":"function"},{"doc":"ErrorDescriptor = error_description() Chars = [char() | Chars] Uses an ErrorDescriptor and returns a string that describes the error. This function is usually called implicitly when an ErrorInfo structure is processed (see section Error Information ).","ref":"erl_parse.html#format_error/1","title":"erl_parse.format_error/1","type":"function"},{"doc":"Modifies the erl_parse tree Abstr by applying Fun on each collection of annotations of the nodes of the erl_parse tree. The erl_parse tree is traversed in a depth-first, left-to-right fashion.","ref":"erl_parse.html#map_anno/2","title":"erl_parse.map_anno/2","type":"function"},{"doc":"Modifies the erl_parse tree Abstr by applying Fun on each collection of annotations of the nodes of the erl_parse tree, while at the same time updating an accumulator. The first call to Fun has AccIn as second argument, the returned accumulator AccOut is passed to the next call, and so on. The modified erl_parse tree and the final value of the accumulator are returned. The erl_parse tree is traversed in a depth-first, left-to-right fashion.","ref":"erl_parse.html#mapfold_anno/3","title":"erl_parse.mapfold_anno/3","type":"function"},{"doc":"Assumes that Term is a term with the same structure as a erl_parse tree, but with locations where a erl_parse tree has collections of annotations. Returns a erl_parse tree where each location L is replaced by the value returned by erl_anno:new(L) . The term Term is traversed in a depth-first, left-to-right fashion.","ref":"erl_parse.html#new_anno/1","title":"erl_parse.new_anno/1","type":"function"},{"doc":"Converts the abstract form AbsTerm of a term into a conventional Erlang data structure (that is, the term itself). This function is the inverse of abstract/1 .","ref":"erl_parse.html#normalise/1","title":"erl_parse.normalise/1","type":"function"},{"doc":"Parses Tokens as if it was a list of expressions. Returns one of the following: {ok, ExprList} The parsing was successful. ExprList is a list of the abstract forms of the parsed expressions. {error, ErrorInfo} An error occurred.","ref":"erl_parse.html#parse_exprs/1","title":"erl_parse.parse_exprs/1","type":"function"},{"doc":"Parses Tokens as if it was a form. Returns one of the following: {ok, AbsForm} The parsing was successful. AbsForm is the abstract form of the parsed form. {error, ErrorInfo} An error occurred.","ref":"erl_parse.html#parse_form/1","title":"erl_parse.parse_form/1","type":"function"},{"doc":"Parses Tokens as if it was a term. Returns one of the following: {ok, Term} The parsing was successful. Term is the Erlang term corresponding to the token list. {error, ErrorInfo} An error occurred.","ref":"erl_parse.html#parse_term/1","title":"erl_parse.parse_term/1","type":"function"},{"doc":"Generates a list of tokens representing the abstract form AbsTerm of an expression. Optionally, MoreTokens is appended.","ref":"erl_parse.html#tokens/1","title":"erl_parse.tokens/1","type":"function"},{"doc":"","ref":"erl_parse.html#tokens/2","title":"erl_parse.tokens/2","type":"function"},{"doc":"Abstract form of an Erlang clause.","ref":"erl_parse.html#t:abstract_clause/0","title":"erl_parse.abstract_clause/0","type":"type"},{"doc":"Abstract form of an Erlang expression.","ref":"erl_parse.html#t:abstract_expr/0","title":"erl_parse.abstract_expr/0","type":"type"},{"doc":"Abstract form of an Erlang form.","ref":"erl_parse.html#t:abstract_form/0","title":"erl_parse.abstract_form/0","type":"type"},{"doc":"Abstract form of an Erlang type.","ref":"erl_parse.html#t:abstract_type/0","title":"erl_parse.abstract_type/0","type":"type"},{"doc":"Abstract representation of an element of a bitstring.","ref":"erl_parse.html#t:af_binelement/1","title":"erl_parse.af_binelement/1","type":"type"},{"doc":"Abstract representation of a record field.","ref":"erl_parse.html#t:af_field_decl/0","title":"erl_parse.af_field_decl/0","type":"type"},{"doc":"Abstract representation of a generator or a bitstring generator.","ref":"erl_parse.html#t:af_generator/0","title":"erl_parse.af_generator/0","type":"type"},{"doc":"Abstract representation of a remote function call.","ref":"erl_parse.html#t:af_remote_function/0","title":"erl_parse.af_remote_function/0","type":"type"},{"doc":"","ref":"erl_parse.html#t:erl_parse_tree/0","title":"erl_parse.erl_parse_tree/0","type":"type"},{"doc":"","ref":"erl_parse.html#t:error_description/0","title":"erl_parse.error_description/0","type":"type"},{"doc":"","ref":"erl_parse.html#t:error_info/0","title":"erl_parse.error_info/0","type":"type"},{"doc":"Tuples {error, error_info()} and {warning, error_info()} , denoting syntactically incorrect forms and warnings, and {eof, line()} , denoting an end-of-stream encountered before a complete form had been parsed.","ref":"erl_parse.html#t:form_info/0","title":"erl_parse.form_info/0","type":"type"},{"doc":"","ref":"erl_parse.html#t:token/0","title":"erl_parse.token/0","type":"type"},{"doc":"The functions in this module are used to generate aesthetically attractive representations of abstract forms, which are suitable for printing. All functions return (possibly deep) lists of characters and generate an error if the form is wrong. All functions can have an optional argument, which specifies a hook that is called if an attempt is made to print an unknown form. Known Limitations It is not possible to have hook functions for unknown forms at other places than expressions. See Also erl_eval(3) , erl_parse(3) , io(3)","ref":"erl_pp.html","title":"erl_pp","type":"module"},{"doc":"Same as form/1,2 , but only for attribute Attribute .","ref":"erl_pp.html#attribute/1","title":"erl_pp.attribute/1","type":"function"},{"doc":"","ref":"erl_pp.html#attribute/2","title":"erl_pp.attribute/2","type":"function"},{"doc":"Prints one expression. It is useful for implementing hooks (see section Known Limitations ).","ref":"erl_pp.html#expr/1","title":"erl_pp.expr/1","type":"function"},{"doc":"","ref":"erl_pp.html#expr/2","title":"erl_pp.expr/2","type":"function"},{"doc":"","ref":"erl_pp.html#expr/3","title":"erl_pp.expr/3","type":"function"},{"doc":"","ref":"erl_pp.html#expr/4","title":"erl_pp.expr/4","type":"function"},{"doc":"Same as form/1,2 , but only for the sequence of expressions in Expressions .","ref":"erl_pp.html#exprs/1","title":"erl_pp.exprs/1","type":"function"},{"doc":"","ref":"erl_pp.html#exprs/2","title":"erl_pp.exprs/2","type":"function"},{"doc":"","ref":"erl_pp.html#exprs/3","title":"erl_pp.exprs/3","type":"function"},{"doc":"Pretty prints a Form , which is an abstract form of a type that is returned by erl_parse:parse_form/1 .","ref":"erl_pp.html#form/1","title":"erl_pp.form/1","type":"function"},{"doc":"","ref":"erl_pp.html#form/2","title":"erl_pp.form/2","type":"function"},{"doc":"Same as form/1,2 , but only for function Function .","ref":"erl_pp.html#function/1","title":"erl_pp.function/1","type":"function"},{"doc":"","ref":"erl_pp.html#function/2","title":"erl_pp.function/2","type":"function"},{"doc":"Same as form/1,2 , but only for the guard test Guard .","ref":"erl_pp.html#guard/1","title":"erl_pp.guard/1","type":"function"},{"doc":"","ref":"erl_pp.html#guard/2","title":"erl_pp.guard/2","type":"function"},{"doc":"Optional argument HookFunction , shown in the functions described in this module, defines a function that is called when an unknown form occurs where there is to be a valid expression. If HookFunction is equal to none , there is no hook function. The called hook function is to return a (possibly deep) list of characters. Function expr/4 is useful in a hook. If CurrentIndentation is negative, there are no line breaks and only a space is used as a separator.","ref":"erl_pp.html#t:hook_function/0","title":"erl_pp.hook_function/0","type":"type"},{"doc":"The option quote_singleton_atom_types is used to add quotes to all singleton atom types. The option linewidth controls the maximum line width for formatted lines (defaults to 72 characters). The option indent controls the indention for formatted lines (defaults to 4 spaces).","ref":"erl_pp.html#t:option/0","title":"erl_pp.option/0","type":"type"},{"doc":"","ref":"erl_pp.html#t:options/0","title":"erl_pp.options/0","type":"type"},{"doc":"This module contains functions for tokenizing (scanning) characters into Erlang tokens. Error Information ErrorInfo is the standard ErrorInfo structure that is returned from all I/O modules. The format is as follows: {ErrorLocation, Module, ErrorDescriptor} A string describing the error is obtained with the following call: Module:format_error(ErrorDescriptor) Notes The continuation of the first call to the re-entrant input functions must be [] . For a complete description of how the re-entrant input scheme works, see Armstrong, Virding and Williams: 'Concurrent Programming in Erlang', Chapter 13. See Also erl_anno(3) , erl_parse(3) , io(3)","ref":"erl_scan.html","title":"erl_scan","type":"module"},{"doc":"Returns the category of Token .","ref":"erl_scan.html#category/1","title":"erl_scan.category/1","type":"function"},{"doc":"Returns the column of Token 's collection of annotations.","ref":"erl_scan.html#column/1","title":"erl_scan.column/1","type":"function"},{"doc":"Returns the end location of the text of Token 's collection of annotations. If there is no text, undefined is returned.","ref":"erl_scan.html#end_location/1","title":"erl_scan.end_location/1","type":"function"},{"doc":"Uses an ErrorDescriptor and returns a string that describes the error or warning. This function is usually called implicitly when an ErrorInfo structure is processed (see section Error Information ).","ref":"erl_scan.html#format_error/1","title":"erl_scan.format_error/1","type":"function"},{"doc":"Returns the line of Token 's collection of annotations.","ref":"erl_scan.html#line/1","title":"erl_scan.line/1","type":"function"},{"doc":"Returns the location of Token 's collection of annotations.","ref":"erl_scan.html#location/1","title":"erl_scan.location/1","type":"function"},{"doc":"Returns true if Atom is an Erlang reserved word, otherwise false .","ref":"erl_scan.html#reserved_word/1","title":"erl_scan.reserved_word/1","type":"function"},{"doc":"Takes the list of characters String and tries to scan (tokenize) them. Returns one of the following: {ok, Tokens, EndLocation} Tokens are the Erlang tokens from String . EndLocation is the first location after the last token. {error, ErrorInfo, ErrorLocation} An error occurred. ErrorLocation is the first location after the erroneous token. string(String) is equivalent to string(String, 1) , and string(String, StartLocation) is equivalent to string(String, StartLocation, []) . StartLocation indicates the initial location when scanning starts. If StartLocation is a line, Anno , EndLocation , and ErrorLocation are lines. If StartLocation is a pair of a line and a column, Anno takes the form of an opaque compound data type, and EndLocation and ErrorLocation are pairs of a line and a column. The token annotations contain information about the column and the line where the token begins, as well as the text of the token (if option text is specified), all of which can be accessed by calling column/1 , line/1 , location/1 , and text/1 . A token is a tuple containing information about syntactic category, the token annotations, and the terminal symbol. For punctuation characters (such as ; and | ) and reserved words, the category and the symbol coincide, and the token is represented by a two-tuple. Three-tuples have one of the following forms: {atom, Anno, atom()} {char, Anno, char()} {comment, Anno, string()} {float, Anno, float()} {integer, Anno, integer()} {var, Anno, atom()} {white_space, Anno, string()} Valid options: {reserved_word_fun, reserved_word_fun()} A callback function that is called when the scanner has found an unquoted atom. If the function returns true , the unquoted atom itself becomes the category of the token. If the function returns false , atom becomes the category of the unquoted atom. return_comments Return comment tokens. return_white_spaces Return white space tokens. By convention, a newline character, if present, is always the first character of the text (there cannot be more than one newline in a white space token). return Short for [return_comments, return_white_spaces] . text Include the token text in the token annotation. The text is the part of the input corresponding to the token.","ref":"erl_scan.html#string/1","title":"erl_scan.string/1","type":"function"},{"doc":"","ref":"erl_scan.html#string/2","title":"erl_scan.string/2","type":"function"},{"doc":"","ref":"erl_scan.html#string/3","title":"erl_scan.string/3","type":"function"},{"doc":"Returns the symbol of Token .","ref":"erl_scan.html#symbol/1","title":"erl_scan.symbol/1","type":"function"},{"doc":"Returns the text of Token 's collection of annotations. If there is no text, undefined is returned.","ref":"erl_scan.html#text/1","title":"erl_scan.text/1","type":"function"},{"doc":"An opaque continuation. This is the re-entrant scanner, which scans characters until either a dot ('.' followed by a white space) or eof is reached. It returns: {done, Result, LeftOverChars} Indicates that there is sufficient input data to get a result. Result is: {ok, Tokens, EndLocation} The scanning was successful. Tokens is the list of tokens including dot . {eof, EndLocation} End of file was encountered before any more tokens. {error, ErrorInfo, EndLocation} An error occurred. LeftOverChars is the remaining characters of the input data, starting from EndLocation . {more, Continuation1} More data is required for building a term. Continuation1 must be passed in a new call to tokens/3,4 when more data is available. The CharSpec eof signals end of file. LeftOverChars then takes the value eof as well. tokens(Continuation, CharSpec, StartLocation) is equivalent to tokens(Continuation, CharSpec, StartLocation, []) . For a description of the options, see string/3 .","ref":"erl_scan.html#tokens/3","title":"erl_scan.tokens/3","type":"function"},{"doc":"","ref":"erl_scan.html#tokens/4","title":"erl_scan.tokens/4","type":"function"},{"doc":"","ref":"erl_scan.html#t:category/0","title":"erl_scan.category/0","type":"type"},{"doc":"","ref":"erl_scan.html#t:error_description/0","title":"erl_scan.error_description/0","type":"type"},{"doc":"","ref":"erl_scan.html#t:error_info/0","title":"erl_scan.error_info/0","type":"type"},{"doc":"","ref":"erl_scan.html#t:option/0","title":"erl_scan.option/0","type":"type"},{"doc":"","ref":"erl_scan.html#t:options/0","title":"erl_scan.options/0","type":"type"},{"doc":"","ref":"erl_scan.html#t:resword_fun/0","title":"erl_scan.resword_fun/0","type":"type"},{"doc":"","ref":"erl_scan.html#t:symbol/0","title":"erl_scan.symbol/0","type":"type"},{"doc":"","ref":"erl_scan.html#t:token/0","title":"erl_scan.token/0","type":"type"},{"doc":"","ref":"erl_scan.html#t:tokens/0","title":"erl_scan.tokens/0","type":"type"},{"doc":"","ref":"erl_scan.html#t:tokens_result/0","title":"erl_scan.tokens_result/0","type":"type"},{"doc":"This module archives and extract files to and from a tar file. This module supports reading most common tar formats, namely v7, STAR, USTAR, and PAX, as well as some of GNU tar's extensions to the USTAR format (sparse files most notably). It produces tar archives in USTAR format, unless the files being archived require PAX format due to restrictions in USTAR (such as unicode metadata, filename length, and more). As such, erl_tar supports tar archives produced by most all modern tar utilities, and produces tarballs which should be similarly portable. By convention, the name of a tar file is to end in &quot; .tar &quot;. To abide to the convention, add &quot; .tar &quot; to the name. Tar files can be created in one operation using function create/2 or create/3 . Alternatively, for more control, use functions open/2 , add/3,4 , and close/1 . To extract all files from a tar file, use function extract/1 . To extract only some files or to be able to specify some more options, use function extract/2 . To return a list of the files in a tar file, use function table/1 or table/2 . To print a list of files to the Erlang shell, use function t/1 or tt/1 . To convert an error term returned from one of the functions above to a readable message, use function format_error/1 . Unicode Support If file:native_name_encoding/0 returns utf8 , path names are encoded in UTF-8 when creating tar files, and path names are assumed to be encoded in UTF-8 when extracting tar files. If file:native_name_encoding/0 returns latin1 , no translation of path names is done. Unicode metadata stored in PAX headers is preserved Other Storage Media The ftp module normally accesses the tar file on disk using the file module. When other needs arise, you can define your own low-level Erlang functions to perform the writing and reading on the storage media; use function init/3 . An example of this is the SFTP support in ssh_sftp:open_tar/3 . This function opens a tar file on a remote machine using an SFTP channel. Limitations If you must remain compatible with the USTAR tar format, you must ensure file paths being stored are less than 255 bytes in total, with a maximum filename component length of 100 bytes. USTAR uses a header field (prefix) in addition to the name field, and splits file paths longer than 100 bytes into two parts. This split is done on a directory boundary, and is done in such a way to make the best use of the space available in those two fields, but in practice this will often mean that you have less than 255 bytes for a path. erl_tar will automatically upgrade the format to PAX to handle longer filenames, so this is only an issue if you need to extract the archive with an older implementation of erl_tar or tar which does not support PAX. In this case, the PAX headers will be extracted as regular files, and you will need to apply them manually. Like the above, if you must remain USTAR compatible, you must also ensure than paths for symbolic/hard links are no more than 100 bytes, otherwise PAX headers will be used.","ref":"erl_tar.html","title":"erl_tar","type":"module"},{"doc":"Adds a file to a tar file that has been opened for writing by open/1 . NameInArchive is the name under which the file becomes stored in the tar file. The file gets this name when it is extracted from the tar file. Options: dereference By default, symbolic links are stored as symbolic links in the tar file. To override the default and store the file that the symbolic link points to into the tar file, use option dereference . verbose Prints an informational message about the added file. {chunks,ChunkSize} Reads data in parts from the file. This is intended for memory-limited machines that, for example, builds a tar file on a remote machine over SFTP, see ssh_sftp:open_tar/3 . {atime,non_neg_integer()} Sets the last time, as POSIX time, when the file was read. See also file:read_file_info/1 . {mtime,non_neg_integer()} Sets the last time, as POSIX time, when the file was written. See also file:read_file_info/1 . {ctime,non_neg_integer()} Sets the time, as POSIX time, when the file was created. See also file:read_file_info/1 . {uid,non_neg_integer()} Sets the file owner. file:read_file_info/1 . {gid,non_neg_integer()} Sets the group that the file owner belongs to. file:read_file_info/1 .","ref":"erl_tar.html#add/3","title":"erl_tar.add/3","type":"function"},{"doc":"","ref":"erl_tar.html#add/4","title":"erl_tar.add/4","type":"function"},{"doc":"Closes a tar file opened by open/2 .","ref":"erl_tar.html#close/1","title":"erl_tar.close/1","type":"function"},{"doc":"Creates a tar file and archives the files whose names are specified in FileList into it. The files can either be read from disk or be specified as binaries.","ref":"erl_tar.html#create/2","title":"erl_tar.create/2","type":"function"},{"doc":"Creates a tar file and archives the files whose names are specified in FileList into it. The files can either be read from disk or be specified as binaries. The options in OptionList modify the defaults as follows: compressed The entire tar file is compressed, as if it has been run through the gzip program. To abide to the convention that a compressed tar file is to end in &quot; .tar.gz &quot; or &quot; .tgz &quot;, add the appropriate extension. cooked By default, function open/2 opens the tar file in raw mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding cooked to the mode list overrides the default and opens the tar file without option raw . dereference By default, symbolic links are stored as symbolic links in the tar file. To override the default and store the file that the symbolic link points to into the tar file, use option dereference . verbose Prints an informational message about each added file.","ref":"erl_tar.html#create/3","title":"erl_tar.create/3","type":"function"},{"doc":"Extracts all files from a tar archive. If argument Name is specified as {binary,Binary} , the contents of the binary is assumed to be a tar archive. If argument Name is specified as {file,Fd} , Fd is assumed to be a file descriptor returned from function file:open/2 . Otherwise, Name is to be a filename. Leading slashes in tar member names will be removed before writing the file. That is, absolute paths will be turned into relative paths. There will be an info message written to the error logger when paths are changed in this way. The compressed and cooked flags are invalid when passing a file descriptor with {file,Fd} . The file is assumed to have been opened with the appropriate flags.","ref":"erl_tar.html#extract/1","title":"erl_tar.extract/1","type":"function"},{"doc":"Extracts files from a tar archive. If argument Name is specified as {binary,Binary} , the contents of the binary is assumed to be a tar archive. If argument Name is specified as {file,Fd} , Fd is assumed to be a file descriptor returned from function file:open/2 . Otherwise, Name is to be a filename. The following options modify the defaults for the extraction as follows: {cwd,Cwd} Files with relative filenames are by default extracted to the current working directory. With this option, files are instead extracted into directory Cwd . {files,FileList} By default, all files are extracted from the tar file. With this option, only those files are extracted whose names are included in FileList . compressed With this option, the file is uncompressed while extracting. If the tar file is not compressed, this option is ignored. cooked By default, function open/2 function opens the tar file in raw mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding cooked to the mode list overrides the default and opens the tar file without option raw . memory Instead of extracting to a directory, this option gives the result as a list of tuples {Filename, Binary} , where Binary is a binary containing the extracted data of the file named Filename in the tar file. keep_old_files By default, all existing files with the same name as files in the tar file are overwritten. With this option, existing files are not overwriten. verbose Prints an informational message for each extracted file. The compressed and cooked flags are invalid when passing a file descriptor with {file,Fd} . The file is assumed to have been opened with the appropriate flags.","ref":"erl_tar.html#extract/2","title":"erl_tar.extract/2","type":"function"},{"doc":"Converts an error reason term to a human-readable error message string.","ref":"erl_tar.html#format_error/1","title":"erl_tar.format_error/1","type":"function"},{"doc":"The Fun is the definition of what to do when the different storage operations functions are to be called from the higher tar handling functions (such as add/3 , add/4 , and close/1 ). The Fun is called when the tar function wants to do a low-level operation, like writing a block to a file. The Fun is called as Fun(Op, {UserData,Parameters...}) , where Op is the operation name, UserData is the term passed as the first argument to init/1 and Parameters... are the data added by the tar function to be passed down to the storage handling function. Parameter UserData is typically the result of opening a low-level structure like a file descriptor or an SFTP channel id. The different Fun clauses operate on that very term. The following are the fun clauses parameter lists: (write, {UserData,DataToWrite}) Writes term DataToWrite using UserData . (close, UserData) Closes the access. (read2, {UserData,Size}) Reads using UserData but only Size bytes. Notice that there is only an arity-2 read function, not an arity-1 function. (position,{UserData,Position}) Sets the position of UserData as defined for files in file:position/2 Example: The following is a complete Fun parameter for reading and writing on files using the file module: ExampleFun = fun(write, {Fd,Data}) -&gt; file:write(Fd, Data); (position, {Fd,Pos}) -&gt; file:position(Fd, Pos); (read2, {Fd,Size}) -&gt; file:read(Fd, Size); (close, Fd) -&gt; file:close(Fd) end Here Fd was specified to function init/3 as: { ok , Fd } = file : open ( Name , . . . ) . { ok , TarDesc } = erl_tar : init ( Fd , [ write ] , ExampleFun ) , TarDesc is then used: erl_tar : add ( TarDesc , SomeValueIwantToAdd , FileNameInTarFile ) , . . . , erl_tar : close ( TarDesc ) When the erl_tar core wants to, for example, write a piece of Data , it would call ExampleFun(write, {UserData,Data}) . This example with the file module operations is not necessary to use directly, as that is what function open/2 in principle does. The TarDescriptor term is not a file descriptor. You are advised not to rely on the specific contents of this term, as it can change in future Erlang/OTP releases when more features are added to this module.","ref":"erl_tar.html#init/3","title":"erl_tar.init/3","type":"function"},{"doc":"Creates a tar file for writing (any existing file with the same name is truncated). By convention, the name of a tar file is to end in &quot; .tar &quot;. To abide to the convention, add &quot; .tar &quot; to the name. Except for the write atom, the following atoms can be added to OpenModeList : compressed The entire tar file is compressed, as if it has been run through the gzip program. To abide to the convention that a compressed tar file is to end in &quot; .tar.gz &quot; or &quot; .tgz &quot;, add the appropriate extension. cooked By default, the tar file is opened in raw mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding cooked to the mode list overrides the default and opens the tar file without option raw . To add one file at the time into an opened tar file, use function add/3,4 . When you are finished adding files, use function close/1 to close the tar file. The compressed and cooked flags are invalid when passing a file descriptor with {file,Fd} . The file must already be opened with the appropriate flags. The TarDescriptor term is not a file descriptor. You are advised not to rely on the specific contents of this term, as it can change in future Erlang/OTP releases when more features are added to this module.","ref":"erl_tar.html#open/2","title":"erl_tar.open/2","type":"function"},{"doc":"Prints the names of all files in the tar file Name to the Erlang shell (similar to &quot; tar t &quot;).","ref":"erl_tar.html#t/1","title":"erl_tar.t/1","type":"function"},{"doc":"Retrieves the names of all files in the tar file Name .","ref":"erl_tar.html#table/1","title":"erl_tar.table/1","type":"function"},{"doc":"","ref":"erl_tar.html#table/2","title":"erl_tar.table/2","type":"function"},{"doc":"Prints names and information about all files in the tar file Name to the Erlang shell (similar to &quot; tar tv &quot;).","ref":"erl_tar.html#tt/1","title":"erl_tar.tt/1","type":"function"},{"doc":"","ref":"erl_tar.html#t:name_in_archive/0","title":"erl_tar.name_in_archive/0","type":"type"},{"doc":"","ref":"erl_tar.html#t:open_type/0","title":"erl_tar.open_type/0","type":"type"},{"doc":"","ref":"erl_tar.html#t:tar_descriptor/0","title":"erl_tar.tar_descriptor/0","type":"opaque"},{"doc":"This module is an interface to the Erlang built-in term storage BIFs. These provide the ability to store very large quantities of data in an Erlang runtime system, and to have constant access time to the data. (In the case of ordered_set , see below, access time is proportional to the logarithm of the number of stored objects.) Data is organized as a set of dynamic tables, which can store tuples. Each table is created by a process. When the process terminates, the table is automatically destroyed. Every table has access rights set at creation. Tables are divided into four different types, set , ordered_set , bag , and duplicate_bag . A set or ordered_set table can only have one object associated with each key. A bag or duplicate_bag table can have many objects associated with each key. The number of tables stored at one Erlang node used to be limited. This is no longer the case (except by memory usage). The previous default limit was about 1400 tables and could be increased by setting the environment variable ERL_MAX_ETS_TABLES or the command line option +e before starting the Erlang runtime system. This hard limit has been removed, but it is currently useful to set the ERL_MAX_ETS_TABLES anyway. It should be set to an approximate of the maximum amount of tables used since an internal table for named tables is sized using this value. If large amounts of named tables are used and ERL_MAX_ETS_TABLES hasn't been increased, the performance of named table lookup will degrade. Notice that there is no automatic garbage collection for tables. Even if there are no references to a table from any process, it is not automatically destroyed unless the owner process terminates. To destroy a table explicitly, use function delete/1 . The default owner is the process that created the table. To transfer table ownership at process termination, use option heir or call give_away/3 . Some implementation details: In the current implementation, every object insert and look-up operation results in a copy of the object. '$end_of_table' is not to be used as a key, as this atom is used to mark the end of the table when using functions first/1 and next/2 . Notice the subtle difference between matching and comparing equal , which is demonstrated by table types set and ordered_set : Two Erlang terms match if they are of the same type and have the same value, so that 1 matches 1 , but not 1.0 (as 1.0 is a float() and not an integer() ). Two Erlang terms compare equal if they either are of the same type and value, or if both are numeric types and extend to the same value, so that 1 compares equal to both 1 and 1.0 . The ordered_set works on the Erlang term order and no defined order exists between an integer() and a float() that extends to the same value. Hence the key 1 and the key 1.0 are regarded as equal in an ordered_set table. Failures Functions in this module fail by raising an error exception with error reason: badarg If any argument has the wrong format. badarg If the table identifier is invalid. badarg If the operation is denied because of table access rights ( protected or private ). system_limit Modification of a value causes it to not be representable internally in the VM. For example, incrementation of a counter past the largest integer representable. system_limit If a match specification passed as argument has excessive nesting which causes scheduler stack exhaustion for the scheduler that the calling process is executing on. Scheduler stack size can be configured when starting the runtime system. Concurrency This module provides some limited support for concurrent access. All updates to single objects are guaranteed to be both atomic and isolated . This means that an updating operation to a single object either succeeds or fails completely without any effect (atomicity) and that no intermediate results of the update can be seen by other processes (isolation). Some functions that update many objects state that they even guarantee atomicity and isolation for the entire operation. In database terms the isolation level can be seen as &quot;serializable&quot;, as if all isolated operations are carried out serially, one after the other in a strict order. Table traversal There are different ways to traverse through the objects of a table. Single-step traversal one key at at time, using first/1 , next/2 , last/1 and prev/2 . Search with simple match patterns , using match/1/2/3 , match_delete/2 and match_object/1/2/3 . Search with more powerful match specifications , using select/1/2/3 , select_count/2 , select_delete/2 , select_replace/2 and select_reverse/1/2/3 . Table conversions , using tab2file/2/3 and tab2list/1 . No table traversal will guarantee a consistent snapshot of the entire table if the table is also updated by concurrent processes during the traversal. The result of each concurrently updated object may be seen (or not) depending on if it has happened when the traversal visits that part of the table. The only way to guarantee a full consistent table snapshot (if you really need that) is to disallow concurrent updates during the entire traversal. Moreover, traversals not done in a safe way, on tables where keys are inserted or deleted during the traversal, may yield the following undesired effects: Any key may be missed. Any key may be found more than once. The traversal may fail with badarg exception if keys are deleted. A table traversal is safe if either the table is of type ordered_set . the entire table traversal is done within one ETS function call. function safe_fixtable/2 is used to keep the table fixated during the entire traversal. Even though the access of a single object is always guaranteed to be atomic and isolated , each traversal through a table to find the next key is not done with such guarantees. This is often not a problem, but may cause rare subtle &quot;unexpected&quot; effects if a concurrent process inserts objects during a traversal. For example, consider one process doing ets : new ( t , [ ordered_set , named_table ] ) , ets : insert ( t , { 1 } ) , ets : insert ( t , { 2 } ) , ets : insert ( t , { 3 } ) , A concurrent call to ets:first(t) , done by another process, may then in rare cases return 2 even though 2 has never existed in the table ordered as the first key. In the same way, a concurrent call to ets:next(t, 1) may return 3 even though 3 never existed in the table ordered directly after 1 . Effects like this are improbable but possible. The probability will further be reduced (if not vanish) if table option write_concurrency is not enabled. This can also only be a potential concern for ordered_set where the traversal order is defined. Traversals using match and select functions may not need to scan the entire table depending on how the key is specified. A match pattern with a fully bound key (without any match variables) will optimize the operation to a single key lookup without any table traversal at all. For ordered_set a partially bound key will limit the traversal to only scan a subset of the table based on term order. A partially bound key is either a list or a tuple with a prefix that is fully bound. Example: 1 &gt; T = ets : new ( t , [ ordered_set ] ) , ets : insert ( T , { &quot;555-1234&quot; , &quot;John Smith&quot; } ) . true 2 &gt; %% Efficient search of all with area code 555 2 &gt; ets : match ( T , { [ $5 , $5 , $5 , $- | &#39;$1&#39; ] , &#39;$2&#39; } ) . [ [ &quot;1234&quot; , &quot;John Smith&quot; ] ] Match Specifications Some of the functions use a match specification , match_spec . For a brief explanation, see select/2 . For a detailed description, see section Match Specifications in Erlang in ERTS User's Guide. A match specifications with excessive nesting will cause a system_limit error exception to be raised.","ref":"ets.html","title":"ets","type":"module"},{"doc":"Returns a list of all tables at the node. Named tables are specified by their names, unnamed tables are specified by their table identifiers. There is no guarantee of consistency in the returned list. Tables created or deleted by other processes &quot;during&quot; the ets:all() call either are or are not included in the list. Only tables created/deleted before ets:all() is called are guaranteed to be included/excluded.","ref":"ets.html#all/0","title":"ets.all/0","type":"function"},{"doc":"Deletes the entire table Tab .","ref":"ets.html#delete/1","title":"ets.delete/1","type":"function"},{"doc":"Deletes all objects with key Key from table Tab .","ref":"ets.html#delete/2","title":"ets.delete/2","type":"function"},{"doc":"Delete all objects in the ETS table Tab . The operation is guaranteed to be atomic and isolated .","ref":"ets.html#delete_all_objects/1","title":"ets.delete_all_objects/1","type":"function"},{"doc":"Delete the exact object Object from the ETS table, leaving objects with the same key but other differences (useful for type bag ). In a duplicate_bag table, all instances of the object are deleted.","ref":"ets.html#delete_object/2","title":"ets.delete_object/2","type":"function"},{"doc":"Reads a file produced by tab2file/2 or tab2file/3 and creates the corresponding table Tab . Equivalent to file2tab(Filename, []) .","ref":"ets.html#file2tab/1","title":"ets.file2tab/1","type":"function"},{"doc":"Reads a file produced by tab2file/2 or tab2file/3 and creates the corresponding table Tab . The only supported option is {verify,boolean()} . If verification is turned on (by specifying {verify,true} ), the function uses whatever information is present in the file to assert that the information is not damaged. How this is done depends on which extended_info was written using tab2file/3 . If no extended_info is present in the file and {verify,true} is specified, the number of objects written is compared to the size of the original table when the dump was started. This can make verification fail if the table was public and objects were added or removed while the table was dumped to file. To avoid this problem, either do not verify files dumped while updated simultaneously or use option {extended_info, [object_count]} to tab2file/3 , which extends the information in the file with the number of objects written. If verification is turned on and the file was written with option {extended_info, [md5sum]} , reading the file is slower and consumes radically more CPU time than otherwise. {verify,false} is the default.","ref":"ets.html#file2tab/2","title":"ets.file2tab/2","type":"function"},{"doc":"Returns the first key Key in table Tab . For an ordered_set table, the first key in Erlang term order is returned. For other table types, the first key according to the internal order of the table is returned. If the table is empty, '$end_of_table' is returned. To find subsequent keys in the table, use next/2 .","ref":"ets.html#first/1","title":"ets.first/1","type":"function"},{"doc":"Acc0 is returned if the table is empty. This function is similar to lists:foldl/3 . The table elements are traversed in an unspecified order, except for ordered_set tables, where they are traversed first to last. If Function inserts objects into the table, or another process inserts objects into the table, those objects can (depending on key ordering) be included in the traversal.","ref":"ets.html#foldl/3","title":"ets.foldl/3","type":"function"},{"doc":"Acc0 is returned if the table is empty. This function is similar to lists:foldr/3 . The table elements are traversed in an unspecified order, except for ordered_set tables, where they are traversed last to first. If Function inserts objects into the table, or another process inserts objects into the table, those objects can (depending on key ordering) be included in the traversal.","ref":"ets.html#foldr/3","title":"ets.foldr/3","type":"function"},{"doc":"Fills an already created ETS table with the objects in the already opened Dets table DetsTab . Existing objects in the ETS table are kept unless overwritten. If any of the tables does not exist or the Dets table is not open, a badarg exception is raised.","ref":"ets.html#from_dets/2","title":"ets.from_dets/2","type":"function"},{"doc":"Pseudo function that by a parse_transform translates LiteralFun typed as parameter in the function call to a match specification . With &quot;literal&quot; is meant that the fun must textually be written as the parameter of the function, it cannot be held in a variable that in turn is passed to the function. The parse transform is provided in the ms_transform module and the source must include file ms_transform.hrl in STDLIB for this pseudo function to work. Failing to include the hrl file in the source results in a runtime error, not a compile time error. The include file is easiest included by adding line -include_lib(&quot;stdlib/include/ms_transform.hrl&quot;). to the source file. The fun is very restricted, it can take only a single parameter (the object to match): a sole variable or a tuple. It must use the is_ guard tests. Language constructs that have no representation in a match specification ( if , case , receive , and so on) are not allowed. The return value is the resulting match specification. Example: 1 &gt; ets : fun2ms ( fun ( { M , N } ) when N &gt; 3 -&gt; M end ) . [ { { &#39;$1&#39; , &#39;$2&#39; } , [ { &#39;&gt;&#39; , &#39;$2&#39; , 3 } ] , [ &#39;$1&#39; ] } ] Variables from the environment can be imported, so that the following works: 2 &gt; X = 3 . 3 3 &gt; ets : fun2ms ( fun ( { M , N } ) when N &gt; X -&gt; M end ) . [ { { &#39;$1&#39; , &#39;$2&#39; } , [ { &#39;&gt;&#39; , &#39;$2&#39; , { const , 3 } } ] , [ &#39;$1&#39; ] } ] The imported variables are replaced by match specification const expressions, which is consistent with the static scoping for Erlang funs. However, local or global function calls cannot be in the guard or body of the fun. Calls to built-in match specification functions is of course allowed: 4 &gt; ets : fun2ms ( fun ( { M , N } ) when N &gt; X , my_fun ( M ) -&gt; M end ) . Error : fun containing local Erlang function calls ( &#39;my_fun&#39; called in guard ) cannot be translated into match_spec { error , transform_error } 5 &gt; ets : fun2ms ( fun ( { M , N } ) when N &gt; X , is_atom ( M ) -&gt; M end ) . [ { { &#39;$1&#39; , &#39;$2&#39; } , [ { &#39;&gt;&#39; , &#39;$2&#39; , { const , 3 } } , { is_atom , &#39;$1&#39; } ] , [ &#39;$1&#39; ] } ] As shown by the example, the function can be called from the shell also. The fun must be literally in the call when used from the shell as well. If the parse_transform is not applied to a module that calls this pseudo function, the call fails in runtime (with a badarg ). The ets module exports a function with this name, but it is never to be called except when using the function in the shell. If the parse_transform is properly applied by including header file ms_transform.hrl , compiled code never calls the function, but the function call is replaced by a literal match specification. For more information, see ms_transform(3) .","ref":"ets.html#fun2ms/1","title":"ets.fun2ms/1","type":"function"},{"doc":"Make process Pid the new owner of table Tab . If successful, message {'ETS-TRANSFER',Tab,FromPid,GiftData} is sent to the new owner. The process Pid must be alive, local, and not already the owner of the table. The calling process must be the table owner. Notice that this function does not affect option heir of the table. A table owner can, for example, set heir to itself, give the table away, and then get it back if the receiver terminates.","ref":"ets.html#give_away/3","title":"ets.give_away/3","type":"function"},{"doc":"Displays information about all ETS tables on a terminal.","ref":"ets.html#i/0","title":"ets.i/0","type":"function"},{"doc":"Browses table Tab on a terminal.","ref":"ets.html#i/1","title":"ets.i/1","type":"function"},{"doc":"Returns information about table Tab as a list of tuples. If Tab has the correct type for a table identifier, but does not refer to an existing ETS table, undefined is returned. If Tab is not of the correct type, a badarg exception is raised. {compressed, boolean()} Indicates if the table is compressed. {decentralized_counters, boolean()} Indicates whether the table uses decentralized_counters . {heir, pid() | none} The pid of the heir of the table, or none if no heir is set. {id, tid() } The table identifier. {keypos, integer() &gt;= 1} The key position. {memory, integer() &gt;= 0 The number of words allocated to the table. {name, atom()} The table name. {named_table, boolean()} Indicates if the table is named. {node, node()} The node where the table is stored. This field is no longer meaningful, as tables cannot be accessed from other nodes. {owner, pid()} The pid of the owner of the table. {protection, access() } The table access rights. {size, integer() &gt;= 0 The number of objects inserted in the table. {type, type() } The table type. {read_concurrency, boolean()} Indicates whether the table uses read_concurrency or not. {write_concurrency, boolean()} Indicates whether the table uses write_concurrency . The execution time of this function is affected by the decentralized_counters table option. The execution time is much longer when the decentralized_counters option is set to true than when the decentralized_counters option is set to false .","ref":"ets.html#info/1","title":"ets.info/1","type":"function"},{"doc":"Returns the information associated with Item for table Tab , or returns undefined if Tab does not refer an existing ETS table. If Tab is not of the correct type, or if Item is not one of the allowed values, a badarg exception is raised. In addition to the {Item,Value} pairs defined for info/1 , the following items are allowed: Item=binary, Value=BinInfo BinInfo is a list containing miscellaneous information about binaries kept by the table. This Item can be changed or removed without prior notice. In the current implementation BinInfo is a list of tuples {BinaryId,BinarySize,BinaryRefcCount} . Item=fixed, Value=boolean() Indicates if the table is fixed by any process. Item=safe_fixed|safe_fixed_monotonic_time, Value={FixationTime,Info}|false If the table is fixed using safe_fixtable/2 , the call returns a tuple where FixationTime is the last time when the table changed from unfixed to fixed. The format and value of FixationTime depends on Item : safe_fixed FixationTime corresponds to the result returned by erlang:timestamp/0 at the time of fixation. Notice that when the system uses single or multi time warp modes this can produce strange results, as the use of safe_fixed is not time warp safe. Time warp safe code must use safe_fixed_monotonic_time instead. safe_fixed_monotonic_time FixationTime corresponds to the result returned by erlang:monotonic_time/0 at the time of fixation. The use of safe_fixed_monotonic_time is time warp safe. Info is a possibly empty lists of tuples {Pid,RefCount} , one tuple for every process the table is fixed by now. RefCount is the value of the reference counter and it keeps track of how many times the table has been fixed by the process. Table fixations are not limited to safe_fixtable/2 . Temporary fixations may also be done by for example traversing functions like select and match . Such table fixations are automatically released before the corresponding functions returns, but they may be seen by a concurrent call to ets:info(T,safe_fixed|safe_fixed_monotonic_time) . If the table is not fixed at all, the call returns false . Item=stats, Value=tuple() Returns internal statistics about tables on an internal format used by OTP test suites. Not for production use. The execution time of this function is affected by the decentralized_counters table option when the second argument of the function is size or memory . The execution time is much longer when the decentralized_counters option is set to true than when the decentralized_counters option is set to false .","ref":"ets.html#info/2","title":"ets.info/2","type":"function"},{"doc":"Replaces the existing objects of table Tab with objects created by calling the input function InitFun , see below. This function is provided for compatibility with the dets module, it is not more efficient than filling a table by using insert/2 . When called with argument read , the function InitFun is assumed to return end_of_input when there is no more input, or {Objects, Fun} , where Objects is a list of objects and Fun is a new input function. Any other value Value is returned as an error {error, {init_fun, Value}} . Each input function is called exactly once, and if an error occur, the last function is called with argument close , the reply of which is ignored. If the table type is set and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. This holds also for duplicated objects stored in tables of type bag .","ref":"ets.html#init_table/2","title":"ets.init_table/2","type":"function"},{"doc":"Inserts the object or all of the objects in list ObjectOrObjects into table Tab . If the table type is set and the key of the inserted objects matches the key of any object in the table, the old object is replaced. If the table type is ordered_set and the key of the inserted object compares equal to the key of any object in the table, the old object is replaced. If the list contains more than one object with matching keys and the table type is set , one is inserted, which one is not defined. The same holds for table type ordered_set if the keys compare equal . The entire operation is guaranteed to be atomic and isolated , even when a list of objects is inserted.","ref":"ets.html#insert/2","title":"ets.insert/2","type":"function"},{"doc":"Same as insert/2 except that instead of overwriting objects with the same key (for set or ordered_set ) or adding more objects with keys already existing in the table (for bag and duplicate_bag ), false is returned. If ObjectOrObjects is a list, the function checks every key before inserting anything. Nothing is inserted unless all keys present in the list are absent from the table. Like insert/2 , the entire operation is guaranteed to be atomic and isolated .","ref":"ets.html#insert_new/2","title":"ets.insert_new/2","type":"function"},{"doc":"Checks if a term represent a valid compiled match specification . A compiled match specifications is only valid on the Erlang node where it was compiled by calling match_spec_compile/1 . Before STDLIB 3.4 (OTP 20.0) compiled match specifications did not have an external representation. If passed through binary_to_term(term_to_binary(CMS)) or sent to another node and back, the result was always an empty binary &lt;&lt;&gt;&gt; . After STDLIB 3.4 (OTP 20.0) compiled match specifications have an external representation as a node specific reference to the original compiled match specification. If passed through binary_to_term(term_to_binary(CMS)) or sent to another node and back, the result may or may not be a valid compiled match specification depending on if the original compiled match specification was still alive.","ref":"ets.html#is_compiled_ms/1","title":"ets.is_compiled_ms/1","type":"function"},{"doc":"Returns the last key Key according to Erlang term order in table Tab of type ordered_set . For other table types, the function is synonymous to first/1 . If the table is empty, '$end_of_table' is returned. To find preceding keys in the table, use prev/2 .","ref":"ets.html#last/1","title":"ets.last/1","type":"function"},{"doc":"Returns a list of all objects with key Key in table Tab . For tables of type set , bag , or duplicate_bag , an object is returned only if the specified key matches the key of the object in the table. For tables of type ordered_set , an object is returned if the specified key compares equal to the key of an object in the table. The difference is the same as between =:= and == . As an example, one can insert an object with integer() 1 as a key in an ordered_set and get the object returned as a result of doing a lookup/2 with float() 1.0 as the key to search for. For tables of type set or ordered_set , the function returns either the empty list or a list with one element, as there cannot be more than one object with the same key. For tables of type bag or duplicate_bag , the function returns a list of arbitrary length. Notice that the time order of object insertions is preserved; the first object inserted with the specified key is the first in the resulting list, and so on. Insert and lookup times in tables of type set , bag , and duplicate_bag are constant, regardless of the table size. For the ordered_set datatype, time is proportional to the (binary) logarithm of the number of objects.","ref":"ets.html#lookup/2","title":"ets.lookup/2","type":"function"},{"doc":"For a table Tab of type set or ordered_set , the function returns the Pos :th element of the object with key Key . For tables of type bag or duplicate_bag , the functions returns a list with the Pos :th element of every object with key Key . If no object with key Key exists, the function exits with reason badarg . The difference between set , bag , and duplicate_bag on one hand, and ordered_set on the other, regarding the fact that ordered_set view keys as equal when they compare equal whereas the other table types regard them equal only when they match , holds for lookup_element/3 .","ref":"ets.html#lookup_element/3","title":"ets.lookup_element/3","type":"function"},{"doc":"Continues a match started with match/3 . The next chunk of the size specified in the initial match/3 call is returned together with a new Continuation , which can be used in subsequent calls to this function. When there are no more objects in the table, '$end_of_table' is returned.","ref":"ets.html#match/1","title":"ets.match/1","type":"function"},{"doc":"Matches the objects in table Tab against pattern Pattern . A pattern is a term that can contain: Bound parts (Erlang terms) '_' that matches any Erlang term Pattern variables '$N' , where N =0,1,... The function returns a list with one element for each matching object, where each element is an ordered list of pattern variable bindings, for example: 6 &gt; ets : match ( T , &#39;$1&#39; ) . % Matches every object in table [ [ { rufsen , dog , 7 } ] , [ { brunte , horse , 5 } ] , [ { ludde , dog , 5 } ] ] 7 &gt; ets : match ( T , { &#39;_&#39; , dog , &#39;$1&#39; } ) . [ [ 7 ] , [ 5 ] ] 8 &gt; ets : match ( T , { &#39;_&#39; , cow , &#39;$1&#39; } ) . [ ] If the key is specified in the pattern, the match is very efficient. If the key is not specified, that is, if it is a variable or an underscore, the entire table must be searched. The search time can be substantial if the table is very large. For tables of type ordered_set , the result is in the same order as in a first / next traversal.","ref":"ets.html#match/2","title":"ets.match/2","type":"function"},{"doc":"Works like match/2 , but returns only a limited ( Limit ) number of matching objects. Term Continuation can then be used in subsequent calls to match/1 to get the next chunk of matching objects. This is a space-efficient way to work on objects in a table, which is faster than traversing the table object by object using first/1 and next/2 . If the table is empty, '$end_of_table' is returned. Use safe_fixtable/2 to guarantee safe traversal for subsequent calls to match/1 .","ref":"ets.html#match/3","title":"ets.match/3","type":"function"},{"doc":"Deletes all objects that match pattern Pattern from table Tab . For a description of patterns, see match/2 .","ref":"ets.html#match_delete/2","title":"ets.match_delete/2","type":"function"},{"doc":"Continues a match started with match_object/3 . The next chunk of the size specified in the initial match_object/3 call is returned together with a new Continuation , which can be used in subsequent calls to this function. When there are no more objects in the table, '$end_of_table' is returned.","ref":"ets.html#match_object/1","title":"ets.match_object/1","type":"function"},{"doc":"Matches the objects in table Tab against pattern Pattern . For a description of patterns, see match/2 . The function returns a list of all objects that match the pattern. If the key is specified in the pattern, the match is very efficient. If the key is not specified, that is, if it is a variable or an underscore, the entire table must be searched. The search time can be substantial if the table is very large. For tables of type ordered_set , the result is in the same order as in a first / next traversal.","ref":"ets.html#match_object/2","title":"ets.match_object/2","type":"function"},{"doc":"Works like match_object/2 , but only returns a limited ( Limit ) number of matching objects. Term Continuation can then be used in subsequent calls to match_object/1 to get the next chunk of matching objects. This is a space-efficient way to work on objects in a table, which is faster than traversing the table object by object using first/1 and next/2 . If the table is empty, '$end_of_table' is returned. Use safe_fixtable/2 to guarantee safe traversal for subsequent calls to match_object/1 .","ref":"ets.html#match_object/3","title":"ets.match_object/3","type":"function"},{"doc":"Transforms a match specification into an internal representation that can be used in subsequent calls to match_spec_run/2 . The internal representation is opaque. To check the validity of a compiled match specification, use is_compiled_ms/1 . If term MatchSpec does not represent a valid match specification, a badarg exception is raised. This function has limited use in normal code. It is used by the dets module to perform the dets:select() operations.","ref":"ets.html#match_spec_compile/1","title":"ets.match_spec_compile/1","type":"function"},{"doc":"Executes the matching specified in a compiled match specification on a list of terms. Term CompiledMatchSpec is to be the result of a call to match_spec_compile/1 and is hence the internal representation of the match specification one wants to use. The matching is executed on each element in List and the function returns a list containing all results. If an element in List does not match, nothing is returned for that element. The length of the result list is therefore equal or less than the length of parameter List . Example: The following two calls give the same result (but certainly not the same execution time): Table = ets:new... MatchSpec = ... % The following call... ets:match_spec_run(ets:tab2list(Table), ets:match_spec_compile(MatchSpec)), % ...gives the same result as the more common (and more efficient) ets:select(Table, MatchSpec), This function has limited use in normal code. It is used by the dets module to perform the dets:select() operations and by Mnesia during transactions.","ref":"ets.html#match_spec_run/2","title":"ets.match_spec_run/2","type":"function"},{"doc":"Works like lookup/2 , but does not return the objects. Returns true if one or more elements in the table has key Key , otherwise false .","ref":"ets.html#member/2","title":"ets.member/2","type":"function"},{"doc":"Creates a new table and returns a table identifier that can be used in subsequent operations. The table identifier can be sent to other processes so that a table can be shared between different processes within a node. Parameter Options is a list of options that specifies table type, access rights, key position, and whether the table is named. Default values are used for omitted options. This means that not specifying any options ( [] ) is the same as specifying [set, protected, {keypos,1}, {heir,none}, {write_concurrency,false}, {read_concurrency,false}, {decentralized_counters,false}] . set The table is a set table: one key, one object, no order among objects. This is the default table type. ordered_set The table is a ordered_set table: one key, one object, ordered in Erlang term order, which is the order implied by the &lt; and &gt; operators. Tables of this type have a somewhat different behavior in some situations than tables of other types. Most notably, the ordered_set tables regard keys as equal when they compare equal , not only when they match. This means that to an ordered_set table, integer() 1 and float() 1.0 are regarded as equal. This also means that the key used to lookup an element not necessarily matches the key in the returned elements, if float() 's and integer() 's are mixed in keys of a table. bag The table is a bag table, which can have many objects, but only one instance of each object, per key. duplicate_bag The table is a duplicate_bag table, which can have many objects, including multiple copies of the same object, per key. public Any process can read or write to the table. protected The owner process can read and write to the table. Other processes can only read the table. This is the default setting for the access rights. private Only the owner process can read or write to the table. named_table If this option is present, the table is registered under its Name which can then be used instead of the table identifier in subsequent operations. The function will also return the Name instead of the table identifier. To get the table identifier of a named table, use whereis/1 . {keypos,Pos} Specifies which element in the stored tuples to use as key. By default, it is the first element, that is, Pos=1 . However, this is not always appropriate. In particular, we do not want the first element to be the key if we want to store Erlang records in a table. Notice that any tuple stored in the table must have at least Pos number of elements. {heir,Pid,HeirData} | {heir,none} Set a process as heir. The heir inherits the table if the owner terminates. Message {'ETS-TRANSFER',tid(),FromPid,HeirData} is sent to the heir when that occurs. The heir must be a local process. Default heir is none , which destroys the table when the owner terminates. {write_concurrency,boolean()} Performance tuning. Defaults to false , in which case an operation that mutates (writes to) the table obtains exclusive access, blocking any concurrent access of the same table until finished. If set to true , the table is optimized to concurrent write access. Different objects of the same table can be mutated (and read) by concurrent processes. This is achieved to some degree at the expense of memory consumption and the performance of sequential access and concurrent reading. The write_concurrency option can be combined with the options read_concurrency and decentralized_counters . You typically want to combine write_concurrency with read_concurrency when large concurrent read bursts and large concurrent write bursts are common; for more information, see option read_concurrency . The decentralized_counters option is turned on by default for tables of type ordered_set with the write_concurrency option enabled, and the decentralized_counters option is turned off by default for all other table types. For more information, see the documentation for the decentralized_counters option. Notice that this option does not change any guarantees about atomicity and isolation . Functions that makes such promises over many objects (like insert/2 ) gain less (or nothing) from this option. The memory consumption inflicted by both write_concurrency and read_concurrency is a constant overhead per table for set , bag and duplicate_bag . For ordered_set the memory overhead depends on the number of inserted objects and the amount of actual detected concurrency in runtime. The memory overhead can be especially large when both options are combined. Prior to stdlib-3.7 (OTP-22.0) write_concurrency had no effect on ordered_set . {read_concurrency,boolean()} Performance tuning. Defaults to false . When set to true , the table is optimized for concurrent read operations. When this option is enabled read operations become much cheaper; especially on systems with multiple physical processors. However, switching between read and write operations becomes more expensive. You typically want to enable this option when concurrent read operations are much more frequent than write operations, or when concurrent reads and writes comes in large read and write bursts (that is, many reads not interrupted by writes, and many writes not interrupted by reads). You typically do not want to enable this option when the common access pattern is a few read operations interleaved with a few write operations repeatedly. In this case, you would get a performance degradation by enabling this option. Option read_concurrency can be combined with option write_concurrency . You typically want to combine these when large concurrent read bursts and large concurrent write bursts are common. {decentralized_counters,boolean()} Performance tuning. Defaults to true for tables of type ordered_set with the write_concurrency option enabled, and defaults to false for all other table types. This option has no effect if the write_concurrency option is set to false . When this option is set to true , the table is optimized for frequent concurrent calls to operations that modify the tables size and/or its memory consumption (e.g., insert/2 and delete/2 ). The drawback is that calls to info/1 and info/2 with size or memory as the second argument can get much slower when the decentralized_counters option is turned on. When this option is enabled the counters for the table size and memory consumption are distributed over several cache lines and the scheduling threads are mapped to one of those cache lines. The erl option +dcg can be used to control the number of cache lines that the counters are distributed over. compressed If this option is present, the table data is stored in a more compact format to consume less memory. However, it will make table operations slower. Especially operations that need to inspect entire objects, such as match and select , get much slower. The key element is not compressed.","ref":"ets.html#new/2","title":"ets.new/2","type":"function"},{"doc":"Returns the next key Key2 , following key Key1 in table Tab . For table type ordered_set , the next key in Erlang term order is returned. For other table types, the next key according to the internal order of the table is returned. If no next key exists, '$end_of_table' is returned. To find the first key in the table, use first/1 . Unless a table of type set , bag , or duplicate_bag is fixated using safe_fixtable/2 , a call to next/2 will fail if Key1 no longer exists in the table. For table type ordered_set , the function always returns the next key after Key1 in term order, regardless whether Key1 ever existed in the table.","ref":"ets.html#next/2","title":"ets.next/2","type":"function"},{"doc":"Returns the previous key Key2 , preceding key Key1 according to Erlang term order in table Tab of type ordered_set . For other table types, the function is synonymous to next/2 . If no previous key exists, '$end_of_table' is returned. To find the last key in an ordered_set table, use last/1 .","ref":"ets.html#prev/2","title":"ets.prev/2","type":"function"},{"doc":"Renames the named table Tab to the new name Name . Afterwards, the old name cannot be used to access the table. Renaming an unnamed table has no effect.","ref":"ets.html#rename/2","title":"ets.rename/2","type":"function"},{"doc":"Restores an opaque continuation returned by select/3 or select/1 if the continuation has passed through external term format (been sent between nodes or stored on disk). The reason for this function is that continuation terms contain compiled match specifications and may therefore be invalidated if converted to external term format. Given that the original match specification is kept intact, the continuation can be restored, meaning it can once again be used in subsequent select/1 calls even though it has been stored on disk or on another node. Examples: The following sequence of calls may fail: T=ets:new(x,[]), ... MS = ets:fun2ms(fun({N,_}=A) when (N rem 10) =:= 0 -&gt; A end), {_,C} = ets:select(T, MS, 10), MaybeBroken = binary_to_term(term_to_binary(C)), ets:select(MaybeBroken). The following sequence works, as the call to repair_continuation/2 reestablishes the MaybeBroken continuation. T=ets:new(x,[]), ... MS = ets:fun2ms(fun({N,_}=A) when (N rem 10) =:= 0 -&gt; A end), {_,C} = ets:select(T,MS,10), MaybeBroken = binary_to_term(term_to_binary(C)), ets:select(ets:repair_continuation(MaybeBroken,MS)). This function is rarely needed in application code. It is used by Mnesia to provide distributed select/3 and select/1 sequences. A normal application would either use Mnesia or keep the continuation from being converted to external format. The actual behavior of compiled match specifications when recreated from external format has changed and may change in future releases, but this interface remains for backward compatibility. See is_compiled_ms/1 .","ref":"ets.html#repair_continuation/2","title":"ets.repair_continuation/2","type":"function"},{"doc":"Fixes a table of type set , bag , or duplicate_bag for safe traversal using first/1 &amp; next/2 , match/3 &amp; match/1 , match_object/3 &amp; match_object/1 , or select/3 &amp; select/1 . A process fixes a table by calling safe_fixtable(Tab, true) . The table remains fixed until the process releases it by calling safe_fixtable(Tab, false) , or until the process terminates. If many processes fix a table, the table remains fixed until all processes have released it (or terminated). A reference counter is kept on a per process basis, and N consecutive fixes requires N releases to release the table. When a table is fixed, a sequence of first/1 and next/2 calls are guaranteed to succeed even if keys are removed during the traversal. The keys for objects inserted or deleted during a traversal may or may not be returned by next/2 depending on the ordering of keys within the table and if the key exists at the time next/2 is called. Example: clean_all_with_value(Tab,X) -&gt; safe_fixtable(Tab,true), clean_all_with_value(Tab,X,ets:first(Tab)), safe_fixtable(Tab,false). clean_all_with_value(Tab,X,'$end_of_table') -&gt; true; clean_all_with_value(Tab,X,Key) -&gt; case ets:lookup(Tab,Key) of [{Key,X}] -&gt; ets:delete(Tab,Key); _ -&gt; true end, clean_all_with_value(Tab,X,ets:next(Tab,Key)). Notice that deleted objects are not freed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects is never freed. The performance of operations on the table also degrades significantly. To retrieve information about which processes have fixed which tables, use info(Tab, safe_fixed_monotonic_time) . A system with many processes fixing tables can need a monitor that sends alarms when tables have been fixed for too long. Notice that safe_fixtable/2 is not necessary for table type ordered_set and for traversals done by a single ETS function call, like select/2 .","ref":"ets.html#safe_fixtable/2","title":"ets.safe_fixtable/2","type":"function"},{"doc":"Continues a match started with select/3 . The next chunk of the size specified in the initial select/3 call is returned together with a new Continuation , which can be used in subsequent calls to this function. When there are no more objects in the table, '$end_of_table' is returned.","ref":"ets.html#select/1","title":"ets.select/1","type":"function"},{"doc":"Matches the objects in table Tab using a match specification . This is a more general call than match/2 and match_object/2 calls. In its simplest form, the match specification is as follows: MatchSpec = [MatchFunction] MatchFunction = {MatchHead, [Guard], [Result]} MatchHead = &quot;Pattern as in ets:match&quot; Guard = {&quot;Guardtest name&quot;, ...} Result = &quot;Term construct&quot; This means that the match specification is always a list of one or more tuples (of arity 3). The first element of the tuple is to be a pattern as described in match/2 . The second element of the tuple is to be a list of 0 or more guard tests (described below). The third element of the tuple is to be a list containing a description of the value to return. In almost all normal cases, the list contains exactly one term that fully describes the value to return for each object. The return value is constructed using the &quot;match variables&quot; bound in MatchHead or using the special match variables '$_' (the whole matching object) and '$$' (all match variables in a list), so that the following match/2 expression: ets:match(Tab,{'$1','$2','$3'}) is exactly equivalent to: ets:select(Tab,[{{'$1','$2','$3'},[],['$$']}]) And that the following match_object/2 call: ets:match_object(Tab,{'$1','$2','$1'}) is exactly equivalent to ets:select(Tab,[{{'$1','$2','$1'},[],['$_']}]) Composite terms can be constructed in the Result part either by simply writing a list, so that the following code: ets:select(Tab,[{{'$1','$2','$3'},[],['$$']}]) gives the same output as: ets:select(Tab,[{{'$1','$2','$3'},[],[['$1','$2','$3']]}]) That is, all the bound variables in the match head as a list. If tuples are to be constructed, one has to write a tuple of arity 1 where the single element in the tuple is the tuple one wants to construct (as an ordinary tuple can be mistaken for a Guard ). Therefore the following call: ets:select(Tab,[{{'$1','$2','$1'},[],['$_']}]) gives the same output as: ets:select(Tab,[{{'$1','$2','$1'},[],[{{'$1','$2','$3'}}]}]) This syntax is equivalent to the syntax used in the trace patterns (see the dbg(3) ) module in Runtime_Tools. The Guard s are constructed as tuples, where the first element is the test name and the remaining elements are the test parameters. To check for a specific type (say a list) of the element bound to the match variable '$1' , one would write the test as {is_list, '$1'} . If the test fails, the object in the table does not match and the next MatchFunction (if any) is tried. Most guard tests present in Erlang can be used, but only the new versions prefixed is_ are allowed ( is_float , is_atom , and so on). The Guard section can also contain logic and arithmetic operations, which are written with the same syntax as the guard tests (prefix notation), so that the following guard test written in Erlang: is_integer(X), is_integer(Y), X + Y &lt; 4711 is expressed as follows ( X replaced with '$1' and Y with '$2' ): [{is_integer, '$1'}, {is_integer, '$2'}, {'&lt;', {'+', '$1', '$2'}, 4711}] For tables of type ordered_set , objects are visited in the same order as in a first / next traversal. This means that the match specification is executed against objects with keys in the first / next order and the corresponding result list is in the order of that execution.","ref":"ets.html#select/2","title":"ets.select/2","type":"function"},{"doc":"Works like select/2 , but only returns a limited ( Limit ) number of matching objects. Term Continuation can then be used in subsequent calls to select/1 to get the next chunk of matching objects. This is a space-efficient way to work on objects in a table, which is still faster than traversing the table object by object using first/1 and next/2 . If the table is empty, '$end_of_table' is returned. Use safe_fixtable/2 to guarantee safe traversal for subsequent calls to select/1 .","ref":"ets.html#select/3","title":"ets.select/3","type":"function"},{"doc":"Matches the objects in table Tab using a match specification . If the match specification returns true for an object, that object considered a match and is counted. For any other result from the match specification the object is not considered a match and is therefore not counted. This function can be described as a select_delete/2 function that does not delete any elements, but only counts them. The function returns the number of objects matched.","ref":"ets.html#select_count/2","title":"ets.select_count/2","type":"function"},{"doc":"Matches the objects in table Tab using a match specification . If the match specification returns true for an object, that object is removed from the table. For any other result from the match specification the object is retained. This is a more general call than the match_delete/2 call. The function returns the number of objects deleted from the table. The match specification has to return the atom true if the object is to be deleted. No other return value gets the object deleted. So one cannot use the same match specification for looking up elements as for deleting them.","ref":"ets.html#select_delete/2","title":"ets.select_delete/2","type":"function"},{"doc":"Matches the objects in the table Tab using a match specification . For each matched object, the existing object is replaced with the match specification result. The match-and-replace operation for each individual object is guaranteed to be atomic and isolated . The select_replace table traversal as a whole, like all other select functions, does not give such guarantees. The match specifiction must be guaranteed to retain the key of any matched object. If not, select_replace will fail with badarg without updating any objects. For the moment, due to performance and semantic constraints, tables of type bag are not yet supported. The function returns the total number of replaced objects. Example For all 2-tuples with a list in second position, add atom 'marker' first in the list: 1 &gt; T = ets : new ( x , [ ] ) , ets : insert ( T , { key , [ 1 , 2 , 3 ] } ) . true 2 &gt; MS = ets : fun2ms ( fun ( { K , L } ) when is_list ( L ) -&gt; { K , [ marker | L ] } end ) . [ { { &#39;$1&#39; , &#39;$2&#39; } , [ { is_list , &#39;$2&#39; } ] , [ { { &#39;$1&#39; , [ marker | &#39;$2&#39; ] } } ] } ] 3 &gt; ets : select_replace ( T , MS ) . 1 4 &gt; ets : tab2list ( T ) . [ { key , [ marker , 1 , 2 , 3 ] } ] A generic single object compare-and-swap operation: [ Old ] = ets : lookup ( T , Key ) , New = update_object ( Old ) , Success = ( 1 =:= ets : select_replace ( T , [ { Old , [ ] , [ { const , New } ] } ] ) ) ,","ref":"ets.html#select_replace/2","title":"ets.select_replace/2","type":"function"},{"doc":"Continues a match started with select_reverse/3 . For tables of type ordered_set , the traversal of the table continues to objects with keys earlier in the Erlang term order. The returned list also contains objects with keys in reverse order. For all other table types, the behavior is exactly that of select/1 . Example: 1 &gt; T = ets : new ( x , [ ordered_set ] ) . 2 &gt; [ ets : insert ( T , { N } ) || N &lt;- lists : seq ( 1 , 10 ) ] . . . . 3 &gt; { R0 , C0 } = ets : select_reverse ( T , [ { &#39;_&#39; , [ ] , [ &#39;$_&#39; ] } ] , 4 ) . . . . 4 &gt; R0 . [ { 10 } , { 9 } , { 8 } , { 7 } ] 5 &gt; { R1 , C1 } = ets : select_reverse ( C0 ) . . . . 6 &gt; R1 . [ { 6 } , { 5 } , { 4 } , { 3 } ] 7 &gt; { R2 , C2 } = ets : select_reverse ( C1 ) . . . . 8 &gt; R2 . [ { 2 } , { 1 } ] 9 &gt; &#39;$end_of_table&#39; = ets : select_reverse ( C2 ) . . . .","ref":"ets.html#select_reverse/1","title":"ets.select_reverse/1","type":"function"},{"doc":"Works like select/2 , but returns the list in reverse order for table type ordered_set . For all other table types, the return value is identical to that of select/2 .","ref":"ets.html#select_reverse/2","title":"ets.select_reverse/2","type":"function"},{"doc":"Works like select/3 , but for table type ordered_set traversing is done starting at the last object in Erlang term order and moves to the first. For all other table types, the return value is identical to that of select/3 . Notice that this is not equivalent to reversing the result list of a select/3 call, as the result list is not only reversed, but also contains the last Limit matching objects in the table, not the first.","ref":"ets.html#select_reverse/3","title":"ets.select_reverse/3","type":"function"},{"doc":"Sets table options. The only allowed option to be set after the table has been created is heir . The calling process must be the table owner.","ref":"ets.html#setopts/2","title":"ets.setopts/2","type":"function"},{"doc":"This function is mostly for debugging purposes, Normally first / next or last / prev are to be used instead. Returns all objects in slot I of table Tab . A table can be traversed by repeatedly calling the function, starting with the first slot I=0 and ending when '$end_of_table' is returned. If argument I is out of range, the function fails with reason badarg . Unless a table of type set , bag , or duplicate_bag is protected using safe_fixtable/2 , a traversal can fail if concurrent updates are made to the table. For table type ordered_set , the function returns a list containing object I in Erlang term order.","ref":"ets.html#slot/2","title":"ets.slot/2","type":"function"},{"doc":"Dumps table Tab to file Filename . Equivalent to tab2file(Tab, Filename,[])","ref":"ets.html#tab2file/2","title":"ets.tab2file/2","type":"function"},{"doc":"Dumps table Tab to file Filename . When dumping the table, some information about the table is dumped to a header at the beginning of the dump. This information contains data about the table type, name, protection, size, version, and if it is a named table. It also contains notes about what extended information is added to the file, which can be a count of the objects in the file or a MD5 sum of the header and records in the file. The size field in the header might not correspond to the number of records in the file if the table is public and records are added or removed from the table during dumping. Public tables updated during dump, and that one wants to verify when reading, needs at least one field of extended information for the read verification process to be reliable later. Option extended_info specifies what extra information is written to the table dump: object_count The number of objects written to the file is noted in the file footer, so file truncation can be verified even if the file was updated during dump. md5sum The header and objects in the file are checksummed using the built-in MD5 functions. The MD5 sum of all objects is written in the file footer, so that verification while reading detects the slightest bitflip in the file data. Using this costs a fair amount of CPU time. Whenever option extended_info is used, it results in a file not readable by versions of ETS before that in STDLIB 1.15.1 If option sync is set to true , it ensures that the content of the file is written to the disk before tab2file returns. Defaults to {sync, false} .","ref":"ets.html#tab2file/3","title":"ets.tab2file/3","type":"function"},{"doc":"Returns a list of all objects in table Tab .","ref":"ets.html#tab2list/1","title":"ets.tab2list/1","type":"function"},{"doc":"Returns information about the table dumped to file by tab2file/2 or tab2file/3 . The following items are returned: name The name of the dumped table. If the table was a named table, a table with the same name cannot exist when the table is loaded from file with file2tab/2 . If the table is not saved as a named table, this field has no significance when loading the table from file. type The ETS type of the dumped table (that is, set , bag , duplicate_bag , or ordered_set ). This type is used when loading the table again. protection The protection of the dumped table (that is, private , protected , or public ). A table loaded from the file gets the same protection. named_table true if the table was a named table when dumped to file, otherwise false . Notice that when a named table is loaded from a file, there cannot exist a table in the system with the same name. keypos The keypos of the table dumped to file, which is used when loading the table again. size The number of objects in the table when the table dump to file started. For a public table, this number does not need to correspond to the number of objects saved to the file, as objects can have been added or deleted by another process during table dump. extended_info The extended information written in the file footer to allow stronger verification during table loading from file, as specified to tab2file/3 . Notice that this function only tells which information is present, not the values in the file footer. The value is a list containing one or more of the atoms object_count and md5sum . version A tuple {Major,Minor} containing the major and minor version of the file format for ETS table dumps. This version field was added beginning with STDLIB 1.5.1. Files dumped with older versions return {0,0} in this field. An error is returned if the file is inaccessible, badly damaged, or not produced with tab2file/2 or tab2file/3 .","ref":"ets.html#tabfile_info/1","title":"ets.tabfile_info/1","type":"function"},{"doc":"Returns a Query List Comprehension (QLC) query handle. The qlc module provides a query language aimed mainly at Mnesia, but ETS tables, Dets tables, and lists are also recognized by QLC as sources of data. Calling table/1,2 is the means to make the ETS table Tab usable to QLC. When there are only simple restrictions on the key position, QLC uses lookup/2 to look up the keys. When that is not possible, the whole table is traversed. Option traverse determines how this is done: first_next The table is traversed one key at a time by calling first/1 and next/2 . last_prev The table is traversed one key at a time by calling last/1 and prev/2 . select The table is traversed by calling select/3 and select/1 . Option n_objects determines the number of objects returned (the third argument of select/3 ); the default is to return 100 objects at a time. The match specification (the second argument of select/3 ) is assembled by QLC: simple filters are translated into equivalent match specifications while more complicated filters must be applied to all objects returned by select/3 given a match specification that matches all objects. {select, MatchSpec} As for select , the table is traversed by calling select/3 and select/1 . The difference is that the match specification is explicitly specified. This is how to state match specifications that cannot easily be expressed within the syntax provided by QLC. Examples: An explicit match specification is here used to traverse the table: 9 &gt; true = ets : insert ( Tab = ets : new ( t , [ ] ) , [ { 1 , a } , { 2 , b } , { 3 , c } , { 4 , d } ] ) , MS = ets : fun2ms ( fun ( { X , Y } ) when ( X &gt; 1 ) or ( X &lt; 5 ) -&gt; { Y } end ) , QH1 = ets : table ( Tab , [ { traverse , { select , MS } } ] ) . An example with an implicit match specification: 10 &gt; QH2 = qlc : q ( [ { Y } || { X , Y } &lt;- ets : table ( Tab ) , ( X &gt; 1 ) or ( X &lt; 5 ) ] ) . The latter example is equivalent to the former, which can be verified using function qlc:info/1 : 11 &gt; qlc : info ( QH1 ) =:= qlc : info ( QH2 ) . true qlc:info/1 returns information about a query handle, and in this case identical information is returned for the two query handles.","ref":"ets.html#table/1","title":"ets.table/1","type":"function"},{"doc":"","ref":"ets.html#table/2","title":"ets.table/2","type":"function"},{"doc":"Returns and removes a list of all objects with key Key in table Tab . The specified Key is used to identify the object by either comparing equal the key of an object in an ordered_set table, or matching in other types of tables (for details on the difference, see lookup/2 and new/2 ).","ref":"ets.html#take/2","title":"ets.take/2","type":"function"},{"doc":"This function is a utility to test a match specification used in calls to select/2 . The function both tests MatchSpec for &quot;syntactic&quot; correctness and runs the match specification against object Tuple . If the match specification is syntactically correct, the function either returns {ok,Result} , where Result is what would have been the result in a real select/2 call, or false if the match specification does not match object Tuple . If the match specification contains errors, tuple {error, Errors} is returned, where Errors is a list of natural language descriptions of what was wrong with the match specification. This is a useful debugging and test tool, especially when writing complicated select/2 calls. See also: erlang:match_spec_test/3 .","ref":"ets.html#test_ms/2","title":"ets.test_ms/2","type":"function"},{"doc":"Fills an already created/opened Dets table with the objects in the already opened ETS table named Tab . The Dets table is emptied before the objects are inserted.","ref":"ets.html#to_dets/2","title":"ets.to_dets/2","type":"function"},{"doc":"This function provides an efficient way to update one or more counters, without the trouble of having to look up an object, update the object by incrementing an element, and insert the resulting object into the table again. The operation is guaranteed to be atomic and isolated . This function destructively update the object with key Key in table Tab by adding Incr to the element at position Pos . The new counter value is returned. If no position is specified, the element directly following key ( &lt;keypos&gt;+1 ) is updated. If a Threshold is specified, the counter is reset to value SetValue if the following conditions occur: Incr is not negative ( &gt;= 0 ) and the result would be greater than ( &gt; ) Threshold . Incr is negative ( &lt; 0 ) and the result would be less than ( &lt; ) Threshold . A list of UpdateOp can be supplied to do many update operations within the object. The operations are carried out in the order specified in the list. If the same counter position occurs more than once in the list, the corresponding counter is thus updated many times, each time based on the previous result. The return value is a list of the new counter values from each update operation in the same order as in the operation list. If an empty list is specified, nothing is updated and an empty list is returned. If the function fails, no updates are done. The specified Key is used to identify the object by either matching the key of an object in a set table, or compare equal to the key of an object in an ordered_set table (for details on the difference, see lookup/2 and new/2 ). If a default object Default is specified, it is used as the object to be updated if the key is missing from the table. The value in place of the key is ignored and replaced by the proper key value. The return value is as if the default object had not been used, that is, a single updated element or a list of them. The function fails with reason badarg in the following situations: The table type is not set or ordered_set . No object with the correct key exists and no default object was supplied. The object has the wrong arity. The default object arity is smaller than &lt;keypos&gt; . Any field from the default object that is updated is not an integer. The element to update is not an integer. The element to update is also the key. Any of Pos , Incr , Threshold , or SetValue is not an integer.","ref":"ets.html#update_counter/3","title":"ets.update_counter/3","type":"function"},{"doc":"","ref":"ets.html#update_counter/4","title":"ets.update_counter/4","type":"function"},{"doc":"This function provides an efficient way to update one or more elements within an object, without the trouble of having to look up, update, and write back the entire object. This function destructively updates the object with key Key in table Tab . The element at position Pos is given the value Value . A list of {Pos,Value} can be supplied to update many elements within the same object. If the same position occurs more than once in the list, the last value in the list is written. If the list is empty or the function fails, no updates are done. The function is also atomic in the sense that other processes can never see any intermediate results. Returns true if an object with key Key is found, otherwise false . The specified Key is used to identify the object by either matching the key of an object in a set table, or compare equal to the key of an object in an ordered_set table (for details on the difference, see lookup/2 and new/2 ). The function fails with reason badarg in the following situations: The table type is not set or ordered_set . Pos &lt; 1. Pos &gt; object arity. The element to update is also the key.","ref":"ets.html#update_element/3","title":"ets.update_element/3","type":"function"},{"doc":"This function returns the tid() of the named table identified by TableName , or undefined if no such table exists. The tid() can be used in place of the table name in all operations, which is slightly faster since the name does not have to be resolved on each call. If the table is deleted, the tid() will be invalid even if another named table is created with the same name.","ref":"ets.html#whereis/1","title":"ets.whereis/1","type":"function"},{"doc":"","ref":"ets.html#t:access/0","title":"ets.access/0","type":"type"},{"doc":"A compiled match specification.","ref":"ets.html#t:comp_match_spec/0","title":"ets.comp_match_spec/0","type":"opaque"},{"doc":"Opaque continuation used by select/1,3 , select_reverse/1,3 , match/1,3 , and match_object/1,3 .","ref":"ets.html#t:continuation/0","title":"ets.continuation/0","type":"type"},{"doc":"","ref":"ets.html#t:match_pattern/0","title":"ets.match_pattern/0","type":"type"},{"doc":"A match specification, see above.","ref":"ets.html#t:match_spec/0","title":"ets.match_spec/0","type":"type"},{"doc":"","ref":"ets.html#t:tab/0","title":"ets.tab/0","type":"type"},{"doc":"A table identifier, as returned by new/2 .","ref":"ets.html#t:tid/0","title":"ets.tid/0","type":"opaque"},{"doc":"","ref":"ets.html#t:type/0","title":"ets.type/0","type":"type"},{"doc":"This module contains functions for sorting terms on files, merging already sorted files, and checking files for sortedness. Chunks containing binary terms are read from a sequence of files, sorted internally in memory and written on temporary files, which are merged producing one sorted file as output. Merging is provided as an optimization; it is faster when the files are already sorted, but it always works to sort instead of merge. On a file, a term is represented by a header and a binary. Two options define the format of terms on files: {header, HeaderLength} HeaderLength determines the number of bytes preceding each binary and containing the length of the binary in bytes. Defaults to 4. The order of the header bytes is defined as follows: if B is a binary containing a header only, size Size of the binary is calculated as &lt;&lt;Size:HeaderLength/unit:8&gt;&gt; = B . {format, Format} Option Format determines the function that is applied to binaries to create the terms to be sorted. Defaults to binary_term , which is equivalent to fun binary_to_term/1 . Value binary is equivalent to fun(X) -&gt; X end , which means that the binaries are sorted as they are. This is the fastest format. If Format is term , io:read/2 is called to read terms. In that case, only the default value of option header is allowed. Option format also determines what is written to the sorted output file: if Format is term , then io:format/3 is called to write each term, otherwise the binary prefixed by a header is written. Notice that the binary written is the same binary that was read; the results of applying function Format are thrown away when the terms have been sorted. Reading and writing terms using the io module is much slower than reading and writing binaries. Other options are: {order, Order} The default is to sort terms in ascending order, but that can be changed by value descending or by specifying an ordering function Fun . An ordering function is antisymmetric, transitive, and total. Fun(A, B) is to return true if A comes before B in the ordering, otherwise false . An example of a typical ordering function is less than or equal to, =&lt;/2 . Using an ordering function slows down the sort considerably. Functions keysort , keymerge and keycheck do not accept ordering functions. {unique, boolean()} When sorting or merging files, only the first of a sequence of terms that compare equal ( == ) is output if this option is set to true . Defaults to false , which implies that all terms that compare equal are output. When checking files for sortedness, a check that no pair of consecutive terms compares equal is done if this option is set to true . {tmpdir, TempDirectory} The directory where temporary files are put can be chosen explicitly. The default, implied by value &quot;&quot; , is to put temporary files on the same directory as the sorted output file. If output is a function (see below), the directory returned by file:get_cwd() is used instead. The names of temporary files are derived from the Erlang nodename ( node() ), the process identifier of the current Erlang emulator ( os:getpid() ), and a unique integer ( erlang:unique_integer([positive]) ). A typical name is fs_mynode@myhost_1763_4711.17 , where 17 is a sequence number. Existing files are overwritten. Temporary files are deleted unless some uncaught EXIT signal occurs. {compressed, boolean()} Temporary files and the output file can be compressed. Defaults false , which implies that written files are not compressed. Regardless of the value of option compressed , compressed files can always be read. Notice that reading and writing compressed files are significantly slower than reading and writing uncompressed files. {size, Size} By default about 512*1024 bytes read from files are sorted internally. This option is rarely needed. {no_files, NoFiles} By default 16 files are merged at a time. This option is rarely needed. As an alternative to sorting files, a function of one argument can be specified as input. When called with argument read , the function is assumed to return either of the following: end_of_input or {end_of_input, Value}} when there is no more input ( Value is explained below). {Objects, Fun} , where Objects is a list of binaries or terms depending on the format, and Fun is a new input function. Any other value is immediately returned as value of the current call to sort or keysort . Each input function is called exactly once. If an error occurs, the last function is called with argument close , the reply of which is ignored. A function of one argument can be specified as output. The results of sorting or merging the input is collected in a non-empty sequence of variable length lists of binaries or terms depending on the format. The output function is called with one list at a time, and is assumed to return a new output function. Any other return value is immediately returned as value of the current call to the sort or merge function. Each output function is called exactly once. When some output function has been applied to all of the results or an error occurs, the last function is called with argument close , and the reply is returned as value of the current call to the sort or merge function. If a function is specified as input and the last input function returns {end_of_input, Value} , the function specified as output is called with argument {value, Value} . This makes it easy to initiate the sequence of output functions with a value calculated by the input functions. As an example, consider sorting the terms on a disk log file. A function that reads chunks from the disk log and returns a list of binaries is used as input. The results are collected in a list of terms. sort ( Log ) -&gt; { ok , _ } = disk_log : open ( [ { name , Log } , { mode , read_only } ] ) , Input = input ( Log , start ) , Output = output ( [ ] ) , Reply = file_sorter : sort ( Input , Output , { format , term } ) , ok = disk_log : close ( Log ) , Reply . input ( Log , Cont ) -&gt; fun ( close ) -&gt; ok ; ( read ) -&gt; case disk_log : chunk ( Log , Cont ) of { error , Reason } -&gt; { error , Reason } ; { Cont2 , Terms } -&gt; { Terms , input ( Log , Cont2 ) } ; { Cont2 , Terms , _ Badbytes } -&gt; { Terms , input ( Log , Cont2 ) } ; eof -&gt; end_of_input end end . output ( L ) -&gt; fun ( close ) -&gt; lists : append ( lists : reverse ( L ) ) ; ( Terms ) -&gt; output ( [ Terms | L ] ) end . For more examples of functions as input and output, see the end of the file_sorter module; the term format is implemented with functions. The possible values of Reason returned when an error occurs are: bad_object , {bad_object, FileName} - Applying the format function failed for some binary, or the key(s) could not be extracted from some term. {bad_term, FileName} - io:read/2 failed to read some term. {file_error, FileName, file:posix()} - For an explanation of file:posix() , see file(3) . {premature_eof, FileName} - End-of-file was encountered inside some binary term.","ref":"file_sorter.html","title":"file_sorter","type":"module"},{"doc":"Checks files for sortedness. If a file is not sorted, the first out-of-order element is returned. The first term on a file has position 1. check(FileName) is equivalent to check([FileName], []) .","ref":"file_sorter.html#check/1","title":"file_sorter.check/1","type":"function"},{"doc":"","ref":"file_sorter.html#check/2","title":"file_sorter.check/2","type":"function"},{"doc":"Checks files for sortedness. If a file is not sorted, the first out-of-order element is returned. The first term on a file has position 1. keycheck(KeyPos, FileName) is equivalent to keycheck(KeyPos, [FileName], []) .","ref":"file_sorter.html#keycheck/2","title":"file_sorter.keycheck/2","type":"function"},{"doc":"","ref":"file_sorter.html#keycheck/3","title":"file_sorter.keycheck/3","type":"function"},{"doc":"Merges tuples on files. Each input file is assumed to be sorted on key(s). keymerge(KeyPos, FileNames, Output) is equivalent to keymerge(KeyPos, FileNames, Output, []) .","ref":"file_sorter.html#keymerge/3","title":"file_sorter.keymerge/3","type":"function"},{"doc":"","ref":"file_sorter.html#keymerge/4","title":"file_sorter.keymerge/4","type":"function"},{"doc":"Sorts tuples on files. keysort(N, FileName) is equivalent to keysort(N, [FileName], FileName) .","ref":"file_sorter.html#keysort/2","title":"file_sorter.keysort/2","type":"function"},{"doc":"Sorts tuples on files. The sort is performed on the element(s) mentioned in KeyPos . If two tuples compare equal ( == ) on one element, the next element according to KeyPos is compared. The sort is stable. keysort(N, Input, Output) is equivalent to keysort(N, Input, Output, []) .","ref":"file_sorter.html#keysort/3","title":"file_sorter.keysort/3","type":"function"},{"doc":"","ref":"file_sorter.html#keysort/4","title":"file_sorter.keysort/4","type":"function"},{"doc":"Merges terms on files. Each input file is assumed to be sorted. merge(FileNames, Output) is equivalent to merge(FileNames, Output, []) .","ref":"file_sorter.html#merge/2","title":"file_sorter.merge/2","type":"function"},{"doc":"","ref":"file_sorter.html#merge/3","title":"file_sorter.merge/3","type":"function"},{"doc":"Sorts terms on files. sort(FileName) is equivalent to sort([FileName], FileName) .","ref":"file_sorter.html#sort/1","title":"file_sorter.sort/1","type":"function"},{"doc":"Sorts terms on files. sort(Input, Output) is equivalent to sort(Input, Output, []) .","ref":"file_sorter.html#sort/2","title":"file_sorter.sort/2","type":"function"},{"doc":"","ref":"file_sorter.html#sort/3","title":"file_sorter.sort/3","type":"function"},{"doc":"","ref":"file_sorter.html#t:file_name/0","title":"file_sorter.file_name/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:file_names/0","title":"file_sorter.file_names/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:format/0","title":"file_sorter.format/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:format_fun/0","title":"file_sorter.format_fun/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:header_length/0","title":"file_sorter.header_length/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:i_command/0","title":"file_sorter.i_command/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:i_reply/0","title":"file_sorter.i_reply/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:infun/0","title":"file_sorter.infun/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:input/0","title":"file_sorter.input/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:input_reply/0","title":"file_sorter.input_reply/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:key_pos/0","title":"file_sorter.key_pos/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:no_files/0","title":"file_sorter.no_files/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:o_command/0","title":"file_sorter.o_command/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:o_reply/0","title":"file_sorter.o_reply/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:object/0","title":"file_sorter.object/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:option/0","title":"file_sorter.option/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:options/0","title":"file_sorter.options/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:order/0","title":"file_sorter.order/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:order_fun/0","title":"file_sorter.order_fun/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:outfun/0","title":"file_sorter.outfun/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:output/0","title":"file_sorter.output/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:output_reply/0","title":"file_sorter.output_reply/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:reason/0","title":"file_sorter.reason/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:size/0","title":"file_sorter.size/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:tmp_directory/0","title":"file_sorter.tmp_directory/0","type":"type"},{"doc":"","ref":"file_sorter.html#t:value/0","title":"file_sorter.value/0","type":"type"},{"doc":"This module contains utilities on a higher level than the file module. This module does not support &quot;raw&quot; filenames (that is, files whose names do not comply with the expected encoding). Such files are ignored by the functions in this module. For more information about raw filenames, see the file module. Functionality in this module generally assumes valid input and does not necessarily fail on input that does not use a valid encoding, but may instead very likely produce invalid output. File operations used to accept filenames containing null characters (integer value zero). This caused the name to be truncated and in some cases arguments to primitive operations to be mixed up. Filenames containing null characters inside the filename are now rejected and will cause primitive file operations to fail. Currently null characters at the end of the filename will be accepted by primitive file operations. Such filenames are however still documented as invalid. The implementation will also change in the future and reject such filenames.","ref":"filelib.html","title":"filelib","type":"module"},{"doc":"Ensures that all parent directories for the specified file or directory name Name exist, trying to create them if necessary. Returns ok if all parent directories already exist or can be created. Returns {error, Reason} if some parent directory does not exist and cannot be created.","ref":"filelib.html#ensure_dir/1","title":"filelib.ensure_dir/1","type":"function"},{"doc":"Returns the size of the specified file.","ref":"filelib.html#file_size/1","title":"filelib.file_size/1","type":"function"},{"doc":"Looks for a file of the given name by applying suffix rules to the given directory path. For example, a rule {&quot;ebin&quot;, &quot;src&quot;} means that if the directory path ends with &quot;ebin&quot; , the corresponding path ending in &quot;src&quot; should be searched. If Rules is left out or is an empty list, the default system rules are used. See also the Kernel application parameter source_search_rules .","ref":"filelib.html#find_file/2","title":"filelib.find_file/2","type":"function"},{"doc":"","ref":"filelib.html#find_file/3","title":"filelib.find_file/3","type":"function"},{"doc":"Equivalent to find_source(Base, Dir) , where Dir is filename:dirname(FilePath) and Base is filename:basename(FilePath) .","ref":"filelib.html#find_source/1","title":"filelib.find_source/1","type":"function"},{"doc":"Applies file extension specific rules to find the source file for a given object file relative to the object directory. For example, for a file with the extension .beam , the default rule is to look for a file with a corresponding extension .erl by replacing the suffix &quot;ebin&quot; of the object directory path with &quot;src&quot; or &quot;src/*&quot; . The file search is done through find_file/3 . The directory of the object file is always tried before any other directory specified by the rules. If Rules is left out or is an empty list, the default system rules are used. See also the Kernel application parameter source_search_rules .","ref":"filelib.html#find_source/2","title":"filelib.find_source/2","type":"function"},{"doc":"","ref":"filelib.html#find_source/3","title":"filelib.find_source/3","type":"function"},{"doc":"Folds function Fun over all (regular) files F in directory Dir that match the regular expression RegExp (for a description of the allowed regular expressions, see the re module). If Recursive is true , all subdirectories to Dir are processed. The regular expression matching is only done on the filename without the directory part. If Unicode filename translation is in effect and the file system is transparent, filenames that cannot be interpreted as Unicode can be encountered, in which case the fun() must be prepared to handle raw filenames (that is, binaries). If the regular expression contains codepoints &gt; 255, it does not match filenames that do not conform to the expected character encoding (that is, are not encoded in valid UTF-8). For more information about raw filenames, see the file module.","ref":"filelib.html#fold_files/5","title":"filelib.fold_files/5","type":"function"},{"doc":"Returns true if Name refers to a directory, otherwise false .","ref":"filelib.html#is_dir/1","title":"filelib.is_dir/1","type":"function"},{"doc":"Returns true if Name refers to a file or a directory, otherwise false .","ref":"filelib.html#is_file/1","title":"filelib.is_file/1","type":"function"},{"doc":"Returns true if Name refers to a (regular) file, otherwise false .","ref":"filelib.html#is_regular/1","title":"filelib.is_regular/1","type":"function"},{"doc":"Returns the date and time the specified file or directory was last modified, or 0 if the file does not exist.","ref":"filelib.html#last_modified/1","title":"filelib.last_modified/1","type":"function"},{"doc":"Sanitizes the relative path by eliminating &quot;..&quot; and &quot;.&quot; components to protect against directory traversal attacks. Either returns the sanitized path name, or the atom unsafe if the path is unsafe. The path is considered unsafe in the following circumstances: The path is not relative. A &quot;..&quot; component would climb up above the root of the relative path. A symbolic link in the path points above the root of the relative path. Examples: 1 &gt; { ok , Cwd } = file : get_cwd ( ) . . . . 2 &gt; filelib : safe_relative_path ( &quot;dir/sub_dir/..&quot; , Cwd ) . &quot;dir&quot; 3 &gt; filelib : safe_relative_path ( &quot;dir/..&quot; , Cwd ) . [ ] 4 &gt; filelib : safe_relative_path ( &quot;dir/../..&quot; , Cwd ) . unsafe 5 &gt; filelib : safe_relative_path ( &quot;/abs/path&quot; , Cwd ) . unsafe","ref":"filelib.html#safe_relative_path/2","title":"filelib.safe_relative_path/2","type":"function"},{"doc":"Returns a list of all files that match Unix-style wildcard string Wildcard . The wildcard string looks like an ordinary filename, except that the following &quot;wildcard characters&quot; are interpreted in a special way: ? Matches one character. * Matches any number of characters up to the end of the filename, the next dot, or the next slash. ** Two adjacent * used as a single pattern match all files and zero or more directories and subdirectories. [Character1,Character2,...] Matches any of the characters listed. Two characters separated by a hyphen match a range of characters. Example: [A-Z] matches any uppercase letter. {Item,...} Alternation. Matches one of the alternatives. Other characters represent themselves. Only filenames that have exactly the same character in the same position match. Matching is case-sensitive, for example, &quot;a&quot; does not match &quot;A&quot;. Directory separators must always be written as / , even on Windows. A character preceded by \\ loses its special meaning. Note that \\ must be written as \\\\ in a string literal. For example, &quot;\\\\?*&quot; will match any filename starting with ? . Notice that multiple &quot;*&quot; characters are allowed (as in Unix wildcards, but opposed to Windows/DOS wildcards). Examples: The following examples assume that the current directory is the top of an Erlang/OTP installation. To find all .beam files in all applications, use the following line: filelib:wildcard(&quot;lib/*/ebin/*.beam&quot;). To find .erl or .hrl in all applications src directories, use either of the following lines: filelib:wildcard(&quot;lib/*/src/*.?rl&quot;) filelib:wildcard(&quot;lib/*/src/*.{erl,hrl}&quot;) To find all .hrl files in src or include directories: filelib:wildcard(&quot;lib/*/{src,include}/*.hrl&quot;). To find all .erl or .hrl files in either src or include directories: filelib:wildcard(&quot;lib/*/{src,include}/*.{erl,hrl}&quot;) To find all .erl or .hrl files in any subdirectory: filelib:wildcard(&quot;lib/**/*.{erl,hrl}&quot;)","ref":"filelib.html#wildcard/1","title":"filelib.wildcard/1","type":"function"},{"doc":"Same as wildcard/1 , except that Cwd is used instead of the working directory.","ref":"filelib.html#wildcard/2","title":"filelib.wildcard/2","type":"function"},{"doc":"","ref":"filelib.html#t:dirname/0","title":"filelib.dirname/0","type":"type"},{"doc":"","ref":"filelib.html#t:dirname_all/0","title":"filelib.dirname_all/0","type":"type"},{"doc":"","ref":"filelib.html#t:filename/0","title":"filelib.filename/0","type":"type"},{"doc":"","ref":"filelib.html#t:filename_all/0","title":"filelib.filename_all/0","type":"type"},{"doc":"","ref":"filelib.html#t:find_file_rule/0","title":"filelib.find_file_rule/0","type":"type"},{"doc":"","ref":"filelib.html#t:find_source_rule/0","title":"filelib.find_source_rule/0","type":"type"},{"doc":"This module provides functions for analyzing and manipulating filenames. These functions are designed so that the Erlang code can work on many different platforms with different filename formats. With filename is meant all strings that can be used to denote a file. The filename can be a short relative name like foo.erl , a long absolute name including a drive designator, a directory name like D:\\usr/local\\bin\\erl/lib\\tools\\foo.erl , or any variations in between. In Windows, all functions return filenames with forward slashes only, even if the arguments contain backslashes. To normalize a filename by removing redundant directory separators, use join/1 . The module supports raw filenames in the way that if a binary is present, or the filename cannot be interpreted according to the return value of file:native_name_encoding/0 , a raw filename is also returned. For example, join/1 provided with a path component that is a binary (and cannot be interpreted under the current native filename encoding) results in a raw filename that is returned (the join operation is performed of course). For more information about raw filenames, see the file module. Functionality in this module generally assumes valid input and does not necessarily fail on input that does not use a valid encoding, but may instead very likely produce invalid output. File operations used to accept filenames containing null characters (integer value zero). This caused the name to be truncated and in some cases arguments to primitive operations to be mixed up. Filenames containing null characters inside the filename are now rejected and will cause primitive file operations to fail. Currently null characters at the end of the filename will be accepted by primitive file operations. Such filenames are however still documented as invalid. The implementation will also change in the future and reject such filenames.","ref":"filename.html","title":"filename","type":"module"},{"doc":"Converts a relative Filename and returns an absolute name. No attempt is made to create the shortest absolute name, as this can give incorrect results on file systems that allow links. Unix examples: 1 &gt; pwd ( ) . &quot;/usr/local&quot; 2 &gt; filename : absname ( &quot;foo&quot; ) . &quot;/usr/local/foo&quot; 3 &gt; filename : absname ( &quot;../x&quot; ) . &quot;/usr/local/../x&quot; 4 &gt; filename : absname ( &quot;/&quot; ) . &quot;/&quot; Windows examples: 1 &gt; pwd ( ) . &quot;D:/usr/local&quot; 2 &gt; filename : absname ( &quot;foo&quot; ) . &quot;D:/usr/local/foo&quot; 3 &gt; filename : absname ( &quot;../x&quot; ) . &quot;D:/usr/local/../x&quot; 4 &gt; filename : absname ( &quot;/&quot; ) . &quot;D:/&quot;","ref":"filename.html#absname/1","title":"filename.absname/1","type":"function"},{"doc":"Same as absname/1 , except that the directory to which the filename is to be made relative is specified in argument Dir .","ref":"filename.html#absname/2","title":"filename.absname/2","type":"function"},{"doc":"Joins an absolute directory with a relative filename. Similar to join/2 , but on platforms with tight restrictions on raw filename length and no support for symbolic links (read: VxWorks), leading parent directory components in Filename are matched against trailing directory components in Dir so they can be removed from the result - minimizing its length.","ref":"filename.html#absname_join/2","title":"filename.absname_join/2","type":"function"},{"doc":"Equivalent to basedir(PathType, Application, \#{}) or basedir(PathsType, Application, \#{}) .","ref":"filename.html#basedir/2","title":"filename.basedir/2","type":"function"},{"doc":"Returns a suitable path, or paths, for a given type. If os is not set in Opts the function will default to the native option, that is 'linux' , 'darwin' or 'windows' , as understood by os:type/0 . Anything not recognized as 'darwin' or 'windows' is interpreted as 'linux' . The options 'author' and 'version' are only used with 'windows' option mode. user_cache The path location is intended for transient data files on a local machine. On Linux: Respects the os environment variable XDG_CACHE_HOME . 1 &gt; filename : basedir ( user_cache , &quot;my_application&quot; , \#{ os =&gt; linux } ) . &quot;/home/otptest/.cache/my_application&quot; On Darwin: 1 &gt; filename : basedir ( user_cache , &quot;my_application&quot; , \#{ os =&gt; darwin } ) . &quot;/home/otptest/Library/Caches/my_application&quot; On Windows: 1 &gt; filename : basedir ( user_cache , &quot;My App&quot; ) . &quot;c:/Users/otptest/AppData/Local/My App/Cache&quot; 2 &gt; filename : basedir ( user_cache , &quot;My App&quot; ) . &quot;c:/Users/otptest/AppData/Local/My App/Cache&quot; 3 &gt; filename : basedir ( user_cache , &quot;My App&quot; , \#{ author =&gt; &quot;Erlang&quot; } ) . &quot;c:/Users/otptest/AppData/Local/Erlang/My App/Cache&quot; 4 &gt; filename : basedir ( user_cache , &quot;My App&quot; , \#{ version =&gt; &quot;1.2&quot; } ) . &quot;c:/Users/otptest/AppData/Local/My App/1.2/Cache&quot; 5 &gt; filename : basedir ( user_cache , &quot;My App&quot; , \#{ author =&gt; &quot;Erlang&quot; , version =&gt; &quot;1.2&quot; } ) . &quot;c:/Users/otptest/AppData/Local/Erlang/My App/1.2/Cache&quot; user_config The path location is intended for persistent configuration files. On Linux: Respects the os environment variable XDG_CONFIG_HOME . 2 &gt; filename : basedir ( user_config , &quot;my_application&quot; , \#{ os =&gt; linux } ) . &quot;/home/otptest/.config/my_application&quot; On Darwin: 2 &gt; filename : basedir ( user_config , &quot;my_application&quot; , \#{ os =&gt; darwin } ) . &quot;/home/otptest/Library/Application Support/my_application&quot; On Windows: 1 &gt; filename : basedir ( user_config , &quot;My App&quot; ) . &quot;c:/Users/otptest/AppData/Roaming/My App&quot; 2 &gt; filename : basedir ( user_config , &quot;My App&quot; , \#{ author =&gt; &quot;Erlang&quot; , version =&gt; &quot;1.2&quot; } ) . &quot;c:/Users/otptest/AppData/Roaming/Erlang/My App/1.2&quot; user_data The path location is intended for persistent data files. On Linux: Respects the os environment variable XDG_DATA_HOME . 3 &gt; filename : basedir ( user_data , &quot;my_application&quot; , \#{ os =&gt; linux } ) . &quot;/home/otptest/.local/my_application&quot; On Darwin: 3 &gt; filename : basedir ( user_data , &quot;my_application&quot; , \#{ os =&gt; darwin } ) . &quot;/home/otptest/Library/Application Support/my_application&quot; On Windows: 8 &gt; filename : basedir ( user_data , &quot;My App&quot; ) . &quot;c:/Users/otptest/AppData/Local/My App&quot; 9 &gt; filename : basedir ( user_data , &quot;My App&quot; , \#{ author =&gt; &quot;Erlang&quot; , version =&gt; &quot;1.2&quot; } ) . &quot;c:/Users/otptest/AppData/Local/Erlang/My App/1.2&quot; user_log The path location is intended for transient log files on a local machine. On Linux: Respects the os environment variable XDG_CACHE_HOME . 4 &gt; filename : basedir ( user_log , &quot;my_application&quot; , \#{ os =&gt; linux } ) . &quot;/home/otptest/.cache/my_application/log&quot; On Darwin: 4 &gt; filename : basedir ( user_log , &quot;my_application&quot; , \#{ os =&gt; darwin } ) . &quot;/home/otptest/Library/Caches/my_application&quot; On Windows: 12 &gt; filename : basedir ( user_log , &quot;My App&quot; ) . &quot;c:/Users/otptest/AppData/Local/My App/Logs&quot; 13 &gt; filename : basedir ( user_log , &quot;My App&quot; , \#{ author =&gt; &quot;Erlang&quot; , version =&gt; &quot;1.2&quot; } ) . &quot;c:/Users/otptest/AppData/Local/Erlang/My App/1.2/Logs&quot; site_config On Linux: Respects the os environment variable XDG_CONFIG_DIRS . 5 &gt; filename : basedir ( site_data , &quot;my_application&quot; , \#{ os =&gt; linux } ) . [ &quot;/usr/local/share/my_application&quot; , &quot;/usr/share/my_application&quot; ] 6 &gt; os : getenv ( &quot;XDG_CONFIG_DIRS&quot; ) . &quot;/etc/xdg/xdg-ubuntu:/usr/share/upstart/xdg:/etc/xdg&quot; 7 &gt; filename : basedir ( site_config , &quot;my_application&quot; , \#{ os =&gt; linux } ) . [ &quot;/etc/xdg/xdg-ubuntu/my_application&quot; , &quot;/usr/share/upstart/xdg/my_application&quot; , &quot;/etc/xdg/my_application&quot; ] 8 &gt; os : unsetenv ( &quot;XDG_CONFIG_DIRS&quot; ) . true 9 &gt; filename : basedir ( site_config , &quot;my_application&quot; , \#{ os =&gt; linux } ) . [ &quot;/etc/xdg/my_application&quot; ] On Darwin: 5 &gt; filename : basedir ( site_config , &quot;my_application&quot; , \#{ os =&gt; darwin } ) . [ &quot;/Library/Application Support/my_application&quot; ] site_data On Linux: Respects the os environment variable XDG_DATA_DIRS . 10 &gt; os : getenv ( &quot;XDG_DATA_DIRS&quot; ) . &quot;/usr/share/ubuntu:/usr/share/gnome:/usr/local/share/:/usr/share/&quot; 11 &gt; filename : basedir ( site_data , &quot;my_application&quot; , \#{ os =&gt; linux } ) . [ &quot;/usr/share/ubuntu/my_application&quot; , &quot;/usr/share/gnome/my_application&quot; , &quot;/usr/local/share/my_application&quot; , &quot;/usr/share/my_application&quot; ] 12 &gt; os : unsetenv ( &quot;XDG_DATA_DIRS&quot; ) . true 13 &gt; filename : basedir ( site_data , &quot;my_application&quot; , \#{ os =&gt; linux } ) . [ &quot;/usr/local/share/my_application&quot; , &quot;/usr/share/my_application&quot; ] On Darwin: 5 &gt; filename : basedir ( site_data , &quot;my_application&quot; , \#{ os =&gt; darwin } ) . [ &quot;/Library/Application Support/my_application&quot; ]","ref":"filename.html#basedir/3","title":"filename.basedir/3","type":"function"},{"doc":"Returns the last component of Filename , or Filename itself if it does not contain any directory separators. Examples: 5 &gt; filename : basename ( &quot;foo&quot; ) . &quot;foo&quot; 6 &gt; filename : basename ( &quot;/usr/foo&quot; ) . &quot;foo&quot; 7 &gt; filename : basename ( &quot;/&quot; ) . [ ]","ref":"filename.html#basename/1","title":"filename.basename/1","type":"function"},{"doc":"Returns the last component of Filename with extension Ext stripped. This function is to be used to remove a (possible) specific extension. To remove an existing extension when you are unsure which one it is, use rootname(basename(Filename)) . Examples: 8 &gt; filename : basename ( &quot;~/src/kalle.erl&quot; , &quot;.erl&quot; ) . &quot;kalle&quot; 9 &gt; filename : basename ( &quot;~/src/kalle.beam&quot; , &quot;.erl&quot; ) . &quot;kalle.beam&quot; 10 &gt; filename : basename ( &quot;~/src/kalle.old.erl&quot; , &quot;.erl&quot; ) . &quot;kalle.old&quot; 11 &gt; filename : rootname ( filename : basename ( &quot;~/src/kalle.erl&quot; ) ) . &quot;kalle&quot; 12 &gt; filename : rootname ( filename : basename ( &quot;~/src/kalle.beam&quot; ) ) . &quot;kalle&quot;","ref":"filename.html#basename/2","title":"filename.basename/2","type":"function"},{"doc":"Returns the directory part of Filename . Examples: 13 &gt; filename : dirname ( &quot;/usr/src/kalle.erl&quot; ) . &quot;/usr/src&quot; 14 &gt; filename : dirname ( &quot;kalle.erl&quot; ) . &quot;.&quot; 5 &gt; filename : dirname ( &quot;\\\\usr\\\\src/kalle.erl&quot; ) . % Windows &quot;/usr/src&quot;","ref":"filename.html#dirname/1","title":"filename.dirname/1","type":"function"},{"doc":"Returns the file extension of Filename , including the period. Returns an empty string if no extension exists. Examples: 15 &gt; filename : extension ( &quot;foo.erl&quot; ) . &quot;.erl&quot; 16 &gt; filename : extension ( &quot;beam.src/kalle&quot; ) . [ ]","ref":"filename.html#extension/1","title":"filename.extension/1","type":"function"},{"doc":"Converts a possibly deep list filename consisting of characters and atoms into the corresponding flat string filename.","ref":"filename.html#flatten/1","title":"filename.flatten/1","type":"function"},{"doc":"Joins a list of filename Components with directory separators. If one of the elements of Components includes an absolute path, such as &quot;/xxx&quot; , the preceding elements, if any, are removed from the result. The result is &quot;normalized&quot;: Redundant directory separators are removed. In Windows, all directory separators are forward slashes and the drive letter is in lower case. Examples: 17 &gt; filename : join ( [ &quot;/usr&quot; , &quot;local&quot; , &quot;bin&quot; ] ) . &quot;/usr/local/bin&quot; 18 &gt; filename : join ( [ &quot;a/b///c/&quot; ] ) . &quot;a/b/c&quot; 6 &gt; filename : join ( [ &quot;B:a\\\\b///c/&quot; ] ) . % Windows &quot;b:a/b/c&quot;","ref":"filename.html#join/1","title":"filename.join/1","type":"function"},{"doc":"Joins two filename components with directory separators. Equivalent to join([Name1, Name2]) .","ref":"filename.html#join/2","title":"filename.join/2","type":"function"},{"doc":"Converts Path to a form accepted by the command shell and native applications on the current platform. On Windows, forward slashes are converted to backward slashes. On all platforms, the name is normalized as done by join/1 . Examples: 19 &gt; filename : nativename ( &quot;/usr/local/bin/&quot; ) . % Unix &quot;/usr/local/bin&quot; 7 &gt; filename : nativename ( &quot;/usr/local/bin/&quot; ) . % Windows &quot;\\\\usr\\\\local\\\\bin&quot;","ref":"filename.html#nativename/1","title":"filename.nativename/1","type":"function"},{"doc":"Returns the path type, which is one of the following: absolute The path name refers to a specific file on a specific volume. Unix example: /usr/local/bin Windows example: D:/usr/local/bin relative The path name is relative to the current working directory on the current volume. Example: foo/bar, ../src volumerelative The path name is relative to the current working directory on a specified volume, or it is a specific file on the current working volume. Windows example: D:bar.erl, /bar/foo.erl","ref":"filename.html#pathtype/1","title":"filename.pathtype/1","type":"function"},{"doc":"Removes a filename extension. rootname/2 works as rootname/1 , except that the extension is removed only if it is Ext . Examples: 20 &gt; filename : rootname ( &quot;/beam.src/kalle&quot; ) . &quot;/beam.src/kalle&quot; 21 &gt; filename : rootname ( &quot;/beam.src/foo.erl&quot; ) . &quot;/beam.src/foo&quot; 22 &gt; filename : rootname ( &quot;/beam.src/foo.erl&quot; , &quot;.erl&quot; ) . &quot;/beam.src/foo&quot; 23 &gt; filename : rootname ( &quot;/beam.src/foo.beam&quot; , &quot;.erl&quot; ) . &quot;/beam.src/foo.beam&quot;","ref":"filename.html#rootname/1","title":"filename.rootname/1","type":"function"},{"doc":"","ref":"filename.html#rootname/2","title":"filename.rootname/2","type":"function"},{"doc":"Sanitizes the relative path by eliminating &quot;..&quot; and &quot;.&quot; components to protect against directory traversal attacks. Either returns the sanitized path name, or the atom unsafe if the path is unsafe. The path is considered unsafe in the following circumstances: The path is not relative. A &quot;..&quot; component would climb up above the root of the relative path. This function is deprecated. Use filelib:safe_relative_path/2 instead for sanitizing paths. Examples: 1 &gt; filename : safe_relative_path ( &quot;dir/sub_dir/..&quot; ) . &quot;dir&quot; 2 &gt; filename : safe_relative_path ( &quot;dir/..&quot; ) . [ ] 3 &gt; filename : safe_relative_path ( &quot;dir/../..&quot; ) . unsafe 4 &gt; filename : safe_relative_path ( &quot;/abs/path&quot; ) . unsafe","ref":"filename.html#safe_relative_path/1","title":"filename.safe_relative_path/1","type":"function"},{"doc":"Returns a list whose elements are the path components of Filename . Examples: 24 &gt; filename : split ( &quot;/usr/local/bin&quot; ) . [ &quot;/&quot; , &quot;usr&quot; , &quot;local&quot; , &quot;bin&quot; ] 25 &gt; filename : split ( &quot;foo/bar&quot; ) . [ &quot;foo&quot; , &quot;bar&quot; ] 26 &gt; filename : split ( &quot;a:\\\\msdev\\\\include&quot; ) . [ &quot;a:/&quot; , &quot;msdev&quot; , &quot;include&quot; ]","ref":"filename.html#split/1","title":"filename.split/1","type":"function"},{"doc":"This module provides ordered sets using Prof. Arne Andersson's General Balanced Trees. Ordered sets can be much more efficient than using ordered lists, for larger sets, but depends on the application. This module considers two elements as different if and only if they do not compare equal ( == ). Complexity Note The complexity on set operations is bounded by either O(|S|) or O(|T| * log(|S|)) , where S is the largest given set, depending on which is fastest for any particular function call. For operating on sets of almost equal size, this implementation is about 3 times slower than using ordered-list sets directly. For sets of very different sizes, however, this solution can be arbitrarily much faster; in practical cases, often 10-100 times. This implementation is particularly suited for accumulating elements a few at a time, building up a large set (&gt; 100-200 elements), and repeatedly testing for membership in the current set. As with normal tree structures, lookup (membership testing), insertion, and deletion have logarithmic complexity. Compatibility The following functions in this module also exist and provides the same functionality in the sets(3) and ordsets(3) modules. That is, by only changing the module name for each call, you can try out different set representations. add_element/2 del_element/2 filter/2 fold/3 from_list/1 intersection/1 intersection/2 is_element/2 is_empty/1 is_set/1 is_subset/2 new/0 size/1 subtract/2 to_list/1 union/1 union/2 See Also gb_trees(3) , ordsets(3) , sets(3)","ref":"gb_sets.html","title":"gb_sets","type":"module"},{"doc":"Returns a new set formed from Set1 with Element inserted. If Element is already an element in Set1 , nothing is changed.","ref":"gb_sets.html#add/2","title":"gb_sets.add/2","type":"function"},{"doc":"","ref":"gb_sets.html#add_element/2","title":"gb_sets.add_element/2","type":"function"},{"doc":"Rebalances the tree representation of Set1 . Notice that this is rarely necessary, but can be motivated when a large number of elements have been deleted from the tree without further insertions. Rebalancing can then be forced to minimise lookup times, as deletion does not rebalance the tree.","ref":"gb_sets.html#balance/1","title":"gb_sets.balance/1","type":"function"},{"doc":"Returns a new set formed from Set1 with Element removed. If Element is not an element in Set1 , nothing is changed.","ref":"gb_sets.html#del_element/2","title":"gb_sets.del_element/2","type":"function"},{"doc":"Returns a new set formed from Set1 with Element removed. Assumes that Element is present in Set1 .","ref":"gb_sets.html#delete/2","title":"gb_sets.delete/2","type":"function"},{"doc":"Returns a new set formed from Set1 with Element removed. If Element is not an element in Set1 , nothing is changed.","ref":"gb_sets.html#delete_any/2","title":"gb_sets.delete_any/2","type":"function"},{"doc":"Returns only the elements of Set1 that are not also elements of Set2 .","ref":"gb_sets.html#difference/2","title":"gb_sets.difference/2","type":"function"},{"doc":"Returns a new empty set.","ref":"gb_sets.html#empty/0","title":"gb_sets.empty/0","type":"function"},{"doc":"Filters elements in Set1 using predicate function Pred .","ref":"gb_sets.html#filter/2","title":"gb_sets.filter/2","type":"function"},{"doc":"Folds Function over every element in Set returning the final value of the accumulator.","ref":"gb_sets.html#fold/3","title":"gb_sets.fold/3","type":"function"},{"doc":"Returns a set of the elements in List , where List can be unordered and contain duplicates.","ref":"gb_sets.html#from_list/1","title":"gb_sets.from_list/1","type":"function"},{"doc":"Turns an ordered-set list List into a set. The list must not contain duplicates.","ref":"gb_sets.html#from_ordset/1","title":"gb_sets.from_ordset/1","type":"function"},{"doc":"Returns a new set formed from Set1 with Element inserted. Assumes that Element is not present in Set1 .","ref":"gb_sets.html#insert/2","title":"gb_sets.insert/2","type":"function"},{"doc":"Returns the intersection of the non-empty list of sets.","ref":"gb_sets.html#intersection/1","title":"gb_sets.intersection/1","type":"function"},{"doc":"Returns the intersection of Set1 and Set2 .","ref":"gb_sets.html#intersection/2","title":"gb_sets.intersection/2","type":"function"},{"doc":"Returns true if Set1 and Set2 are disjoint (have no elements in common), otherwise false .","ref":"gb_sets.html#is_disjoint/2","title":"gb_sets.is_disjoint/2","type":"function"},{"doc":"Returns true if Element is an element of Set , otherwise false .","ref":"gb_sets.html#is_element/2","title":"gb_sets.is_element/2","type":"function"},{"doc":"Returns true if Set is an empty set, otherwise false .","ref":"gb_sets.html#is_empty/1","title":"gb_sets.is_empty/1","type":"function"},{"doc":"Returns true if Element is an element of Set , otherwise false .","ref":"gb_sets.html#is_member/2","title":"gb_sets.is_member/2","type":"function"},{"doc":"Returns true if Term appears to be a set, otherwise false .","ref":"gb_sets.html#is_set/1","title":"gb_sets.is_set/1","type":"function"},{"doc":"Returns true when every element of Set1 is also a member of Set2 , otherwise false .","ref":"gb_sets.html#is_subset/2","title":"gb_sets.is_subset/2","type":"function"},{"doc":"Returns an iterator that can be used for traversing the entries of Set ; see next/1 . The implementation of this is very efficient; traversing the whole set using next/1 is only slightly slower than getting the list of all elements using to_list/1 and traversing that. The main advantage of the iterator approach is that it does not require the complete list of all elements to be built in memory at one time.","ref":"gb_sets.html#iterator/1","title":"gb_sets.iterator/1","type":"function"},{"doc":"Returns an iterator that can be used for traversing the entries of Set ; see next/1 . The difference as compared to the iterator returned by iterator/1 is that the first element greater than or equal to Element is returned.","ref":"gb_sets.html#iterator_from/2","title":"gb_sets.iterator_from/2","type":"function"},{"doc":"Returns the largest element in Set . Assumes that Set is not empty.","ref":"gb_sets.html#largest/1","title":"gb_sets.largest/1","type":"function"},{"doc":"Returns a new empty set.","ref":"gb_sets.html#new/0","title":"gb_sets.new/0","type":"function"},{"doc":"Returns {Element, Iter2} , where Element is the smallest element referred to by iterator Iter1 , and Iter2 is the new iterator to be used for traversing the remaining elements, or the atom none if no elements remain.","ref":"gb_sets.html#next/1","title":"gb_sets.next/1","type":"function"},{"doc":"Returns a set containing only element Element .","ref":"gb_sets.html#singleton/1","title":"gb_sets.singleton/1","type":"function"},{"doc":"Returns the number of elements in Set .","ref":"gb_sets.html#size/1","title":"gb_sets.size/1","type":"function"},{"doc":"Returns the smallest element in Set . Assumes that Set is not empty.","ref":"gb_sets.html#smallest/1","title":"gb_sets.smallest/1","type":"function"},{"doc":"Returns only the elements of Set1 that are not also elements of Set2 .","ref":"gb_sets.html#subtract/2","title":"gb_sets.subtract/2","type":"function"},{"doc":"Returns {Element, Set2} , where Element is the largest element in Set1 , and Set2 is this set with Element deleted. Assumes that Set1 is not empty.","ref":"gb_sets.html#take_largest/1","title":"gb_sets.take_largest/1","type":"function"},{"doc":"Returns {Element, Set2} , where Element is the smallest element in Set1 , and Set2 is this set with Element deleted. Assumes that Set1 is not empty.","ref":"gb_sets.html#take_smallest/1","title":"gb_sets.take_smallest/1","type":"function"},{"doc":"Returns the elements of Set as a list.","ref":"gb_sets.html#to_list/1","title":"gb_sets.to_list/1","type":"function"},{"doc":"Returns the merged (union) set of the list of sets.","ref":"gb_sets.html#union/1","title":"gb_sets.union/1","type":"function"},{"doc":"Returns the merged (union) set of Set1 and Set2 .","ref":"gb_sets.html#union/2","title":"gb_sets.union/2","type":"function"},{"doc":"","ref":"gb_sets.html#t:iter/0","title":"gb_sets.iter/0","type":"type"},{"doc":"A general balanced set iterator.","ref":"gb_sets.html#t:iter/1","title":"gb_sets.iter/1","type":"opaque"},{"doc":"","ref":"gb_sets.html#t:set/0","title":"gb_sets.set/0","type":"type"},{"doc":"A general balanced set.","ref":"gb_sets.html#t:set/1","title":"gb_sets.set/1","type":"opaque"},{"doc":"This module provides Prof. Arne Andersson's General Balanced Trees. These have no storage overhead compared to unbalanced binary trees, and their performance is better than AVL trees. This module considers two keys as different if and only if they do not compare equal ( == ). Data Structure Trees and iterators are built using opaque data structures that should not be pattern-matched from outside this module. There is no attempt to balance trees after deletions. As deletions do not increase the height of a tree, this should be OK. The original balance condition h(T) &lt;= ceil(c * log(|T|)) has been changed to the similar (but not quite equivalent) condition 2 ^ h(T) &lt;= |T| ^ c . This should also be OK. See Also dict(3) , gb_sets(3)","ref":"gb_trees.html","title":"gb_trees","type":"module"},{"doc":"Rebalances Tree1 . Notice that this is rarely necessary, but can be motivated when many nodes have been deleted from the tree without further insertions. Rebalancing can then be forced to minimize lookup times, as deletion does not rebalance the tree.","ref":"gb_trees.html#balance/1","title":"gb_trees.balance/1","type":"function"},{"doc":"Removes the node with key Key from Tree1 and returns the new tree. Assumes that the key is present in the tree, crashes otherwise.","ref":"gb_trees.html#delete/2","title":"gb_trees.delete/2","type":"function"},{"doc":"Removes the node with key Key from Tree1 if the key is present in the tree, otherwise does nothing. Returns the new tree.","ref":"gb_trees.html#delete_any/2","title":"gb_trees.delete_any/2","type":"function"},{"doc":"Returns a new empty tree.","ref":"gb_trees.html#empty/0","title":"gb_trees.empty/0","type":"function"},{"doc":"Inserts Key with value Value into Tree1 if the key is not present in the tree, otherwise updates Key to value Value in Tree1 . Returns the new tree.","ref":"gb_trees.html#enter/3","title":"gb_trees.enter/3","type":"function"},{"doc":"Turns an ordered list List of key-value tuples into a tree. The list must not contain duplicate keys.","ref":"gb_trees.html#from_orddict/1","title":"gb_trees.from_orddict/1","type":"function"},{"doc":"Retrieves the value stored with Key in Tree . Assumes that the key is present in the tree, crashes otherwise.","ref":"gb_trees.html#get/2","title":"gb_trees.get/2","type":"function"},{"doc":"Inserts Key with value Value into Tree1 and returns the new tree. Assumes that the key is not present in the tree, crashes otherwise.","ref":"gb_trees.html#insert/3","title":"gb_trees.insert/3","type":"function"},{"doc":"Returns true if Key is present in Tree , otherwise false .","ref":"gb_trees.html#is_defined/2","title":"gb_trees.is_defined/2","type":"function"},{"doc":"Returns true if Tree is an empty tree, othwewise false .","ref":"gb_trees.html#is_empty/1","title":"gb_trees.is_empty/1","type":"function"},{"doc":"Returns an iterator that can be used for traversing the entries of Tree ; see next/1 . The implementation of this is very efficient; traversing the whole tree using next/1 is only slightly slower than getting the list of all elements using to_list/1 and traversing that. The main advantage of the iterator approach is that it does not require the complete list of all elements to be built in memory at one time.","ref":"gb_trees.html#iterator/1","title":"gb_trees.iterator/1","type":"function"},{"doc":"Returns an iterator that can be used for traversing the entries of Tree ; see next/1 . The difference as compared to the iterator returned by iterator/1 is that the first key greater than or equal to Key is returned.","ref":"gb_trees.html#iterator_from/2","title":"gb_trees.iterator_from/2","type":"function"},{"doc":"Returns the keys in Tree as an ordered list.","ref":"gb_trees.html#keys/1","title":"gb_trees.keys/1","type":"function"},{"doc":"Returns {Key, Value} , where Key is the largest key in Tree , and Value is the value associated with this key. Assumes that the tree is not empty.","ref":"gb_trees.html#largest/1","title":"gb_trees.largest/1","type":"function"},{"doc":"Looks up Key in Tree . Returns {value, Value} , or none if Key is not present.","ref":"gb_trees.html#lookup/2","title":"gb_trees.lookup/2","type":"function"},{"doc":"Maps function F(K, V1) -&gt; V2 to all key-value pairs of tree Tree1 . Returns a new tree Tree2 with the same set of keys as Tree1 and the new set of values V2 .","ref":"gb_trees.html#map/2","title":"gb_trees.map/2","type":"function"},{"doc":"Returns {Key, Value, Iter2} , where Key is the smallest key referred to by iterator Iter1 , and Iter2 is the new iterator to be used for traversing the remaining nodes, or the atom none if no nodes remain.","ref":"gb_trees.html#next/1","title":"gb_trees.next/1","type":"function"},{"doc":"Returns the number of nodes in Tree .","ref":"gb_trees.html#size/1","title":"gb_trees.size/1","type":"function"},{"doc":"Returns {Key, Value} , where Key is the smallest key in Tree , and Value is the value associated with this key. Assumes that the tree is not empty.","ref":"gb_trees.html#smallest/1","title":"gb_trees.smallest/1","type":"function"},{"doc":"Returns a value Value from node with key Key and new Tree2 without the node with this value. Assumes that the node with key is present in the tree, crashes otherwise.","ref":"gb_trees.html#take/2","title":"gb_trees.take/2","type":"function"},{"doc":"Returns a value Value from node with key Key and new Tree2 without the node with this value. Returns error if the node with the key is not present in the tree.","ref":"gb_trees.html#take_any/2","title":"gb_trees.take_any/2","type":"function"},{"doc":"Returns {Key, Value, Tree2} , where Key is the largest key in Tree1 , Value is the value associated with this key, and Tree2 is this tree with the corresponding node deleted. Assumes that the tree is not empty.","ref":"gb_trees.html#take_largest/1","title":"gb_trees.take_largest/1","type":"function"},{"doc":"Returns {Key, Value, Tree2} , where Key is the smallest key in Tree1 , Value is the value associated with this key, and Tree2 is this tree with the corresponding node deleted. Assumes that the tree is not empty.","ref":"gb_trees.html#take_smallest/1","title":"gb_trees.take_smallest/1","type":"function"},{"doc":"Converts a tree into an ordered list of key-value tuples.","ref":"gb_trees.html#to_list/1","title":"gb_trees.to_list/1","type":"function"},{"doc":"Updates Key to value Value in Tree1 and returns the new tree. Assumes that the key is present in the tree.","ref":"gb_trees.html#update/3","title":"gb_trees.update/3","type":"function"},{"doc":"Returns the values in Tree as an ordered list, sorted by their corresponding keys. Duplicates are not removed.","ref":"gb_trees.html#values/1","title":"gb_trees.values/1","type":"function"},{"doc":"","ref":"gb_trees.html#t:iter/0","title":"gb_trees.iter/0","type":"type"},{"doc":"A general balanced tree iterator.","ref":"gb_trees.html#t:iter/2","title":"gb_trees.iter/2","type":"opaque"},{"doc":"","ref":"gb_trees.html#t:tree/0","title":"gb_trees.tree/0","type":"type"},{"doc":"A general balanced tree.","ref":"gb_trees.html#t:tree/2","title":"gb_trees.tree/2","type":"opaque"},{"doc":"This behavior module provides event handling functionality. It consists of a generic event manager process with any number of event handlers that are added and deleted dynamically. An event manager implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see OTP Design Principles. Each event handler is implemented as a callback module exporting a predefined set of functions. The relationship between the behavior functions and the callback functions is as follows: gen_event module Callback module -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - gen_event : start gen_event : start_monitor gen_event : start_link -- -- -&gt; - gen_event : add_handler gen_event : add_sup_handler -- -- -&gt; Module : init / 1 gen_event : notify gen_event : sync_notify -- -- -&gt; Module : handle_event / 2 gen_event : send_request gen_event : call -- -- -&gt; Module : handle_call / 2 - -- -- -&gt; Module : handle_info / 2 gen_event : delete_handler -- -- -&gt; Module : terminate / 2 gen_event : swap_handler gen_event : swap_sup_handler -- -- -&gt; Module1 : terminate / 2 Module2 : init / 1 gen_event : which_handlers -- -- -&gt; - gen_event : stop -- -- -&gt; Module : terminate / 2 - -- -- -&gt; Module : code_change / 3 As each event handler is one callback module, an event manager has many callback modules that are added and deleted dynamically. gen_event is therefore more tolerant of callback module errors than the other behaviors. If a callback function for an installed event handler fails with Reason , or returns a bad value Term , the event manager does not fail. It deletes the event handler by calling callback function Module:terminate/2 , giving as argument {error,{'EXIT',Reason}} or {error,Term} , respectively. No other event handler is affected. A gen_event process handles system messages as described in sys(3) . The sys module can be used for debugging an event manager. Notice that an event manager does trap exit signals automatically. The gen_event process can go into hibernation (see erlang:hibernate/3 ) if a callback function in a handler module specifies hibernate in its return value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each event handled by a busy event manager. Notice that when multiple event handlers are invoked, it is sufficient that one single event handler returns a hibernate request for the whole event manager to go into hibernation. Unless otherwise stated, all functions in this module fail if the specified event manager does not exist or if bad arguments are specified. See Also supervisor(3) , sys(3)","ref":"gen_event.html","title":"gen_event","type":"behaviour"},{"doc":"EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()  Name = Node = atom()  GlobalName = ViaName = term() Handler = Module | {Module,Id}  Module = atom()  Id = term() Args = term() Result = ok | {'EXIT',Reason} | term()  Reason = term() Adds a new event handler to event manager EventMgrRef . The event manager calls Module:init/1 to initiate the event handler and its internal state. EventMgrRef can be any of the following: The pid Name , if the event manager is locally registered {Name,Node} , if the event manager is locally registered at another node {global,GlobalName} , if the event manager is globally registered {via,Module,ViaName} , if the event manager is registered through an alternative process registry Handler is the name of the callback module Module or a tuple {Module,Id} , where Id is any term. The {Module,Id} representation makes it possible to identify a specific event handler when many event handlers use the same callback module. Args is any term that is passed as the argument to Module:init/1 . If Module:init/1 returns a correct value indicating successful completion, the event manager adds the event handler and this function returns ok . If Module:init/1 fails with Reason or returns {error,Reason} , the event handler is ignored and this function returns {'EXIT',Reason} or {error,Reason} , respectively.","ref":"gen_event.html#add_handler/3","title":"gen_event.add_handler/3","type":"function"},{"doc":"EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()  Name = Node = atom()  GlobalName = ViaName = term() Handler = Module | {Module,Id}  Module = atom()  Id = term() Args = term() Result = ok | {'EXIT',Reason} | term()  Reason = term() Adds a new event handler in the same way as add_handler/3 , but also supervises the connection between the event handler and the calling process. If the calling process later terminates with Reason , the event manager deletes the event handler by calling Module:terminate/2 with {stop,Reason} as argument. If the event handler is deleted later, the event manager sends a message {gen_event_EXIT,Handler,Reason} to the calling process. Reason is one of the following: normal , if the event handler has been removed because of a call to delete_handler/3 , or remove_handler has been returned by a callback function (see below). shutdown , if the event handler has been removed because the event manager is terminating. {swapped,NewHandler,Pid} , if the process Pid has replaced the event handler with another event handler NewHandler using a call to swap_handler/3 or swap_sup_handler/3 . A term, if the event handler is removed because of an error. Which term depends on the error. For a description of the arguments and return values, see add_handler/3 .","ref":"gen_event.html#add_sup_handler/3","title":"gen_event.add_sup_handler/3","type":"function"},{"doc":"EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()  Name = Node = atom()  GlobalName = ViaName = term() Handler = Module | {Module,Id}  Module = atom()  Id = term() Request = term() Timeout = int()&gt;0 | infinity Result = Reply | {error,Error}  Reply = term()  Error = bad_module | {'EXIT',Reason} | term()   Reason = term() Makes a synchronous call to event handler Handler installed in event manager EventMgrRef by sending a request and waiting until a reply arrives or a time-out occurs. The event manager calls Module:handle_call/2 to handle the request. For a description of EventMgrRef and Handler , see add_handler/3 . Request is any term that is passed as one of the arguments to Module:handle_call/2 . Timeout is an integer greater than zero that specifies how many milliseconds to wait for a reply, or the atom infinity to wait indefinitely. Defaults to 5000. If no reply is received within the specified time, the function call fails. The return value Reply is defined in the return value of Module:handle_call/2 . If the specified event handler is not installed, the function returns {error,bad_module} . If the callback function fails with Reason or returns an unexpected value Term , this function returns {error,{'EXIT',Reason}} or {error,Term} , respectively.","ref":"gen_event.html#call/3","title":"gen_event.call/3","type":"function"},{"doc":"","ref":"gen_event.html#call/4","title":"gen_event.call/4","type":"function"},{"doc":"Msg = term() RequestId = request_id() Result = {reply, Reply} | no_reply | {error, Error} Reply = Error = term() This function is used to check if a previously received message, for example by receive or handle_info/2 , is a result of a request made with send_request/3 . If Msg is a reply to the handle RequestId the result of the request is returned in Reply . Otherwise returns no_reply and no cleanup is done, and thus the function shall be invoked repeatedly until a reply is returned. If the specified event handler is not installed, the function returns {error,bad_module} . If the callback function fails with Reason or returns an unexpected value Term , this function returns {error,{'EXIT',Reason}} or {error,Term} , respectively. If the event manager dies before or during the request this function returns {error,{Reason, EventMgrRef}} .","ref":"gen_event.html#check_response/2","title":"gen_event.check_response/2","type":"function"},{"doc":"OldVsn = Vsn | {down, Vsn}   Vsn = term() State = NewState = term() Extra = term() This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with Change={advanced,Extra} specified in the .appup file is made when code_change/3 isn't implemented the event handler will crash with an undef error reason. This function is called for an installed event handler that is to update its internal state during a release upgrade/downgrade, that is, when the instruction {update,Module,Change,...} , where Change={advanced,Extra} , is specified in the .appup file. For more information, see OTP Design Principles. For an upgrade, OldVsn is Vsn , and for a downgrade, OldVsn is {down,Vsn} . Vsn is defined by the vsn attribute(s) of the old version of the callback module Module . If no such attribute is defined, the version is the checksum of the Beam file. State is the internal state of the event handler. Extra is passed &quot;as is&quot; from the {advanced,Extra} part of the update instruction. The function is to return the updated internal state.","ref":"gen_event.html#c:code_change/3","title":"gen_event.code_change/3","type":"callback"},{"doc":"EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()  Name = Node = atom()  GlobalName = ViaName = term() Handler = Module | {Module,Id}  Module = atom()  Id = term() Args = term() Result = term() | {error,module_not_found} | {'EXIT',Reason}  Reason = term() Deletes an event handler from event manager EventMgrRef . The event manager calls Module:terminate/2 to terminate the event handler. For a description of EventMgrRef and Handler , see add_handler/3 . Args is any term that is passed as one of the arguments to Module:terminate/2 . The return value is the return value of Module:terminate/2 . If the specified event handler is not installed, the function returns {error,module_not_found} . If the callback function fails with Reason , the function returns {'EXIT',Reason} .","ref":"gen_event.html#delete_handler/3","title":"gen_event.delete_handler/3","type":"function"},{"doc":"Opt = normal | terminate PDict = [{Key, Value}] State = term() Status = term() This callback is optional, so event handler modules need not export it. If a handler does not export this function, the gen_event module uses the handler state directly for the purposes described below. This function is called by a gen_event process in the following situations: One of sys:get_status/1,2 is invoked to get the gen_event status. Opt is set to the atom normal for this case. The event handler terminates abnormally and gen_event logs an error. Opt is set to the atom terminate for this case. This function is useful for changing the form and appearance of the event handler state for these cases. An event handler callback module wishing to change the the sys:get_status/1,2 return value as well as how its state appears in termination error logs, exports an instance of format_status/2 that returns a term describing the current state of the event handler. PDict is the current value of the process dictionary of gen_event . State is the internal state of the event handler. The function is to return Status , a term that change the details of the current state of the event handler. Any term is allowed for Status . The gen_event module uses Status as follows: When sys:get_status/1,2 is called, gen_event ensures that its return value contains Status in place of the state term of the event handler. When an event handler terminates abnormally, gen_event logs Status in place of the state term of the event handler. One use for this function is to return compact alternative state representations to avoid that large state terms are printed in log files.","ref":"gen_event.html#c:format_status/2","title":"gen_event.format_status/2","type":"callback"},{"doc":"Request = term() State = term() Result = {ok,Reply,NewState} | {ok,Reply,NewState,hibernate}  | {swap_handler,Reply,Args1,NewState,Handler2,Args2}  | {remove_handler, Reply}  Reply = term()  NewState = term()  Args1 = Args2 = term()  Handler2 = Module2 | {Module2,Id}   Module2 = atom()   Id = term() Whenever an event manager receives a request sent using call/3,4 , this function is called for the specified event handler to handle the request. Request is the Request argument of call/3,4 . State is the internal state of the event handler. The return values are the same as for Module:handle_event/2 except that they also contain a term Reply , which is the reply to the client as the return value of call/3,4 .","ref":"gen_event.html#c:handle_call/2","title":"gen_event.handle_call/2","type":"callback"},{"doc":"Event = term() State = term() Result = {ok,NewState} | {ok,NewState,hibernate}   | {swap_handler,Args1,NewState,Handler2,Args2} | remove_handler  NewState = term()  Args1 = Args2 = term()  Handler2 = Module2 | {Module2,Id}   Module2 = atom()   Id = term() Whenever an event manager receives an event sent using notify/2 or sync_notify/2 , this function is called for each installed event handler to handle the event. Event is the Event argument of notify/2 / sync_notify/2 . State is the internal state of the event handler. If {ok,NewState} or {ok,NewState,hibernate} is returned, the event handler remains in the event manager with the possible updated internal state NewState . If {ok,NewState,hibernate} is returned, the event manager also goes into hibernation (by calling proc_lib:hibernate/3 ), waiting for the next event to occur. It is sufficient that one of the event handlers return {ok,NewState,hibernate} for the whole event manager process to hibernate. If {swap_handler,Args1,NewState,Handler2,Args2} is returned, the event handler is replaced by Handler2 by first calling Module:terminate(Args1,NewState) and then Module2:init({Args2,Term}) , where Term is the return value of Module:terminate/2 . For more information, see swap_handler/3 . If remove_handler is returned, the event handler is deleted by calling Module:terminate(remove_handler,State) .","ref":"gen_event.html#c:handle_event/2","title":"gen_event.handle_event/2","type":"callback"},{"doc":"Info = term() State = term() Result = {ok,NewState} | {ok,NewState,hibernate}  | {swap_handler,Args1,NewState,Handler2,Args2} | remove_handler  NewState = term()  Args1 = Args2 = term()  Handler2 = Module2 | {Module2,Id}   Module2 = atom()   Id = term() This callback is optional, so callback modules need not export it. The gen_event module provides a default implementation of this function that logs about the unexpected Info message, drops it and returns {ok, State} . This function is called for each installed event handler when an event manager receives any other message than an event or a synchronous request (or a system message). Info is the received message. For a description of State and possible return values, see Module:handle_event/2 .","ref":"gen_event.html#c:handle_info/2","title":"gen_event.handle_info/2","type":"callback"},{"doc":"InitArgs = Args | {Args,Term}  Args = Term = term() State = term() Reason = term() Whenever a new event handler is added to an event manager, this function is called to initialize the event handler. If the event handler is added because of a call to add_handler/3 or add_sup_handler/3 , InitArgs is the Args argument of these functions. If the event handler replaces another event handler because of a call to swap_handler/3 or swap_sup_handler/3 , or because of a swap return tuple from one of the other callback functions, InitArgs is a tuple {Args,Term} , where Args is the argument provided in the function call/return tuple and Term is the result of terminating the old event handler, see swap_handler/3 . If successful, the function returns {ok,State} or {ok,State,hibernate} , where State is the initial internal state of the event handler. If {ok,State,hibernate} is returned, the event manager goes into hibernation (by calling proc_lib:hibernate/3 ), waiting for the next event to occur.","ref":"gen_event.html#c:init/1","title":"gen_event.init/1","type":"callback"},{"doc":"EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()  Name = Node = atom()  GlobalName = ViaName = term() Event = term() Sends an event notification to event manager EventMgrRef . The event manager calls Module:handle_event/2 for each installed event handler to handle the event. notify/2 is asynchronous and returns immediately after the event notification has been sent. sync_notify/2 is synchronous in the sense that it returns ok after the event has been handled by all event handlers. For a description of EventMgrRef , see add_handler/3 . Event is any term that is passed as one of the arguments to Module:handle_event/2 . notify/1 does not fail even if the specified event manager does not exist, unless it is specified as Name .","ref":"gen_event.html#notify/2","title":"gen_event.notify/2","type":"function"},{"doc":"RequestId = request_id() Reply = term() Timeout = timeout() Result = {reply, Reply} | timeout | {error, Error} Reply = Error = term() This function is used to receive for a reply of a request made with send_request/3 to the event manager. This function must be called from the same process from which send_request/3 was made. Timeout is an integer greater then or equal to zero that specifies how many milliseconds to wait for an reply, or the atom infinity to wait indefinitely. If no reply is received within the specified time, the function returns timeout . Assuming that the server executes on a node supporting aliases (introduced in OTP 24) no response will be received after a timeout. Otherwise, a garbage response might be received at a later time. The return value Reply is defined in the return value of Module:handle_call/3 . If the specified event handler is not installed, the function returns {error,bad_module} . If the callback function fails with Reason or returns an unexpected value Term , this function returns {error,{'EXIT',Reason}} or {error,Term} , respectively. If the event manager dies before or during the request this function returns {error,{Reason, EventMgrRef}} . The difference between wait_response() and receive_response() is that receive_response() abandons the request at timeout so that a potential future response is ignored, while wait_response() does not.","ref":"gen_event.html#receive_response/2","title":"gen_event.receive_response/2","type":"function"},{"doc":"EventMgrRef = Name | {Name,Node} | {global,GlobalName}   | {via,Module,ViaName} | pid()  Node = atom()  GlobalName = ViaName = term() Handler = Module | {Module,Id}  Module = atom()  Id = term() Request = term() RequestId = request_id() Sends a request to event handler Handler installed in event manager EventMgrRef and returns a handle RequestId . The return value RequestId shall later be used with receive_response/2 , wait_response/2 , or check_response/2 in the same process to fetch the actual result of the request. The call gen_event:wait_response(gen_event:send_request(EventMgrRef,Handler,Request), Timeout) can be seen as equivalent to gen_event:call(EventMgrRef,Handler,Request,Timeout) , ignoring the error handling. The event manager calls Module:handle_call/2 to handle the request. Request is any term that is passed as one of the arguments to Module:handle_call/3 .","ref":"gen_event.html#send_request/3","title":"gen_event.send_request/3","type":"function"},{"doc":"EventMgrName = {local,Name} | {global,GlobalName} | {via,Module,ViaName}  Name = atom()  GlobalName = ViaName = term() Options = [Option]  Option = {debug,Dbgs} | {timeout,Time} | {hibernate_after,HibernateAfterTimeout} | {spawn_opt,SOpts}   Dbgs = [Dbg]    Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}   SOpts = [term()] Result = {ok,Pid} | {error,{already_started,Pid}}  Pid = pid() Creates a stand-alone event manager process, that is, an event manager that is not part of a supervision tree and thus has no supervisor. For a description of the arguments and return values, see start_link/0,1 .","ref":"gen_event.html#start/0","title":"gen_event.start/0","type":"function"},{"doc":"","ref":"gen_event.html#start/1","title":"gen_event.start/1","type":"function"},{"doc":"","ref":"gen_event.html#start/2","title":"gen_event.start/2","type":"function"},{"doc":"EventMgrName = {local,Name} | {global,GlobalName} | {via,Module,ViaName}  Name = atom()  GlobalName = ViaName = term() Options = [Option]  Option = {debug,Dbgs} | {timeout,Time} | {hibernate_after,HibernateAfterTimeout} | {spawn_opt,SOpts}   Dbgs = [Dbg]    Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}   SOpts = [term()] Result = {ok,Pid} | {error,{already_started,Pid}}  Pid = pid() Creates an event manager process as part of a supervision tree. The function is to be called, directly or indirectly, by the supervisor. For example, it ensures that the event manager is linked to the supervisor. If EventMgrName={local,Name} , the event manager is registered locally as Name using register/2 . If EventMgrName={global,GlobalName} , the event manager is registered globally as GlobalName using global:register_name/2 . If no name is provided, the event manager is not registered. If EventMgrName={via,Module,ViaName} , the event manager registers with the registry represented by Module . The Module callback is to export the functions register_name/2 , unregister_name/1 , whereis_name/1 , and send/2 , which are to behave as the corresponding functions in global . Thus, {via,global,GlobalName} is a valid reference. If option {hibernate_after,HibernateAfterTimeout} is present, the gen_event process awaits any message for HibernateAfterTimeout milliseconds and if no message is received, the process goes into hibernation automatically (by calling proc_lib:hibernate/3 ). If the event manager is successfully created, the function returns {ok,Pid} , where Pid is the pid of the event manager. If a process with the specified EventMgrName exists already, the function returns {error,{already_started,Pid}} , where Pid is the pid of that process.","ref":"gen_event.html#start_link/0","title":"gen_event.start_link/0","type":"function"},{"doc":"","ref":"gen_event.html#start_link/1","title":"gen_event.start_link/1","type":"function"},{"doc":"","ref":"gen_event.html#start_link/2","title":"gen_event.start_link/2","type":"function"},{"doc":"EventMgrName = {local,Name} | {global,GlobalName} | {via,Module,ViaName}  Name = atom()  GlobalName = ViaName = term() Options = [Option]  Option = {debug,Dbgs} | {timeout,Time} | {hibernate_after,HibernateAfterTimeout} | {spawn_opt,SOpts}   Dbgs = [Dbg]    Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}   SOpts = [term()] Result = {ok,{Pid,Mon}} | {error,{already_started,Pid}}  Pid = pid() Creates a stand-alone event manager process, that is, an event manager that is not part of a supervision tree (and thus has no supervisor) and atomically sets up a monitor to the newly created process. For a description of the arguments and return values, see start_link/0,1 . Note that the return value on successful start differs from start_link/3,4 . start_monitor/3,4 will return {ok,{Pid,Mon}} where Pid is the process identifier of the process, and Mon is a reference to the monitor set up to monitor the process. If the start is not successful, the caller will be blocked until the DOWN message has been received and removed from the message queue.","ref":"gen_event.html#start_monitor/0","title":"gen_event.start_monitor/0","type":"function"},{"doc":"","ref":"gen_event.html#start_monitor/1","title":"gen_event.start_monitor/1","type":"function"},{"doc":"","ref":"gen_event.html#start_monitor/2","title":"gen_event.start_monitor/2","type":"function"},{"doc":"EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid() Name = Node = atom() GlobalName = ViaName = term() Reason = term() Timeout = int()&gt;0 | infinity Orders event manager EventMgrRef to exit with the specifies Reason and waits for it to terminate. Before terminating, gen_event calls Module:terminate(stop,...) for each installed event handler. The function returns ok if the event manager terminates with the expected reason. Any other reason than normal , shutdown , or {shutdown,Term} causes an error report to be issued using logger(3) . The default Reason is normal . Timeout is an integer greater than zero that specifies how many milliseconds to wait for the event manager to terminate, or the atom infinity to wait indefinitely. Defaults to infinity . If the event manager has not terminated within the specified time, a timeout exception is raised. If the process does not exist, a noproc exception is raised. For a description of EventMgrRef , see add_handler/3 .","ref":"gen_event.html#stop/1","title":"gen_event.stop/1","type":"function"},{"doc":"","ref":"gen_event.html#stop/3","title":"gen_event.stop/3","type":"function"},{"doc":"EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()  Name = Node = atom()  GlobalName = ViaName = term() Handler1 = Handler2 = Module | {Module,Id}  Module = atom()  Id = term() Args1 = Args2 = term() Result = ok | {error,Error}  Error = {'EXIT',Reason} | term()   Reason = term() Replaces an old event handler with a new event handler in event manager EventMgrRef . For a description of the arguments, see add_handler/3 . First the old event handler Handler1 is deleted. The event manager calls Module1:terminate(Args1, ...) , where Module1 is the callback module of Handler1 , and collects the return value. Then the new event handler Handler2 is added and initiated by calling Module2:init({Args2,Term}) , where Module2 is the callback module of Handler2 and Term is the return value of Module1:terminate/2 . This makes it possible to transfer information from Handler1 to Handler2 . The new handler is added even if the the specified old event handler is not installed, in which case Term=error , or if Module1:terminate/2 fails with Reason , in which case Term={'EXIT',Reason} . The old handler is deleted even if Module2:init/1 fails. If there was a supervised connection between Handler1 and a process Pid , there is a supervised connection between Handler2 and Pid instead. If Module2:init/1 returns a correct value, this function returns ok . If Module2:init/1 fails with Reason or returns an unexpected value Term , this function returns {error,{'EXIT',Reason}} or {error,Term} , respectively.","ref":"gen_event.html#swap_handler/3","title":"gen_event.swap_handler/3","type":"function"},{"doc":"EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()  Name = Node = atom()  GlobalName = ViaName = term() Handler1 = Handler 2 = Module | {Module,Id}  Module = atom()  Id = term() Args1 = Args2 = term() Result = ok | {error,Error}  Error = {'EXIT',Reason} | term()   Reason = term() Replaces an event handler in event manager EventMgrRef in the same way as swap_handler/3 , but also supervises the connection between Handler2 and the calling process. For a description of the arguments and return values, see swap_handler/3 .","ref":"gen_event.html#swap_sup_handler/3","title":"gen_event.swap_sup_handler/3","type":"function"},{"doc":"","ref":"gen_event.html#sync_notify/2","title":"gen_event.sync_notify/2","type":"function"},{"doc":"Arg = Args | {stop,Reason} | stop | remove_handler  | {error,{'EXIT',Reason}} | {error,Term}  Args = Reason = Term = term() This callback is optional, so callback modules need not export it. The gen_event module provides a default implementation without cleanup. Whenever an event handler is deleted from an event manager, this function is called. It is to be the opposite of Module:init/1 and do any necessary cleaning up. If the event handler is deleted because of a call to delete_handler/3 , swap_handler/3 , or swap_sup_handler/3 , Arg is the Args argument of this function call. Arg={stop,Reason} if the event handler has a supervised connection to a process that has terminated with reason Reason . Arg=stop if the event handler is deleted because the event manager is terminating. The event manager terminates if it is part of a supervision tree and it is ordered by its supervisor to terminate. Even if it is not part of a supervision tree, it terminates if it receives an 'EXIT' message from its parent. Arg=remove_handler if the event handler is deleted because another callback function has returned remove_handler or {remove_handler,Reply} . Arg={error,Term} if the event handler is deleted because a callback function returned an unexpected value Term , or Arg={error,{'EXIT',Reason}} if a callback function failed. State is the internal state of the event handler. The function can return any term. If the event handler is deleted because of a call to gen_event:delete_handler/3 , the return value of that function becomes the return value of this function. If the event handler is to be replaced with another event handler because of a swap, the return value is passed to the init function of the new event handler. Otherwise the return value is ignored.","ref":"gen_event.html#c:terminate/2","title":"gen_event.terminate/2","type":"callback"},{"doc":"RequestId = request_id() Reply = term() Timeout = timeout() Result = {reply, Reply} | timeout | {error, Error} Reply = Error = term() This function is used to wait for a reply of a request made with send_request/3 to the event manager. This function must be called from the same process from which send_request/3 was made. Timeout is an integer greater then or equal to zero that specifies how many milliseconds to wait for an reply, or the atom infinity to wait indefinitely. If no reply is received within the specified time, the function returns timeout and no cleanup is done, and thus the function must be invoked repeatedly until a reply is returned. The return value Reply is defined in the return value of Module:handle_call/3 . If the specified event handler is not installed, the function returns {error,bad_module} . If the callback function fails with Reason or returns an unexpected value Term , this function returns {error,{'EXIT',Reason}} or {error,Term} , respectively. If the event manager dies before or during the request this function returns {error,{Reason, EventMgrRef}} . The difference between receive_response() and wait_response() is that receive_response() abandons the request at timeout so that a potential future response is ignored, while wait_response() does not.","ref":"gen_event.html#wait_response/2","title":"gen_event.wait_response/2","type":"function"},{"doc":"EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()  Name = Node = atom()  GlobalName = ViaName = term() Handler = Module | {Module,Id}  Module = atom()  Id = term() Returns a list of all event handlers installed in event manager EventMgrRef . For a description of EventMgrRef and Handler , see add_handler/3 .","ref":"gen_event.html#which_handlers/1","title":"gen_event.which_handlers/1","type":"function"},{"doc":"","ref":"gen_event.html#t:add_handler_ret/0","title":"gen_event.add_handler_ret/0","type":"type"},{"doc":"","ref":"gen_event.html#t:del_handler_ret/0","title":"gen_event.del_handler_ret/0","type":"type"},{"doc":"","ref":"gen_event.html#t:handler/0","title":"gen_event.handler/0","type":"type"},{"doc":"","ref":"gen_event.html#t:handler_args/0","title":"gen_event.handler_args/0","type":"type"},{"doc":"A request handle, see send_request/3 for details.","ref":"gen_event.html#t:request_id/0","title":"gen_event.request_id/0","type":"type"},{"doc":"Deprecated and replaced by gen_statem Migration to gen_statem Here follows a simple example of turning a gen_fsm into a gen_statem . The example comes from the previous Users Guide for gen_fsm -module(code_lock). -define(NAME, code_lock). %-define(BEFORE_REWRITE, true). -ifdef(BEFORE_REWRITE). -behaviour(gen_fsm). -else. -behaviour(gen_statem). -endif. -export([start_link/1, button/1, stop/0]). -ifdef(BEFORE_REWRITE). -export([init/1, locked/2, open/2, handle_sync_event/4, handle_event/3, handle_info/3, terminate/3, code_change/4]). -else. -export([init/1, callback_mode/0, locked/3, open/3, terminate/3, code_change/4]). %% Add callback__mode/0 %% Change arity of the state functions %% Remove handle_info/3 -endif. -ifdef(BEFORE_REWRITE). start_link(Code) -&gt; gen_fsm:start_link({local, ?NAME}, ?MODULE, Code, []). -else. start_link(Code) -&gt; gen_statem:start_link({local,?NAME}, ?MODULE, Code, []). -endif. -ifdef(BEFORE_REWRITE). button(Digit) -&gt; gen_fsm:send_event(?NAME, {button, Digit}). -else. button(Digit) -&gt; gen_statem:cast(?NAME, {button,Digit}). %% send_event is asynchronous and becomes a cast -endif. -ifdef(BEFORE_REWRITE). stop() -&gt; gen_fsm:sync_send_all_state_event(?NAME, stop). -else. stop() -&gt; gen_statem:call(?NAME, stop). %% sync_send is synchronous and becomes call %% all_state is handled by callback code in gen_statem -endif. init(Code) -&gt; do_lock(), Data = \#{code =&gt; Code, remaining =&gt; Code}, {ok, locked, Data}. -ifdef(BEFORE_REWRITE). -else. callback_mode() -&gt; state_functions. %% state_functions mode is the mode most similar to %% gen_fsm. There is also handle_event mode which is %% a fairly different concept. -endif. -ifdef(BEFORE_REWRITE). locked({button, Digit}, Data0) -&gt; case analyze_lock(Digit, Data0) of {open = StateName, Data} -&gt; {next_state, StateName, Data, 10000}; {StateName, Data} -&gt; {next_state, StateName, Data} end. -else. locked(cast, {button,Digit}, Data0) -&gt; case analyze_lock(Digit, Data0) of {open = StateName, Data} -&gt; {next_state, StateName, Data, 10000}; {StateName, Data} -&gt; {next_state, StateName, Data} end; locked({call, From}, Msg, Data) -&gt; handle_call(From, Msg, Data); locked({info, Msg}, StateName, Data) -&gt; handle_info(Msg, StateName, Data). %% Arity differs %% All state events are dispatched to handle_call and handle_info help %% functions. If you want to handle a call or cast event specifically %% for this state you would add a special clause for it above. -endif. -ifdef(BEFORE_REWRITE). open(timeout, State) -&gt; do_lock(), {next_state, locked, State}; open({button,_}, Data) -&gt; {next_state, locked, Data}. -else. open(timeout, _, Data) -&gt; do_lock(), {next_state, locked, Data}; open(cast, {button,_}, Data) -&gt; {next_state, locked, Data}; open({call, From}, Msg, Data) -&gt; handle_call(From, Msg, Data); open(info, Msg, Data) -&gt; handle_info(Msg, open, Data). %% Arity differs %% All state events are dispatched to handle_call and handle_info help %% functions. If you want to handle a call or cast event specifically %% for this state you would add a special clause for it above. -endif. -ifdef(BEFORE_REWRITE). handle_sync_event(stop, _From, _StateName, Data) -&gt; {stop, normal, ok, Data}. handle_event(Event, StateName, Data) -&gt; {stop, {shutdown, {unexpected, Event, StateName}}, Data}. handle_info(Info, StateName, Data) -&gt; {stop, {shutdown, {unexpected, Info, StateName}}, StateName, Data}. -else. -endif. terminate(_Reason, State, _Data) -&gt; State =/= locked andalso do_lock(), ok. code_change(_Vsn, State, Data, _Extra) -&gt; {ok, State, Data}. %% Internal functions -ifdef(BEFORE_REWRITE). -else. handle_call(From, stop, Data) -&gt; {stop_and_reply, normal, {reply, From, ok}, Data}. handle_info(Info, StateName, Data) -&gt; {stop, {shutdown, {unexpected, Info, StateName}}, StateName, Data}. %% These are internal functions for handling all state events %% and not behaviour callbacks as in gen_fsm -endif. analyze_lock(Digit, \#{code := Code, remaining := Remaining} = Data) -&gt; case Remaining of [Digit] -&gt; do_unlock(), {open, Data\#{remaining := Code}}; [Digit|Rest] -&gt; % Incomplete {locked, Data\#{remaining := Rest}}; _Wrong -&gt; {locked, Data\#{remaining := Code}} end. do_lock() -&gt; io:format(&quot;Lock~n&quot;, []). do_unlock() -&gt; io:format(&quot;Unlock~n&quot;, []).","ref":"gen_fsm.html","title":"gen_fsm","type":"behaviour"},{"doc":"This behavior module provides the server of a client-server relation. A generic server process ( gen_server ) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see section gen_server Behaviour in OTP Design Principles. A gen_server process assumes all specific parts to be located in a callback module exporting a predefined set of functions. The relationship between the behavior functions and the callback functions is as follows: gen_server module Callback module -- -- -- -- -- -- -- -- - -- -- -- -- -- -- -- - gen_server : start gen_server : start_monitor gen_server : start_link -- -- -&gt; Module : init / 1 gen_server : stop -- -- -&gt; Module : terminate / 2 gen_server : call gen_server : send_request gen_server : multi_call -- -- -&gt; Module : handle_call / 3 gen_server : cast gen_server : abcast -- -- -&gt; Module : handle_cast / 2 - -- -- -&gt; Module : handle_info / 2 - -- -- -&gt; Module : handle_continue / 2 - -- -- -&gt; Module : terminate / 2 - -- -- -&gt; Module : code_change / 3 If a callback function fails or returns a bad value, the gen_server process terminates. A gen_server process handles system messages as described in sys(3) . The sys module can be used for debugging a gen_server process. Notice that a gen_server process does not trap exit signals automatically, this must be explicitly initiated in the callback module. Unless otherwise stated, all functions in this module fail if the specified gen_server process does not exist or if bad arguments are specified. The gen_server process can go into hibernation (see erlang:hibernate/3 ) if a callback function specifies 'hibernate' instead of a time-out value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each call to a busy server. If the gen_server process needs to perform an action immediately after initialization or to break the execution of a callback into multiple steps, it can return {continue,Continue} in place of the time-out or hibernation value, which will immediately invoke the handle_continue/2 callback. If the gen_server process terminates, e.g. as a result of a function in the callback module returning {stop,Reason,NewState} , an exit signal with this Reason is sent to linked processes and ports. See Processes in the Reference Manual for details regarding error handling using exit signals. See Also gen_event(3) , gen_statem(3) , proc_lib(3) , supervisor(3) , sys(3)","ref":"gen_server.html","title":"gen_server","type":"behaviour"},{"doc":"Nodes = [Node]  Node = atom() Name = atom() Request = term() Sends an asynchronous request to the gen_server processes locally registered as Name at the specified nodes. The function returns immediately and ignores nodes that do not exist, or where the gen_server Name does not exist. The gen_server processes call Module:handle_cast/2 to handle the request. For a description of the arguments, see multi_call/2,3,4 .","ref":"gen_server.html#abcast/2","title":"gen_server.abcast/2","type":"function"},{"doc":"","ref":"gen_server.html#abcast/3","title":"gen_server.abcast/3","type":"function"},{"doc":"ServerRef = Name | {Name,Node} | {global,GlobalName}   | {via,Module,ViaName} | pid()  Node = atom()  GlobalName = ViaName = term() Request = term() Timeout = int()&gt;0 | infinity Reply = term() Makes a synchronous call to the ServerRef of the gen_server process by sending a request and waiting until a reply arrives or a time-out occurs. The gen_server process calls Module:handle_call/3 to handle the request. ServerRef can be any of the following: The pid Name , if the gen_server process is locally registered {Name,Node} , if the gen_server process is locally registered at another node {global,GlobalName} , if the gen_server process is globally registered {via,Module,ViaName} , if the gen_server process is registered through an alternative process registry Request is any term that is passed as the first argument to Module:handle_call/3 . Timeout is an integer greater than zero that specifies how many milliseconds to wait for a reply, or the atom infinity to wait indefinitely. Defaults to 5000. If no reply is received within the specified time, the function call fails. If the caller catches the failure and continues running, and the server is just late with the reply, it can arrive at any time later into the message queue of the caller. The caller must in this case be prepared for this and discard any such garbage messages that are two element tuples with a reference as the first element. The return value Reply is defined in the return value of Module:handle_call/3 . The call can fail for many reasons, including time-out and the called gen_server process dying before or during the call.","ref":"gen_server.html#call/2","title":"gen_server.call/2","type":"function"},{"doc":"","ref":"gen_server.html#call/3","title":"gen_server.call/3","type":"function"},{"doc":"ServerRef = Name | {Name,Node} | {global,GlobalName}   | {via,Module,ViaName} | pid()  Node = atom()  GlobalName = ViaName = term() Request = term() Sends an asynchronous request to the ServerRef of the gen_server process and returns ok immediately, ignoring if the destination node or gen_server process does not exist. The gen_server process calls Module:handle_cast/2 to handle the request. For a description of ServerRef , see call/2,3 . Request is any term that is passed as one of the arguments to Module:handle_cast/2 .","ref":"gen_server.html#cast/2","title":"gen_server.cast/2","type":"function"},{"doc":"RequestId = term() Result = {reply, Reply} | no_reply | {error, {Reason, ServerRef}} Msg = Reply = term() Timeout = timeout() Reason = term() ServerRef = Name | {Name,Node} | {global,GlobalName}   | {via,Module,ViaName} | pid()  Node = atom()  GlobalName = ViaName = term() This function is used to check if a previously received message, for example by receive or handle_info/2 , is a result of a request made with send_request/2 . If Msg is a reply to the handle RequestId the result of the request is returned in Reply . Otherwise returns no_reply and no cleanup is done, and thus the function must be invoked repeatedly until a reply is returned. The return value Reply is defined in the return value of Module:handle_call/3 . The function returns an error if the gen_server dies before or during this request.","ref":"gen_server.html#check_response/2","title":"gen_server.check_response/2","type":"function"},{"doc":"OldVsn = Vsn | {down, Vsn}   Vsn = term() State = NewState = term() Extra = term() Reason = term() This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with Change={advanced,Extra} specified in the appup file is made when code_change/3 isn't implemented the process will crash with an undef exit reason. This function is called by a gen_server process when it is to update its internal state during a release upgrade/downgrade, that is, when the instruction {update,Module,Change,...} , where Change={advanced,Extra} , is specifed in the appup file. For more information, see section Release Handling Instructions in OTP Design Principles. For an upgrade, OldVsn is Vsn , and for a downgrade, OldVsn is {down,Vsn} . Vsn is defined by the vsn attribute(s) of the old version of the callback module Module . If no such attribute is defined, the version is the checksum of the Beam file. State is the internal state of the gen_server process. Extra is passed &quot;as is&quot; from the {advanced,Extra} part of the update instruction. If successful, the function must return the updated internal state. If the function returns {error,Reason} , the ongoing upgrade fails and rolls back to the old release.","ref":"gen_server.html#c:code_change/3","title":"gen_server.code_change/3","type":"callback"},{"doc":"Module = atom() Options = [Option]  Option = {debug,Dbgs} | {hibernate_after,HibernateAfterTimeout}   Dbgs = [Dbg]    Dbg = trace | log | statistics     | {log_to_file,FileName} | {install,{Func,FuncState}} State = term() ServerName = {local,Name} | {global,GlobalName}   | {via,Module,ViaName}  Name = atom()  GlobalName = ViaName = term() Timeout = int() | infinity Makes an existing process into a gen_server process. Does not return, instead the calling process enters the gen_server process receive loop and becomes a gen_server process. The process must have been started using one of the start functions in proc_lib(3) . The user is responsible for any initialization of the process, including registering a name for it. This function is useful when a more complex initialization procedure is needed than the gen_server process behavior provides. Module , Options , and ServerName have the same meanings as when calling start[_link|_monitor]/3,4 . However, if ServerName is specified, the process must have been registered accordingly before this function is called. State and Timeout have the same meanings as in the return value of Module:init/1 . The callback module Module does not need to export an init/1 function. The function fails if the calling process was not started by a proc_lib start function, or if it is not registered according to ServerName .","ref":"gen_server.html#enter_loop/3","title":"gen_server.enter_loop/3","type":"function"},{"doc":"","ref":"gen_server.html#enter_loop/4","title":"gen_server.enter_loop/4","type":"function"},{"doc":"","ref":"gen_server.html#enter_loop/5","title":"gen_server.enter_loop/5","type":"function"},{"doc":"Opt = normal | terminate PDict = [{Key, Value}] State = term() Status = term() This callback is optional, so callback modules need not export it. The gen_server module provides a default implementation of this function that returns the callback module state. This function is called by a gen_server process in the following situations: One of sys:get_status/1,2 is invoked to get the gen_server status. Opt is set to the atom normal . The gen_server process terminates abnormally and logs an error. Opt is set to the atom terminate . This function is useful for changing the form and appearance of the gen_server status for these cases. A callback module wishing to change the sys:get_status/1,2 return value, as well as how its status appears in termination error logs, exports an instance of format_status/2 that returns a term describing the current status of the gen_server process. PDict is the current value of the process dictionary of the gen_server process.. State is the internal state of the gen_server process. The function is to return Status , a term that changes the details of the current state and status of the gen_server process. There are no restrictions on the form Status can take, but for the sys:get_status/1,2 case (when Opt is normal ), the recommended form for the Status value is [{data, [{&quot;State&quot;, Term}]}] , where Term provides relevant details of the gen_server state. Following this recommendation is not required, but it makes the callback module status consistent with the rest of the sys:get_status/1,2 return value. One use for this function is to return compact alternative state representations to avoid that large state terms are printed in log files.","ref":"gen_server.html#c:format_status/2","title":"gen_server.format_status/2","type":"callback"},{"doc":"Request = term() From = {pid(),Tag} State = term() Result = {reply,Reply,NewState} | {reply,Reply,NewState,Timeout}   | {reply,Reply,NewState,hibernate}   | {reply,Reply,NewState,{continue,Continue}}   | {noreply,NewState} | {noreply,NewState,Timeout}   | {noreply,NewState,hibernate}   | {noreply,NewState,{continue,Continue}}   | {stop,Reason,Reply,NewState} | {stop,Reason,NewState}  Reply = term()  NewState = term()  Timeout = int()&gt;=0 | infinity  Continue = term()  Reason = term() Whenever a gen_server process receives a request sent using call/2,3 or multi_call/2,3,4 , this function is called to handle the request. Request is the Request argument provided to call or multi_call . From is a tuple {Pid,Tag} , where Pid is the pid of the client and Tag is a unique tag. State is the internal state of the gen_server process. If {reply,Reply,NewState} is returned, {reply,Reply,NewState,Timeout} or {reply,Reply,NewState,hibernate} , Reply is given back to From as the return value of call/2,3 or included in the return value of multi_call/2,3,4 . The gen_server process then continues executing with the possibly updated internal state NewState . For a description of Timeout and hibernate , see Module:init/1 . If {noreply,NewState} is returned, {noreply,NewState,Timeout} , or {noreply,NewState,hibernate} , the gen_server process continues executing with NewState . Any reply to From must be specified explicitly using reply/2 . If {stop,Reason,Reply,NewState} is returned, Reply is given back to From . If {stop,Reason,NewState} is returned, any reply to From must be specified explicitly using reply/2 . The gen_server process then calls Module:terminate(Reason,NewState) and terminates.","ref":"gen_server.html#c:handle_call/3","title":"gen_server.handle_call/3","type":"callback"},{"doc":"Request = term() State = term() Result = {noreply,NewState} | {noreply,NewState,Timeout}   | {noreply,NewState,hibernate}   | {noreply,NewState,{continue,Continue}}   | {stop,Reason,NewState}  NewState = term()  Timeout = int()&gt;=0 | infinity  Continue = term()  Reason = term() Whenever a gen_server process receives a request sent using cast/2 or abcast/2,3 , this function is called to handle the request. For a description of the arguments and possible return values, see Module:handle_call/3 .","ref":"gen_server.html#c:handle_cast/2","title":"gen_server.handle_cast/2","type":"callback"},{"doc":"Continue = term() State = term() Result = {noreply,NewState} | {noreply,NewState,Timeout}   | {noreply,NewState,hibernate}   | {noreply,NewState,{continue,Continue}}   | {stop,Reason,NewState}  NewState = term()  Timeout = int()&gt;=0 | infinity  Continue = term()  Reason = normal | term() This callback is optional, so callback modules need to export it only if they return {continue,Continue} from another callback. If continue is used and the callback is not implemented, the process will exit with undef error. This function is called by a gen_server process whenever a previous callback returns {continue, Continue} . handle_continue/2 is invoked immediately after the previous callback, which makes it useful for performing work after initialization or for splitting the work in a callback in multiple steps, updating the process state along the way. For a description of the other arguments and possible return values, see Module:handle_call/3 .","ref":"gen_server.html#c:handle_continue/2","title":"gen_server.handle_continue/2","type":"callback"},{"doc":"Info = timeout | term() State = term() Result = {noreply,NewState} | {noreply,NewState,Timeout}   | {noreply,NewState,hibernate}   | {noreply,NewState,{continue,Continue}}   | {stop,Reason,NewState}  NewState = term()  Timeout = int()&gt;=0 | infinity  Reason = normal | term() This callback is optional, so callback modules need not export it. The gen_server module provides a default implementation of this function that logs about the unexpected Info message, drops it and returns {noreply, State} . This function is called by a gen_server process when a time-out occurs or when it receives any other message than a synchronous or asynchronous request (or a system message). Info is either the atom timeout , if a time-out has occurred, or the received message. For a description of the other arguments and possible return values, see Module:handle_call/3 .","ref":"gen_server.html#c:handle_info/2","title":"gen_server.handle_info/2","type":"callback"},{"doc":"Args = term() Result = {ok,State} | {ok,State,Timeout} | {ok,State,hibernate}  | {ok,State,{continue,Continue}} | {stop,Reason} | ignore  State = term()  Timeout = int()&gt;=0 | infinity  Reason = term() Whenever a gen_server process is started using start/3,4 , start_monitor/3,4 , or start_link/3,4 , this function is called by the new process to initialize. Args is the Args argument provided to the start function. If the initialization is successful, the function is to return {ok,State} , {ok,State,Timeout} , {ok,State,hibernate} , or {ok,State,{continue,Continue}} where State is the internal state of the gen_server process. If an integer time-out value is provided, a time-out occurs unless a request or a message is received within Timeout milliseconds. A time-out is represented by the atom timeout , which is to be handled by the Module:handle_info/2 callback function. The atom infinity can be used to wait indefinitely, this is the default value. If hibernate is specified instead of a time-out value, the process goes into hibernation when waiting for the next message to arrive (by calling proc_lib:hibernate/3 ). If {continue,Continue} is specified, the process will execute the Module:handle_continue/2 callback function, with Continue as the first argument. If the initialization fails, the function is to return {stop,Reason} , where Reason is any term, or ignore . An exit signal with this Reason (or with reason normal if ignore is returned) is sent to linked processes and ports, notably to the process starting the gen_server when start_link/3,4 is used.","ref":"gen_server.html#c:init/1","title":"gen_server.init/1","type":"callback"},{"doc":"Nodes = [Node]  Node = atom() Name = atom() Request = term() Timeout = int()&gt;=0 | infinity Result = {Replies,BadNodes}  Replies = [{Node,Reply}]   Reply = term() BadNodes = [Node] Makes a synchronous call to all gen_server processes locally registered as Name at the specified nodes by first sending a request to every node and then waits for the replies. The gen_server process calls Module:handle_call/3 to handle the request. The function returns a tuple {Replies,BadNodes} , where Replies is a list of {Node,Reply} and BadNodes is a list of node that either did not exist, or where the gen_server Name did not exist or did not reply. Nodes is a list of node names to which the request is to be sent. Default value is the list of all known nodes [node()|nodes()] . Name is the locally registered name of each gen_server process. Request is any term that is passed as the first argument to Module:handle_call/3 . Timeout is an integer greater than zero that specifies how many milliseconds to wait for each reply, or the atom infinity to wait indefinitely. Defaults to infinity . If no reply is received from a node within the specified time, the node is added to BadNodes . When a reply Reply is received from the gen_server process at a node Node , {Node,Reply} is added to Replies . Reply is defined in the return value of Module:handle_call/3 . If one of the nodes cannot process monitors, for example, C or Java nodes, and the gen_server process is not started when the requests are sent, but starts within 2 seconds, this function waits the whole Timeout , which may be infinity. This problem does not exist if all nodes are Erlang nodes. To prevent late answers (after the time-out) from polluting the message queue of the caller, a middleman process is used to do the calls. Late answers are then discarded when they arrive to a terminated process.","ref":"gen_server.html#multi_call/2","title":"gen_server.multi_call/2","type":"function"},{"doc":"","ref":"gen_server.html#multi_call/3","title":"gen_server.multi_call/3","type":"function"},{"doc":"","ref":"gen_server.html#multi_call/4","title":"gen_server.multi_call/4","type":"function"},{"doc":"RequestId = term() Result = {reply, Reply} | timeout | {error, {Reason, ServerRef}} Reply = term() Timeout = timeout() Reason = term() ServerRef = Name | {Name,Node} | {global,GlobalName}   | {via,Module,ViaName} | pid()  Node = atom()  GlobalName = ViaName = term() This function is used to receive a reply of a request made with send_request/2 to a gen_server process. This function must be called from the same process from which send_request/2 was made. Timeout is an integer greater then or equal to zero that specifies how many milliseconds to wait for an reply, or the atom infinity to wait indefinitely. If no reply is received within the specified time, the function returns timeout . Assuming that the server executes on a node supporting aliases (introduced in OTP 24) no response will be received after a timeout. Otherwise, a garbage response might be received at a later time. The return value Reply is defined in the return value of Module:handle_call/3 . The function returns an error if the gen_server dies before or during this request. The difference between wait_response() and receive_response() is that receive_response() abandons the request at timeout so that a potential future response is ignored, while wait_response() does not.","ref":"gen_server.html#receive_response/2","title":"gen_server.receive_response/2","type":"function"},{"doc":"Client - see below Reply = term() This function can be used by a gen_server process to explicitly send a reply to a client that called call/2,3 or multi_call/2,3,4 , when the reply cannot be defined in the return value of Module:handle_call/3 . Client must be the From argument provided to the callback function. Reply is any term given back to the client as the return value of call/2,3 or multi_call/2,3,4 .","ref":"gen_server.html#reply/2","title":"gen_server.reply/2","type":"function"},{"doc":"ServerRef = Name | {Name,Node} | {global,GlobalName}   | {via,Module,ViaName} | pid()  Node = atom()  GlobalName = ViaName = term() RequestId = term() Timeout = int()&gt;0 | infinity Request = term() Sends a request to the ServerRef of the gen_server process and returns a handle RequestId . The return value RequestId shall later be used with receive_response/2 , wait_response/2 , or check_response/2 to fetch the actual result of the request. The call gen_server:wait_response(gen_server:send_request(ServerRef,Request), Timeout) can be seen as equivalent to gen_server:call(Server,Request,Timeout) , ignoring the error handling. The gen_server process calls Module:handle_call/3 to handle the request. ServerRef can be any of the following: The pid Name , if the gen_server process is locally registered {Name,Node} , if the gen_server process is locally registered at another node {global,GlobalName} , if the gen_server process is globally registered {via,Module,ViaName} , if the gen_server process is registered through an alternative process registry Request is any term that is passed as the first argument to Module:handle_call/3 .","ref":"gen_server.html#send_request/2","title":"gen_server.send_request/2","type":"function"},{"doc":"ServerName = {local,Name} | {global,GlobalName}   | {via,Module,ViaName}  Name = atom()  GlobalName = ViaName = term() Module = atom() Args = term() Options = [Option]  Option = {debug,Dbgs} | {timeout,Time} | {hibernate_after,HibernateAfterTimeout} | {spawn_opt,SOpts}   Dbgs = [Dbg]    Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}   SOpts = [term()] Result = {ok,Pid} | ignore | {error,Error}  Pid = pid()  Error = {already_started,Pid} | term() Creates a standalone gen_server process, that is, a gen_server process that is not part of a supervision tree and thus has no supervisor. For a description of arguments and return values, see start_link/3,4 .","ref":"gen_server.html#start/3","title":"gen_server.start/3","type":"function"},{"doc":"","ref":"gen_server.html#start/4","title":"gen_server.start/4","type":"function"},{"doc":"ServerName = {local,Name} | {global,GlobalName}   | {via,Module,ViaName}  Name = atom()  GlobalName = ViaName = term() Module = atom() Args = term() Options = [Option]  Option = {debug,Dbgs} | {timeout,Time} | {hibernate_after,HibernateAfterTimeout} | {spawn_opt,SOpts}   Dbgs = [Dbg]    Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}   SOpts = [term()] Result = {ok,Pid} | ignore | {error,Error}  Pid = pid()  Error = {already_started,Pid} | term() Creates a gen_server process as part of a supervision tree. This function is to be called, directly or indirectly, by the supervisor. For example, it ensures that the gen_server process is linked to the supervisor. The gen_server process calls Module:init/1 to initialize. To ensure a synchronized startup procedure, start_link/3,4 does not return until Module:init/1 has returned. If ServerName={local,Name} , the gen_server process is registered locally as Name using register/2 . If ServerName={global,GlobalName} , the gen_server process id registered globally as GlobalName using global:register_name/2 If no name is provided, the gen_server process is not registered. If ServerName={via,Module,ViaName} , the gen_server process registers with the registry represented by Module . The Module callback is to export the functions register_name/2 , unregister_name/1 , whereis_name/1 , and send/2 , which are to behave like the corresponding functions in global . Thus, {via,global,GlobalName} is a valid reference. Module is the name of the callback module. Args is any term that is passed as the argument to Module:init/1 . If option {timeout,Time} is present, the gen_server process is allowed to spend Time milliseconds initializing or it is terminated and the start function returns {error,timeout} . If option {hibernate_after,HibernateAfterTimeout} is present, the gen_server process awaits any message for HibernateAfterTimeout milliseconds and if no message is received, the process goes into hibernation automatically (by calling proc_lib:hibernate/3 ). If option {debug,Dbgs} is present, the corresponding sys function is called for each item in Dbgs ; see sys(3) . If option {spawn_opt,SOpts} is present, SOpts is passed as option list to the spawn_opt BIF, which is used to spawn the gen_server process; see spawn_opt/2 . Using spawn option monitor is not allowed, it causes the function to fail with reason badarg . If the gen_server process is successfully created and initialized, the function returns {ok,Pid} , where Pid is the pid of the gen_server process. If a process with the specified ServerName exists already, the function returns {error,{already_started,Pid}} , where Pid is the pid of that process. If Module:init/1 fails with Reason , the function returns {error,Reason} . If Module:init/1 returns {stop,Reason} or ignore , the process is terminated and the function returns {error,Reason} or ignore , respectively. An exit signal with the same Reason (or normal if Module:init/1 returns ignore ) is sent to linked processes and ports.","ref":"gen_server.html#start_link/3","title":"gen_server.start_link/3","type":"function"},{"doc":"","ref":"gen_server.html#start_link/4","title":"gen_server.start_link/4","type":"function"},{"doc":"ServerName = {local,Name} | {global,GlobalName}   | {via,Module,ViaName}  Name = atom()  GlobalName = ViaName = term() Module = atom() Args = term() Options = [Option]  Option = {debug,Dbgs} | {timeout,Time} | {hibernate_after,HibernateAfterTimeout} | {spawn_opt,SOpts}   Dbgs = [Dbg]    Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}   SOpts = [term()] Result = {ok,{Pid,Mon}} | ignore | {error,Error}  Pid = pid()  Error = {already_started,Pid} | term() Creates a standalone gen_server process, that is, a gen_server process that is not part of a supervision tree (and thus has no supervisor) and atomically sets up a monitor to the newly created server. For a description of arguments and return values, see start_link/3,4 . Note that the return value on successful start differs from start_link/3,4 . start_monitor/3,4 will return {ok,{Pid,Mon}} where Pid is the process identifier of the server, and Mon is a reference to the monitor set up to monitor the server. If the start is not successful, the caller will be blocked until the DOWN message has been received and removed from the message queue.","ref":"gen_server.html#start_monitor/3","title":"gen_server.start_monitor/3","type":"function"},{"doc":"","ref":"gen_server.html#start_monitor/4","title":"gen_server.start_monitor/4","type":"function"},{"doc":"ServerRef = Name | {Name,Node} | {global,GlobalName}   | {via,Module,ViaName} | pid()  Node = atom()  GlobalName = ViaName = term() Reason = term() Timeout = int()&gt;0 | infinity Orders a generic server to exit with the specified Reason and waits for it to terminate. The gen_server process calls Module:terminate/2 before exiting. The function returns ok if the server terminates with the expected reason. Any other reason than normal , shutdown , or {shutdown,Term} causes an error report to be issued using logger(3) . An exit signal with the same reason is sent to linked processes and ports. The default Reason is normal . Timeout is an integer greater than zero that specifies how many milliseconds to wait for the server to terminate, or the atom infinity to wait indefinitely. Defaults to infinity . If the server has not terminated within the specified time, a timeout exception is raised. If the process does not exist, a noproc exception is raised.","ref":"gen_server.html#stop/1","title":"gen_server.stop/1","type":"function"},{"doc":"","ref":"gen_server.html#stop/3","title":"gen_server.stop/3","type":"function"},{"doc":"Reason = normal | shutdown | {shutdown,term()} | term() State = term() This callback is optional, so callback modules need not export it. The gen_server module provides a default implementation without cleanup. This function is called by a gen_server process when it is about to terminate. It is to be the opposite of Module:init/1 and do any necessary cleaning up. When it returns, the gen_server process terminates with Reason . The return value is ignored. Reason is a term denoting the stop reason and State is the internal state of the gen_server process. Reason depends on why the gen_server process is terminating. If it is because another callback function has returned a stop tuple {stop,..} , Reason has the value specified in that tuple. If it is because of a failure, Reason is the error reason. If the gen_server process is part of a supervision tree and is ordered by its supervisor to terminate, this function is called with Reason=shutdown if the following conditions apply: The gen_server process has been set to trap exit signals. The shutdown strategy as defined in the child specification of the supervisor is an integer time-out value, not brutal_kill . Even if the gen_server process is not part of a supervision tree, this function is called if it receives an 'EXIT' message from its parent. Reason is the same as in the 'EXIT' message. Otherwise, the gen_server process terminates immediately. Notice that for any other reason than normal , shutdown , or {shutdown,Term} , the gen_server process is assumed to terminate because of an error and an error report is issued using logger(3) . When the gen_server process exits, an exit signal with the same reason is sent to linked processes and ports.","ref":"gen_server.html#c:terminate/2","title":"gen_server.terminate/2","type":"callback"},{"doc":"RequestId = term() Result = {reply, Reply} | timeout | {error, {Reason, ServerRef}} Reply = term() Timeout = timeout() Reason = term() ServerRef = Name | {Name,Node} | {global,GlobalName}   | {via,Module,ViaName} | pid()  Node = atom()  GlobalName = ViaName = term() This function is used to wait for a reply of a request made with send_request/2 from the gen_server process. This function must be called from the same process from which send_request/2 was made. Timeout is an integer greater then or equal to zero that specifies how many milliseconds to wait for an reply, or the atom infinity to wait indefinitely. If no reply is received within the specified time, the function returns timeout and no cleanup is done, and thus the function can be invoked repeatedly until a reply is returned. The return value Reply is defined in the return value of Module:handle_call/3 . The function returns an error if the gen_server dies before or during this request. The difference between receive_response() and wait_response() is that receive_response() abandons the request at timeout so that a potential future response is ignored, while wait_response() does not.","ref":"gen_server.html#wait_response/2","title":"gen_server.wait_response/2","type":"function"},{"doc":"gen_statem provides a generic state machine behaviour that for new code replaces its predecessor gen_fsm since Erlang/OTP 20.0. The gen_fsm behaviour remains in OTP &quot;as is&quot;. If you are new to gen_statem and want an overview of concepts and operation the section gen_statem  Behaviour located in the User's Guide OTP Design Principles is recommended to read before this reference manual, possibly after the Description section you are reading here. This reference manual contains type descriptions generated from types in the gen_statem source code, so they are correct. However, the generated descriptions also reflect the type hierarchy, which sometimes makes it hard to get a good overview. If so, see the section gen_statem  Behaviour in the OTP Design Principles User's Guide. This behavior appeared in Erlang/OTP 19.0. In OTP 19.1 a backwards incompatible change of the return tuple from Module:init/1 was made and the mandatory callback function Module:callback_mode/0 was introduced. In OTP 20.0 generic time-outs were added. In OTP 22.1 time-out content update and explicit time-out cancel were added. In OTP 22.3 the possibility to change the callback module with actions change_callback_module , push_callback_module and pop_callback_module , was added. gen_statem has got the same features that gen_fsm had and adds some really useful: Co-located state code Arbitrary term state Event postponing Self-generated events State time-out Multiple generic named time-outs Absolute time-out time Automatic state enter calls Reply from other state than the request, sys traceable Multiple sys traceable replies Changing the callback module Two callback modes are supported: One for finite-state machines ( gen_fsm like), which requires the state to be an atom and uses that state as the name of the current callback function. One that allows the state to be any term and that uses one callback function for all states. The callback model(s) for gen_statem differs from the one for gen_fsm , but it is still fairly easy to rewrite from gen_fsm to gen_statem . A generic state machine server process ( gen_statem ) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see OTP Design Principles. A gen_statem assumes all specific parts to be located in a callback module exporting a predefined set of functions. The relationship between the behavior functions and the callback functions is as follows: gen_statem module Callback module -- -- -- -- -- -- -- -- - -- -- -- -- -- -- -- - gen_statem : start gen_statem : start_monitor gen_statem : start_link -- -- -&gt; Module : init / 1 Server start or code change -- -- -&gt; Module : callback_mode / 0 gen_statem : stop -- -- -&gt; Module : terminate / 3 gen_statem : call gen_statem : cast gen_statem : send_request erlang : send erlang : &#39;!&#39; -- -- -&gt; Module : StateName / 3 Module : handle_event / 4 - -- -- -&gt; Module : terminate / 3 - -- -- -&gt; Module : code_change / 4 Events are of different types , so the callback functions can know the origin of an event and how to respond. If a callback function fails or returns a bad value, the gen_statem terminates, unless otherwise stated. However, an exception of class throw is not regarded as an error but as a valid return from all callback functions. The state callback for a specific state in a gen_statem is the callback function that is called for all events in this state. It is selected depending on which callback mode that the callback module defines with the callback function Module:callback_mode/0 . When the callback mode is state_functions , the state must be an atom and is used as the state callback name; see Module:StateName/3 . This co-locates all code for a specific state in one function as the gen_statem engine branches depending on state name. Note the fact that the callback function Module:terminate/3 makes the state name terminate unusable in this mode. When the callback mode is handle_event_function , the state can be any term and the state callback name is Module:handle_event/4 . This makes it easy to branch depending on state or event as you desire. Be careful about which events you handle in which states so that you do not accidentally postpone an event forever creating an infinite busy loop. When gen_statem receives a process message it is converted into an event and the state callback is called with the event as two arguments: type and content. When the state callback has processed the event it returns to gen_statem which does a state transition . If this state transition is to a different state, that is: NextState =/= State , it is a state change . The state callback may return transition actions for gen_statem to execute during the state transition , for example to reply to a gen_statem:call/2,3 . One of the possible transition actions is to postpone the current event. Then it is not retried in the current state. The gen_statem engine keeps a queue of events divided into the postponed events and the events still to process. After a state change the queue restarts with the postponed events. The gen_statem event queue model is sufficient to emulate the normal process message queue with selective receive. Postponing an event corresponds to not matching it in a receive statement, and changing states corresponds to entering a new receive statement. The state callback can insert events using the transition actions next_event and such an event is inserted in the event queue as the next to call the state callback with. That is, as if it is the oldest incoming event. A dedicated event_type() internal can be used for such events making them impossible to mistake for external events. Inserting an event replaces the trick of calling your own state handling functions that you often would have to resort to in, for example, gen_fsm to force processing an inserted event before others. The gen_statem engine can automatically make a specialized call to the state callback whenever a new state is entered; see state_enter() . This is for writing code common to all state entries. Another way to do it is to explicitly insert an event at the state transition , and/or to use a dedicated state transition function, but that is something you will have to remember at every state transition to the state(s) that need it. If you in gen_statem , for example, postpone an event in one state and then call another state callback of yours, you have not done a state change and hence the postponed event is not retried, which is logical but can be confusing. For the details of a state transition , see type transition_option() . A gen_statem handles system messages as described in sys . The sys module can be used for debugging a gen_statem . Notice that a gen_statem does not trap exit signals automatically, this must be explicitly initiated in the callback module (by calling process_flag(trap_exit, true) . Unless otherwise stated, all functions in this module fail if the specified gen_statem does not exist or if bad arguments are specified. The gen_statem process can go into hibernation; see proc_lib:hibernate/3 . It is done when a state callback or Module:init/1 specifies hibernate in the returned Actions list. This feature can be useful to reclaim process heap memory while the server is expected to be idle for a long time. However, use this feature with care, as hibernation can be too costly to use after every event; see erlang:hibernate/3 . There is also a server start option {hibernate_after, Timeout} for start/3,4 , start_monitor/3,4 , start_link/3,4 or enter_loop/4,5,6 , that may be used to automatically hibernate the server. If the gen_statem process terminates, e.g. as a result of a function in the callback module returning {stop,Reason} , an exit signal with this Reason is sent to linked processes and ports. See Processes in the Reference Manual for details regarding error handling using exit signals. Example The following example shows a simple pushbutton model for a toggling pushbutton implemented with callback mode state_functions . You can push the button and it replies if it went on or off, and you can ask for a count of how many times it has been pushed to switch on. The following is the complete callback module file pushbutton.erl : -module(pushbutton). -behaviour(gen_statem). -export([start/0,push/0,get_count/0,stop/0]). -export([terminate/3,code_change/4,init/1,callback_mode/0]). -export([on/3,off/3]). name() -&gt; pushbutton_statem. % The registered server name %% API. This example uses a registered name name() %% and does not link to the caller. start() -&gt; gen_statem:start({local,name()}, ?MODULE, [], []). push() -&gt; gen_statem:call(name(), push). get_count() -&gt; gen_statem:call(name(), get_count). stop() -&gt; gen_statem:stop(name()). %% Mandatory callback functions terminate(_Reason, _State, _Data) -&gt; void. code_change(_Vsn, State, Data, _Extra) -&gt; {ok,State,Data}. init([]) -&gt; %% Set the initial state + data. Data is used only as a counter. State = off, Data = 0, {ok,State,Data}. callback_mode() -&gt; state_functions. %%% state callback(s) off({call,From}, push, Data) -&gt; %% Go to 'on', increment count and reply %% that the resulting status is 'on' {next_state,on,Data+1,[{reply,From,on}]}; off(EventType, EventContent, Data) -&gt; handle_event(EventType, EventContent, Data). on({call,From}, push, Data) -&gt; %% Go to 'off' and reply that the resulting status is 'off' {next_state,off,Data,[{reply,From,off}]}; on(EventType, EventContent, Data) -&gt; handle_event(EventType, EventContent, Data). %% Handle events common to all states handle_event({call,From}, get_count, Data) -&gt; %% Reply with the current count {keep_state,Data,[{reply,From,Data}]}; handle_event(_, _, Data) -&gt; %% Ignore all other events {keep_state,Data}. The following is a shell session when running it: 1 &gt; pushbutton : start ( ) . { ok , &lt; 0.36 . 0 &gt; } 2 &gt; pushbutton : get_count ( ) . 0 3 &gt; pushbutton : push ( ) . on 4 &gt; pushbutton : get_count ( ) . 1 5 &gt; pushbutton : push ( ) . off 6 &gt; pushbutton : get_count ( ) . 1 7 &gt; pushbutton : stop ( ) . ok 8 &gt; pushbutton : push ( ) . * * exception exit : { noproc , { gen_statem , call , [ pushbutton_statem , push , infinity ] } } in function gen : do_for_proc / 2 ( gen . erl , line 261 ) in call from gen_statem : call / 3 ( gen_statem . erl , line 386 ) To compare styles, here follows the same example using callback mode handle_event_function , or rather the code to replace after function init/1 of the pushbutton.erl example file above: callback_mode() -&gt; handle_event_function. %%% state callback(s) handle_event({call,From}, push, off, Data) -&gt; %% Go to 'on', increment count and reply %% that the resulting status is 'on' {next_state,on,Data+1,[{reply,From,on}]}; handle_event({call,From}, push, on, Data) -&gt; %% Go to 'off' and reply that the resulting status is 'off' {next_state,off,Data,[{reply,From,off}]}; %% %% Event handling common to all states handle_event({call,From}, get_count, State, Data) -&gt; %% Reply with the current count {next_state,State,Data,[{reply,From,Data}]}; handle_event(_, _, State, Data) -&gt; %% Ignore all other events {next_state,State,Data}. See Also gen_event(3) , gen_fsm(3) , gen_server(3) , proc_lib(3) , supervisor(3) , sys(3) .","ref":"gen_statem.html","title":"gen_statem","type":"behaviour"},{"doc":"EventType = event_type() EventContent = term() State = state() Data = NewData = data() StateEnterResult(StateName) = state_enter_result(StateName) StateFunctionResult = event_handler_result( state_name() ) StateEnterResult(State) = state_enter_result(State) HandleEventResult = event_handler_result( state() ) Whenever a gen_statem receives an event from call/2 , cast/2 , or as a normal process message, one of these functions is called. If callback mode is state_functions , Module:StateName/3 is called, and if it is handle_event_function , Module:handle_event/4 is called. If EventType is {call,From} , the caller waits for a reply. The reply can be sent from this or from any other state callback by returning with {reply,From,Reply} in Actions , in Replies , or by calling reply(From, Reply) . If this function returns with a next state that does not match equal ( =/= ) to the current state, all postponed events are retried in the next state. The only difference between StateFunctionResult and HandleEventResult is that for StateFunctionResult the next state must be an atom, but for HandleEventResult there is no restriction on the next state. For options that can be set and actions that can be done by gen_statem after returning from this function, see action() . When the gen_statem runs with state enter calls , these functions are also called with arguments (enter, OldState, ...) during every state change . In this case there are some restrictions on the actions that may be returned: postpone() is not allowed since a state enter call is not an event so there is no event to postpone, and {next_event,_,_} is not allowed since using state enter calls should not affect how events are consumed and produced. You may also not change states from this call. Should you return {next_state,NextState, ...} with NextState =/= State the gen_statem crashes. Note that it is actually allowed to use {repeat_state, NewData, ...} although it makes little sense since you immediately will be called again with a new state enter call making this just a weird way of looping, and there are better ways to loop in Erlang. If you do not update NewData and have some loop termination condition, or if you use {repeat_state_and_data, _} or repeat_state_and_data you have an infinite loop! You are advised to use {keep_state,...} , {keep_state_and_data,_} or keep_state_and_data since changing states from a state enter call is not possible anyway. Note the fact that you can use throw to return the result, which can be useful. For example to bail out with throw(keep_state_and_data) from deep within complex code that cannot return {next_state,State,Data} because State or Data is no longer in scope.","ref":"gen_statem.html#c:StateName/3","title":"gen_statem.StateName/3","type":"callback"},{"doc":"Makes a synchronous call to the gen_statem ServerRef by sending a request and waiting until its reply arrives. The gen_statem calls the state callback with event_type() {call,From} and event content Request . A Reply is generated when a state callback returns with {reply,From,Reply} as one action() , and that Reply becomes the return value of this function. Timeout is an integer &gt; 0, which specifies how many milliseconds to wait for a reply, or the atom infinity to wait indefinitely, which is the default. If no reply is received within the specified time, the function call fails. For Timeout &lt; infinity , to avoid getting a late reply in the caller's inbox if the caller should catch exceptions, this function spawns a proxy process that does the call. A late reply gets delivered to the dead proxy process, hence gets discarded. This is less efficient than using Timeout == infinity . Timeout can also be a tuple {clean_timeout,T} or {dirty_timeout,T} , where T is the time-out time. {clean_timeout,T} works like just T described in the note above and uses a proxy process while {dirty_timeout,T} bypasses the proxy process which is more lightweight. If you combine catching exceptions from this function with {dirty_timeout,T} to avoid that the calling process dies when the call times out, you will have to be prepared to handle a late reply. Note that there is an odd chance to get a late reply even with {dirty_timeout,infinity} or infinity for example in the event of network problems. So why not just let the calling process die by not catching the exception? The call can also fail, for example, if the gen_statem dies before or during this function call.","ref":"gen_statem.html#call/2","title":"gen_statem.call/2","type":"function"},{"doc":"","ref":"gen_statem.html#call/3","title":"gen_statem.call/3","type":"function"},{"doc":"CallbackMode = callback_mode() | [ callback_mode() | state_enter() ] This function is called by a gen_statem when it needs to find out the callback mode of the callback module. The value is cached by gen_statem for efficiency reasons, so this function is only called once after server start, after code change, and after changing the callback module, but before the first state callback in the current callback module's code version is called. More occasions may be added in future versions of gen_statem . Server start happens either when Module:init/1 returns or when enter_loop/4-6 is called. Code change happens when Module:code_change/4 returns. A change of the callback module happens when a state callback returns any of the actions change_callback_module , push_callback_module or pop_callback_module . The CallbackMode is either just callback_mode() or a list containing callback_mode() and possibly the atom state_enter . If this function's body does not return an inline constant value the callback module is doing something strange.","ref":"gen_statem.html#c:callback_mode/0","title":"gen_statem.callback_mode/0","type":"callback"},{"doc":"Sends an asynchronous event to the gen_statem ServerRef and returns ok immediately, ignoring if the destination node or gen_statem does not exist. The gen_statem calls the state callback with event_type() cast and event content Msg .","ref":"gen_statem.html#cast/2","title":"gen_statem.cast/2","type":"function"},{"doc":"This function is used to check if a previously received message, for example by receive or handle_info/2 , is a result of a request made with send_request/2 . If Msg is a reply to the handle RequestId the result of the request is returned in Reply . Otherwise returns no_reply and no cleanup is done, and thus the function shall be invoked repeatedly until a reply is returned. The return value Reply is generated when a state callback returns with {reply,From,Reply} as one action() , and that Reply becomes the return value of this function. The function returns an error if the gen_statem dies before or during this request.","ref":"gen_statem.html#check_response/2","title":"gen_statem.check_response/2","type":"function"},{"doc":"OldVsn = Vsn | {down,Vsn}   Vsn = term() OldState = NewState = term() Extra = term() Result = {ok,NewState,NewData} | Reason OldState = NewState = state() OldData = NewData = data() Reason = term() This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with Change = {advanced,Extra} specified in the .appup file is made when code_change/4 is not implemented the process will crash with exit reason undef . This function is called by a gen_statem when it is to update its internal state during a release upgrade/downgrade, that is, when the instruction {update,Module,Change,...} , where Change = {advanced,Extra} , is specified in the appup file. For more information, see OTP Design Principles. For an upgrade, OldVsn is Vsn , and for a downgrade, OldVsn is {down,Vsn} . Vsn is defined by the vsn attribute(s) of the old version of the callback module Module . If no such attribute is defined, the version is the checksum of the Beam file. OldState and OldData is the internal state of the gen_statem . Extra is passed &quot;as is&quot; from the {advanced,Extra} part of the update instruction. If successful, the function must return the updated internal state in an {ok,NewState,NewData} tuple. If the function returns a failure Reason , the ongoing upgrade fails and rolls back to the old release. Note that Reason cannot be an {ok,_,_} tuple since that will be regarded as a {ok,NewState,NewData} tuple, and that a tuple matching {ok,_} is an also invalid failure Reason . It is recommended to use an atom as Reason since it will be wrapped in an {error,Reason} tuple. Also note when upgrading a gen_statem , this function and hence the Change = {advanced,Extra} parameter in the appup file is not only needed to update the internal state or to act on the Extra argument. It is also needed if an upgrade or downgrade should change callback mode , or else the callback mode after the code change will not be honoured, most probably causing a server crash. If the server changes callback module using any of the actions change_callback_module , push_callback_module or pop_callback_module , be aware that it is always the current callback module that will get this callback call. That the current callback module handles the current state and data update should be no surprise, but it must be able to handle even parts of the state and data that it is not familiar with, somehow. In the supervisor child specification there is a list of modules which is recommended to contain only the callback module. For a gen_statem with multiple callback modules there is no real need to list all of them, it may not even be possible since the list could change after code upgrade. If this list would contain only the start callback module, as recommended, what is important is to upgrade that module whenever a synchronized code replacement is done. Then the release handler concludes that an upgrade that upgrades that module needs to suspend, code change, and resume any server whose child specification declares that it is using that module. And again; the current callback module will get the Module:code_change/4 call.","ref":"gen_statem.html#c:code_change/4","title":"gen_statem.code_change/4","type":"callback"},{"doc":"The same as enter_loop/6 with Actions = [] except that no server_name() must have been registered. This creates an anonymous server.","ref":"gen_statem.html#enter_loop/4","title":"gen_statem.enter_loop/4","type":"function"},{"doc":"If Server_or_Actions is a list() , the same as enter_loop/6 except that no server_name() must have been registered and Actions = Server_or_Actions . This creates an anonymous server. Otherwise the same as enter_loop/6 with Server = Server_or_Actions and Actions = [] .","ref":"gen_statem.html#enter_loop/5","title":"gen_statem.enter_loop/5","type":"function"},{"doc":"Makes the calling process become a gen_statem . Does not return, instead the calling process enters the gen_statem receive loop and becomes a gen_statem server. The process must have been started using one of the start functions in proc_lib . The user is responsible for any initialization of the process, including registering a name for it. This function is useful when a more complex initialization procedure is needed than the gen_statem behavior provides. Module , Opts have the same meaning as when calling start[_link|_monitor]/3,4 . If Server is self() an anonymous server is created just as when using start[_link|_monitor]/3 . If Server is a server_name() a named server is created just as when using start[_link|_monitor]/4 . However, the server_name() name must have been registered accordingly before this function is called. State , Data , and Actions have the same meanings as in the return value of Module:init/1 . Also, the callback module does not need to export a Module:init/1 function. The function fails if the calling process was not started by a proc_lib start function, or if it is not registered according to server_name() .","ref":"gen_statem.html#enter_loop/6","title":"gen_statem.enter_loop/6","type":"function"},{"doc":"Opt = normal | terminate PDict = [{Key, Value}] State = state() Data = data() Key = term() Value = term() Status = term() This callback is optional, so a callback module does not need to export it. The gen_statem module provides a default implementation of this function that returns {State,Data} . If this callback is exported but fails, to hide possibly sensitive data, the default function will instead return {State,Info} , where Info says nothing but the fact that format_status/2 has crashed. This function is called by a gen_statem process when any of the following apply: One of sys:get_status/1,2 is invoked to get the gen_statem status. Opt is set to the atom normal for this case. The gen_statem terminates abnormally and logs an error. Opt is set to the atom terminate for this case. This function is useful for changing the form and appearance of the gen_statem status for these cases. A callback module wishing to change the sys:get_status/1,2 return value and how its status appears in termination error logs exports an instance of format_status/2 , which returns a term describing the current status of the gen_statem . PDict is the current value of the process dictionary of the gen_statem . State is the internal state of the gen_statem . Data is the internal server data of the gen_statem . The function is to return Status , a term that contains the appropriate details of the current state and status of the gen_statem . There are no restrictions on the form Status can take, but for the sys:get_status/1,2 case (when Opt is normal ), the recommended form for the Status value is [{data, [{&quot;State&quot;, Term}]}] , where Term provides relevant details of the gen_statem state. Following this recommendation is not required, but it makes the callback module status consistent with the rest of the sys:get_status/1,2 return value. One use for this function is to return compact alternative state representations to avoid having large state terms printed in log files. Another use is to hide sensitive data from being written to the error log.","ref":"gen_statem.html#c:format_status/2","title":"gen_statem.format_status/2","type":"callback"},{"doc":"","ref":"gen_statem.html#c:handle_event/4","title":"gen_statem.handle_event/4","type":"callback"},{"doc":"Args = term() Result(StateType) = init_result(StateType) Whenever a gen_statem is started using start_link/3,4 , start_monitor/3,4 , or start/3,4 , this function is called by the new process to initialize the implementation state and server data. Args is the Args argument provided to that start function. Note that if the gen_statem is started through proc_lib and enter_loop/4-6 , this callback will never be called. Since this callback is not optional it can in that case be implemented as: - spec init ( _ ) -&gt; no_return ( ) . init ( Args ) -&gt; erlang : error ( not_implemented , [ Args ] ) .","ref":"gen_statem.html#c:init/1","title":"gen_statem.init/1","type":"callback"},{"doc":"This function is used to receive for a reply of a request made with send_request/2 to the gen_statem process. This function must be called from the same process from which send_request/2 was made. Timeout is an integer greater then or equal to zero that specifies how many milliseconds to wait for an reply, or the atom infinity to wait indefinitely. Defaults to infinity . If no reply is received within the specified time, the function returns timeout . Assuming that the server executes on a node supporting aliases (introduced in OTP 24) no response will be received after a timeout. Otherwise, a garbage response might be received at a later time. The return value Reply is generated when a state callback returns with {reply,From,Reply} as one action() , and that Reply becomes the return value of this function. The function returns an error if the gen_statem dies before or during this function call. The difference between wait_response() and receive_response() is that receive_response() abandons the request at timeout so that a potential future response is ignored, while wait_response() does not.","ref":"gen_statem.html#receive_response/1","title":"gen_statem.receive_response/1","type":"function"},{"doc":"","ref":"gen_statem.html#receive_response/2","title":"gen_statem.receive_response/2","type":"function"},{"doc":"This function can be used by a gen_statem to explicitly send a reply to a process that waits in call/2 when the reply cannot be defined in the return value of a state callback . From must be the term from argument {call,From} to the state callback . A reply or multiple replies canalso be sent using one or several reply_action() s from a state callback . A reply sent with this function is not visible in sys debug output.","ref":"gen_statem.html#reply/1","title":"gen_statem.reply/1","type":"function"},{"doc":"","ref":"gen_statem.html#reply/2","title":"gen_statem.reply/2","type":"function"},{"doc":"Sends a request to the gen_statem ServerRef and returns a handle RequestId . The return value RequestId shall later be used with receive_response/1,2 , wait_response/1,2 , or check_response/2 to fetch the actual result of the request. The call gen_statem:wait_response(gen_statem:send_request(ServerRef,Request), Timeout) can be seen as equivalent to gen_statem:call(Server,Request,Timeout) , ignoring the error handling. The gen_statem calls the state callback with event_type() {call,From} and event content Request . A Reply is generated when a state callback returns with {reply,From,Reply} as one action() , and that Reply becomes the return value of receive_response/1,2 , wait_response/1,2 , or check_response/2 function.","ref":"gen_statem.html#send_request/2","title":"gen_statem.send_request/2","type":"function"},{"doc":"Creates a standalone gen_statem process according to OTP design principles (using proc_lib primitives). As it does not get linked to the calling process, this start function cannot be used by a supervisor to start a child. For a description of arguments and return values, see start_link/3,4 .","ref":"gen_statem.html#start/3","title":"gen_statem.start/3","type":"function"},{"doc":"","ref":"gen_statem.html#start/4","title":"gen_statem.start/4","type":"function"},{"doc":"Creates a gen_statem process according to OTP design principles (using proc_lib primitives) that is linked to the calling process. This is essential when the gen_statem must be part of a supervision tree so it gets linked to its supervisor. The gen_statem process calls Module:init/1 to initialize the server. To ensure a synchronized startup procedure, start_link/3,4 does not return until Module:init/1 has returned. ServerName specifies the server_name() to register for the gen_statem . If the gen_statem is started with start_link/3 , no ServerName is provided and the gen_statem is not registered. Module is the name of the callback module. Args is an arbitrary term that is passed as the argument to Module:init/1 . If option {timeout,Time} is present in Opts , the gen_statem is allowed to spend Time milliseconds initializing or it terminates and the start function returns {error,timeout} . If option {hibernate_after,HibernateAfterTimeout} is present, the gen_statem process awaits any message for HibernateAfterTimeout milliseconds and if no message is received, the process goes into hibernation automatically (by calling proc_lib:hibernate/3 ). If option {debug,Dbgs} is present in Opts , debugging through sys is activated. If option {spawn_opt,SpawnOpts} is present in Opts , SpawnOpts is passed as option list to erlang:spawn_opt/2 , which is used to spawn the gen_statem process. Using spawn option monitor is not allowed, it causes this function to fail with reason badarg . If the gen_statem is successfully created and initialized, this function returns {ok,Pid} , where Pid is the pid() of the gen_statem . If a process with the specified ServerName exists already, this function returns {error,{already_started,Pid}} , where Pid is the pid() of that process. If Module:init/1 fails with Reason , this function returns {error,Reason} . If Module:init/1 returns {stop,Reason} or ignore , the process is terminated and this function returns {error,Reason} or ignore , respectively. An exit signal with the same Reason (or normal if Module:init/1 returns ignore ) is set to linked processes and ports, including the process calling start_link/3,4 .","ref":"gen_statem.html#start_link/3","title":"gen_statem.start_link/3","type":"function"},{"doc":"","ref":"gen_statem.html#start_link/4","title":"gen_statem.start_link/4","type":"function"},{"doc":"Creates a standalone gen_statem process according to OTP design principles (using proc_lib primitives) and atomically sets up a monitor to the newly created process. As it does not get linked to the calling process, this start function cannot be used by a supervisor to start a child. For a description of arguments and return values, see start_link/3,4 . Note that the return value on successful start differs from start_link/3,4 . start_monitor/3,4 will return {ok,{Pid,Mon}} where Pid is the process identifier of the process, and Mon is a reference to the monitor set up to monitor the process. If the start is not successful, the caller will be blocked until the DOWN message has been received and removed from the message queue.","ref":"gen_statem.html#start_monitor/3","title":"gen_statem.start_monitor/3","type":"function"},{"doc":"","ref":"gen_statem.html#start_monitor/4","title":"gen_statem.start_monitor/4","type":"function"},{"doc":"The same as stop(ServerRef, normal, infinity) .","ref":"gen_statem.html#stop/1","title":"gen_statem.stop/1","type":"function"},{"doc":"Orders the gen_statem ServerRef to exit with the specified Reason and waits for it to terminate. The gen_statem calls Module:terminate/3 before exiting. This function returns ok if the server terminates with the expected reason. Any other reason than normal , shutdown , or {shutdown,Term} causes an error report to be issued through logger(3) . An exit signal with the same reason is sent to linked processes and ports. The default Reason is normal . Timeout is an integer &gt; 0, which specifies how many milliseconds to wait for the server to terminate, or the atom infinity to wait indefinitely. Defaults to infinity . If the server does not terminate within the specified time, a timeout exception is raised. If the process does not exist, a noproc exception is raised.","ref":"gen_statem.html#stop/3","title":"gen_statem.stop/3","type":"function"},{"doc":"Reason = normal | shutdown | {shutdown,term()} | term() State = state() Data = data() Ignored = term() This callback is optional, so callback modules need not export it. The gen_statem module provides a default implementation without cleanup. This function is called by a gen_statem when it is about to terminate. It is to be the opposite of Module:init/1 and do any necessary cleaning up. When it returns, the gen_statem terminates with Reason . The return value is ignored. Reason is a term denoting the stop reason and State is the internal state of the gen_statem . Reason depends on why the gen_statem is terminating. If it is because another callback function has returned, a stop tuple {stop,Reason} in Actions , Reason has the value specified in that tuple. If it is because of a failure, Reason is the error reason. If the gen_statem is part of a supervision tree and is ordered by its supervisor to terminate, this function is called with Reason = shutdown if both the following conditions apply: The gen_statem has been set to trap exit signals. The shutdown strategy as defined in the supervisor's child specification is an integer time-out value, not brutal_kill . Even if the gen_statem is not part of a supervision tree, this function is called if it receives an 'EXIT' message from its parent. Reason is the same as in the 'EXIT' message. Otherwise, the gen_statem is immediately terminated. Notice that for any other reason than normal , shutdown , or {shutdown,Term} , the gen_statem is assumed to terminate because of an error and an error report is issued using logger(3) . When the gen_statem process exits, an exit signal with the same reason is sent to linked processes and ports.","ref":"gen_statem.html#c:terminate/3","title":"gen_statem.terminate/3","type":"callback"},{"doc":"This function is used to wait for a reply of a request made with send_request/2 to the gen_statem process. This function must be called from the same process from which send_request/2 was made. Timeout is an integer greater then or equal to zero that specifies how many milliseconds to wait for an reply, or the atom infinity to wait indefinitely. Defaults to infinity . If no reply is received within the specified time, the function returns timeout and no cleanup is done, and thus the function can be invoked repeatedly until a reply is returned. The return value Reply is generated when a state callback returns with {reply,From,Reply} as one action() , and that Reply becomes the return value of this function. The function returns an error if the gen_statem dies before or during this function call. The difference between receive_response() and wait_response() is that receive_response() abandons the request at timeout so that a potential future response is ignored, while wait_response() does not.","ref":"gen_statem.html#wait_response/1","title":"gen_statem.wait_response/1","type":"function"},{"doc":"","ref":"gen_statem.html#wait_response/2","title":"gen_statem.wait_response/2","type":"function"},{"doc":"These transition actions can be invoked by returning them from the state callback when it is called with an event , from Module:init/1 or by giving them to enter_loop/5,6 . Actions are executed in the containing list order. Actions that set transition options override any previous of the same type, so the last in the containing list wins. For example, the last postpone() overrides any previous postpone() in the list. postpone Sets the transition_option() postpone() for this state transition . This action is ignored when returned from Module:init/1 or given to enter_loop/5,6 , as there is no event to postpone in those cases. next_event This action does not set any transition_option() but instead stores the specified EventType and EventContent for insertion after all actions have been executed. The stored events are inserted in the queue as the next to process before any already queued events. The order of these stored events is preserved, so the first next_event in the containing list becomes the first to process. An event of type internal is to be used when you want to reliably distinguish an event inserted this way from any external event. change_callback_module Changes the callback module to NewModule which will be used when calling all subsequent state callbacks . The gen_statem engine will find out the callback mode of NewModule by calling NewModule:callback_mode/0 before the next state callback . Changing the callback module does not affect the state transition in any way, it only changes which module that handles the events. Be aware that all relevant callback functions in NewModule such as the state callback , NewModule:code_change/4 , NewModule:format_status/2 and NewModule:terminate/3 must be able to handle the state and data from the old module. push_callback_module Pushes the current callback module to the top of an internal stack of callback modules and changes the callback module to NewModule . Otherwise like {change_callback_module, NewModule} above. pop_callback_module Pops the top module from the internal stack of callback modules and changes the callback module to be the popped module. If the stack is empty the server fails. Otherwise like {change_callback_module, NewModule} above.","ref":"gen_statem.html#t:action/0","title":"gen_statem.action/0","type":"type"},{"doc":"The callback mode is selected with the return value from Module:callback_mode/0 : state_functions The state must be of type state_name() and one callback function per state, that is, Module:StateName/3 , is used. handle_event_function The state can be any term and the callback function Module:handle_event/4 is used for all states. The function Module:callback_mode/0 is called when starting the gen_statem , after code change and after changing the callback module with any of the actions change_callback_module , push_callback_module or pop_callback_module . The result is cached for subsequent calls to state callbacks .","ref":"gen_statem.html#t:callback_mode/0","title":"gen_statem.callback_mode/0","type":"type"},{"doc":"This is the return type from Module:callback_mode/0 and selects callback mode and whether to do state enter calls , or not.","ref":"gen_statem.html#t:callback_mode_result/0","title":"gen_statem.callback_mode_result/0","type":"type"},{"doc":"A term in which the state machine implementation is to store any server data it needs. The difference between this and the state() itself is that a change in this data does not cause postponed events to be retried. Hence, if a change in this data would change the set of events that are handled, then that data item is to be made a part of the state.","ref":"gen_statem.html#t:data/0","title":"gen_statem.data/0","type":"type"},{"doc":"These transition actions can be invoked by returning them from the state callback , from Module:init/1 or by giving them to enter_loop/5,6 . Actions are executed in the containing list order. Actions that set transition options override any previous of the same type, so the last in the containing list wins. For example, the last event_timeout() overrides any previous event_timeout() in the list. hibernate Sets the transition_option() hibernate() for this state transition .","ref":"gen_statem.html#t:enter_action/0","title":"gen_statem.enter_action/0","type":"type"},{"doc":"Options that can be used when starting a gen_statem server through, enter_loop/4-6 . hibernate_after HibernateAfterTimeout specifies that the gen_statem process awaits any message for HibernateAfterTimeout milliseconds and if no message is received, the process goes into hibernation automatically (by calling proc_lib:hibernate/3 ). debug For every entry in Dbgs , the corresponding function in sys is called.","ref":"gen_statem.html#t:enter_loop_opt/0","title":"gen_statem.enter_loop_opt/0","type":"type"},{"doc":"StateType is state_name() if callback mode is state_functions , or state() if callback mode is handle_event_function . next_state The gen_statem does a state transition to NextState (which can be the same as the current state), sets NewData , and executes all Actions . If NextState =/= CurrentState the state transition is a state change .","ref":"gen_statem.html#t:event_handler_result/1","title":"gen_statem.event_handler_result/1","type":"type"},{"doc":"Starts a timer set by enter_action() timeout . When the timer expires an event of event_type() timeout will be generated. See erlang:start_timer/4 for how Time and Options are interpreted. Future erlang:start_timer/4 Options will not necessarily be supported. Any event that arrives cancels this time-out. Note that a retried or inserted event counts as arrived. So does a state time-out zero event, if it was generated before this time-out is requested. If Time is infinity , no timer is started, as it never would expire anyway. If Time is relative and 0 no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event, but after already queued events. Note that it is not possible nor needed to cancel this time-out, as it is cancelled automatically by any other event.","ref":"gen_statem.html#t:event_timeout/0","title":"gen_statem.event_timeout/0","type":"type"},{"doc":"There are 3 categories of events: external , timeout , and internal . internal events can only be generated by the state machine itself through the transition action next_event .","ref":"gen_statem.html#t:event_type/0","title":"gen_statem.event_type/0","type":"type"},{"doc":"External events are of 3 types: {call,From} , cast , or info . Type call originates from the API functions call/2 and send_request/2 . For calls, the event contains whom to reply to. Type cast originates from the API function cast/2 . Type info originates from regular process messages sent to the gen_statem .","ref":"gen_statem.html#t:external_event_type/0","title":"gen_statem.external_event_type/0","type":"type"},{"doc":"Destination to use when replying through, for example, the action() {reply,From,Reply} to a process that has called the gen_statem server using call/2 .","ref":"gen_statem.html#t:from/0","title":"gen_statem.from/0","type":"type"},{"doc":"Starts a timer set by enter_action() {timeout,Name} . When the timer expires an event of event_type() {timeout,Name} will be generated. See erlang:start_timer/4 for how Time and Options are interpreted. Future erlang:start_timer/4 Options will not necessarily be supported. If Time is infinity , no timer is started, as it never would expire anyway. If Time is relative and 0 no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event. Setting a timer with the same Name while it is running will restart it with the new time-out value. Therefore it is possible to cancel a specific time-out by setting it to infinity .","ref":"gen_statem.html#t:generic_timeout/0","title":"gen_statem.generic_timeout/0","type":"type"},{"doc":"If true , hibernates the gen_statem by calling proc_lib:hibernate/3 before going into receive to wait for a new external event. If there are enqueued events to process when hibrnation is requested, this is optimized by not hibernating but instead calling erlang:garbage_collect/0 to simulate that the gen_statem entered hibernation and immediately got awakened by an enqueued event.","ref":"gen_statem.html#t:hibernate/0","title":"gen_statem.hibernate/0","type":"type"},{"doc":"For a succesful initialization, State is the initial state() and Data the initial server data() of the gen_statem . The Actions are executed when entering the first state just as for a state callback , except that the action postpone is forced to false since there is no event to postpone. For an unsuccesful initialization, {stop,Reason} or ignore should be used; see start_link/3,4 .","ref":"gen_statem.html#t:init_result/1","title":"gen_statem.init_result/1","type":"type"},{"doc":"If true , postpones the current event and retries it after a state change ( NextState =/= State ).","ref":"gen_statem.html#t:postpone/0","title":"gen_statem.postpone/0","type":"type"},{"doc":"This transition action can be invoked by returning it from the state callback , from Module:init/1 or by giving it to enter_loop/5,6 . It does not set any transition_option() but instead replies to a caller waiting for a reply in call/2 . From must be the term from argument {call,From} in a call to a state callback . Note that using this action from Module:init/1 or enter_loop/5,6 would be weird on the border of witchcraft since there has been no earlier call to a state callback in this server.","ref":"gen_statem.html#t:reply_action/0","title":"gen_statem.reply_action/0","type":"type"},{"doc":"A request handle, see send_request/2 for details.","ref":"gen_statem.html#t:request_id/0","title":"gen_statem.request_id/0","type":"type"},{"doc":"Name specification to use when starting a gen_statem server. See start_link/3 and server_ref() below.","ref":"gen_statem.html#t:server_name/0","title":"gen_statem.server_name/0","type":"type"},{"doc":"Server specification to use when addressing a gen_statem server. See call/2 and server_name() above. It can be: pid() | LocalName The gen_statem is locally registered. {Name,Node} The gen_statem is locally registered on another node. {global,GlobalName} The gen_statem is globally registered in global . {via,RegMod,ViaName} The gen_statem is registered in an alternative process registry. The registry callback module RegMod is to export functions register_name/2 , unregister_name/1 , whereis_name/1 , and send/2 , which are to behave like the corresponding functions in global . Thus, {via,global,GlobalName} is the same as {global,GlobalName} .","ref":"gen_statem.html#t:server_ref/0","title":"gen_statem.server_ref/0","type":"type"},{"doc":"Return value from the start_monitor() functions.","ref":"gen_statem.html#t:start_mon_ret/0","title":"gen_statem.start_mon_ret/0","type":"type"},{"doc":"Options that can be used when starting a gen_statem server through, for example, start_link/3 .","ref":"gen_statem.html#t:start_opt/0","title":"gen_statem.start_opt/0","type":"type"},{"doc":"Return value from the start() and start_link() functions, for example, start_link/3 .","ref":"gen_statem.html#t:start_ret/0","title":"gen_statem.start_ret/0","type":"type"},{"doc":"If the callback mode is handle_event_function , the state can be any term. After a state change ( NextState =/= State ), all postponed events are retried.","ref":"gen_statem.html#t:state/0","title":"gen_statem.state/0","type":"type"},{"doc":"ActionType is enter_action() if the state callback was called with a state enter call and action() if the state callback was called with an event. keep_state The same as {next_state,CurrentState,NewData,Actions} . keep_state_and_data The same as {keep_state,CurrentData,Actions} . repeat_state If the gen_statem runs with state enter calls , the state enter call is repeated, see type transition_option() , other than that repeat_state is the same as keep_state . repeat_state_and_data The same as {repeat_state,CurrentData,Actions} . stop Terminates the gen_statem by calling Module:terminate/3 with Reason and NewData , if specified. An exit signal with this reason is sent to linked processes and ports. The default Reason is normal . stop_and_reply Sends all Replies , then terminates the gen_statem by calling Module:terminate/3 with Reason and NewData , if specified. An exit signal with this reason is sent to linked processes and ports. All these terms are tuples or atoms and this property will hold in any future version of gen_statem .","ref":"gen_statem.html#t:state_callback_result/1","title":"gen_statem.state_callback_result/1","type":"type"},{"doc":"Whether the state machine should use state enter calls or not is selected when starting the gen_statem and after code change using the return value from Module:callback_mode/0 . If Module:callback_mode/0 returns a list containing state_enter , the gen_statem engine will, at every state change , call the state callback with arguments (enter, OldState, Data) or (enter, OldState, State, Data) , depending on the callback mode . This may look like an event but is really a call performed after the previous state callback returned and before any event is delivered to the new state callback . See Module:StateName/3 and Module:handle_event/4 . Such a call can be repeated by returning a repeat_state or repeat_state_and_data tuple from the state callback . If Module:callback_mode/0 does not return such a list, no state enter calls are done. If Module:code_change/4 should transform the state, it is regarded as a state rename and not a state change , which will not cause a state enter call . Note that a state enter call will be done right before entering the initial state even though this actually is not a state change . In this case OldState =:= State , which cannot happen for a subsequent state change, but will happen when repeating the state enter call .","ref":"gen_statem.html#t:state_enter/0","title":"gen_statem.state_enter/0","type":"type"},{"doc":"State is the current state and it cannot be changed since the state callback was called with a state enter call . next_state The gen_statem does a state transition to State , which has to be the current state, sets NewData , and executes all Actions .","ref":"gen_statem.html#t:state_enter_result/1","title":"gen_statem.state_enter_result/1","type":"type"},{"doc":"If the callback mode is state_functions , the state must be an atom. After a state change ( NextState =/= State ), all postponed events are retried. Note that the state terminate is not possible to use since it would collide with the optional callback function Module:terminate/3 .","ref":"gen_statem.html#t:state_name/0","title":"gen_statem.state_name/0","type":"type"},{"doc":"Starts a timer set by enter_action() state_timeout . When the timer expires an event of event_type() state_timeout will be generated. See erlang:start_timer/4 for how Time and Options are interpreted. Future erlang:start_timer/4 Options will not necessarily be supported. If Time is infinity , no timer is started, as it never would expire anyway. If Time is relative and 0 no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event. Setting this timer while it is running will restart it with the new time-out value. Therefore it is possible to cancel this time-out by setting it to infinity .","ref":"gen_statem.html#t:state_timeout/0","title":"gen_statem.state_timeout/0","type":"type"},{"doc":"These transition actions can be invoked by returning them from the state callback , from Module:init/1 or by giving them to enter_loop/5,6 . These time-out actions sets time-out transition options . Time Short for {timeout,Time,Time} , that is, the time-out message is the time-out time. This form exists to make the state callback return value {next_state,NextState,NewData,Time} allowed like for gen_fsm . timeout Sets the transition_option() event_timeout() to Time with EventContent and time-out options Options . {timeout,Name} Sets the transition_option() generic_timeout() to Time for Name with EventContent and time-out options Options . state_timeout Sets the transition_option() state_timeout() to Time with EventContent and time-out options Options .","ref":"gen_statem.html#t:timeout_action/0","title":"gen_statem.timeout_action/0","type":"type"},{"doc":"This is a shorter and clearer form of timeout_action() with Time = infinity which cancels a time-out.","ref":"gen_statem.html#t:timeout_cancel_action/0","title":"gen_statem.timeout_cancel_action/0","type":"type"},{"doc":"There are 3 types of time-out events that the state machine can generate for itself with the corresponding timeout_action() s.","ref":"gen_statem.html#t:timeout_event_type/0","title":"gen_statem.timeout_event_type/0","type":"type"},{"doc":"If Abs is true an absolute timer is started, and if it is false a relative, which is the default. See erlang:start_timer/4 for details.","ref":"gen_statem.html#t:timeout_option/0","title":"gen_statem.timeout_option/0","type":"type"},{"doc":"Updates a time-out with a new EventContent . See timeout_action() for how to start a time-out. If no time-out of the same type is active instead insert the time-out event just like when starting a time-out with relative Time = 0 .","ref":"gen_statem.html#t:timeout_update_action/0","title":"gen_statem.timeout_update_action/0","type":"type"},{"doc":"Transition options can be set by actions and modify the state transition . The state transition takes place when the state callback has processed an event and returns. Here are the sequence of steps for a state transition : All returned actions are processed in order of appearance. In this step all replies generated by any reply_action() are sent. Other actions set transition_option() s that come into play in subsequent steps. If state enter calls are used, and either it is the initial state or one of the callback results repeat_state_and_data or repeat_state_and_data is used the gen_statem engine calls the current state callback with arguments (enter, State, Data) or (enter, State, State, Data) (depending on callback mode ) and when it returns starts again from the top of this sequence. If state enter calls are used, and the state changes the gen_statem engine calls the new state callback with arguments (enter, OldState, Data) or (enter, OldState, State, Data) (depending on callback mode ) and when it returns starts again from the top of this sequence. If postpone() is true , the current event is postponed. If this is a state change , the queue of incoming events is reset to start with the oldest postponed. All events stored with action() next_event are inserted to be processed before previously queued events. Time-out timers event_timeout() , generic_timeout() and state_timeout() are handled. Time-outs with zero time are guaranteed to be delivered to the state machine before any external not yet received event so if there is such a time-out requested, the corresponding time-out zero event is enqueued as the newest received event; that is after already queued events such as inserted and postponed events. Any event cancels an event_timeout() so a zero time event time-out is only generated if the event queue is empty. A state change cancels a state_timeout() and any new transition option of this type belongs to the new state, that is; a state_timeout() applies to the state the state machine enters. If there are enqueued events the state callback for the possibly new state is called with the oldest enqueued event, and we start again from the top of this sequence. Otherwise the gen_statem goes into receive or hibernation (if hibernate() is true ) to wait for the next message. In hibernation the next non-system event awakens the gen_statem , or rather the next incoming message awakens the gen_statem , but if it is a system event it goes right back into hibernation. When a new message arrives the state callback is called with the corresponding event, and we start again from the top of this sequence.","ref":"gen_statem.html#t:transition_option/0","title":"gen_statem.transition_option/0","type":"type"},{"doc":"This module provides an interface to standard Erlang I/O servers. The output functions all return ok if they are successful, or exit if they are not. All functions in this module have an optional parameter IoDevice . If included, it must be the pid of a process that handles the I/O protocols. Normally, it is a IoDevice returned by file:open/2 . If no IoDevice is given, standard_io is used. For a description of the I/O protocols, see section The Erlang I/O Protocol in the User's Guide. As from Erlang/OTP R13A, data supplied to function put_chars/2 is to be in the unicode:chardata() format. This means that programs supplying binaries to this function must convert them to UTF-8 before trying to output the data on an I/O device. If an I/O device is set in binary mode, functions get_chars/2,3 and get_line/1,2 can return binaries instead of lists. The binaries are, as from Erlang/OTP R13A, encoded in UTF-8. To work with binaries in ISO Latin-1 encoding, use the file module instead. For conversion functions between character encodings, see the unicode module. Standard Input/Output All Erlang processes have a default standard I/O device. This device is used when no IoDevice argument is specified in the function calls in this module. However, it is sometimes desirable to use an explicit IoDevice argument that refers to the default I/O device. This is the case with functions that can access either a file or the default I/O device. The atom standard_io has this special meaning. The following example illustrates this: 27 &gt; io : read ( &#39;enter&gt;&#39; ) . enter &gt; foo . { ok , foo } 28 &gt; io : read ( standard_io , &#39;enter&gt;&#39; ) . enter &gt; bar . { ok , bar } standard_io is an alias for group_leader/0 , so in order to change where the default input/output requests are sent you can change the group leader for the current process using group_leader(NewGroupLeader, self()). There is always a process registered under the name of user . This can be used for sending output to the user. Standard Error In certain situations, especially when the standard output is redirected, access to an I/O server specific for error messages can be convenient. The I/O device standard_error can be used to direct output to whatever the current operating system considers a suitable I/O device for error output. Example on a Unix-like operating system: $ erl -noshell -noinput -eval &#39;io:format(standard_error,&quot;Error: ~s~n&quot;,[&quot;error 11&quot;]),&#39;\\ &#39;init:stop().&#39; &gt; /dev/null Error: error 11 Error Information The ErrorInfo mentioned in this module is the standard ErrorInfo structure that is returned from all I/O modules. It has the following format: {ErrorLocation, Module, ErrorDescriptor} A string that describes the error is obtained with the following call: Module:format_error(ErrorDescriptor)","ref":"io.html","title":"io","type":"module"},{"doc":"Retrieves the number of columns of the IoDevice (that is, the width of a terminal). The function succeeds for terminal devices and returns {error, enotsup} for all other I/O devices.","ref":"io.html#columns/0","title":"io.columns/0","type":"function"},{"doc":"","ref":"io.html#columns/1","title":"io.columns/1","type":"function"},{"doc":"Writes the items in Data ( [] ) on the standard output ( IoDevice ) in accordance with Format . Format contains plain characters that are copied to the output device, and control sequences for formatting, see below. If Format is an atom or a binary, it is first converted to a list with the aid of atom_to_list/1 or binary_to_list/1 . Example: 1 &gt; io : fwrite ( &quot;Hello world! ~n &quot; , [ ] ) . Hello world ! ok The general format of a control sequence is ~F.P.PadModC . The character C determines the type of control sequence to be used. It is the only required field. All of F , P , Pad , and Mod are optional. For example, to use a # for Pad but use the default values for F and P , you can write ~..#C . F is the field width of the printed argument. A negative value means that the argument is left-justified within the field, otherwise right-justified. If no field width is specified, the required print width is used. If the field width specified is too small, the whole field is filled with * characters. P is the precision of the printed argument. A default value is used if no precision is specified. The interpretation of precision depends on the control sequences. Unless otherwise specified, argument within is used to determine print width. Pad is the padding character. This is the character used to pad the printed representation of the argument so that it conforms to the specified field width and precision. Only one padding character can be specified and, whenever applicable, it is used for both the field width and precision. The default padding character is ' ' (space). Mod is the control sequence modifier. This is one or more characters that change the interpretation of Data . The current modifiers are t , for Unicode translation, and l , for stopping p and P from detecting printable characters. If F , P , or Pad is a * character, the next argument in Data is used as the value. For example: 1 &gt; io : fwrite ( &quot;~*.*.0f ~n &quot; , [ 9 , 5 , 3.14159265 ] ) . 003.14159 ok To use a literal * character as Pad , it must be passed as an argument: 2 &gt; io : fwrite ( &quot;~*.*.*f ~n &quot; , [ 9 , 5 , $* , 3.14159265 ] ) . * * 3.14159 ok Available control sequences: ~ Character ~ is written. c The argument is a number that is interpreted as an ASCII code. The precision is the number of times the character is printed and defaults to the field width, which in turn defaults to 1. Example: 1 &gt; io : fwrite ( &quot;|~10.5c| ~- 10.5c|~5c| ~n &quot; , [ $a , $b , $c ] ) . | aaaaa | bbbbb | ccccc | ok If the Unicode translation modifier ( t ) is in effect, the integer argument can be any number representing a valid Unicode codepoint, otherwise it is to be an integer less than or equal to 255, otherwise it is masked with 16#FF: 2 &gt; io : fwrite ( &quot;~tc ~n &quot; , [ 1024 ] ) . \\ x { 400 } ok 3 &gt; io : fwrite ( &quot;~c ~n &quot; , [ 1024 ] ) . ^ @ ok f The argument is a float that is written as [-]ddd.ddd , where the precision is the number of digits after the decimal point. The default precision is 6 and it cannot be &lt; 1. e The argument is a float that is written as [-]d.ddde+-ddd , where the precision is the number of digits written. The default precision is 6 and it cannot be &lt; 2. g The argument is a float that is written as f , if it is &gt;= 0.1 and &lt; 10000.0. Otherwise, it is written in the e format. The precision is the number of significant digits. It defaults to 6 and is not to be &lt; 2. If the absolute value of the float does not allow it to be written in the f format with the desired number of significant digits, it is also written in the e format. s Prints the argument with the string syntax. The argument is, if no Unicode translation modifier is present, an iolist() , a binary() , or an atom() . If the Unicode translation modifier ( t ) is in effect, the argument is unicode:chardata() , meaning that binaries are in UTF-8. The characters are printed without quotes. The string is first truncated by the specified precision and then padded and justified to the specified field width. The default precision is the field width. This format can be used for printing any object and truncating the output so it fits a specified field: 1 &gt; io : fwrite ( &quot;| ~10w | ~n &quot; , [ { hey , hey , hey } ] ) . | * * * * * * * * * * | ok 2 &gt; io : fwrite ( &quot;| ~10s | ~n &quot; , [ io_lib : write ( { hey , hey , hey } ) ] ) . | { hey , hey , h | 3 &gt; io : fwrite ( &quot;| ~- 10.8s| ~n &quot; , [ io_lib : write ( { hey , hey , hey } ) ] ) . | { hey , hey | ok A list with integers &gt; 255 is considered an error if the Unicode translation modifier is not specified: 4 &gt; io : fwrite ( &quot;~ts ~n &quot; , [ [ 1024 ] ] ) . \\ x { 400 } ok 5 &gt; io : fwrite ( &quot; ~s ~n &quot; , [ [ 1024 ] ] ) . * * exception error : bad argument in function io : format / 3 called as io : format ( &lt; 0.53 . 0 &gt; , &quot; ~s ~n &quot; , [ [ 1024 ] ] ) w Writes data with the standard syntax. This is used to output Erlang terms. Atoms are printed within quotes if they contain embedded non-printable characters. Atom characters &gt; 255 are escaped unless the Unicode translation modifier ( t ) is used. Floats are printed accurately as the shortest, correctly rounded string. p Writes the data with standard syntax in the same way as ~w , but breaks terms whose printed representation is longer than one line into many lines and indents each line sensibly. Left-justification is not supported. It also tries to detect flat lists of printable characters and output these as strings. For example: 1 &gt; T = [ { attributes , [ [ { id , age , 1.50000 } , { mode , explicit } , { typename , &quot;INTEGER&quot; } ] , [ { id , cho } , { mode , explicit } , { typename , &#39;Cho&#39; } ] ] } , { typename , &#39;Person&#39; } , { tag , { &#39;PRIVATE&#39; , 3 } } , { mode , implicit } ] . . . . 2 &gt; io : fwrite ( &quot; ~w ~n &quot; , [ T ] ) . [ { attributes , [ [ { id , age , 1.5 } , { mode , explicit } , { typename , [ 73 , 78 , 84 , 69 , 71 , 69 , 82 ] } ] , [ { id , cho } , { mode , explicit } , { typena me , &#39;Cho&#39; } ] ] } , { typename , &#39;Person&#39; } , { tag , { &#39;PRIVATE&#39; , 3 } } , { mode , implicit } ] ok 3 &gt; io : fwrite ( &quot; ~62p ~n &quot; , [ T ] ) . [ { attributes , [ [ { id , age , 1.5 } , { mode , explicit } , { typename , &quot;INTEGER&quot; } ] , [ { id , cho } , { mode , explicit } , { typename , &#39;Cho&#39; } ] ] } , { typename , &#39;Person&#39; } , { tag , { &#39;PRIVATE&#39; , 3 } } , { mode , implicit } ] ok The field width specifies the maximum line length. It defaults to 80. The precision specifies the initial indentation of the term. It defaults to the number of characters printed on this line in the same call to write/1 or format/1,2,3 . For example, using T above: 4 &gt; io : fwrite ( &quot;Here T = ~62p ~n &quot; , [ T ] ) . Here T = [ { attributes , [ [ { id , age , 1.5 } , { mode , explicit } , { typename , &quot;INTEGER&quot; } ] , [ { id , cho } , { mode , explicit } , { typename , &#39;Cho&#39; } ] ] } , { typename , &#39;Person&#39; } , { tag , { &#39;PRIVATE&#39; , 3 } } , { mode , implicit } ] ok As from Erlang/OTP 21.0, a field width of value 0 can be used for specifying that a line is infinitely long, which means that no line breaks are inserted. For example: 5 &gt; io : fwrite ( &quot; ~0p ~n &quot; , [ lists : seq ( 1 , 30 ) ] ) . [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 ] ok When the modifier l is specified, no detection of printable character lists takes place, for example: 6 &gt; S = [ { a , &quot;a&quot; } , { b , &quot;b&quot; } ] , io : fwrite ( &quot; ~15p ~n &quot; , [ S ] ) . [ { a , &quot;a&quot; } , { b , &quot;b&quot; } ] ok 7 &gt; io : fwrite ( &quot;~15lp ~n &quot; , [ S ] ) . [ { a , [ 97 ] } , { b , [ 98 ] } ] ok The Unicode translation modifier t specifies how to treat characters outside the Latin-1 range of codepoints, in atoms, strings, and binaries. For example, printing an atom containing a character &gt; 255: 8 &gt; io : fwrite ( &quot; ~p ~n &quot; , [ list_to_atom ( [ 1024 ] ) ] ) . &#39;\\x{400}&#39; ok 9 &gt; io : fwrite ( &quot;~tp ~n &quot; , [ list_to_atom ( [ 1024 ] ) ] ) . &#39;Ѐ&#39; ok By default, Erlang only detects lists of characters in the Latin-1 range as strings, but the +pc unicode flag can be used to change this (see printable_range/0 for details). For example: 10 &gt; io : fwrite ( &quot; ~p ~n &quot; , [ [ 214 ] ] ) . &quot;Ö&quot; ok 11 &gt; io : fwrite ( &quot; ~p ~n &quot; , [ [ 1024 ] ] ) . [ 1024 ] ok 12 &gt; io : fwrite ( &quot;~tp ~n &quot; , [ [ 1024 ] ] ) . [ 1024 ] ok but if Erlang was started with +pc unicode : 13 &gt; io : fwrite ( &quot; ~p ~n &quot; , [ [ 1024 ] ] ) . [ 1024 ] ok 14 &gt; io : fwrite ( &quot;~tp ~n &quot; , [ [ 1024 ] ] ) . &quot;Ѐ&quot; ok Similarly, binaries that look like UTF-8 encoded strings are output with the binary string syntax if the t modifier is specified: 15 &gt; io : fwrite ( &quot; ~p ~n &quot; , [ &lt;&lt; 208 , 128 &gt;&gt; ] ) . &lt;&lt; 208 , 128 &gt;&gt; ok 16 &gt; io : fwrite ( &quot;~tp ~n &quot; , [ &lt;&lt; 208 , 128 &gt;&gt; ] ) . &lt;&lt; &quot;Ѐ&quot; / utf8 &gt;&gt; ok 17 &gt; io : fwrite ( &quot;~tp ~n &quot; , [ &lt;&lt; 128 , 128 &gt;&gt; ] ) . &lt;&lt; 128 , 128 &gt;&gt; ok W Writes data in the same way as ~w , but takes an extra argument that is the maximum depth to which terms are printed. Anything below this depth is replaced with ... . For example, using T above: 8 &gt; io : fwrite ( &quot; ~W ~n &quot; , [ T , 9 ] ) . [ { attributes , [ [ { id , age , 1.5 } , { mode , explicit } , { typename , . . . } ] , [ { id , cho } , { mode , . . . } , { . . . } ] ] } , { typename , &#39;Person&#39; } , { tag , { &#39;PRIVATE&#39; , 3 } } , { mode , implicit } ] ok If the maximum depth is reached, it cannot be read in the resultant output. Also, the ,... form in a tuple denotes that there are more elements in the tuple but these are below the print depth. P Writes data in the same way as ~p , but takes an extra argument that is the maximum depth to which terms are printed. Anything below this depth is replaced with ... , for example: 9 &gt; io : fwrite ( &quot; ~62P ~n &quot; , [ T , 9 ] ) . [ { attributes , [ [ { id , age , 1.5 } , { mode , explicit } , { typename , . . . } ] , [ { id , cho } , { mode , . . . } , { . . . } ] ] } , { typename , &#39;Person&#39; } , { tag , { &#39;PRIVATE&#39; , 3 } } , { mode , implicit } ] ok B Writes an integer in base 2-36, the default base is 10. A leading dash is printed for negative integers. The precision field selects base, for example: 1 &gt; io : fwrite ( &quot; ~.16B ~n &quot; , [ 31 ] ) . 1 F ok 2 &gt; io : fwrite ( &quot; ~.2B ~n &quot; , [ - 19 ] ) . - 10011 ok 3 &gt; io : fwrite ( &quot; ~.36B ~n &quot; , [ 5 * 36 + 35 ] ) . 5 Z ok X Like B , but takes an extra argument that is a prefix to insert before the number, but after the leading dash, if any. The prefix can be a possibly deep list of characters or an atom. Example: 1 &gt; io : fwrite ( &quot; ~X ~n &quot; , [ 31 , &quot;10#&quot; ] ) . 10#31 ok 2 &gt; io : fwrite ( &quot; ~.16X ~n &quot; , [ - 31 , &quot;0x&quot; ] ) . - 0 x1F ok # Like B , but prints the number with an Erlang style # -separated base prefix. Example: 1 &gt; io : fwrite ( &quot; ~.10# ~n &quot; , [ 31 ] ) . 10#31 ok 2 &gt; io : fwrite ( &quot; ~.16# ~n &quot; , [ - 31 ] ) . - 16#1F ok b Like B , but prints lowercase letters. x Like X , but prints lowercase letters. + Like # , but prints lowercase letters. n Writes a new line. i Ignores the next term. The function returns: ok The formatting succeeded. If an error occurs, there is no output. Example: 1 &gt; io : fwrite ( &quot; ~s ~w ~i ~w ~c ~n &quot; , [ &#39;abc def&#39; , &#39;abc def&#39; , { foo , 1 } , { foo , 1 } , 65 ] ) . abc def &#39;abc def&#39; { foo , 1 } A ok 2 &gt; io : fwrite ( &quot; ~s &quot; , [ 65 ] ) . * * exception error : bad argument in function io : format / 3 called as io : format ( &lt; 0.53 . 0 &gt; , &quot; ~s &quot; , &quot;A&quot; ) In this example, an attempt was made to output the single character 65 with the aid of the string formatting directive &quot;~s&quot; .","ref":"io.html#format/1","title":"io.format/1","type":"function"},{"doc":"","ref":"io.html#format/2","title":"io.format/2","type":"function"},{"doc":"","ref":"io.html#format/3","title":"io.format/3","type":"function"},{"doc":"Reads characters from the standard input ( IoDevice ), prompting it with Prompt . Interprets the characters in accordance with Format . Format contains control sequences that directs the interpretation of the input. Format can contain the following: Whitespace characters ( Space , Tab , and Newline ) that cause input to be read to the next non-whitespace character. Ordinary characters that must match the next input character. Control sequences, which have the general format ~*FMC , where: Character * is an optional return suppression character. It provides a method to specify a field that is to be omitted. F is the field width of the input field. M is an optional translation modifier (of which t is the only supported, meaning Unicode translation). C determines the type of control sequence. Unless otherwise specified, leading whitespace is ignored for all control sequences. An input field cannot be more than one line wide. Available control sequences: ~ A single ~ is expected in the input. d A decimal integer is expected. u An unsigned integer in base 2-36 is expected. The field width parameter is used to specify base. Leading whitespace characters are not skipped. - An optional sign character is expected. A sign character - gives return value -1 . Sign character + or none gives 1 . The field width parameter is ignored. Leading whitespace characters are not skipped. # An integer in base 2-36 with Erlang-style base prefix (for example, &quot;16#ffff&quot; ) is expected. f A floating point number is expected. It must follow the Erlang floating point number syntax. s A string of non-whitespace characters is read. If a field width has been specified, this number of characters are read and all trailing whitespace characters are stripped. An Erlang string (list of characters) is returned. If Unicode translation is in effect ( ~ts ), characters &gt; 255 are accepted, otherwise not. With the translation modifier, the returned list can as a consequence also contain integers &gt; 255: 1 &gt; io : fread ( &quot;Prompt&gt; &quot; , &quot; ~s &quot; ) . Prompt &gt; &lt; Characters beyond latin1 range not printable in this medium &gt; { error , { fread , string } } 2 &gt; io : fread ( &quot;Prompt&gt; &quot; , &quot;~ts&quot; ) . Prompt &gt; &lt; Characters beyond latin1 range not printable in this medium &gt; { ok , [ [ 1091 , 1085 , 1080 , 1094 , 1086 , 1076 , 1077 ] ] } a Similar to s , but the resulting string is converted into an atom. c The number of characters equal to the field width are read (default is 1) and returned as an Erlang string. However, leading and trailing whitespace characters are not omitted as they are with s . All characters are returned. The Unicode translation modifier works as with s : 1 &gt; io : fread ( &quot;Prompt&gt; &quot; , &quot;~c&quot; ) . Prompt &gt; &lt; Character beyond latin1 range not printable in this medium &gt; { error , { fread , string } } 2 &gt; io : fread ( &quot;Prompt&gt; &quot; , &quot;~tc&quot; ) . Prompt &gt; &lt; Character beyond latin1 range not printable in this medium &gt; { ok , [ [ 1091 ] ] } l Returns the number of characters that have been scanned up to that point, including whitespace characters. The function returns: {ok, Terms} The read was successful and Terms is the list of successfully matched and read items. eof End of file was encountered. {error, FreadError} The reading failed and FreadError gives a hint about the error. {error, ErrorDescription} The read operation failed and parameter ErrorDescription gives a hint about the error. Examples: 20 &gt; io : fread ( &#39;enter&gt;&#39; , &quot;~f~f~f&quot; ) . enter &gt; 1.9 35.5e3 15.0 { ok , [ 1.9 , 3.55e4 , 15.0 ] } 21 &gt; io : fread ( &#39;enter&gt;&#39; , &quot;~10f~d&quot; ) . enter &gt; 5.67899 { ok , [ 5.678 , 99 ] } 22 &gt; io : fread ( &#39;enter&gt;&#39; , &quot;: ~10s :~10c:&quot; ) . enter &gt; : alan : joe : { ok , [ &quot;alan&quot; , &quot; joe &quot; ] }","ref":"io.html#fread/2","title":"io.fread/2","type":"function"},{"doc":"","ref":"io.html#fread/3","title":"io.fread/3","type":"function"},{"doc":"","ref":"io.html#fwrite/1","title":"io.fwrite/1","type":"function"},{"doc":"","ref":"io.html#fwrite/2","title":"io.fwrite/2","type":"function"},{"doc":"","ref":"io.html#fwrite/3","title":"io.fwrite/3","type":"function"},{"doc":"Reads Count characters from standard input ( IoDevice ), prompting it with Prompt . The function returns: Data The input characters. If the I/O device supports Unicode, the data can represent codepoints &gt; 255 (the latin1 range). If the I/O server is set to deliver binaries, they are encoded in UTF-8 (regardless of whether the I/O device supports Unicode). eof End of file was encountered. {error, ErrorDescription} Other (rare) error condition, such as {error, estale} if reading from an NFS file system.","ref":"io.html#get_chars/2","title":"io.get_chars/2","type":"function"},{"doc":"","ref":"io.html#get_chars/3","title":"io.get_chars/3","type":"function"},{"doc":"Reads a line from the standard input ( IoDevice ), prompting it with Prompt . The function returns: Data The characters in the line terminated by a line feed (or end of file). If the I/O device supports Unicode, the data can represent codepoints &gt; 255 (the latin1 range). If the I/O server is set to deliver binaries, they are encoded in UTF-8 (regardless of if the I/O device supports Unicode). eof End of file was encountered. {error, ErrorDescription} Other (rare) error condition, such as {error, estale} if reading from an NFS file system.","ref":"io.html#get_line/1","title":"io.get_line/1","type":"function"},{"doc":"","ref":"io.html#get_line/2","title":"io.get_line/2","type":"function"},{"doc":"Requests all available options and their current values for a specific I/O device, for example: 1 &gt; { ok , F } = file : open ( &quot;/dev/null&quot; , [ read ] ) . { ok , &lt; 0.42 . 0 &gt; } 2 &gt; io : getopts ( F ) . [ { binary , false } , { encoding , latin1 } ] Here the file I/O server returns all available options for a file, which are the expected ones, encoding and binary . However, the standard shell has some more options: 3 &gt; io : getopts ( ) . [ { expand_fun , # Fun &lt; group . 0.120017273 &gt; } , { echo , true } , { binary , false } , { encoding , unicode } ] This example is, as can be seen, run in an environment where the terminal supports Unicode input and output.","ref":"io.html#getopts/0","title":"io.getopts/0","type":"function"},{"doc":"","ref":"io.html#getopts/1","title":"io.getopts/1","type":"function"},{"doc":"Writes new line to the standard output ( IoDevice ).","ref":"io.html#nl/0","title":"io.nl/0","type":"function"},{"doc":"","ref":"io.html#nl/1","title":"io.nl/1","type":"function"},{"doc":"Reads data from the standard input ( IoDevice ), prompting it with Prompt . Starts reading at location StartLocation ( 1 ). Argument Options is passed on as argument Options of function erl_scan:tokens/4 . The data is tokenized and parsed as if it was a sequence of Erlang expressions until a final dot ( . ) is reached. The function returns: {ok, ExprList, EndLocation} The parsing was successful. {eof, EndLocation} End of file was encountered by the tokenizer. eof End of file was encountered by the I/O server. {error, ErrorInfo, ErrorLocation} An error occurred while tokenizing or parsing. {error, ErrorDescription} Other (rare) error condition, such as {error, estale} if reading from an NFS file system. Example: 25 &gt; io : parse_erl_exprs ( &#39;enter&gt;&#39; ) . enter &gt; abc ( ) , &quot;hey&quot; . { ok , [ { call , 1 , { atom , 1 , abc } , [ ] } , { string , 1 , &quot;hey&quot; } ] , 2 } 26 &gt; io : parse_erl_exprs ( &#39;enter&gt;&#39; ) . enter &gt; abc ( &quot;hey&quot; . { error , { 1 , erl_parse , [ &quot;syntax error before: &quot; , [ &quot;&#39;.&#39;&quot; ] ] } , 2 }","ref":"io.html#parse_erl_exprs/1","title":"io.parse_erl_exprs/1","type":"function"},{"doc":"","ref":"io.html#parse_erl_exprs/2","title":"io.parse_erl_exprs/2","type":"function"},{"doc":"","ref":"io.html#parse_erl_exprs/3","title":"io.parse_erl_exprs/3","type":"function"},{"doc":"","ref":"io.html#parse_erl_exprs/4","title":"io.parse_erl_exprs/4","type":"function"},{"doc":"Reads data from the standard input ( IoDevice ), prompting it with Prompt . Starts reading at location StartLocation ( 1 ). Argument Options is passed on as argument Options of function erl_scan:tokens/4 . The data is tokenized and parsed as if it was an Erlang form (one of the valid Erlang expressions in an Erlang source file) until a final dot ( . ) is reached. The function returns: {ok, AbsForm, EndLocation} The parsing was successful. {eof, EndLocation} End of file was encountered by the tokenizer. eof End of file was encountered by the I/O server. {error, ErrorInfo, ErrorLocation} An error occurred while tokenizing or parsing. {error, ErrorDescription} Other (rare) error condition, such as {error, estale} if reading from an NFS file system.","ref":"io.html#parse_erl_form/1","title":"io.parse_erl_form/1","type":"function"},{"doc":"","ref":"io.html#parse_erl_form/2","title":"io.parse_erl_form/2","type":"function"},{"doc":"","ref":"io.html#parse_erl_form/3","title":"io.parse_erl_form/3","type":"function"},{"doc":"","ref":"io.html#parse_erl_form/4","title":"io.parse_erl_form/4","type":"function"},{"doc":"Returns the user-requested range of printable Unicode characters. The user can request a range of characters that are to be considered printable in heuristic detection of strings by the shell and by the formatting functions. This is done by supplying +pc &lt;range&gt; when starting Erlang. The only valid values for &lt;range&gt; are latin1 and unicode . latin1 means that only code points &lt; 256 (except control characters, and so on) are considered printable. unicode means that all printable characters in all Unicode character ranges are considered printable by the I/O functions. By default, Erlang is started so that only the latin1 range of characters indicate that a list of integers is a string. The simplest way to use the setting is to call io_lib:printable_list/1 , which uses the return value of this function to decide if a list is a string of printable characters. In a future release, this function may return more values and ranges. To avoid compatibility problems, it is recommended to use function io_lib:printable_list/1 .","ref":"io.html#printable_range/0","title":"io.printable_range/0","type":"function"},{"doc":"Writes the characters of CharData to the I/O server ( IoDevice ).","ref":"io.html#put_chars/1","title":"io.put_chars/1","type":"function"},{"doc":"","ref":"io.html#put_chars/2","title":"io.put_chars/2","type":"function"},{"doc":"Reads a term Term from the standard input ( IoDevice ), prompting it with Prompt . The function returns: {ok, Term} The parsing was successful. eof End of file was encountered. {error, ErrorInfo} The parsing failed. {error, ErrorDescription} Other (rare) error condition, such as {error, estale} if reading from an NFS file system.","ref":"io.html#read/1","title":"io.read/1","type":"function"},{"doc":"","ref":"io.html#read/2","title":"io.read/2","type":"function"},{"doc":"Reads a term Term from IoDevice , prompting it with Prompt . Reading starts at location StartLocation . Argument Options is passed on as argument Options of function erl_scan:tokens/4 . The function returns: {ok, Term, EndLocation} The parsing was successful. {eof, EndLocation} End of file was encountered. {error, ErrorInfo, ErrorLocation} The parsing failed. {error, ErrorDescription} Other (rare) error condition, such as {error, estale} if reading from an NFS file system.","ref":"io.html#read/3","title":"io.read/3","type":"function"},{"doc":"","ref":"io.html#read/4","title":"io.read/4","type":"function"},{"doc":"Retrieves the number of rows of IoDevice (that is, the height of a terminal). The function only succeeds for terminal devices, for all other I/O devices the function returns {error, enotsup} .","ref":"io.html#rows/0","title":"io.rows/0","type":"function"},{"doc":"","ref":"io.html#rows/1","title":"io.rows/1","type":"function"},{"doc":"Reads data from the standard input ( IoDevice ), prompting it with Prompt . Reading starts at location StartLocation ( 1 ). Argument Options is passed on as argument Options of function erl_scan:tokens/4 . The data is tokenized as if it were a sequence of Erlang expressions until a final dot ( . ) is reached. This token is also returned. The function returns: {ok, Tokens, EndLocation} The tokenization succeeded. {eof, EndLocation} End of file was encountered by the tokenizer. eof End of file was encountered by the I/O server. {error, ErrorInfo, ErrorLocation} An error occurred while tokenizing. {error, ErrorDescription} Other (rare) error condition, such as {error, estale} if reading from an NFS file system. Example: 23 &gt; io : scan_erl_exprs ( &#39;enter&gt;&#39; ) . enter &gt; abc ( ) , &quot;hey&quot; . { ok , [ { atom , 1 , abc } , { &#39;(&#39; , 1 } , { &#39;)&#39; , 1 } , { &#39;,&#39; , 1 } , { string , 1 , &quot;hey&quot; } , { dot , 1 } ] , 2 } 24 &gt; io : scan_erl_exprs ( &#39;enter&gt;&#39; ) . enter &gt; 1.0 er . { error , { 1 , erl_scan , { illegal , float } } , 2 }","ref":"io.html#scan_erl_exprs/1","title":"io.scan_erl_exprs/1","type":"function"},{"doc":"","ref":"io.html#scan_erl_exprs/2","title":"io.scan_erl_exprs/2","type":"function"},{"doc":"","ref":"io.html#scan_erl_exprs/3","title":"io.scan_erl_exprs/3","type":"function"},{"doc":"","ref":"io.html#scan_erl_exprs/4","title":"io.scan_erl_exprs/4","type":"function"},{"doc":"Reads data from the standard input ( IoDevice ), prompting it with Prompt . Starts reading at location StartLocation ( 1 ). Argument Options is passed on as argument Options of function erl_scan:tokens/4 . The data is tokenized as if it was an Erlang form (one of the valid Erlang expressions in an Erlang source file) until a final dot ( . ) is reached. This last token is also returned. The return values are the same as for scan_erl_exprs/1,2,3,4 .","ref":"io.html#scan_erl_form/1","title":"io.scan_erl_form/1","type":"function"},{"doc":"","ref":"io.html#scan_erl_form/2","title":"io.scan_erl_form/2","type":"function"},{"doc":"","ref":"io.html#scan_erl_form/3","title":"io.scan_erl_form/3","type":"function"},{"doc":"","ref":"io.html#scan_erl_form/4","title":"io.scan_erl_form/4","type":"function"},{"doc":"Set options for the standard I/O device ( IoDevice ). Possible options and values vary depending on the I/O device. For a list of supported options and their current values on a specific I/O device, use function getopts/1 . The options and values supported by the OTP I/O devices are as follows: binary , list , or {binary, boolean()} If set in binary mode ( binary or {binary, true} ), the I/O server sends binary data (encoded in UTF-8) as answers to the get_line , get_chars , and, if possible, get_until requests (for details, see section The Erlang I/O Protocol) in the User's Guide). The immediate effect is that get_chars/2,3 and get_line/1,2 return UTF-8 binaries instead of lists of characters for the affected I/O device. By default, all I/O devices in OTP are set in list mode. However, the I/O functions can handle any of these modes and so should other, user-written, modules behaving as clients to I/O servers. This option is supported by the standard shell ( group.erl ), the 'oldshell' ( user.erl ), and the file I/O servers. {echo, boolean()} Denotes if the terminal is to echo input. Only supported for the standard shell I/O server ( group.erl ) {expand_fun, expand_fun()} Provides a function for tab-completion (expansion) like the Erlang shell. This function is called when the user presses the Tab key. The expansion is active when calling line-reading functions, such as get_line/1,2 . The function is called with the current line, up to the cursor, as a reversed string. It is to return a three-tuple: {yes|no, string(), [string(), ...]} . The first element gives a beep if no , otherwise the expansion is silent; the second is a string that will be entered at the cursor position; the third is a list of possible expansions. If this list is not empty, it is printed and the current input line is written once again. Trivial example (beep on anything except empty line, which is expanded to &quot;quit&quot; ): fun(&quot;&quot;) -&gt; {yes, &quot;quit&quot;, []}; (_) -&gt; {no, &quot;&quot;, [&quot;quit&quot;]} end This option is only supported by the standard shell ( group.erl ). {encoding, latin1 | unicode} Specifies how characters are input or output from or to the I/O device, implying that, for example, a terminal is set to handle Unicode input and output or a file is set to handle UTF-8 data encoding. The option does not affect how data is returned from the I/O functions or how it is sent in the I/O protocol, it only affects how the I/O device is to handle Unicode characters to the &quot;physical&quot; device. The standard shell is set for unicode or latin1 encoding when the system is started. The encoding is set with the help of the LANG or LC_CTYPE environment variables on Unix-like system or by other means on other systems. So, the user can input Unicode characters and the I/O device is in {encoding, unicode} mode if the I/O device supports it. The mode can be changed, if the assumption of the runtime system is wrong, by setting this option. The I/O device used when Erlang is started with the &quot;-oldshell&quot; or &quot;-noshell&quot; flags is by default set to latin1 encoding, meaning that any characters &gt; codepoint 255 are escaped and that input is expected to be plain 8-bit ISO Latin-1. If the encoding is changed to Unicode, input and output from the standard file descriptors are in UTF-8 (regardless of operating system). Files can also be set in {encoding, unicode} , meaning that data is written and read as UTF-8. More encodings are possible for files, see below. {encoding, unicode | latin1} is supported by both the standard shell ( group.erl including werl on Windows), the 'oldshell' ( user.erl ), and the file I/O servers. {encoding, utf8 | utf16 | utf32 | {utf16,big} | {utf16,little} | {utf32,big} | {utf32,little}} For disk files, the encoding can be set to various UTF variants. This has the effect that data is expected to be read as the specified encoding from the file, and the data is written in the specified encoding to the disk file. {encoding, utf8} has the same effect as {encoding, unicode} on files. The extended encodings are only supported on disk files (opened by function file:open/2 ).","ref":"io.html#setopts/1","title":"io.setopts/1","type":"function"},{"doc":"","ref":"io.html#setopts/2","title":"io.setopts/2","type":"function"},{"doc":"Writes term Term to the standard output ( IoDevice ).","ref":"io.html#write/1","title":"io.write/1","type":"function"},{"doc":"","ref":"io.html#write/2","title":"io.write/2","type":"function"},{"doc":"An I/O device, either standard_io , standard_error , a registered name, or a pid handling I/O protocols (returned from file:open/2 ). For more information about the built-in devices see Standard Input/Output and Standard Error .","ref":"io.html#t:device/0","title":"io.device/0","type":"type"},{"doc":"","ref":"io.html#t:encoding/0","title":"io.encoding/0","type":"type"},{"doc":"","ref":"io.html#t:expand_fun/0","title":"io.expand_fun/0","type":"type"},{"doc":"","ref":"io.html#t:format/0","title":"io.format/0","type":"type"},{"doc":"","ref":"io.html#t:location/0","title":"io.location/0","type":"type"},{"doc":"","ref":"io.html#t:opt_pair/0","title":"io.opt_pair/0","type":"type"},{"doc":"","ref":"io.html#t:prompt/0","title":"io.prompt/0","type":"type"},{"doc":"What the I/O server sends when there is no data.","ref":"io.html#t:server_no_data/0","title":"io.server_no_data/0","type":"type"},{"doc":"","ref":"io.html#t:setopt/0","title":"io.setopt/0","type":"type"},{"doc":"This module contains functions for converting to and from strings (lists of characters). They are used for implementing the functions in the io module. There is no guarantee that the character lists returned from some of the functions are flat, they can be deep lists. Function lists:flatten/1 can be used for flattening deep lists.","ref":"io_lib.html","title":"io_lib","type":"module"},{"doc":"For details, see scan_format/2 .","ref":"io_lib.html#build_text/1","title":"io_lib.build_text/1","type":"function"},{"doc":"Returns true if Term is a flat list of characters in the Unicode range, otherwise false .","ref":"io_lib.html#char_list/1","title":"io_lib.char_list/1","type":"function"},{"doc":"Returns true if Term is a, possibly deep, list of characters in the Unicode range, otherwise false .","ref":"io_lib.html#deep_char_list/1","title":"io_lib.deep_char_list/1","type":"function"},{"doc":"Returns true if Term is a, possibly deep, list of characters in the ISO Latin-1 range, otherwise false .","ref":"io_lib.html#deep_latin1_char_list/1","title":"io_lib.deep_latin1_char_list/1","type":"function"},{"doc":"Returns a character list that represents Data formatted in accordance with Format . For a detailed description of the available formatting options, see io:fwrite/1,2,3 . If the format string or argument list contains an error, a fault is generated. If and only if the Unicode translation modifier is used in the format string (that is, ~ts or ~tc ), the resulting list can contain characters beyond the ISO Latin-1 character range (that is, numbers &gt; 255). If so, the result is still an ordinary Erlang string() , and can well be used in any context where Unicode data is allowed.","ref":"io_lib.html#format/2","title":"io_lib.format/2","type":"function"},{"doc":"Returns a character list that represents Data formatted in accordance with Format in the same way as fwrite/2 and format/2 , but takes an extra argument, a list of options. Valid option: {chars_limit, CharsLimit} A soft limit on the number of characters returned. When the number of characters is reached, remaining structures are replaced by &quot; ... &quot;. CharsLimit defaults to -1, which means no limit on the number of characters returned.","ref":"io_lib.html#format/3","title":"io_lib.format/3","type":"function"},{"doc":"Tries to read String in accordance with the control sequences in Format . For a detailed description of the available formatting options, see io:fread/3 . It is assumed that String contains whole lines. The function returns: {ok, InputList, LeftOverChars} The string was read. InputList is the list of successfully matched and read items, and LeftOverChars are the input characters not used. {more, RestFormat, Nchars, InputStack} The string was read, but more input is needed to complete the original format string. RestFormat is the remaining format string, Nchars is the number of characters scanned, and InputStack is the reversed list of inputs matched up to that point. {error, What} The read operation failed and parameter What gives a hint about the error. Example: 3 &gt; io_lib : fread ( &quot;~f~f~f&quot; , &quot;15.6 17.3e-6 24.5&quot; ) . { ok , [ 15.6 , 1.73e-5 , 24.5 ] , [ ] }","ref":"io_lib.html#fread/2","title":"io_lib.fread/2","type":"function"},{"doc":"This is the re-entrant formatted reader. The continuation of the first call to the functions must be [] . For a complete description of how the re-entrant input scheme works, see Armstrong, Virding, Williams: 'Concurrent Programming in Erlang', Chapter 13. The function returns: {done, Result, LeftOverChars} The input is complete. The result is one of the following: {ok, InputList} The string was read. InputList is the list of successfully matched and read items, and LeftOverChars are the remaining characters. eof End of file was encountered. LeftOverChars are the input characters not used. {error, What} An error occurred and parameter What gives a hint about the error. {more, Continuation} More data is required to build a term. Continuation must be passed to fread/3 when more data becomes available.","ref":"io_lib.html#fread/3","title":"io_lib.fread/3","type":"function"},{"doc":"","ref":"io_lib.html#fwrite/2","title":"io_lib.fwrite/2","type":"function"},{"doc":"","ref":"io_lib.html#fwrite/3","title":"io_lib.fwrite/3","type":"function"},{"doc":"Returns the indentation if String has been printed, starting at StartIndent .","ref":"io_lib.html#indentation/2","title":"io_lib.indentation/2","type":"function"},{"doc":"Returns true if Term is a flat list of characters in the ISO Latin-1 range, otherwise false .","ref":"io_lib.html#latin1_char_list/1","title":"io_lib.latin1_char_list/1","type":"function"},{"doc":"Returns a character list that represents a new line character.","ref":"io_lib.html#nl/0","title":"io_lib.nl/0","type":"function"},{"doc":"Returns a list of characters that represents Term , but breaks representations longer than one line into many lines and indents each line sensibly. Also tries to detect and output lists of printable characters as strings. Column is the starting column; defaults to 1. LineLength is the maximum line length; defaults to 80. Depth is the maximum print depth; defaults to -1, which means no limitation.","ref":"io_lib.html#print/1","title":"io_lib.print/1","type":"function"},{"doc":"","ref":"io_lib.html#print/4","title":"io_lib.print/4","type":"function"},{"doc":"Returns true if Term is a flat list of printable ISO Latin-1 characters, otherwise false .","ref":"io_lib.html#printable_latin1_list/1","title":"io_lib.printable_latin1_list/1","type":"function"},{"doc":"Returns true if Term is a flat list of printable characters, otherwise false . What is a printable character in this case is determined by startup flag +pc to the Erlang VM; see io:printable_range/0 and erl(1) .","ref":"io_lib.html#printable_list/1","title":"io_lib.printable_list/1","type":"function"},{"doc":"Returns true if Term is a flat list of printable Unicode characters, otherwise false .","ref":"io_lib.html#printable_unicode_list/1","title":"io_lib.printable_unicode_list/1","type":"function"},{"doc":"Returns a list corresponding to the specified format string, where control sequences have been replaced with corresponding tuples. This list can be passed to: build_text/1 to have the same effect as format(Format, Args) unscan_format/1 to get the corresponding pair of Format and Args (with every * and corresponding argument expanded to numeric values) A typical use of this function is to replace unbounded-size control sequences like ~w and ~p with the depth-limited variants ~W and ~P before formatting to text in, for example, a logger.","ref":"io_lib.html#scan_format/2","title":"io_lib.scan_format/2","type":"function"},{"doc":"For details, see scan_format/2 .","ref":"io_lib.html#unscan_format/1","title":"io_lib.unscan_format/1","type":"function"},{"doc":"Returns a character list that represents Term . Option Depth controls the depth of the structures written. When the specified depth is reached, everything below this level is replaced by &quot; ... &quot;. Depth defaults to -1, which means no limitation. Option CharsLimit puts a soft limit on the number of characters returned. When the number of characters is reached, remaining structures are replaced by &quot; ... &quot;. CharsLimit defaults to -1, which means no limit on the number of characters returned. Example: 1 &gt; lists : flatten ( io_lib : write ( { 1 , [ 2 ] , [ 3 ] , [ 4 , 5 ] , 6 , 7 , 8 , 9 } ) ) . &quot;{1,[2],[3],[4,5],6,7,8,9}&quot; 2 &gt; lists : flatten ( io_lib : write ( { 1 , [ 2 ] , [ 3 ] , [ 4 , 5 ] , 6 , 7 , 8 , 9 } , 5 ) ) . &quot;{1,[2],[3],[...],...}&quot; 3 &gt; lists : flatten ( io_lib : write ( { [ 1 , 2 , 3 ] , [ 4 , 5 ] , 6 , 7 , 8 , 9 } , [ { chars_limit , 20 } ] ) ) . &quot;{[1,2|...],[4|...],...}&quot;","ref":"io_lib.html#write/1","title":"io_lib.write/1","type":"function"},{"doc":"","ref":"io_lib.html#write/2","title":"io_lib.write/2","type":"function"},{"doc":"Returns the list of characters needed to print atom Atom .","ref":"io_lib.html#write_atom/1","title":"io_lib.write_atom/1","type":"function"},{"doc":"Returns the list of characters needed to print atom Atom . Non-Latin-1 characters are escaped.","ref":"io_lib.html#write_atom_as_latin1/1","title":"io_lib.write_atom_as_latin1/1","type":"function"},{"doc":"Returns the list of characters needed to print a character constant in the Unicode character set.","ref":"io_lib.html#write_char/1","title":"io_lib.write_char/1","type":"function"},{"doc":"Returns the list of characters needed to print a character constant in the Unicode character set. Non-Latin-1 characters are escaped.","ref":"io_lib.html#write_char_as_latin1/1","title":"io_lib.write_char_as_latin1/1","type":"function"},{"doc":"Returns the list of characters needed to print a character constant in the ISO Latin-1 character set.","ref":"io_lib.html#write_latin1_char/1","title":"io_lib.write_latin1_char/1","type":"function"},{"doc":"Returns the list of characters needed to print Latin1String as a string.","ref":"io_lib.html#write_latin1_string/1","title":"io_lib.write_latin1_string/1","type":"function"},{"doc":"Returns the list of characters needed to print String as a string.","ref":"io_lib.html#write_string/1","title":"io_lib.write_string/1","type":"function"},{"doc":"Returns the list of characters needed to print String as a string. Non-Latin-1 characters are escaped.","ref":"io_lib.html#write_string_as_latin1/1","title":"io_lib.write_string_as_latin1/1","type":"function"},{"doc":"","ref":"io_lib.html#t:chars/0","title":"io_lib.chars/0","type":"type"},{"doc":"","ref":"io_lib.html#t:chars_limit/0","title":"io_lib.chars_limit/0","type":"type"},{"doc":"A continuation as returned by fread/3 .","ref":"io_lib.html#t:continuation/0","title":"io_lib.continuation/0","type":"opaque"},{"doc":"","ref":"io_lib.html#t:depth/0","title":"io_lib.depth/0","type":"type"},{"doc":"Where: control_char is the type of control sequence: $P , $w , and so on. args is a list of the arguments used by the control sequence, or an empty list if the control sequence does not take any arguments. width is the field width. adjust is the adjustment. precision is the precision of the printed argument. pad_char is the padding character. encoding is set to true if translation modifier t is present. strings is set to false if modifier l is present.","ref":"io_lib.html#t:format_spec/0","title":"io_lib.format_spec/0","type":"type"},{"doc":"","ref":"io_lib.html#t:fread_error/0","title":"io_lib.fread_error/0","type":"type"},{"doc":"","ref":"io_lib.html#t:fread_item/0","title":"io_lib.fread_item/0","type":"type"},{"doc":"","ref":"io_lib.html#t:latin1_string/0","title":"io_lib.latin1_string/0","type":"type"},{"doc":"This module contains functions for list processing. Unless otherwise stated, all functions assume that position numbering starts at 1. That is, the first element of a list is at position 1. Two terms T1 and T2 compare equal if T1 == T2 evaluates to true . They match if T1 =:= T2 evaluates to true . Whenever an ordering function F is expected as argument, it is assumed that the following properties hold of F for all x, y, and z: If x F y and y F x, then x = y ( F is antisymmetric). If x F y and y F z, then x F z ( F is transitive). x F y or y F x ( F is total). An example of a typical ordering function is less than or equal to: =&lt;/2 .","ref":"lists.html","title":"lists","type":"module"},{"doc":"Returns true if Pred(Elem) returns true for all elements Elem in List , otherwise false . The Pred function must return a boolean.","ref":"lists.html#all/2","title":"lists.all/2","type":"function"},{"doc":"Returns true if Pred(Elem) returns true for at least one element Elem in List . The Pred function must return a boolean.","ref":"lists.html#any/2","title":"lists.any/2","type":"function"},{"doc":"Returns a list in which all the sublists of ListOfLists have been appended. Example: &gt; lists : append ( [ [ 1 , 2 , 3 ] , [ a , b ] , [ 4 , 5 , 6 ] ] ) . [ 1 , 2 , 3 , a , b , 4 , 5 , 6 ]","ref":"lists.html#append/1","title":"lists.append/1","type":"function"},{"doc":"Returns a new list List3 , which is made from the elements of List1 followed by the elements of List2 . Example: &gt; lists : append ( &quot;abc&quot; , &quot;def&quot; ) . &quot;abcdef&quot; lists:append(A, B) is equivalent to A ++ B .","ref":"lists.html#append/2","title":"lists.append/2","type":"function"},{"doc":"Concatenates the text representation of the elements of Things . The elements of Things can be atoms, integers, floats, or strings. Example: &gt; lists : concat ( [ doc , &#39;/&#39; , file , &#39;.&#39; , 3 ] ) . &quot;doc/file.3&quot;","ref":"lists.html#concat/1","title":"lists.concat/1","type":"function"},{"doc":"Returns a copy of List1 where the first element matching Elem is deleted, if there is such an element.","ref":"lists.html#delete/2","title":"lists.delete/2","type":"function"},{"doc":"Drops the last element of a List . The list is to be non-empty, otherwise the function crashes with a function_clause .","ref":"lists.html#droplast/1","title":"lists.droplast/1","type":"function"},{"doc":"Drops elements Elem from List1 while Pred(Elem) returns true and returns the remaining list. The Pred function must return a boolean.","ref":"lists.html#dropwhile/2","title":"lists.dropwhile/2","type":"function"},{"doc":"Returns a list containing N copies of term Elem . Example: &gt; lists : duplicate ( 5 , xx ) . [ xx , xx , xx , xx , xx ]","ref":"lists.html#duplicate/2","title":"lists.duplicate/2","type":"function"},{"doc":"Returns List1 with each element H replaced by a tuple of form {I, H} where I is the position of H in List1 . The enumeration starts with 1 and increases by 1 in each step. That is, enumerate/1 behaves as if it had been defined as follows: enumerate(List) -&gt; {List1, _ } = lists:mapfoldl(fun(T, Acc) -&gt; {{Acc, T}, Acc+1} end, 1, List), List1. Example: &gt; lists : enumerate ( [ a , b , c ] ) . [ { 1 , a } , { 2 , b } , { 3 , c } ]","ref":"lists.html#enumerate/1","title":"lists.enumerate/1","type":"function"},{"doc":"Returns List1 with each element H replaced by a tuple of form {I, H} where I is the position of H in List1 . The enumeration starts with Index and increases by 1 in each step. That is, enumerate/2 behaves as if it had been defined as follows: enumerate(I, List) -&gt; {List1, _ } = lists:mapfoldl(fun(T, Acc) -&gt; {{Acc, T}, Acc+1} end, I, List), List1. Example: &gt; lists : enumerate ( 10 , [ a , b , c ] ) . [ { 10 , a } , { 11 , b } , { 12 , c } ]","ref":"lists.html#enumerate/2","title":"lists.enumerate/2","type":"function"},{"doc":"List2 is a list of all elements Elem in List1 for which Pred(Elem) returns true . The Pred function must return a boolean.","ref":"lists.html#filter/2","title":"lists.filter/2","type":"function"},{"doc":"Calls Fun(Elem) on successive elements Elem of List1 . Fun/1 must return either a Boolean or a tuple {true, Value} . The function returns the list of elements for which Fun returns a new value, where a value of true is synonymous with {true, Elem} . That is, filtermap behaves as if it had been defined as follows: filtermap(Fun, List1) -&gt; lists:foldr(fun(Elem, Acc) -&gt; case Fun(Elem) of false -&gt; Acc; true -&gt; [Elem|Acc]; {true,Value} -&gt; [Value|Acc] end end, [], List1). Example: &gt; lists : filtermap ( fun ( X ) -&gt; case X rem 2 of 0 -&gt; { true , X div 2 } ; _ -&gt; false end end , [ 1 , 2 , 3 , 4 , 5 ] ) . [ 1 , 2 ]","ref":"lists.html#filtermap/2","title":"lists.filtermap/2","type":"function"},{"doc":"Equivalent to length(flatten(DeepList)) , but more efficient.","ref":"lists.html#flatlength/1","title":"lists.flatlength/1","type":"function"},{"doc":"Takes a function from A s to lists of B s, and a list of A s ( List1 ) and produces a list of B s by applying the function to every element in List1 and appending the resulting lists. That is, flatmap behaves as if it had been defined as follows: flatmap(Fun, List1) -&gt; append(map(Fun, List1)). Example: &gt; lists : flatmap ( fun ( X ) -&gt; [ X , X ] end , [ a , b , c ] ) . [ a , a , b , b , c , c ]","ref":"lists.html#flatmap/2","title":"lists.flatmap/2","type":"function"},{"doc":"Returns a flattened version of DeepList .","ref":"lists.html#flatten/1","title":"lists.flatten/1","type":"function"},{"doc":"Returns a flattened version of DeepList with tail Tail appended.","ref":"lists.html#flatten/2","title":"lists.flatten/2","type":"function"},{"doc":"Calls Fun(Elem, AccIn) on successive elements A of List , starting with AccIn == Acc0 . Fun/2 must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. Acc0 is returned if the list is empty. Example: &gt; lists : foldl ( fun ( X , Sum ) -&gt; X + Sum end , 0 , [ 1 , 2 , 3 , 4 , 5 ] ) . 15 &gt; lists : foldl ( fun ( X , Prod ) -&gt; X * Prod end , 1 , [ 1 , 2 , 3 , 4 , 5 ] ) . 120","ref":"lists.html#foldl/3","title":"lists.foldl/3","type":"function"},{"doc":"Like foldl/3 , but the list is traversed from right to left. Example: &gt; P = fun ( A , AccIn ) -&gt; io : format ( &quot; ~p &quot; , [ A ] ) , AccIn end . # Fun &lt; erl_eval . 12.2225172 &gt; &gt; lists : foldl ( P , void , [ 1 , 2 , 3 ] ) . 1 2 3 void &gt; lists : foldr ( P , void , [ 1 , 2 , 3 ] ) . 3 2 1 void foldl/3 is tail recursive and is usually preferred to foldr/3 .","ref":"lists.html#foldr/3","title":"lists.foldr/3","type":"function"},{"doc":"Calls Fun(Elem) for each element Elem in List . This function is used for its side effects and the evaluation order is defined to be the same as the order of the elements in the list.","ref":"lists.html#foreach/2","title":"lists.foreach/2","type":"function"},{"doc":"Inserts Sep between each element in List1 . Has no effect on the empty list and on a singleton list. For example: &gt; lists : join ( x , [ a , b , c ] ) . [ a , x , b , x , c ] &gt; lists : join ( x , [ a ] ) . [ a ] &gt; lists : join ( x , [ ] ) . [ ]","ref":"lists.html#join/2","title":"lists.join/2","type":"function"},{"doc":"Returns a copy of TupleList1 where the first occurrence of a tuple whose N th element compares equal to Key is deleted, if there is such a tuple.","ref":"lists.html#keydelete/3","title":"lists.keydelete/3","type":"function"},{"doc":"Searches the list of tuples TupleList for a tuple whose N th element compares equal to Key . Returns Tuple if such a tuple is found, otherwise false .","ref":"lists.html#keyfind/3","title":"lists.keyfind/3","type":"function"},{"doc":"Returns a list of tuples where, for each tuple in TupleList1 , the N th element Term1 of the tuple has been replaced with the result of calling Fun(Term1) . Examples: &gt; Fun = fun ( Atom ) -&gt; atom_to_list ( Atom ) end . # Fun &lt; erl_eval . 6.10732646 &gt; 2 &gt; lists : keymap ( Fun , 2 , [ { name , jane , 22 } , { name , lizzie , 20 } , { name , lydia , 15 } ] ) . [ { name , &quot;jane&quot; , 22 } , { name , &quot;lizzie&quot; , 20 } , { name , &quot;lydia&quot; , 15 } ]","ref":"lists.html#keymap/3","title":"lists.keymap/3","type":"function"},{"doc":"Returns true if there is a tuple in TupleList whose N th element compares equal to Key , otherwise false .","ref":"lists.html#keymember/3","title":"lists.keymember/3","type":"function"},{"doc":"Returns the sorted list formed by merging TupleList1 and TupleList2 . The merge is performed on the N th element of each tuple. Both TupleList1 and TupleList2 must be key-sorted before evaluating this function. When two tuples compare equal, the tuple from TupleList1 is picked before the tuple from TupleList2 .","ref":"lists.html#keymerge/3","title":"lists.keymerge/3","type":"function"},{"doc":"Returns a copy of TupleList1 where the first occurrence of a T tuple whose N th element compares equal to Key is replaced with NewTuple , if there is such a tuple T .","ref":"lists.html#keyreplace/4","title":"lists.keyreplace/4","type":"function"},{"doc":"Searches the list of tuples TupleList for a tuple whose N th element compares equal to Key . Returns {value, Tuple} if such a tuple is found, otherwise false . This function is retained for backward compatibility. Function keyfind/3 is usually more convenient.","ref":"lists.html#keysearch/3","title":"lists.keysearch/3","type":"function"},{"doc":"Returns a list containing the sorted elements of list TupleList1 . Sorting is performed on the N th element of the tuples. The sort is stable.","ref":"lists.html#keysort/2","title":"lists.keysort/2","type":"function"},{"doc":"Returns a copy of TupleList1 where the first occurrence of a tuple T whose N th element compares equal to Key is replaced with NewTuple , if there is such a tuple T . If there is no such tuple T , a copy of TupleList1 where [ NewTuple ] has been appended to the end is returned.","ref":"lists.html#keystore/4","title":"lists.keystore/4","type":"function"},{"doc":"Searches the list of tuples TupleList1 for a tuple whose N th element compares equal to Key . Returns {value, Tuple, TupleList2} if such a tuple is found, otherwise false . TupleList2 is a copy of TupleList1 where the first occurrence of Tuple has been removed.","ref":"lists.html#keytake/3","title":"lists.keytake/3","type":"function"},{"doc":"Returns the last element in List .","ref":"lists.html#last/1","title":"lists.last/1","type":"function"},{"doc":"Takes a function from A s to B s, and a list of A s and produces a list of B s by applying the function to every element in the list. This function is used to obtain the return values. The evaluation order depends on the implementation.","ref":"lists.html#map/2","title":"lists.map/2","type":"function"},{"doc":"Combines the operations of map/2 and foldl/3 into one pass. Example: Summing the elements in a list and double them at the same time: &gt; lists : mapfoldl ( fun ( X , Sum ) -&gt; { 2 * X , X + Sum } end , 0 , [ 1 , 2 , 3 , 4 , 5 ] ) . { [ 2 , 4 , 6 , 8 , 10 ] , 15 }","ref":"lists.html#mapfoldl/3","title":"lists.mapfoldl/3","type":"function"},{"doc":"Combines the operations of map/2 and foldr/3 into one pass.","ref":"lists.html#mapfoldr/3","title":"lists.mapfoldr/3","type":"function"},{"doc":"Returns the first element of List that compares greater than or equal to all other elements of List .","ref":"lists.html#max/1","title":"lists.max/1","type":"function"},{"doc":"Returns true if Elem matches some element of List , otherwise false .","ref":"lists.html#member/2","title":"lists.member/2","type":"function"},{"doc":"Returns the sorted list formed by merging all the sublists of ListOfLists . All sublists must be sorted before evaluating this function. When two elements compare equal, the element from the sublist with the lowest position in ListOfLists is picked before the other element.","ref":"lists.html#merge/1","title":"lists.merge/1","type":"function"},{"doc":"Returns the sorted list formed by merging List1 and List2 . Both List1 and List2 must be sorted before evaluating this function. When two elements compare equal, the element from List1 is picked before the element from List2 .","ref":"lists.html#merge/2","title":"lists.merge/2","type":"function"},{"doc":"Returns the sorted list formed by merging List1 and List2 . Both List1 and List2 must be sorted according to the ordering function Fun before evaluating this function. Fun(A, B) is to return true if A compares less than or equal to B in the ordering, otherwise false . When two elements compare equal, the element from List1 is picked before the element from List2 .","ref":"lists.html#merge/3","title":"lists.merge/3","type":"function"},{"doc":"Returns the sorted list formed by merging List1 , List2 , and List3 . All of List1 , List2 , and List3 must be sorted before evaluating this function. When two elements compare equal, the element from List1 , if there is such an element, is picked before the other element, otherwise the element from List2 is picked before the element from List3 .","ref":"lists.html#merge3/3","title":"lists.merge3/3","type":"function"},{"doc":"Returns the first element of List that compares less than or equal to all other elements of List .","ref":"lists.html#min/1","title":"lists.min/1","type":"function"},{"doc":"Returns the N th element of List . Example: &gt; lists : nth ( 3 , [ a , b , c , d , e ] ) . c","ref":"lists.html#nth/2","title":"lists.nth/2","type":"function"},{"doc":"Returns the N th tail of List , that is, the sublist of List starting at N+1 and continuing up to the end of the list. Example &gt; lists : nthtail ( 3 , [ a , b , c , d , e ] ) . [ d , e ] &gt; tl ( tl ( tl ( [ a , b , c , d , e ] ) ) ) . [ d , e ] &gt; lists : nthtail ( 0 , [ a , b , c , d , e ] ) . [ a , b , c , d , e ] &gt; lists : nthtail ( 5 , [ a , b , c , d , e ] ) . [ ]","ref":"lists.html#nthtail/2","title":"lists.nthtail/2","type":"function"},{"doc":"Partitions List into two lists, where the first list contains all elements for which Pred(Elem) returns true , and the second list contains all elements for which Pred(Elem) returns false . Examples: &gt; lists : partition ( fun ( A ) -&gt; A rem 2 == 1 end , [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] ) . { [ 1 , 3 , 5 , 7 ] , [ 2 , 4 , 6 ] } &gt; lists : partition ( fun ( A ) -&gt; is_atom ( A ) end , [ a , b , 1 , c , d , 2 , 3 , 4 , e ] ) . { [ a , b , c , d , e ] , [ 1 , 2 , 3 , 4 ] } For a different way to partition a list, see splitwith/2 .","ref":"lists.html#partition/2","title":"lists.partition/2","type":"function"},{"doc":"Returns true if List1 is a prefix of List2 , otherwise false .","ref":"lists.html#prefix/2","title":"lists.prefix/2","type":"function"},{"doc":"Returns a list with the elements in List1 in reverse order.","ref":"lists.html#reverse/1","title":"lists.reverse/1","type":"function"},{"doc":"Returns a list with the elements in List1 in reverse order, with tail Tail appended. Example: &gt; lists : reverse ( [ 1 , 2 , 3 , 4 ] , [ a , b , c ] ) . [ 4 , 3 , 2 , 1 , a , b , c ]","ref":"lists.html#reverse/2","title":"lists.reverse/2","type":"function"},{"doc":"If there is a Value in List such that Pred(Value) returns true , returns {value, Value} for the first such Value , otherwise returns false . The Pred function must return a boolean.","ref":"lists.html#search/2","title":"lists.search/2","type":"function"},{"doc":"Returns a sequence of integers that starts with From and contains the successive results of adding Incr to the previous element, until To is reached or passed (in the latter case, To is not an element of the sequence). Incr defaults to 1. Failures: If To &lt; From - Incr and Incr &gt; 0 . If To &gt; From - Incr and Incr &lt; 0 . If Incr =:= 0 and From =/= To . The following equalities hold for all sequences: length(lists:seq(From, To)) =:= To - From + 1 length(lists:seq(From, To, Incr)) =:= (To - From + Incr) div Incr Examples: &gt; lists : seq ( 1 , 10 ) . [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] &gt; lists : seq ( 1 , 20 , 3 ) . [ 1 , 4 , 7 , 10 , 13 , 16 , 19 ] &gt; lists : seq ( 1 , 0 , 1 ) . [ ] &gt; lists : seq ( 10 , 6 , 4 ) . [ ] &gt; lists : seq ( 1 , 1 , 0 ) . [ 1 ]","ref":"lists.html#seq/2","title":"lists.seq/2","type":"function"},{"doc":"","ref":"lists.html#seq/3","title":"lists.seq/3","type":"function"},{"doc":"Returns a list containing the sorted elements of List1 .","ref":"lists.html#sort/1","title":"lists.sort/1","type":"function"},{"doc":"Returns a list containing the sorted elements of List1 , according to the ordering function Fun . Fun(A, B) is to return true if A compares less than or equal to B in the ordering, otherwise false .","ref":"lists.html#sort/2","title":"lists.sort/2","type":"function"},{"doc":"Splits List1 into List2 and List3 . List2 contains the first N elements and List3 the remaining elements (the N th tail).","ref":"lists.html#split/2","title":"lists.split/2","type":"function"},{"doc":"Partitions List into two lists according to Pred . splitwith/2 behaves as if it is defined as follows: splitwith(Pred, List) -&gt; {takewhile(Pred, List), dropwhile(Pred, List)}. Examples: &gt; lists : splitwith ( fun ( A ) -&gt; A rem 2 == 1 end , [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] ) . { [ 1 ] , [ 2 , 3 , 4 , 5 , 6 , 7 ] } &gt; lists : splitwith ( fun ( A ) -&gt; is_atom ( A ) end , [ a , b , 1 , c , d , 2 , 3 , 4 , e ] ) . { [ a , b ] , [ 1 , c , d , 2 , 3 , 4 , e ] } The Pred function must return a boolean. For a different way to partition a list, see partition/2 .","ref":"lists.html#splitwith/2","title":"lists.splitwith/2","type":"function"},{"doc":"Returns the sublist of List1 starting at position 1 and with (maximum) Len elements. It is not an error for Len to exceed the length of the list, in that case the whole list is returned.","ref":"lists.html#sublist/2","title":"lists.sublist/2","type":"function"},{"doc":"Returns the sublist of List1 starting at Start and with (maximum) Len elements. It is not an error for Start+Len to exceed the length of the list. Examples: &gt; lists : sublist ( [ 1 , 2 , 3 , 4 ] , 2 , 2 ) . [ 2 , 3 ] &gt; lists : sublist ( [ 1 , 2 , 3 , 4 ] , 2 , 5 ) . [ 2 , 3 , 4 ] &gt; lists : sublist ( [ 1 , 2 , 3 , 4 ] , 5 , 2 ) . [ ]","ref":"lists.html#sublist/3","title":"lists.sublist/3","type":"function"},{"doc":"Returns a new list List3 that is a copy of List1 , subjected to the following procedure: for each element in List2 , its first occurrence in List1 is deleted. Example: &gt; lists : subtract ( &quot;123212&quot; , &quot;212&quot; ) . &quot;312&quot; . lists:subtract(A, B) is equivalent to A -- B .","ref":"lists.html#subtract/2","title":"lists.subtract/2","type":"function"},{"doc":"Returns true if List1 is a suffix of List2 , otherwise false .","ref":"lists.html#suffix/2","title":"lists.suffix/2","type":"function"},{"doc":"Returns the sum of the elements in List .","ref":"lists.html#sum/1","title":"lists.sum/1","type":"function"},{"doc":"Takes elements Elem from List1 while Pred(Elem) returns true , that is, the function returns the longest prefix of the list for which all elements satisfy the predicate. The Pred function must return a boolean.","ref":"lists.html#takewhile/2","title":"lists.takewhile/2","type":"function"},{"doc":"Returns the sorted list formed by merging TupleList1 and TupleList2 . The merge is performed on the N th element of each tuple. Both TupleList1 and TupleList2 must be key-sorted without duplicates before evaluating this function. When two tuples compare equal, the tuple from TupleList1 is picked and the one from TupleList2 is deleted.","ref":"lists.html#ukeymerge/3","title":"lists.ukeymerge/3","type":"function"},{"doc":"Returns a list containing the sorted elements of list TupleList1 where all except the first tuple of the tuples comparing equal have been deleted. Sorting is performed on the N th element of the tuples.","ref":"lists.html#ukeysort/2","title":"lists.ukeysort/2","type":"function"},{"doc":"Returns the sorted list formed by merging all the sublists of ListOfLists . All sublists must be sorted and contain no duplicates before evaluating this function. When two elements compare equal, the element from the sublist with the lowest position in ListOfLists is picked and the other is deleted.","ref":"lists.html#umerge/1","title":"lists.umerge/1","type":"function"},{"doc":"Returns the sorted list formed by merging List1 and List2 . Both List1 and List2 must be sorted and contain no duplicates before evaluating this function. When two elements compare equal, the element from List1 is picked and the one from List2 is deleted.","ref":"lists.html#umerge/2","title":"lists.umerge/2","type":"function"},{"doc":"Returns the sorted list formed by merging List1 and List2 . Both List1 and List2 must be sorted according to the ordering function Fun and contain no duplicates before evaluating this function. Fun(A, B) is to return true if A compares less than or equal to B in the ordering, otherwise false . When two elements compare equal, the element from List1 is picked and the one from List2 is deleted.","ref":"lists.html#umerge/3","title":"lists.umerge/3","type":"function"},{"doc":"Returns the sorted list formed by merging List1 , List2 , and List3 . All of List1 , List2 , and List3 must be sorted and contain no duplicates before evaluating this function. When two elements compare equal, the element from List1 is picked if there is such an element, otherwise the element from List2 is picked, and the other is deleted.","ref":"lists.html#umerge3/3","title":"lists.umerge3/3","type":"function"},{"doc":"&quot;Unzips&quot; a list of two-tuples into two lists, where the first list contains the first element of each tuple, and the second list contains the second element of each tuple.","ref":"lists.html#unzip/1","title":"lists.unzip/1","type":"function"},{"doc":"&quot;Unzips&quot; a list of three-tuples into three lists, where the first list contains the first element of each tuple, the second list contains the second element of each tuple, and the third list contains the third element of each tuple.","ref":"lists.html#unzip3/1","title":"lists.unzip3/1","type":"function"},{"doc":"Returns a list containing the sorted elements of List1 where all except the first element of the elements comparing equal have been deleted.","ref":"lists.html#usort/1","title":"lists.usort/1","type":"function"},{"doc":"Returns a list containing the sorted elements of List1 where all except the first element of the elements comparing equal according to the ordering function Fun have been deleted. Fun(A, B) is to return true if A compares less than or equal to B in the ordering, otherwise false .","ref":"lists.html#usort/2","title":"lists.usort/2","type":"function"},{"doc":"&quot;Zips&quot; two lists of equal length into one list of two-tuples, where the first element of each tuple is taken from the first list and the second element is taken from the corresponding element in the second list.","ref":"lists.html#zip/2","title":"lists.zip/2","type":"function"},{"doc":"&quot;Zips&quot; three lists of equal length into one list of three-tuples, where the first element of each tuple is taken from the first list, the second element is taken from the corresponding element in the second list, and the third element is taken from the corresponding element in the third list.","ref":"lists.html#zip3/3","title":"lists.zip3/3","type":"function"},{"doc":"Combines the elements of two lists of equal length into one list. For each pair X, Y of list elements from the two lists, the element in the result list is Combine(X, Y) . zipwith(fun(X, Y) -&gt; {X,Y} end, List1, List2) is equivalent to zip(List1, List2) . Example: &gt; lists : zipwith ( fun ( X , Y ) -&gt; X + Y end , [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ) . [ 5 , 7 , 9 ]","ref":"lists.html#zipwith/3","title":"lists.zipwith/3","type":"function"},{"doc":"Combines the elements of three lists of equal length into one list. For each triple X, Y, Z of list elements from the three lists, the element in the result list is Combine(X, Y, Z) . zipwith3(fun(X, Y, Z) -&gt; {X,Y,Z} end, List1, List2, List3) is equivalent to zip3(List1, List2, List3) . Examples: &gt; lists : zipwith3 ( fun ( X , Y , Z ) -&gt; X + Y + Z end , [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ) . [ 12 , 15 , 18 ] &gt; lists : zipwith3 ( fun ( X , Y , Z ) -&gt; [ X , Y , Z ] end , [ a , b , c ] , [ x , y , z ] , [ 1 , 2 , 3 ] ) . [ [ a , x , 1 ] , [ b , y , 2 ] , [ c , z , 3 ] ]","ref":"lists.html#zipwith3/4","title":"lists.zipwith3/4","type":"function"},{"doc":"This module is a gen_event handler module that can be installed in any gen_event process. It logs onto disk all events that are sent to an event manager. Each event is written as a binary, which makes the logging very fast. However, a tool such as the Report Browser ( rb(3) ) must be used to read the files. The events are written to multiple files. When all files have been used, the first one is reused and overwritten. The directory location, the number of files, and the size of each file are configurable. The directory will include one file called index , and report files 1, 2, ... . See Also gen_event(3) , rb(3)","ref":"log_mf_h.html","title":"log_mf_h","type":"module"},{"doc":"Initiates the event handler. Returns Args , which is to be used in a call to gen_event:add_handler(EventMgr, log_mf_h, Args) . Dir specifies which directory to use for the log files. MaxBytes specifies the size of each individual file. MaxFiles specifies how many files are used. Pred is a predicate function used to filter the events. If no predicate function is specified, all events are logged.","ref":"log_mf_h.html#init/3","title":"log_mf_h.init/3","type":"function"},{"doc":"","ref":"log_mf_h.html#init/4","title":"log_mf_h.init/4","type":"function"},{"doc":"Term to be sent to gen_event:add_handler/3 .","ref":"log_mf_h.html#t:args/0","title":"log_mf_h.args/0","type":"opaque"},{"doc":"This module contains functions for maps processing. The Efficiency Guide contains a chapter that describes how to use maps efficiently.","ref":"maps.html","title":"maps","type":"module"},{"doc":"Returns a map Map for which predicate Pred holds true in MapOrIter . The call fails with a {badmap,Map} exception if MapOrIter is not a map or valid iterator, or with badarg if Pred is not a function of arity 2. Example: &gt; M = \#{a =&gt; 2, b =&gt; 3, c=&gt; 4, &quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 4}, Pred = fun(K,V) -&gt; is_atom(K) andalso (V rem 2) =:= 0 end, maps:filter(Pred,M). \#{a =&gt; 2,c =&gt; 4}","ref":"maps.html#filter/2","title":"maps.filter/2","type":"function"},{"doc":"Returns a map Map that is the result of calling Fun(Key, Value1) for every Key to value Value1 association in MapOrIter in any order. If Fun(Key, Value1) returns true , the association is copied to the result map. If it returns false , the association is not copied. If it returns {true, NewValue} , the value for Key is replaced with NewValue at this position is replaced in the result map. The call fails with a {badmap,Map} exception if MapOrIter is not a map or valid iterator, or with badarg if Fun is not a function of arity 3. Example: &gt; Fun = fun(K,V) when is_atom(K) -&gt; {true, V*2}; (_,V) -&gt; (V rem 2) =:= 0 end, Map = \#{k1 =&gt; 1, &quot;k2&quot; =&gt; 2, &quot;k3&quot; =&gt; 3}, maps:filtermap(Fun,Map). \#{k1 =&gt; 2,&quot;k2&quot; =&gt; 2}","ref":"maps.html#filtermap/2","title":"maps.filtermap/2","type":"function"},{"doc":"Returns a tuple {ok, Value} , where Value is the value associated with Key , or error if no value is associated with Key in Map . The call fails with a {badmap,Map} exception if Map is not a map. Example: &gt; Map = \#{&quot;hi&quot; =&gt; 42}, Key = &quot;hi&quot;, maps:find(Key,Map). {ok,42}","ref":"maps.html#find/2","title":"maps.find/2","type":"function"},{"doc":"Calls F(Key, Value, AccIn) for every Key to value Value association in MapOrIter in any order. Function fun F/3 must return a new accumulator, which is passed to the next successive call. This function returns the final value of the accumulator. The initial accumulator value Init is returned if the map is empty. The call fails with a {badmap,Map} exception if MapOrIter is not a map or valid iterator, or with badarg if Fun is not a function of arity 3. Example: &gt; Fun = fun(K,V,AccIn) when is_list(K) -&gt; AccIn + V end, Map = \#{&quot;k1&quot; =&gt; 1, &quot;k2&quot; =&gt; 2, &quot;k3&quot; =&gt; 3}, maps:fold(Fun,0,Map). 6","ref":"maps.html#fold/3","title":"maps.fold/3","type":"function"},{"doc":"Calls fun F(Key, Value) for every Key to value Value association in MapOrIter in any order. The call fails with a {badmap,Map} exception if MapOrIter is not a map or valid iterator, or with badarg if Fun is not a function of arity 2.","ref":"maps.html#foreach/2","title":"maps.foreach/2","type":"function"},{"doc":"Takes a list of keys and a value and builds a map where all keys point to the same value. The key can be in any order, and keys and value can be of any term. Example: &gt; Keys = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], maps:from_keys(Keys, ok). \#{&quot;a&quot; =&gt; ok,&quot;b&quot; =&gt; ok,&quot;c&quot; =&gt; ok}","ref":"maps.html#from_keys/2","title":"maps.from_keys/2","type":"function"},{"doc":"Takes a list of key-value tuples elements and builds a map. The associations can be in any order, and both keys and values in the association can be of any term. If the same key appears more than once, the latter (right-most) value is used and the previous values are ignored. Example: &gt; List = [{&quot;a&quot;,ignored},{1337,&quot;value two&quot;},{42,value_three},{&quot;a&quot;,1}], maps:from_list(List). \#{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1}","ref":"maps.html#from_list/1","title":"maps.from_list/1","type":"function"},{"doc":"Returns value Value associated with Key if Map contains Key . The call fails with a {badmap,Map} exception if Map is not a map, or with a {badkey,Key} exception if no value is associated with Key . Example: &gt; Key = 1337, Map = \#{42 =&gt; value_two,1337 =&gt; &quot;value one&quot;,&quot;a&quot; =&gt; 1}, maps:get(Key,Map). &quot;value one&quot;","ref":"maps.html#get/2","title":"maps.get/2","type":"function"},{"doc":"Returns value Value associated with Key if Map contains Key . If no value is associated with Key , Default is returned. The call fails with a {badmap,Map} exception if Map is not a map. Example: &gt; Map = \#{ key1 =&gt; val1, key2 =&gt; val2 }. \#{key1 =&gt; val1,key2 =&gt; val2} &gt; maps:get(key1, Map, &quot;Default value&quot;). val1 &gt; maps:get(key3, Map, &quot;Default value&quot;). &quot;Default value&quot;","ref":"maps.html#get/3","title":"maps.get/3","type":"function"},{"doc":"Intersects two maps into a single map Map3 . If a key exists in both maps, the value in Map1 is superseded by the value in Map2 . The call fails with a {badmap,Map} exception if Map1 or Map2 is not a map. Example: &gt; Map1 = \#{a =&gt; &quot;value_one&quot;, b =&gt; &quot;value_two&quot;}, Map2 = \#{a =&gt; 1, c =&gt; 2}, maps:intersect(Map1,Map2). \#{a =&gt; 1}","ref":"maps.html#intersect/2","title":"maps.intersect/2","type":"function"},{"doc":"Intersects two maps into a single map Map3 . If a key exists in both maps, the value in Map1 is combined with the value in Map2 by the Combiner fun. When Combiner is applied the key that exists in both maps is the first parameter, the value from Map1 is the second parameter, and the value from Map2 is the third parameter. The call fails with a {badmap,Map} exception if Map1 or Map2 is not a map. The call fails with a badarg exception if Combiner is not a fun that takes three arguments. Example: &gt; Map1 = \#{a =&gt; &quot;value_one&quot;, b =&gt; &quot;value_two&quot;}, Map2 = \#{a =&gt; 1, c =&gt; 2}, maps:intersect_with(fun(_Key, Value1, Value2) -&gt; {Value1, Value2} end, Map1, Map2). \#{a =&gt; {&quot;value_one&quot;,1}}","ref":"maps.html#intersect_with/3","title":"maps.intersect_with/3","type":"function"},{"doc":"Returns true if map Map contains Key and returns false if it does not contain the Key . The call fails with a {badmap,Map} exception if Map is not a map. Example: &gt; Map = \#{&quot;42&quot; =&gt; value}. \#{&quot;42&quot; =&gt; value} &gt; maps:is_key(&quot;42&quot;,Map). true &gt; maps:is_key(value,Map). false","ref":"maps.html#is_key/2","title":"maps.is_key/2","type":"function"},{"doc":"Returns a map iterator Iterator that can be used by maps:next/1 to traverse the key-value associations in a map. When iterating over a map, the memory usage is guaranteed to be bounded no matter the size of the map. The call fails with a {badmap,Map} exception if Map is not a map. Example: &gt; M = \#{ a =&gt; 1, b =&gt; 2 }. \#{a =&gt; 1,b =&gt; 2} &gt; I = maps:iterator(M), ok. ok &gt; {K1, V1, I2} = maps:next(I), {K1, V1}. {a,1} &gt; {K2, V2, I3} = maps:next(I2),{K2, V2}. {b,2} &gt; maps:next(I3). none","ref":"maps.html#iterator/1","title":"maps.iterator/1","type":"function"},{"doc":"Returns a complete list of keys, in any order, which resides within Map . The call fails with a {badmap,Map} exception if Map is not a map. Example: &gt; Map = \#{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1}, maps:keys(Map). [42,1337,&quot;a&quot;]","ref":"maps.html#keys/1","title":"maps.keys/1","type":"function"},{"doc":"Produces a new map Map by calling function fun F(Key, Value1) for every Key to value Value1 association in MapOrIter in any order. Function fun Fun/2 must return value Value2 to be associated with key Key for the new map Map . The call fails with a {badmap,Map} exception if MapOrIter is not a map or valid iterator, or with badarg if Fun is not a function of arity 2. Example: &gt; Fun = fun(K,V1) when is_list(K) -&gt; V1*2 end, Map = \#{&quot;k1&quot; =&gt; 1, &quot;k2&quot; =&gt; 2, &quot;k3&quot; =&gt; 3}, maps:map(Fun,Map). \#{&quot;k1&quot; =&gt; 2,&quot;k2&quot; =&gt; 4,&quot;k3&quot; =&gt; 6}","ref":"maps.html#map/2","title":"maps.map/2","type":"function"},{"doc":"Merges two maps into a single map Map3 . If two keys exist in both maps, the value in Map1 is superseded by the value in Map2 . The call fails with a {badmap,Map} exception if Map1 or Map2 is not a map. Example: &gt; Map1 = \#{a =&gt; &quot;value_one&quot;, b =&gt; &quot;value_two&quot;}, Map2 = \#{a =&gt; 1, c =&gt; 2}, maps:merge(Map1,Map2). \#{a =&gt; 1,b =&gt; &quot;value_two&quot;,c =&gt; 2}","ref":"maps.html#merge/2","title":"maps.merge/2","type":"function"},{"doc":"Merges two maps into a single map Map3 . If a key exists in both maps, the value in Map1 is combined with the value in Map2 by the Combiner fun. When Combiner is applied the key that exists in both maps is the first parameter, the value from Map1 is the second parameter, and the value from Map2 is the third parameter. The call fails with a {badmap,Map} exception if Map1 or Map2 is not a map. The call fails with a badarg exception if Combiner is not a fun that takes three arguments. Example: &gt; Map1 = \#{a =&gt; &quot;value_one&quot;, b =&gt; &quot;value_two&quot;}, Map2 = \#{a =&gt; 1, c =&gt; 2}, maps:merge_with(fun(_Key, Value1, Value2) -&gt; {Value1, Value2} end, Map1, Map2). \#{a =&gt; {&quot;value_one&quot;,1},b =&gt; &quot;value_two&quot;,c =&gt; 2}","ref":"maps.html#merge_with/3","title":"maps.merge_with/3","type":"function"},{"doc":"Returns a new empty map. Example: &gt; maps:new(). \#{}","ref":"maps.html#new/0","title":"maps.new/0","type":"function"},{"doc":"Returns the next key-value association in Iterator and a new iterator for the remaining associations in the iterator. If there are no more associations in the iterator, none is returned. Example: &gt; Map = \#{a =&gt; 1, b =&gt; 2, c =&gt; 3}. \#{a =&gt; 1,b =&gt; 2,c =&gt; 3} &gt; I = maps:iterator(Map), ok. ok &gt; {K1, V1, I1} = maps:next(I), {K1, V1}. {a,1} &gt; {K2, V2, I2} = maps:next(I1), {K2, V2}. {b,2} &gt; {K3, V3, I3} = maps:next(I2), {K3, V3}. {c,3} &gt; maps:next(I3). none","ref":"maps.html#next/1","title":"maps.next/1","type":"function"},{"doc":"Associates Key with value Value and inserts the association into map Map2 . If key Key already exists in map Map1 , the old associated value is replaced by value Value . The function returns a new map Map2 containing the new association and the old associations in Map1 . The call fails with a {badmap,Map} exception if Map1 is not a map. Example: &gt; Map = \#{&quot;a&quot; =&gt; 1}. \#{&quot;a&quot; =&gt; 1} &gt; maps:put(&quot;a&quot;, 42, Map). \#{&quot;a&quot; =&gt; 42} &gt; maps:put(&quot;b&quot;, 1337, Map). \#{&quot;a&quot; =&gt; 1,&quot;b&quot; =&gt; 1337}","ref":"maps.html#put/3","title":"maps.put/3","type":"function"},{"doc":"Removes the Key , if it exists, and its associated value from Map1 and returns a new map Map2 without key Key . The call fails with a {badmap,Map} exception if Map1 is not a map. Example: &gt; Map = \#{&quot;a&quot; =&gt; 1}. \#{&quot;a&quot; =&gt; 1} &gt; maps:remove(&quot;a&quot;,Map). \#{} &gt; maps:remove(&quot;b&quot;,Map). \#{&quot;a&quot; =&gt; 1}","ref":"maps.html#remove/2","title":"maps.remove/2","type":"function"},{"doc":"Returns the number of key-value associations in Map . This operation occurs in constant time. Example: &gt; Map = \#{42 =&gt; value_two,1337 =&gt; &quot;value one&quot;,&quot;a&quot; =&gt; 1}, maps:size(Map). 3","ref":"maps.html#size/1","title":"maps.size/1","type":"function"},{"doc":"The function removes the Key , if it exists, and its associated value from Map1 and returns a tuple with the removed Value and the new map Map2 without key Key . If the key does not exist error is returned. The call will fail with a {badmap,Map} exception if Map1 is not a map. Example: &gt; Map = \#{&quot;a&quot; =&gt; &quot;hello&quot;, &quot;b&quot; =&gt; &quot;world&quot;}. \#{&quot;a&quot; =&gt; &quot;hello&quot;, &quot;b&quot; =&gt; &quot;world&quot;} &gt; maps:take(&quot;a&quot;,Map). {&quot;hello&quot;,\#{&quot;b&quot; =&gt; &quot;world&quot;}} &gt; maps:take(&quot;does not exist&quot;,Map). error","ref":"maps.html#take/2","title":"maps.take/2","type":"function"},{"doc":"Returns a list of pairs representing the key-value associations of Map , where the pairs [{K1,V1}, ..., {Kn,Vn}] are returned in arbitrary order. The call fails with a {badmap,Map} exception if Map is not a map. Example: &gt; Map = \#{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1}, maps:to_list(Map). [{42,value_three},{1337,&quot;value two&quot;},{&quot;a&quot;,1}]","ref":"maps.html#to_list/1","title":"maps.to_list/1","type":"function"},{"doc":"If Key exists in Map1 , the old associated value is replaced by value Value . The function returns a new map Map2 containing the new associated value. The call fails with a {badmap,Map} exception if Map1 is not a map, or with a {badkey,Key} exception if no value is associated with Key . Example: &gt; Map = \#{&quot;a&quot; =&gt; 1}. \#{&quot;a&quot; =&gt; 1} &gt; maps:update(&quot;a&quot;, 42, Map). \#{&quot;a&quot; =&gt; 42}","ref":"maps.html#update/3","title":"maps.update/3","type":"function"},{"doc":"Update a value in a Map1 associated with Key by calling Fun on the old value to get a new value. An exception {badkey,Key} is generated if Key is not present in the map. Example: &gt; Map = \#{&quot;counter&quot; =&gt; 1}, Fun = fun(V) -&gt; V + 1 end, maps:update_with(&quot;counter&quot;,Fun,Map). \#{&quot;counter&quot; =&gt; 2}","ref":"maps.html#update_with/3","title":"maps.update_with/3","type":"function"},{"doc":"Update a value in a Map1 associated with Key by calling Fun on the old value to get a new value. If Key is not present in Map1 then Init will be associated with Key . Example: &gt; Map = \#{&quot;counter&quot; =&gt; 1}, Fun = fun(V) -&gt; V + 1 end, maps:update_with(&quot;new counter&quot;,Fun,42,Map). \#{&quot;counter&quot; =&gt; 1,&quot;new counter&quot; =&gt; 42}","ref":"maps.html#update_with/4","title":"maps.update_with/4","type":"function"},{"doc":"Returns a complete list of values, in arbitrary order, contained in map Map . The call fails with a {badmap,Map} exception if Map is not a map. Example: &gt; Map = \#{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1}, maps:values(Map). [value_three,&quot;value two&quot;,1]","ref":"maps.html#values/1","title":"maps.values/1","type":"function"},{"doc":"Returns a new map Map2 with the keys K1 through Kn and their associated values from map Map1 . Any key in Ks that does not exist in Map1 is ignored. Example: &gt; Map = \#{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1}, Ks = [&quot;a&quot;,42,&quot;other key&quot;], maps:with(Ks,Map). \#{42 =&gt; value_three,&quot;a&quot; =&gt; 1}","ref":"maps.html#with/2","title":"maps.with/2","type":"function"},{"doc":"Returns a new map Map2 without keys K1 through Kn and their associated values from map Map1 . Any key in Ks that does not exist in Map1 is ignored Example: &gt; Map = \#{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1}, Ks = [&quot;a&quot;,42,&quot;other key&quot;], maps:without(Ks,Map). \#{1337 =&gt; &quot;value two&quot;}","ref":"maps.html#without/2","title":"maps.without/2","type":"function"},{"doc":"","ref":"maps.html#t:iterator/0","title":"maps.iterator/0","type":"type"},{"doc":"An iterator representing the associations in a map with keys of type Key and values of type Value . Created using maps:iterator/1 . Consumed by maps:next/1 , maps:filter/2 , maps:fold/3 and maps:map/2 .","ref":"maps.html#t:iterator/2","title":"maps.iterator/2","type":"opaque"},{"doc":"This module provides an interface to a number of mathematical functions. Not all functions are provided on all platforms. In particular, the erf/1 and erfc/1 functions are not provided on Windows. Limitations As these are the C library, the same limitations apply.","ref":"math.html","title":"math","type":"module"},{"doc":"A collection of mathematical functions that return floats. Arguments are numbers.","ref":"math.html#acos/1","title":"math.acos/1","type":"function"},{"doc":"","ref":"math.html#acosh/1","title":"math.acosh/1","type":"function"},{"doc":"","ref":"math.html#asin/1","title":"math.asin/1","type":"function"},{"doc":"","ref":"math.html#asinh/1","title":"math.asinh/1","type":"function"},{"doc":"","ref":"math.html#atan/1","title":"math.atan/1","type":"function"},{"doc":"","ref":"math.html#atan2/2","title":"math.atan2/2","type":"function"},{"doc":"","ref":"math.html#atanh/1","title":"math.atanh/1","type":"function"},{"doc":"","ref":"math.html#ceil/1","title":"math.ceil/1","type":"function"},{"doc":"","ref":"math.html#cos/1","title":"math.cos/1","type":"function"},{"doc":"","ref":"math.html#cosh/1","title":"math.cosh/1","type":"function"},{"doc":"Returns the error function of X , where: erf ( X ) = 2 / sqrt ( pi ) * integral from 0 to X of exp ( - t * t ) dt .","ref":"math.html#erf/1","title":"math.erf/1","type":"function"},{"doc":"erfc(X) returns 1.0 - erf(X) , computed by methods that avoid cancellation for large X .","ref":"math.html#erfc/1","title":"math.erfc/1","type":"function"},{"doc":"","ref":"math.html#exp/1","title":"math.exp/1","type":"function"},{"doc":"","ref":"math.html#floor/1","title":"math.floor/1","type":"function"},{"doc":"","ref":"math.html#fmod/2","title":"math.fmod/2","type":"function"},{"doc":"","ref":"math.html#log/1","title":"math.log/1","type":"function"},{"doc":"","ref":"math.html#log10/1","title":"math.log10/1","type":"function"},{"doc":"","ref":"math.html#log2/1","title":"math.log2/1","type":"function"},{"doc":"A useful number.","ref":"math.html#pi/0","title":"math.pi/0","type":"function"},{"doc":"","ref":"math.html#pow/2","title":"math.pow/2","type":"function"},{"doc":"","ref":"math.html#sin/1","title":"math.sin/1","type":"function"},{"doc":"","ref":"math.html#sinh/1","title":"math.sinh/1","type":"function"},{"doc":"","ref":"math.html#sqrt/1","title":"math.sqrt/1","type":"function"},{"doc":"","ref":"math.html#tan/1","title":"math.tan/1","type":"function"},{"doc":"","ref":"math.html#tanh/1","title":"math.tanh/1","type":"function"},{"doc":"This module provides the parse transformation that makes calls to ets and dbg:fun2ms/1 translate into literal match specifications. It also provides the back end for the same functions when called from the Erlang shell. The translation from funs to match specifications is accessed through the two &quot;pseudo functions&quot; ets:fun2ms/1 and dbg:fun2ms/1 . As everyone trying to use ets:select/2 or dbg seems to end up reading this manual page, this description is an introduction to the concept of match specifications. Read the whole manual page if it is the first time you are using the transformations. Match specifications are used more or less as filters. They resemble usual Erlang matching in a list comprehension or in a fun used with lists:foldl/3 , and so on. However, the syntax of pure match specifications is awkward, as they are made up purely by Erlang terms, and the language has no syntax to make the match specifications more readable. As the execution and structure of the match specifications are like that of a fun, it is more straightforward to write it using the familiar fun syntax and to have that translated into a match specification automatically. A real fun is clearly more powerful than the match specifications allow, but bearing the match specifications in mind, and what they can do, it is still more convenient to write it all as a fun. This module contains the code that translates the fun syntax into match specification terms. Example 1 Using ets:select/2 and a match specification, one can filter out rows of a table and construct a list of tuples containing relevant parts of the data in these rows. One can use ets:foldl/3 instead, but the ets:select/2 call is far more efficient. Without the translation provided by ms_transform , one must struggle with writing match specifications terms to accommodate this. Consider a simple table of employees: -record(emp, {empno, %Employee number as a string, the key surname, %Surname of the employee givenname, %Given name of employee dept, %Department, one of {dev,sales,prod,adm} empyear}). %Year the employee was employed We create the table using: ets:new(emp_tab, [{keypos,#emp.empno},named_table,ordered_set]). We fill the table with randomly chosen data: [{emp,&quot;011103&quot;,&quot;Black&quot;,&quot;Alfred&quot;,sales,2000}, {emp,&quot;041231&quot;,&quot;Doe&quot;,&quot;John&quot;,prod,2001}, {emp,&quot;052341&quot;,&quot;Smith&quot;,&quot;John&quot;,dev,1997}, {emp,&quot;076324&quot;,&quot;Smith&quot;,&quot;Ella&quot;,sales,1995}, {emp,&quot;122334&quot;,&quot;Weston&quot;,&quot;Anna&quot;,prod,2002}, {emp,&quot;535216&quot;,&quot;Chalker&quot;,&quot;Samuel&quot;,adm,1998}, {emp,&quot;789789&quot;,&quot;Harrysson&quot;,&quot;Joe&quot;,adm,1996}, {emp,&quot;963721&quot;,&quot;Scott&quot;,&quot;Juliana&quot;,dev,2003}, {emp,&quot;989891&quot;,&quot;Brown&quot;,&quot;Gabriel&quot;,prod,1999}] Assuming that we want the employee numbers of everyone in the sales department, there are several ways. ets:match/2 can be used: 1 &gt; ets : match ( emp_tab , { &#39;_&#39; , &#39;$1&#39; , &#39;_&#39; , &#39;_&#39; , sales , &#39;_&#39; } ) . [ [ &quot;011103&quot; ] , [ &quot;076324&quot; ] ] ets:match/2 uses a simpler type of match specification, but it is still unreadable, and one has little control over the returned result. It is always a list of lists. ets:foldl/3 or ets:foldr/3 can be used to avoid the nested lists: ets:foldr(fun(#emp{empno = E, dept = sales},Acc) -&gt; [E | Acc]; (_,Acc) -&gt; Acc end, [], emp_tab). The result is [&quot;011103&quot;,&quot;076324&quot;] . The fun is straightforward, so the only problem is that all the data from the table must be transferred from the table to the calling process for filtering. That is inefficient compared to the ets:match/2 call where the filtering can be done &quot;inside&quot; the emulator and only the result is transferred to the process. Consider a &quot;pure&quot; ets:select/2 call that does what ets:foldr does: ets:select(emp_tab, [{#emp{empno = '$1', dept = sales, _='_'},[],['$1']}]). Although the record syntax is used, it is still hard to read and even harder to write. The first element of the tuple, #emp{empno = '$1', dept = sales, _='_'} , tells what to match. Elements not matching this are not returned, as in the ets:match/2 example. The second element, the empty list, is a list of guard expressions, which we do not need. The third element is the list of expressions constructing the return value (in ETS this is almost always a list containing one single term). In our case '$1' is bound to the employee number in the head (first element of the tuple), and hence the employee number is returned. The result is [&quot;011103&quot;,&quot;076324&quot;] , as in the ets:foldr/3 example, but the result is retrieved much more efficiently in terms of execution speed and memory consumption. Using ets:fun2ms/1 , we can combine the ease of use of the ets:foldr/3 and the efficiency of the pure ets:select/2 example: -include_lib(&quot;stdlib/include/ms_transform.hrl&quot;). ets:select(emp_tab, ets:fun2ms( fun(#emp{empno = E, dept = sales}) -&gt; E end)). This example requires no special knowledge of match specifications to understand. The head of the fun matches what you want to filter out and the body returns what you want returned. As long as the fun can be kept within the limits of the match specifications, there is no need to transfer all table data to the process for filtering as in the ets:foldr/3 example. It is easier to read than the ets:foldr/3 example, as the select call in itself discards anything that does not match, while the fun of the ets:foldr/3 call needs to handle both the elements matching and the ones not matching. In the ets:fun2ms/1 example above, it is needed to include ms_transform.hrl in the source code, as this is what triggers the parse transformation of the ets:fun2ms/1 call to a valid match specification. This also implies that the transformation is done at compile time (except when called from the shell) and therefore takes no resources in runtime. That is, although you use the more intuitive fun syntax, it gets as efficient in runtime as writing match specifications by hand. Example 2 Assume that we want to get all the employee numbers of employees hired before year 2000. Using ets:match/2 is not an alternative here, as relational operators cannot be expressed there. Once again, ets:foldr/3 can do it (slowly, but correct): ets:foldr(fun(#emp{empno = E, empyear = Y},Acc) when Y &lt; 2000 -&gt; [E | Acc]; (_,Acc) -&gt; Acc end, [], emp_tab). The result is [&quot;052341&quot;,&quot;076324&quot;,&quot;535216&quot;,&quot;789789&quot;,&quot;989891&quot;] , as expected. The equivalent expression using a handwritten match specification would look like this: ets:select(emp_tab, [{#emp{empno = '$1', empyear = '$2', _='_'}, [{'&lt;', '$2', 2000}], ['$1']}]). This gives the same result. [{'&lt;', '$2', 2000}] is in the guard part and therefore discards anything that does not have an empyear (bound to '$2' in the head) less than 2000, as the guard in the foldr/3 example. We write it using ets:fun2ms/1 : -include_lib(&quot;stdlib/include/ms_transform.hrl&quot;). ets:select(emp_tab, ets:fun2ms( fun(#emp{empno = E, empyear = Y}) when Y &lt; 2000 -&gt; E end)). Example 3 Assume that we want the whole object matching instead of only one element. One alternative is to assign a variable to every part of the record and build it up once again in the body of the fun, but the following is easier: ets:select(emp_tab, ets:fun2ms( fun(Obj = #emp{empno = E, empyear = Y}) when Y &lt; 2000 -&gt; Obj end)). As in ordinary Erlang matching, you can bind a variable to the whole matched object using a &quot;match inside the match&quot;, that is, a = . Unfortunately in funs translated to match specifications, it is allowed only at the &quot;top-level&quot;, that is, matching the whole object arriving to be matched into a separate variable. If you are used to writing match specifications by hand, we mention that variable A is simply translated into '$_'. Alternatively, pseudo function object/0 also returns the whole matched object, see section Warnings and Restrictions . Example 4 This example concerns the body of the fun. Assume that all employee numbers beginning with zero ( 0 ) must be changed to begin with one ( 1 ) instead, and that we want to create the list [{&lt;Old empno&gt;,&lt;New empno&gt;}] : ets:select(emp_tab, ets:fun2ms( fun(#emp{empno = [$0 | Rest] }) -&gt; {[$0|Rest],[$1|Rest]} end)). This query hits the feature of partially bound keys in table type ordered_set , so that not the whole table needs to be searched, only the part containing keys beginning with 0 is looked into. Example 5 The fun can have many clauses. Assume that we want to do the following: If an employee started before 1997, return the tuple {inventory, &lt;employee number&gt;} . If an employee started 1997 or later, but before 2001, return {rookie, &lt;employee number&gt;} . For all other employees, return {newbie, &lt;employee number&gt;} , except for those named Smith as they would be affronted by anything other than the tag guru and that is also what is returned for their numbers: {guru, &lt;employee number&gt;} . This is accomplished as follows: ets:select(emp_tab, ets:fun2ms( fun(#emp{empno = E, surname = &quot;Smith&quot; }) -&gt; {guru,E}; (#emp{empno = E, empyear = Y}) when Y &lt; 1997 -&gt; {inventory, E}; (#emp{empno = E, empyear = Y}) when Y &gt; 2001 -&gt; {newbie, E}; (#emp{empno = E, empyear = Y}) -&gt; % 1997 -- 2001 {rookie, E} end)). The result is as follows: [{rookie,&quot;011103&quot;}, {rookie,&quot;041231&quot;}, {guru,&quot;052341&quot;}, {guru,&quot;076324&quot;}, {newbie,&quot;122334&quot;}, {rookie,&quot;535216&quot;}, {inventory,&quot;789789&quot;}, {newbie,&quot;963721&quot;}, {rookie,&quot;989891&quot;}] Useful BIFs What more can you do? A simple answer is: see the documentation of match specifications in ERTS User's Guide. However, the following is a brief overview of the most useful &quot;built-in functions&quot; that you can use when the fun is to be translated into a match specification by ets:fun2ms/1 . It is not possible to call other functions than those allowed in match specifications. No &quot;usual&quot; Erlang code can be executed by the fun that is translated by ets:fun2ms/1 . The fun is limited exactly to the power of the match specifications, which is unfortunate, but the price one must pay for the execution speed of ets:select/2 compared to ets:foldl/foldr . The head of the fun is a head matching (or mismatching) one parameter, one object of the table we select from. The object is always a single variable (can be _ ) or a tuple, as ETS, Dets, and Mnesia tables include that. The match specification returned by ets:fun2ms/1 can be used with dets:select/2 and mnesia:select/2 , and with ets:select/2 . The use of = in the head is allowed (and encouraged) at the top-level. The guard section can contain any guard expression of Erlang. The following is a list of BIFs and expressions: Type tests: is_atom , is_float , is_integer , is_list , is_number , is_pid , is_port , is_reference , is_tuple , is_binary , is_function , is_record Boolean operators: not , and , or , andalso , orelse Relational operators: &gt;, &gt;=, &lt;, =&lt;, =:=, ==, =/=, /= Arithmetics: + , - , * , div , rem Bitwise operators: band , bor , bxor , bnot , bsl , bsr The guard BIFs: abs , element , hd , length , node , round , size , byte_size , tl , trunc , binary_part , self Contrary to the fact with &quot;handwritten&quot; match specifications, the is_record guard works as in ordinary Erlang code. Semicolons ( ; ) in guards are allowed, the result is (as expected) one &quot;match specification clause&quot; for each semicolon-separated part of the guard. The semantics is identical to the Erlang semantics. The body of the fun is used to construct the resulting value. When selecting from tables, one usually construct a suiting term here, using ordinary Erlang term construction, like tuple parentheses, list brackets, and variables matched out in the head, possibly with the occasional constant. Whatever expressions are allowed in guards are also allowed here, but no special functions exist except object and bindings (see further down), which returns the whole matched object and all known variable bindings, respectively. The dbg variants of match specifications have an imperative approach to the match specification body, the ETS dialect has not. The fun body for ets:fun2ms/1 returns the result without side effects. As matching ( = ) in the body of the match specifications is not allowed (for performance reasons) the only thing left, more or less, is term construction. Example with dbg This section describes the slightly different match specifications translated by dbg:fun2ms/1 . The same reasons for using the parse transformation apply to dbg , maybe even more, as filtering using Erlang code is not a good idea when tracing (except afterwards, if you trace to file). The concept is similar to that of ets:fun2ms/1 except that you usually use it directly from the shell (which can also be done with ets:fun2ms/1 ). The following is an example module to trace on: -module(toy). -export([start/1, store/2, retrieve/1]). start(Args) -&gt; toy_table = ets:new(toy_table, Args). store(Key, Value) -&gt; ets:insert(toy_table, {Key,Value}). retrieve(Key) -&gt; [{Key, Value}] = ets:lookup(toy_table, Key), Value. During model testing, the first test results in {badmatch,16} in {toy,start,1} , why? We suspect the ets:new/2 call, as we match hard on the return value, but want only the particular new/2 call with toy_table as first parameter. So we start a default tracer on the node: 1 &gt; dbg : tracer ( ) . { ok , &lt; 0.88 . 0 &gt; } We turn on call tracing for all processes, we want to make a pretty restrictive trace pattern, so there is no need to call trace only a few processes (usually it is not): 2 &gt; dbg : p ( all , call ) . { ok , [ { matched , nonode @ nohost , 25 } ] } We specify the filter, we want to view calls that resemble ets:new(toy_table, &lt;something&gt;) : 3 &gt; dbg : tp ( ets , new , dbg : fun2ms ( fun ( [ toy_table , _ ] ) -&gt; true end ) ) . { ok , [ { matched , nonode @ nohost , 1 } , { saved , 1 } ] } As can be seen, the fun used with dbg:fun2ms/1 takes a single list as parameter instead of a single tuple. The list matches a list of the parameters to the traced function. A single variable can also be used. The body of the fun expresses, in a more imperative way, actions to be taken if the fun head (and the guards) matches. true is returned here, only because the body of a fun cannot be empty. The return value is discarded. The following trace output is received during test: (&lt;0.86.0&gt;) call ets:new(toy_table, [ordered_set]) Assume that we have not found the problem yet, and want to see what ets:new/2 returns. We use a slightly different trace pattern: 4 &gt; dbg : tp ( ets , new , dbg : fun2ms ( fun ( [ toy_table , _ ] ) -&gt; return_trace ( ) end ) ) . The following trace output is received during test: (&lt;0.86.0&gt;) call ets:new(toy_table,[ordered_set]) (&lt;0.86.0&gt;) returned from ets:new/2 -&gt; 24 The call to return_trace results in a trace message when the function returns. It applies only to the specific function call triggering the match specification (and matching the head/guards of the match specification). This is by far the most common call in the body of a dbg match specification. The test now fails with {badmatch,24} because the atom toy_table does not match the number returned for an unnamed table. So, the problem is found, the table is to be named, and the arguments supplied by the test program do not include named_table . We rewrite the start function: start(Args) -&gt; toy_table = ets:new(toy_table, [named_table|Args]). With the same tracing turned on, the following trace output is received: (&lt;0.86.0&gt;) call ets:new(toy_table,[named_table,ordered_set]) (&lt;0.86.0&gt;) returned from ets:new/2 -&gt; toy_table Assume that the module now passes all testing and goes into the system. After a while, it is found that table toy_table grows while the system is running and that there are many elements with atoms as keys. We expected only integer keys and so does the rest of the system, but clearly not the entire system. We turn on call tracing and try to see calls to the module with an atom as the key: 1 &gt; dbg : tracer ( ) . { ok , &lt; 0.88 . 0 &gt; } 2 &gt; dbg : p ( all , call ) . { ok , [ { matched , nonode @ nohost , 25 } ] } 3 &gt; dbg : tpl ( toy , store , dbg : fun2ms ( fun ( [ A , _ ] ) when is_atom ( A ) -&gt; true end ) ) . { ok , [ { matched , nonode @ nohost , 1 } , { saved , 1 } ] } We use dbg:tpl/3 to ensure to catch local calls (assume that the module has grown since the smaller version and we are unsure if this inserting of atoms is not done locally). When in doubt, always use local call tracing. Assume that nothing happens when tracing in this way. The function is never called with these parameters. We conclude that someone else (some other module) is doing it and realize that we must trace on ets:insert/2 and want to see the calling function. The calling function can be retrieved using the match specification function caller . To get it into the trace message, the match specification function message must be used. The filter call looks like this (looking for calls to ets:insert/2 ): 4 &gt; dbg : tpl ( ets , insert , dbg : fun2ms ( fun ( [ toy_table , { A , _ } ] ) when is_atom ( A ) -&gt; message ( caller ( ) ) end ) ) . { ok , [ { matched , nonode @ nohost , 1 } , { saved , 2 } ] } The caller is now displayed in the &quot;additional message&quot; part of the trace output, and the following is displayed after a while: (&lt;0.86.0&gt;) call ets:insert(toy_table,{garbage,can}) ({evil_mod,evil_fun,2}) You have realized that function evil_fun of the evil_mod module, with arity 2 , is causing all this trouble. This example illustrates the most used calls in match specifications for dbg . The other, more esoteric, calls are listed and explained in Match specifications in Erlang in ERTS User's Guide, as they are beyond the scope of this description. Warnings and Restrictions The following warnings and restrictions apply to the funs used in with ets:fun2ms/1 and dbg:fun2ms/1 . To use the pseudo functions triggering the translation, ensure to include the header file ms_transform.hrl in the source code. Failure to do so possibly results in runtime errors rather than compile time, as the expression can be valid as a plain Erlang program without translation. The fun must be literally constructed inside the parameter list to the pseudo functions. The fun cannot be bound to a variable first and then passed to ets:fun2ms/1 or dbg:fun2ms/1 . For example, ets:fun2ms(fun(A) -&gt; A end) works, but not F = fun(A) -&gt; A end, ets:fun2ms(F) . The latter results in a compile-time error if the header is included, otherwise a runtime error. Many restrictions apply to the fun that is translated into a match specification. To put it simple: you cannot use anything in the fun that you cannot use in a match specification. This means that, among others, the following restrictions apply to the fun itself: Functions written in Erlang cannot be called, neither can local functions, global functions, or real funs. Everything that is written as a function call is translated into a match specification call to a built-in function, so that the call is_list(X) is translated to {'is_list', '$1'} ( '$1' is only an example, the numbering can vary). If one tries to call a function that is not a match specification built-in, it causes an error. Variables occurring in the head of the fun are replaced by match specification variables in the order of occurrence, so that fragment fun({A,B,C}) is replaced by {'$1', '$2', '$3'} , and so on. Every occurrence of such a variable in the match specification is replaced by a match specification variable in the same way, so that the fun fun({A,B}) when is_atom(A) -&gt; B end is translated into [{{'$1','$2'},[{is_atom,'$1'}],['$2']}] . Variables that are not included in the head are imported from the environment and made into match specification const expressions. Example from the shell: 1 &gt; X = 25 . 25 2 &gt; ets : fun2ms ( fun ( { A , B } ) when A &gt; X -&gt; B end ) . [ { { &#39;$1&#39; , &#39;$2&#39; } , [ { &#39;&gt;&#39; , &#39;$1&#39; , { const , 25 } } ] , [ &#39;$2&#39; ] } ] Matching with = cannot be used in the body. It can only be used on the top-level in the head of the fun. Example from the shell again: 1 &gt; ets : fun2ms ( fun ( { A , [ B | C ] } = D ) when A &gt; B -&gt; D end ) . [ { { &#39;$1&#39; , [ &#39;$2&#39; | &#39;$3&#39; ] } , [ { &#39;&gt;&#39; , &#39;$1&#39; , &#39;$2&#39; } ] , [ &#39;$_&#39; ] } ] 2 &gt; ets : fun2ms ( fun ( { A , [ B | C ] = D } ) when A &gt; B -&gt; D end ) . Error : fun with head matching ( &#39;=&#39; in head ) cannot be translated into match_spec { error , transform_error } 3 &gt; ets : fun2ms ( fun ( { A , [ B | C ] } ) when A &gt; B -&gt; D = [ B | C ] , D end ) . Error : fun with body matching ( &#39;=&#39; in body ) is illegal as match_spec { error , transform_error } All variables are bound in the head of a match specification, so the translator cannot allow multiple bindings. The special case when matching is done on the top-level makes the variable bind to '$_' in the resulting match specification. It is to allow a more natural access to the whole matched object. Pseudo function object() can be used instead, see below. The following expressions are translated equally: ets:fun2ms(fun({a,_} = A) -&gt; A end). ets:fun2ms(fun({a,_}) -&gt; object() end). The special match specification variables '$_' and '$*' can be accessed through the pseudo functions object() (for '$_' ) and bindings() (for '$*' ). As an example, one can translate the following ets:match_object/2 call to a ets:select/2 call: ets:match_object(Table, {'$1',test,'$2'}). This is the same as: ets:select(Table, ets:fun2ms(fun({A,test,B}) -&gt; object() end)). In this simple case, the former expression is probably preferable in terms of readability. The ets:select/2 call conceptually looks like this in the resulting code: ets:select(Table, [{{'$1',test,'$2'},[],['$_']}]). Matching on the top-level of the fun head can be a more natural way to access '$_' , see above. Term constructions/literals are translated as much as is needed to get them into valid match specification. This way tuples are made into match specification tuple constructions (a one element tuple containing the tuple) and constant expressions are used when importing variables from the environment. Records are also translated into plain tuple constructions, calls to element, and so on. The guard test is_record/2 is translated into match specification code using the three parameter version that is built into match specification, so that is_record(A,t) is translated into {is_record,'$1',t,5} if the record size of record type t is 5. Language constructions such as case , if , and catch that are not present in match specifications are not allowed. If header file ms_transform.hrl is not included, the fun is not translated, which can result in a runtime error (depending on whether the fun is valid in a pure Erlang context). Ensure that the header is included when using ets and dbg:fun2ms/1 in compiled code. If pseudo function triggering the translation is ets:fun2ms/1 , the head of the fun must contain a single variable or a single tuple. If the pseudo function is dbg:fun2ms/1 , the head of the fun must contain a single variable or a single list. The translation from funs to match specifications is done at compile time, so runtime performance is not affected by using these pseudo functions. For more information about match specifications, see the Match specifications in Erlang in ERTS User's Guide.","ref":"ms_transform.html","title":"ms_transform","type":"module"},{"doc":"Takes an error code returned by one of the other functions in the module and creates a textual description of the error.","ref":"ms_transform.html#format_error/1","title":"ms_transform.format_error/1","type":"function"},{"doc":"Implements the transformation at compile time. This function is called by the compiler to do the source code transformation if and when header file ms_transform.hrl is included in the source code. For information about how to use this parse transformation, see ets and dbg:fun2ms/1 . For a description of match specifications, see section Match Specification in Erlang in ERTS User's Guide.","ref":"ms_transform.html#parse_transform/2","title":"ms_transform.parse_transform/2","type":"function"},{"doc":"Implements the transformation when the fun2ms/1 functions are called from the shell. In this case, the abstract form is for one single fun (parsed by the Erlang shell). All imported variables are to be in the key-value list passed as BoundEnvironment . The result is a term, normalized, that is, not in abstract format.","ref":"ms_transform.html#transform_from_shell/3","title":"ms_transform.transform_from_shell/3","type":"function"},{"doc":"This module provides a Key - Value dictionary. An orddict is a representation of a dictionary, where a list of pairs is used to store the keys and values. The list is ordered after the keys in the Erlang term order . This module provides the same interface as the dict(3) module but with a defined representation. One difference is that while dict considers two keys as different if they do not match ( =:= ), this module considers two keys as different if and only if they do not compare equal ( == ). Notes Functions append/3 and append_list/3 are included so that keyed values can be stored in a list accumulator , for example: &gt; D0 = orddict : new ( ) , D1 = orddict : store ( files , [ ] , D0 ) , D2 = orddict : append ( files , f1 , D1 ) , D3 = orddict : append ( files , f2 , D2 ) , D4 = orddict : append ( files , f3 , D3 ) , orddict : fetch ( files , D4 ) . [ f1 , f2 , f3 ] This saves the trouble of first fetching a keyed value, appending a new value to the list of stored values, and storing the result. Function fetch/2 is to be used if the key is known to be in the dictionary, otherwise function find/2 . See Also dict(3) , gb_trees(3)","ref":"orddict.html","title":"orddict","type":"module"},{"doc":"Appends a new Value to the current list of values associated with Key . An exception is generated if the initial value associated with Key is not a list of values. See also section Notes .","ref":"orddict.html#append/3","title":"orddict.append/3","type":"function"},{"doc":"Appends a list of values ValList to the current list of values associated with Key . An exception is generated if the initial value associated with Key is not a list of values. See also section Notes .","ref":"orddict.html#append_list/3","title":"orddict.append_list/3","type":"function"},{"doc":"Erases all items with a specified key from a dictionary.","ref":"orddict.html#erase/2","title":"orddict.erase/2","type":"function"},{"doc":"Returns the value associated with Key in dictionary Orddict . This function assumes that the Key is present in the dictionary. An exception is generated if Key is not in the dictionary. See also section Notes .","ref":"orddict.html#fetch/2","title":"orddict.fetch/2","type":"function"},{"doc":"Returns a list of all keys in a dictionary.","ref":"orddict.html#fetch_keys/1","title":"orddict.fetch_keys/1","type":"function"},{"doc":"Orddict2 is a dictionary of all keys and values in Orddict1 for which Pred(Key, Value) is true .","ref":"orddict.html#filter/2","title":"orddict.filter/2","type":"function"},{"doc":"Searches for a key in a dictionary. Returns {ok, Value} , where Value is the value associated with Key , or error if the key is not present in the dictionary. See also section Notes .","ref":"orddict.html#find/2","title":"orddict.find/2","type":"function"},{"doc":"Calls Fun on successive keys and values of Orddict together with an extra argument Acc (short for accumulator). Fun must return a new accumulator that is passed to the next call. Acc0 is returned if the list is empty.","ref":"orddict.html#fold/3","title":"orddict.fold/3","type":"function"},{"doc":"Converts the Key - Value list List to a dictionary.","ref":"orddict.html#from_list/1","title":"orddict.from_list/1","type":"function"},{"doc":"Returns true if Orddict has no elements, otherwise false .","ref":"orddict.html#is_empty/1","title":"orddict.is_empty/1","type":"function"},{"doc":"Tests if Key is contained in dictionary Orddict .","ref":"orddict.html#is_key/2","title":"orddict.is_key/2","type":"function"},{"doc":"Calls Fun on successive keys and values of Orddict1 tvo return a new value for each key.","ref":"orddict.html#map/2","title":"orddict.map/2","type":"function"},{"doc":"Merges two dictionaries, Orddict1 and Orddict2 , to create a new dictionary. All the Key - Value pairs from both dictionaries are included in the new dictionary. If a key occurs in both dictionaries, Fun is called with the key and both values to return a new value. merge/3 can be defined as follows, but is faster: merge(Fun, D1, D2) -&gt; fold(fun (K, V1, D) -&gt; update(K, fun (V2) -&gt; Fun(K, V1, V2) end, V1, D) end, D2, D1).","ref":"orddict.html#merge/3","title":"orddict.merge/3","type":"function"},{"doc":"Creates a new dictionary.","ref":"orddict.html#new/0","title":"orddict.new/0","type":"function"},{"doc":"Returns the number of elements in an Orddict .","ref":"orddict.html#size/1","title":"orddict.size/1","type":"function"},{"doc":"Stores a Key - Value pair in a dictionary. If the Key already exists in Orddict1 , the associated value is replaced by Value .","ref":"orddict.html#store/3","title":"orddict.store/3","type":"function"},{"doc":"This function returns value from dictionary and new dictionary without this value. Returns error if the key is not present in the dictionary.","ref":"orddict.html#take/2","title":"orddict.take/2","type":"function"},{"doc":"Converts a dictionary to a list representation.","ref":"orddict.html#to_list/1","title":"orddict.to_list/1","type":"function"},{"doc":"Updates a value in a dictionary by calling Fun on the value to get a new value. An exception is generated if Key is not present in the dictionary.","ref":"orddict.html#update/3","title":"orddict.update/3","type":"function"},{"doc":"Updates a value in a dictionary by calling Fun on the value to get a new value. If Key is not present in the dictionary, Initial is stored as the first value. For example, append/3 can be defined as follows: append(Key, Val, D) -&gt; update(Key, fun (Old) -&gt; Old ++ [Val] end, [Val], D).","ref":"orddict.html#update/4","title":"orddict.update/4","type":"function"},{"doc":"Adds Increment to the value associated with Key and store this value. If Key is not present in the dictionary, Increment is stored as the first value. This can be defined as follows, but is faster: update_counter(Key, Incr, D) -&gt; update(Key, fun (Old) -&gt; Old + Incr end, Incr, D).","ref":"orddict.html#update_counter/3","title":"orddict.update_counter/3","type":"function"},{"doc":"","ref":"orddict.html#t:orddict/0","title":"orddict.orddict/0","type":"type"},{"doc":"Dictionary as returned by new/0 .","ref":"orddict.html#t:orddict/2","title":"orddict.orddict/2","type":"type"},{"doc":"Sets are collections of elements with no duplicate elements. An ordset is a representation of a set, where an ordered list is used to store the elements of the set. An ordered list is more efficient than an unordered list. Elements are ordered according to the Erlang term order . This module provides the same interface as the sets(3) module but with a defined representation. One difference is that while sets considers two elements as different if they do not match ( =:= ), this module considers two elements as different if and only if they do not compare equal ( == ). See Also gb_sets(3) , sets(3)","ref":"ordsets.html","title":"ordsets","type":"module"},{"doc":"Returns a new ordered set formed from Ordset1 with Element inserted.","ref":"ordsets.html#add_element/2","title":"ordsets.add_element/2","type":"function"},{"doc":"Returns Ordset1 , but with Element removed.","ref":"ordsets.html#del_element/2","title":"ordsets.del_element/2","type":"function"},{"doc":"Filters elements in Ordset1 with boolean function Pred .","ref":"ordsets.html#filter/2","title":"ordsets.filter/2","type":"function"},{"doc":"Folds Function over every element in Ordset and returns the final value of the accumulator.","ref":"ordsets.html#fold/3","title":"ordsets.fold/3","type":"function"},{"doc":"Returns an ordered set of the elements in List .","ref":"ordsets.html#from_list/1","title":"ordsets.from_list/1","type":"function"},{"doc":"Returns the intersection of the non-empty list of sets.","ref":"ordsets.html#intersection/1","title":"ordsets.intersection/1","type":"function"},{"doc":"Returns the intersection of Ordset1 and Ordset2 .","ref":"ordsets.html#intersection/2","title":"ordsets.intersection/2","type":"function"},{"doc":"Returns true if Ordset1 and Ordset2 are disjoint (have no elements in common), otherwise false .","ref":"ordsets.html#is_disjoint/2","title":"ordsets.is_disjoint/2","type":"function"},{"doc":"Returns true if Element is an element of Ordset , otherwise false .","ref":"ordsets.html#is_element/2","title":"ordsets.is_element/2","type":"function"},{"doc":"Returns true if Ordset is an empty set, otherwise false .","ref":"ordsets.html#is_empty/1","title":"ordsets.is_empty/1","type":"function"},{"doc":"Returns true if Ordset is an ordered set of elements, otherwise false .","ref":"ordsets.html#is_set/1","title":"ordsets.is_set/1","type":"function"},{"doc":"Returns true when every element of Ordset1 is also a member of Ordset2 , otherwise false .","ref":"ordsets.html#is_subset/2","title":"ordsets.is_subset/2","type":"function"},{"doc":"Returns a new empty ordered set.","ref":"ordsets.html#new/0","title":"ordsets.new/0","type":"function"},{"doc":"Returns the number of elements in Ordset .","ref":"ordsets.html#size/1","title":"ordsets.size/1","type":"function"},{"doc":"Returns only the elements of Ordset1 that are not also elements of Ordset2 .","ref":"ordsets.html#subtract/2","title":"ordsets.subtract/2","type":"function"},{"doc":"Returns the elements of Ordset as a list.","ref":"ordsets.html#to_list/1","title":"ordsets.to_list/1","type":"function"},{"doc":"Returns the merged (union) set of the list of sets.","ref":"ordsets.html#union/1","title":"ordsets.union/1","type":"function"},{"doc":"Returns the merged (union) set of Ordset1 and Ordset2 .","ref":"ordsets.html#union/2","title":"ordsets.union/2","type":"function"},{"doc":"As returned by new/0 .","ref":"ordsets.html#t:ordset/1","title":"ordsets.ordset/1","type":"type"},{"doc":"This module can be used to run a set of Erlang nodes as a pool of computational processors. It is organized as a master and a set of slave nodes and includes the following features: The slave nodes send regular reports to the master about their current load. Queries can be sent to the master to determine which node will have the least load. The BIF statistics(run_queue) is used for estimating future loads. It returns the length of the queue of ready to run processes in the Erlang runtime system. The slave nodes are started with the slave(3) module. This effects terminal I/O, file I/O, and code loading. If the master node fails, the entire pool exits. Files .hosts.erlang is used to pick hosts where nodes can be started. For information about format and location of this file, see net_adm:host_file/0 . $HOME/.erlang.slave.out.HOST is used for all extra I/O that can come from the slave nodes on standard I/O. If the startup procedure does not work, this file can indicate the reason.","ref":"pool.html","title":"pool","type":"module"},{"doc":"Ensures that a pool master is running and includes Node in the pool master's pool of nodes.","ref":"pool.html#attach/1","title":"pool.attach/1","type":"function"},{"doc":"Returns the node with the expected lowest future load.","ref":"pool.html#get_node/0","title":"pool.get_node/0","type":"function"},{"doc":"Returns a list of the current member nodes of the pool.","ref":"pool.html#get_nodes/0","title":"pool.get_nodes/0","type":"function"},{"doc":"Spawns a process on the pool node that is expected to have the lowest future load.","ref":"pool.html#pspawn/3","title":"pool.pspawn/3","type":"function"},{"doc":"Spawns and links to a process on the pool node that is expected to have the lowest future load.","ref":"pool.html#pspawn_link/3","title":"pool.pspawn_link/3","type":"function"},{"doc":"Starts a new pool. The file .hosts.erlang is read to find host names where the pool nodes can be started; see section Files . The startup procedure fails if the file is not found. The slave nodes are started with slave:start/2,3 , passing along Name and, if provided, Args . Name is used as the first part of the node names, Args is used to specify command-line arguments. Access rights must be set so that all nodes in the pool have the authority to access each other. The function is synchronous and all the nodes, and all the system servers, are running when it returns a value.","ref":"pool.html#start/1","title":"pool.start/1","type":"function"},{"doc":"","ref":"pool.html#start/2","title":"pool.start/2","type":"function"},{"doc":"Stops the pool and kills all the slave nodes.","ref":"pool.html#stop/0","title":"pool.stop/0","type":"function"},{"doc":"This module is used to start processes adhering to the OTP Design Principles. Specifically, the functions in this module are used by the OTP standard behaviors (for example, gen_server and gen_statem ) when starting new processes. The functions can also be used to start special processes , user-defined processes that comply to the OTP design principles. For an example, see section sys and proc_lib in OTP Design Principles. Some useful information is initialized when a process starts. The registered names, or the process identifiers, of the parent process, and the parent ancestors, are stored together with information about the function initially called in the process. While in &quot;plain Erlang&quot;, a process is said to terminate normally only for exit reason normal , a process started using proc_lib is also said to terminate normally if it exits with reason shutdown or {shutdown,Term} . shutdown is the reason used when an application (supervision tree) is stopped. When a process that is started using proc_lib terminates abnormally (that is, with another exit reason than normal , shutdown , or {shutdown,Term} ), a crash report is generated, which is written to terminal by the default logger handler setup by Kernel. For more information about how crash reports were logged prior to Erlang/OTP 21.0, see SASL Error Logging in the SASL User's Guide. Unlike in &quot;plain Erlang&quot;, proc_lib processes will not generate error reports , which are written to the terminal by the emulator. All exceptions are converted to exits which are ignored by the default logger handler. The crash report contains the previously stored information, such as ancestors and initial function, the termination reason, and information about other processes that terminate as a result of this process terminating. See Also error_logger(3) logger(3)","ref":"proc_lib.html","title":"proc_lib","type":"module"},{"doc":"Equivalent to format(CrashReport, latin1) .","ref":"proc_lib.html#format/1","title":"proc_lib.format/1","type":"function"},{"doc":"This function is deprecated in the sense that the error_logger is no longer the preferred interface for logging in Erlang/OTP. A new logging API was added in Erlang/OTP 21.0, but legacy error_logger handlers can still be used. New Logger handlers do not need to use this function, since the formatting callback ( report_cb ) is included as metadata in the log event. This function can be used by a user-defined legacy error_logger event handler to format a crash report. The crash report is sent using logger(3) , and the event to be handled is of the format {error_report, GL, {Pid, crash_report, CrashReport}} , where GL is the group leader pid of process Pid that sent the crash report.","ref":"proc_lib.html#format/2","title":"proc_lib.format/2","type":"function"},{"doc":"This function is deprecated in the sense that the error_logger is no longer the preferred interface for logging in Erlang/OTP. A new logging API was added in Erlang/OTP 21.0, but legacy error_logger handlers can still be used. New Logger handlers do not need to used this function, since the formatting callback ( report_cb ) is included as metadata in the log event. This function can be used by a user-defined legacy error_logger event handler to format a crash report. When Depth is specified as a positive integer, it is used in the format string to limit the output as follows: io_lib:format(&quot;~P&quot;, [Term,Depth]) .","ref":"proc_lib.html#format/3","title":"proc_lib.format/3","type":"function"},{"doc":"This function does the same as (and does call) the hibernate/3 BIF, but ensures that exception handling and logging continues to work as expected when the process wakes up. Always use this function instead of the BIF for processes started using proc_lib functions.","ref":"proc_lib.html#hibernate/3","title":"proc_lib.hibernate/3","type":"function"},{"doc":"This function must be used by a process that has been started by a start[_link]/3,4,5 function. It tells Parent that the process has initialized itself, has started, or has failed to initialize itself. Function init_ack/1 uses the parent value previously stored by the start function used. If this function is not called, the start function returns an error tuple (if a link and/or a time-out is used) or hang otherwise. The following example illustrates how this function and proc_lib:start_link/3 are used: -module(my_proc). -export([start_link/0]). -export([init/1]). start_link() -&gt; proc_lib:start_link(my_proc, init, [self()]). init(Parent) -&gt; case do_initialization() of ok -&gt; proc_lib:init_ack(Parent, {ok, self()}); {error, Reason} -&gt; exit(Reason) end, loop(). ...","ref":"proc_lib.html#init_ack/1","title":"proc_lib.init_ack/1","type":"function"},{"doc":"","ref":"proc_lib.html#init_ack/2","title":"proc_lib.init_ack/2","type":"function"},{"doc":"Extracts the initial call of a process that was started using one of the spawn or start functions in this module. Process can either be a pid, an integer tuple (from which a pid can be created), or the process information of a process Pid fetched through an erlang:process_info(Pid) function call. The list Args no longer contains the arguments, but the same number of atoms as the number of arguments; the first atom is 'Argument__1' , the second 'Argument__2' , and so on. The reason is that the argument list could waste a significant amount of memory, and if the argument list contained funs, it could be impossible to upgrade the code for the module. If the process was spawned using a fun, initial_call/1 no longer returns the fun, but the module, function for the local function implementing the fun, and the arity, for example, {some_module,-work/3-fun-0-,0} (meaning that the fun was created in function some_module:work/3 ). The reason is that keeping the fun would prevent code upgrade for the module, and that a significant amount of memory could be wasted.","ref":"proc_lib.html#initial_call/1","title":"proc_lib.initial_call/1","type":"function"},{"doc":"Spawns a new process and initializes it as described in the beginning of this manual page. The process is spawned using the spawn BIFs.","ref":"proc_lib.html#spawn/1","title":"proc_lib.spawn/1","type":"function"},{"doc":"","ref":"proc_lib.html#spawn/2","title":"proc_lib.spawn/2","type":"function"},{"doc":"","ref":"proc_lib.html#spawn/3","title":"proc_lib.spawn/3","type":"function"},{"doc":"","ref":"proc_lib.html#spawn/4","title":"proc_lib.spawn/4","type":"function"},{"doc":"Spawns a new process and initializes it as described in the beginning of this manual page. The process is spawned using the spawn_link BIFs.","ref":"proc_lib.html#spawn_link/1","title":"proc_lib.spawn_link/1","type":"function"},{"doc":"","ref":"proc_lib.html#spawn_link/2","title":"proc_lib.spawn_link/2","type":"function"},{"doc":"","ref":"proc_lib.html#spawn_link/3","title":"proc_lib.spawn_link/3","type":"function"},{"doc":"","ref":"proc_lib.html#spawn_link/4","title":"proc_lib.spawn_link/4","type":"function"},{"doc":"Spawns a new process and initializes it as described in the beginning of this manual page. The process is spawned using the erlang:spawn_opt BIFs.","ref":"proc_lib.html#spawn_opt/2","title":"proc_lib.spawn_opt/2","type":"function"},{"doc":"","ref":"proc_lib.html#spawn_opt/3","title":"proc_lib.spawn_opt/3","type":"function"},{"doc":"","ref":"proc_lib.html#spawn_opt/4","title":"proc_lib.spawn_opt/4","type":"function"},{"doc":"","ref":"proc_lib.html#spawn_opt/5","title":"proc_lib.spawn_opt/5","type":"function"},{"doc":"Starts a new process synchronously. Spawns the process and waits for it to start. When the process has started, it must call init_ack(Parent, Ret) or init_ack(Ret) , where Parent is the process that evaluates this function. At this time, Ret is returned. If Time is specified as an integer, this function waits for Time milliseconds for the new process to call init_ack , or Ret = {error, timeout} will be returned, and the process is killed. Argument SpawnOpts , if specified, is passed as the last argument to the spawn_opt/2,3,4,5 BIF. Using spawn option monitor is not allowed. It causes the function to fail with reason badarg .","ref":"proc_lib.html#start/3","title":"proc_lib.start/3","type":"function"},{"doc":"","ref":"proc_lib.html#start/4","title":"proc_lib.start/4","type":"function"},{"doc":"","ref":"proc_lib.html#start/5","title":"proc_lib.start/5","type":"function"},{"doc":"Starts a new process synchronously. Spawns the process and waits for it to start. A link is atomically set on the newly spawned process. When the process has started, it must call init_ack(Parent, Ret) or init_ack(Ret) , where Parent is the process that evaluates this function. At this time, Ret is returned. If Time is specified as an integer, this function waits for Time milliseconds for the new process to call init_ack , or Ret = {error, timeout} will be returned, and the process is killed. If the process crashes before it has called init_ack/1,2 , Ret = {error, Reason} will be returned if the calling process traps exits. Argument SpawnOpts , if specified, is passed as the last argument to the spawn_opt/2,3,4,5 BIF. Using spawn option monitor is not allowed. It causes the function to fail with reason badarg .","ref":"proc_lib.html#start_link/3","title":"proc_lib.start_link/3","type":"function"},{"doc":"","ref":"proc_lib.html#start_link/4","title":"proc_lib.start_link/4","type":"function"},{"doc":"","ref":"proc_lib.html#start_link/5","title":"proc_lib.start_link/5","type":"function"},{"doc":"Starts a new process synchronously. Spawns the process and waits for it to start. A monitor is atomically set on the newly spawned process. When the process has started, it must call init_ack(Parent, Ret) or init_ack(Ret) , where Parent is the process that evaluates this function. At this time, Ret is returned. If Time is specified as an integer, this function waits for Time milliseconds for the new process to call init_ack , or Ret = {error, timeout} will be returned, and the process is killed. The return value is {Ret, Mon} where Ret corresponds to the Ret argument in the call to init_ack() , and Mon is the monitor reference of the monitor that has been set up. A 'DOWN' message will be delivered to the caller if this function returns, and the spawned process terminates. This is true also in the case when the operation times out. Argument SpawnOpts , if specified, is passed as the last argument to the spawn_opt/2,3,4,5 BIF. Using spawn option monitor is not allowed. It causes the function to fail with reason badarg .","ref":"proc_lib.html#start_monitor/3","title":"proc_lib.start_monitor/3","type":"function"},{"doc":"","ref":"proc_lib.html#start_monitor/4","title":"proc_lib.start_monitor/4","type":"function"},{"doc":"","ref":"proc_lib.html#start_monitor/5","title":"proc_lib.start_monitor/5","type":"function"},{"doc":"Equivalent to stop(Process, normal, infinity) .","ref":"proc_lib.html#stop/1","title":"proc_lib.stop/1","type":"function"},{"doc":"Orders the process to exit with the specified Reason and waits for it to terminate. Returns ok if the process exits with the specified Reason within Timeout milliseconds. If the call times out, a timeout exception is raised. If the process does not exist, a noproc exception is raised. The implementation of this function is based on the terminate system message, and requires that the process handles system messages correctly. For information about system messages, see sys(3) and section sys and proc_lib in OTP Design Principles.","ref":"proc_lib.html#stop/3","title":"proc_lib.stop/3","type":"function"},{"doc":"This function is used by functions c:i/0 and c:regs/0 to present process information. This function extracts the initial call of a process that was started using one of the spawn or start functions in this module, and translates it to more useful information. Process can either be a pid, an integer tuple (from which a pid can be created), or the process information of a process Pid fetched through an erlang:process_info(Pid) function call. If the initial call is to one of the system-defined behaviors such as gen_server or gen_event , it is translated to more useful information. If a gen_server is spawned, the returned Module is the name of the callback module and Function is init (the function that initiates the new server). A supervisor and a supervisor_bridge are also gen_server processes. To return information that this process is a supervisor and the name of the callback module, Module is supervisor and Function is the name of the supervisor callback module. Arity is 1 , as the init/1 function is called initially in the callback module. By default, {proc_lib,init_p,5} is returned if no information about the initial call can be found. It is assumed that the caller knows that the process has been spawned with the proc_lib module.","ref":"proc_lib.html#translate_initial_call/1","title":"proc_lib.translate_initial_call/1","type":"function"},{"doc":"","ref":"proc_lib.html#t:dict_or_pid/0","title":"proc_lib.dict_or_pid/0","type":"type"},{"doc":"See erlang:spawn_opt/2,3,4,5 .","ref":"proc_lib.html#t:spawn_option/0","title":"proc_lib.spawn_option/0","type":"type"},{"doc":"A restricted set of spawn options . Most notably monitor is not part of these options.","ref":"proc_lib.html#t:start_spawn_option/0","title":"proc_lib.start_spawn_option/0","type":"type"},{"doc":"Property lists are ordinary lists containing entries in the form of either tuples, whose first elements are keys used for lookup and insertion, or atoms, which work as shorthand for tuples {Atom, true} . (Other terms are allowed in the lists, but are ignored by this module.) If there is more than one entry in a list for a certain key, the first occurrence normally overrides any later (irrespective of the arity of the tuples). Property lists are useful for representing inherited properties, such as options passed to a function where a user can specify options overriding the default settings, object properties, annotations, and so on. Two keys are considered equal if they match ( =:= ). That is, numbers are compared literally rather than by value, so that, for example, 1 and 1.0 are different keys.","ref":"proplists.html","title":"proplists","type":"module"},{"doc":"Similar to get_all_values/2 , but each value is wrapped in a list unless it is already itself a list. The resulting list of lists is concatenated. This is often useful for &quot;incremental&quot; options. Example: append_values(a, [{a, [1,2]}, {b, 0}, {a, 3}, {c, -1}, {a, [4]}]) returns: [1,2,3,4]","ref":"proplists.html#append_values/2","title":"proplists.append_values/2","type":"function"},{"doc":"Minimizes the representation of all entries in the list. This is equivalent to [property(P) || P &lt;- ListIn] . See also property/1 , unfold/1 .","ref":"proplists.html#compact/1","title":"proplists.compact/1","type":"function"},{"doc":"Deletes all entries associated with Key from List .","ref":"proplists.html#delete/2","title":"proplists.delete/2","type":"function"},{"doc":"Expands particular properties to corresponding sets of properties (or other terms). For each pair {Property, Expansion} in Expansions : if E is the first entry in ListIn with the same key as Property , and E and Property have equivalent normal forms, then E is replaced with the terms in Expansion , and any following entries with the same key are deleted from ListIn . For example, the following expressions all return [fie, bar, baz, fum] : expand([{foo, [bar, baz]}], [fie, foo, fum]) expand([{{foo, true}, [bar, baz]}], [fie, foo, fum]) expand([{{foo, false}, [bar, baz]}], [fie, {foo, false}, fum]) However, no expansion is done in the following call because {foo, false} shadows foo : expand([{{foo, true}, [bar, baz]}], [{foo, false}, fie, foo, fum]) Notice that if the original property term is to be preserved in the result when expanded, it must be included in the expansion list. The inserted terms are not expanded recursively. If Expansions contains more than one property with the same key, only the first occurrence is used. See also normalize/2 .","ref":"proplists.html#expand/2","title":"proplists.expand/2","type":"function"},{"doc":"Converts the map Map to a property list.","ref":"proplists.html#from_map/1","title":"proplists.from_map/1","type":"function"},{"doc":"Similar to get_value/2 , but returns the list of values for all entries {Key, Value} in List . If no such entry exists, the result is the empty list.","ref":"proplists.html#get_all_values/2","title":"proplists.get_all_values/2","type":"function"},{"doc":"Returns the value of a boolean key/value option. If lookup(Key, List) would yield {Key, true} , this function returns true , otherwise false . See also get_value/2 , lookup/2 .","ref":"proplists.html#get_bool/2","title":"proplists.get_bool/2","type":"function"},{"doc":"Returns an unordered list of the keys used in List , not containing duplicates.","ref":"proplists.html#get_keys/1","title":"proplists.get_keys/1","type":"function"},{"doc":"Equivalent to get_value(Key, List, undefined) .","ref":"proplists.html#get_value/2","title":"proplists.get_value/2","type":"function"},{"doc":"Returns the value of a simple key/value property in List . If lookup(Key, List) would yield {Key, Value} , this function returns the corresponding Value , otherwise Default . See also get_all_values/2 , get_bool/2 , get_value/2 , lookup/2 .","ref":"proplists.html#get_value/3","title":"proplists.get_value/3","type":"function"},{"doc":"Returns true if List contains at least one entry associated with Key , otherwise false .","ref":"proplists.html#is_defined/2","title":"proplists.is_defined/2","type":"function"},{"doc":"Returns the first entry associated with Key in List , if one exists, otherwise returns none . For an atom A in the list, the tuple {A, true} is the entry associated with A . See also get_bool/2 , get_value/2 , lookup_all/2 .","ref":"proplists.html#lookup/2","title":"proplists.lookup/2","type":"function"},{"doc":"Returns the list of all entries associated with Key in List . If no such entry exists, the result is the empty list. See also lookup/2 .","ref":"proplists.html#lookup_all/2","title":"proplists.lookup_all/2","type":"function"},{"doc":"Passes ListIn through a sequence of substitution/expansion stages. For an aliases operation, function substitute_aliases/2 is applied using the specified list of aliases: For a negations operation, substitute_negations/2 is applied using the specified negation list. For an expand operation, function expand/2 is applied using the specified list of expansions. The final result is automatically compacted (compare compact/1 ). Typically you want to substitute negations first, then aliases, then perform one or more expansions (sometimes you want to pre-expand particular entries before doing the main expansion). You might want to substitute negations and/or aliases repeatedly, to allow such forms in the right-hand side of aliases and expansion lists. See also substitute_negations/2 .","ref":"proplists.html#normalize/2","title":"proplists.normalize/2","type":"function"},{"doc":"Creates a normal form (minimal) representation of a property. If PropertyIn is {Key, true} , where Key is an atom, Key is returned, otherwise the whole term PropertyIn is returned. See also property/2 .","ref":"proplists.html#property/1","title":"proplists.property/1","type":"function"},{"doc":"Creates a normal form (minimal) representation of a simple key/value property. Returns Key if Value is true and Key is an atom, otherwise a tuple {Key, Value} is returned. See also property/1 .","ref":"proplists.html#property/2","title":"proplists.property/2","type":"function"},{"doc":"Partitions List into a list of sublists and a remainder. Lists contains one sublist for each key in Keys , in the corresponding order. The relative order of the elements in each sublist is preserved from the original List . Rest contains the elements in List that are not associated with any of the specified keys, also with their original relative order preserved. Example: split([{c, 2}, {e, 1}, a, {c, 3, 4}, d, {b, 5}, b], [a, b, c]) returns: {[[a], [{b, 5}, b],[{c, 2}, {c, 3, 4}]], [{e, 1}, d]}","ref":"proplists.html#split/2","title":"proplists.split/2","type":"function"},{"doc":"Substitutes keys of properties. For each entry in ListIn , if it is associated with some key K1 such that {K1, K2} occurs in Aliases , the key of the entry is changed to K2 . If the same K1 occurs more than once in Aliases , only the first occurrence is used. For example, substitute_aliases([{color, colour}], L) replaces all tuples {color, ...} in L with {colour, ...} , and all atoms color with colour . See also normalize/2 , substitute_negations/2 .","ref":"proplists.html#substitute_aliases/2","title":"proplists.substitute_aliases/2","type":"function"},{"doc":"Substitutes keys of boolean-valued properties and simultaneously negates their values. For each entry in ListIn , if it is associated with some key K1 such that {K1, K2} occurs in Negations : if the entry was {K1, true} , it is replaced with {K2, false} , otherwise with K2 , thus changing the name of the option and simultaneously negating the value specified by get_bool(Key, ListIn) . If the same K1 occurs more than once in Negations , only the first occurrence is used. For example, substitute_negations([{no_foo, foo}], L) replaces any atom no_foo or tuple {no_foo, true} in L with {foo, false} , and any other tuple {no_foo, ...} with foo . See also get_bool/2 , normalize/2 , substitute_aliases/2 .","ref":"proplists.html#substitute_negations/2","title":"proplists.substitute_negations/2","type":"function"},{"doc":"Converts the property list List to a map. Shorthand atom values in List will be expanded to an association of the form Atom =&gt; true . Tuples of the form {Key, Value} in List will be converted to an association of the form Key =&gt; Value . Anything else will be silently ignored. If the same key appears in List multiple times, the value of the one appearing nearest to the head of List will be in the result map, that is the value that would be returned by a call to get_value(Key, List) . Example: to_map([a, {b, 1}, {c, 2}, {c, 3}]) returns: \#{a =&gt; true, b =&gt; 1, c =&gt; 2}","ref":"proplists.html#to_map/1","title":"proplists.to_map/1","type":"function"},{"doc":"Converts the property list List to a map after applying the normalizations given in Stages . See also normalize/2 , to_map/1 .","ref":"proplists.html#to_map/2","title":"proplists.to_map/2","type":"function"},{"doc":"Unfolds all occurrences of atoms in ListIn to tuples {Atom, true} .","ref":"proplists.html#unfold/1","title":"proplists.unfold/1","type":"function"},{"doc":"","ref":"proplists.html#t:property/0","title":"proplists.property/0","type":"type"},{"doc":"","ref":"proplists.html#t:proplist/0","title":"proplists.proplist/0","type":"type"},{"doc":"This module provides a query interface to Mnesia , ETS , Dets , and other data structures that provide an iterator style traversal of objects. Overview This module provides a query interface to QLC tables . Typical QLC tables are Mnesia, ETS, and Dets tables. Support is also provided for user-defined tables, see section Implementing a QLC Table . A query is expressed using Query List Comprehensions (QLCs). The answers to a query are determined by data in QLC tables that fulfill the constraints expressed by the QLCs of the query. QLCs are similar to ordinary list comprehensions as described in Erlang Reference Manual and Programming Examples, except that variables introduced in patterns cannot be used in list expressions. In the absence of optimizations and options such as cache and unique (see section Common Options , every QLC free of QLC tables evaluates to the same list of answers as the identical ordinary list comprehension. While ordinary list comprehensions evaluate to lists, calling q/1,2 returns a query handle . To obtain all the answers to a query, eval/1,2 is to be called with the query handle as first argument. Query handles are essentially functional objects (funs) created in the module calling q/1,2 . As the funs refer to the module code, be careful not to keep query handles too long if the module code is to be replaced. Code replacement is described in section Compilation and Code Loading in the Erlang Reference Manual. The list of answers can also be traversed in chunks by use of a query cursor . Query cursors are created by calling cursor/1,2 with a query handle as first argument. Query cursors are essentially Erlang processes. One answer at a time is sent from the query cursor process to the process that created the cursor. Syntax Syntactically QLCs have the same parts as ordinary list comprehensions: [Expression || Qualifier1, Qualifier2, ...] Expression (the template ) is any Erlang expression. Qualifiers are either filters or generators . Filters are Erlang expressions returning boolean() . Generators have the form Pattern &lt;- ListExpression , where ListExpression is an expression evaluating to a query handle or a list. Query handles are returned from append/1,2 , keysort/2,3 , q/1,2 , sort/1,2 , string_to_handle/1,2,3 , and table/2 . Evaluation A query handle is evaluated in the following order: Inspection of options and the collection of information about tables. As a result, qualifiers are modified during the optimization phase. All list expressions are evaluated. If a cursor has been created, evaluation takes place in the cursor process. For list expressions that are QLCs, the list expressions of the generators of the QLCs are evaluated as well. Be careful if list expressions have side effects, as list expressions are evaluated in unspecified order. The answers are found by evaluating the qualifiers from left to right, backtracking when some filter returns false , or collecting the template when all filters return true . Filters that do not return boolean() but fail are handled differently depending on their syntax: if the filter is a guard, it returns false , otherwise the query evaluation fails. This behavior makes it possible for the qlc module to do some optimizations without affecting the meaning of a query. For example, when testing some position of a table and one or more constants for equality, only the objects with equal values are candidates for further evaluation. The other objects are guaranteed to make the filter return false , but never fail. The (small) set of candidate objects can often be found by looking up some key values of the table or by traversing the table using a match specification. It is necessary to place the guard filters immediately after the table generator, otherwise the candidate objects are not restricted to a small set. The reason is that objects that could make the query evaluation fail must not be excluded by looking up a key or running a match specification. Join The qlc module supports fast join of two query handles. Fast join is possible if some position P1 of one query handler and some position P2 of another query handler are tested for equality. Two fast join methods are provided: Lookup join traverses all objects of one query handle and finds objects of the other handle (a QLC table) such that the values at P1 and P2 match or compare equal. The qlc module does not create any indexes but looks up values using the key position and the indexed positions of the QLC table. Merge join sorts the objects of each query handle if necessary and filters out objects where the values at P1 and P2 do not compare equal. If many objects with the same value of P2 exist, a temporary file is used for the equivalence classes. The qlc module warns at compile time if a QLC combines query handles in such a way that more than one join is possible. That is, no query planner is provided that can select a good order between possible join operations. It is up to the user to order the joins by introducing query handles. The join is to be expressed as a guard filter. The filter must be placed immediately after the two joined generators, possibly after guard filters that use variables from no other generators but the two joined generators. The qlc module inspects the operands of =:=/2 , ==/2 , is_record/2 , element/2 , and logical operators ( and/2 , or/2 , andalso/2 , orelse/2 , xor/2 ) when determining which joins to consider. Common Options The following options are accepted by cursor/2 , eval/2 , fold/4 , and info/2 : {cache_all, Cache} , where Cache is equal to ets or list adds a {cache, Cache} option to every list expression of the query except tables and lists. Defaults to {cache_all, no} . Option cache_all is equivalent to {cache_all, ets} . {max_list_size, MaxListSize} , where MaxListSize is the size in bytes of terms on the external format. If the accumulated size of collected objects exceeds MaxListSize , the objects are written onto a temporary file. This option is used by option {cache, list} and by the merge join method. Defaults to 512*1024 bytes. {tmpdir_usage, TmpFileUsage} determines the action taken when qlc is about to create temporary files on the directory set by option tmpdir . If the value is not_allowed , an error tuple is returned, otherwise temporary files are created as needed. Default is allowed , which means that no further action is taken. The values info_msg , warning_msg , and error_msg mean that the function with the corresponding name in module error_logger is called for printing some information (currently the stacktrace). {tmpdir, TempDirectory} sets the directory used by merge join for temporary files and by option {cache, list} . The option also overrides option tmpdir of keysort/3 and sort/2 . Defaults to &quot;&quot; , which means that the directory returned by file:get_cwd() is used. {unique_all, true} adds a {unique, true} option to every list expression of the query. Defaults to {unique_all, false} . Option unique_all is equivalent to {unique_all, true} . Getting Started As mentioned earlier, queries are expressed in the list comprehension syntax as described in section Expressions in Erlang Reference Manual. In the following, some familiarity with list comprehensions is assumed. The examples in section List Comprehensions in Programming Examples can get you started. Notice that list comprehensions do not add any computational power to the language; anything that can be done with list comprehensions can also be done without them. But they add syntax for expressing simple search problems, which is compact and clear once you get used to it. Many list comprehension expressions can be evaluated by the qlc module. Exceptions are expressions, such that variables introduced in patterns (or filters) are used in some generator later in the list comprehension. As an example, consider an implementation of lists:append(L) : [X ||Y &lt;- L, X &lt;- Y] . Y is introduced in the first generator and used in the second. The ordinary list comprehension is normally to be preferred when there is a choice as to which to use. One difference is that eval/1,2 collects answers in a list that is finally reversed, while list comprehensions collect answers on the stack that is finally unwound. What the qlc module primarily adds to list comprehensions is that data can be read from QLC tables in small chunks. A QLC table is created by calling qlc:table/2 . Usually qlc:table/2 is not called directly from the query but through an interface function of some data structure. Erlang/OTP includes a few examples of such functions: mnesia:table/1,2 , ets:table/1,2 , and dets:table/1,2 . For a given data structure, many functions can create QLC tables, but common for these functions is that they return a query handle created by qlc:table/2 . Using the QLC tables provided by Erlang/OTP is usually probably sufficient, but for the more advanced user section Implementing a QLC Table describes the implementation of a function calling qlc:table/2 . Besides qlc:table/2 , other functions return query handles. They are used more seldom than tables, but are sometimes useful. qlc:append/1,2 traverses objects from many tables or lists after each other. If, for example, you want to traverse all answers to a query QH and then finish off by a term {finished} , you can do that by calling qlc:append(QH, [{finished}]) . append/2 first returns all objects of QH , then {finished} . If a tuple {finished} exists among the answers to QH , it is returned twice from append/2 . As another example, consider concatenating the answers to two queries QH1 and QH2 while removing all duplicates. This is accomplished by using option unique : qlc:q([X || X &lt;- qlc:append(QH1, QH2)], {unique, true}) The cost is substantial: every returned answer is stored in an ETS table. Before returning an answer, it is looked up in the ETS table to check if it has already been returned. Without the unique option, all answers to QH1 would be returned followed by all answers to QH2 . The unique option keeps the order between the remaining answers. If the order of the answers is not important, there is an alternative to the unique option, namely to sort the answers uniquely: qlc:sort(qlc:q([X || X &lt;- qlc:append(QH1, QH2)], {unique, true})). This query also removes duplicates but the answers are sorted. If there are many answers, temporary files are used. Notice that to get the first unique answer, all answers must be found and sorted. Both alternatives find duplicates by comparing answers, that is, if A1 and A2 are answers found in that order, then A2 is a removed if A1 == A2 . To return only a few answers, cursors can be used. The following code returns no more than five answers using an ETS table for storing the unique answers: C = qlc:cursor(qlc:q([X || X &lt;- qlc:append(QH1, QH2)],{unique,true})), R = qlc:next_answers(C, 5), ok = qlc:delete_cursor(C), R. QLCs are convenient for stating constraints on data from two or more tables. The following example does a natural join on two query handles on position 2: qlc:q([{X1,X2,X3,Y1} || {X1,X2,X3} &lt;- QH1, {Y1,Y2} &lt;- QH2, X2 =:= Y2]) The qlc module evaluates this differently depending on the query handles QH1 and QH2 . If, for example, X2 is matched against the key of a QLC table, the lookup join method traverses the objects of QH2 while looking up key values in the table. However, if not X2 or Y2 is matched against the key or an indexed position of a QLC table, the merge join method ensures that QH1 and QH2 are both sorted on position 2 and next do the join by traversing the objects one by one. Option join can be used to force the qlc module to use a certain join method. For the rest of this section it is assumed that the excessively slow join method called &quot;nested loop&quot; has been chosen: qlc:q([{X1,X2,X3,Y1} || {X1,X2,X3} &lt;- QH1, {Y1,Y2} &lt;- QH2, X2 =:= Y2], {join, nested_loop}) In this case the filter is applied to every possible pair of answers to QH1 and QH2 , one at a time. If there are M answers to QH1 and N answers to QH2 , the filter is run M*N times. If QH2 is a call to the function for gb_trees , as defined in section Implementing a QLC Table , then gb_table:table/1 , the iterator for the gb-tree is initiated for each answer to QH1 . The objects of the gb-tree are then returned one by one. This is probably the most efficient way of traversing the table in that case, as it takes minimal computational power to get the following object. But if QH2 is not a table but a more complicated QLC, it can be more efficient to use some RAM memory for collecting the answers in a cache, particularly if there are only a few answers. It must then be assumed that evaluating QH2 has no side effects so that the meaning of the query does not change if QH2 is evaluated only once. One way of caching the answers is to evaluate QH2 first of all and substitute the list of answers for QH2 in the query. Another way is to use option cache . It is expressed like this: QH2' = qlc:q([X || X &lt;- QH2], {cache, ets}) or only QH2' = qlc:q([X || X &lt;- QH2], cache) The effect of option cache is that when generator QH2' is run the first time, every answer is stored in an ETS table. When the next answer of QH1 is tried, answers to QH2' are copied from the ETS table, which is very fast. As for option unique the cost is a possibly substantial amount of RAM memory. Option {cache, list} offers the possibility to store the answers in a list on the process heap. This has the potential of being faster than ETS tables, as there is no need to copy answers from the table. However, it can often result in slower evaluation because of more garbage collections of the process heap and increased RAM memory consumption because of larger heaps. Another drawback with cache lists is that if the list size exceeds a limit, a temporary file is used. Reading the answers from a file is much slower than copying them from an ETS table. But if the available RAM memory is scarce, setting the limit to some low value is an alternative. Option cache_all can be set to ets or list when evaluating a query. It adds a cache or {cache, list} option to every list expression except QLC tables and lists on all levels of the query. This can be used for testing if caching would improve efficiency at all. If the answer is yes, further testing is needed to pinpoint the generators that are to be cached. Implementing a QLC Table As an example of how to use function table/2 , the implementation of a QLC table for the gb_trees module is given: -module(gb_table). -export([table/1]). table(T) -&gt; TF = fun() -&gt; qlc_next(gb_trees:next(gb_trees:iterator(T))) end, InfoFun = fun(num_of_objects) -&gt; gb_trees:size(T); (keypos) -&gt; 1; (is_sorted_key) -&gt; true; (is_unique_objects) -&gt; true; (_) -&gt; undefined end, LookupFun = fun(1, Ks) -&gt; lists:flatmap(fun(K) -&gt; case gb_trees:lookup(K, T) of {value, V} -&gt; [{K,V}]; none -&gt; [] end end, Ks) end, FormatFun = fun({all, NElements, ElementFun}) -&gt; ValsS = io_lib:format(&quot;gb_trees:from_orddict(~w)&quot;, [gb_nodes(T, NElements, ElementFun)]), io_lib:format(&quot;gb_table:table(~s)&quot;, [ValsS]); ({lookup, 1, KeyValues, _NElements, ElementFun}) -&gt; ValsS = io_lib:format(&quot;gb_trees:from_orddict(~w)&quot;, [gb_nodes(T, infinity, ElementFun)]), io_lib:format(&quot;lists:flatmap(fun(K) -&gt; &quot; &quot;case gb_trees:lookup(K, ~s) of &quot; &quot;{value, V} -&gt; [{K,V}];none -&gt; [] end &quot; &quot;end, ~w)&quot;, [ValsS, [ElementFun(KV) || KV &lt;- KeyValues]]) end, qlc:table(TF, [{info_fun, InfoFun}, {format_fun, FormatFun}, {lookup_fun, LookupFun},{key_equality,'=='}]). qlc_next({X, V, S}) -&gt; [{X,V} | fun() -&gt; qlc_next(gb_trees:next(S)) end]; qlc_next(none) -&gt; []. gb_nodes(T, infinity, ElementFun) -&gt; gb_nodes(T, -1, ElementFun); gb_nodes(T, NElements, ElementFun) -&gt; gb_iter(gb_trees:iterator(T), NElements, ElementFun). gb_iter(_I, 0, _EFun) -&gt; '...'; gb_iter(I0, N, EFun) -&gt; case gb_trees:next(I0) of {X, V, I} -&gt; [EFun({X,V}) | gb_iter(I, N-1, EFun)]; none -&gt; [] end. TF is the traversal function. The qlc module requires that there is a way of traversing all objects of the data structure. gb_trees has an iterator function suitable for that purpose. Notice that for each object returned, a new fun is created. As long as the list is not terminated by [] , it is assumed that the tail of the list is a nullary function and that calling the function returns further objects (and functions). The lookup function is optional. It is assumed that the lookup function always finds values much faster than it would take to traverse the table. The first argument is the position of the key. As qlc_next/1 returns the objects as {Key, Value} pairs, the position is 1. Notice that the lookup function is to return {Key, Value} pairs, as the traversal function does. The format function is also optional. It is called by info/1,2 to give feedback at runtime of how the query is to be evaluated. Try to give as good feedback as possible without showing too much details. In the example, at most seven objects of the table are shown. The format function handles two cases: all means that all objects of the table are traversed; {lookup, 1, KeyValues} means that the lookup function is used for looking up key values. Whether the whole table is traversed or only some keys looked up depends on how the query is expressed. If the query has the form qlc:q([T || P &lt;- LE, F]) and P is a tuple, the qlc module analyzes P and F in compile time to find positions of tuple P that are tested for equality to constants. If such a position at runtime turns out to be the key position, the lookup function can be used, otherwise all objects of the table must be traversed. The info function InfoFun returns the key position. There can be indexed positions as well, also returned by the info function. An index is an extra table that makes lookup on some position fast. Mnesia maintains indexes upon request, and introduces so called secondary keys. The qlc module prefers to look up objects using the key before secondary keys regardless of the number of constants to look up. Key Equality Erlang/OTP has two operators for testing term equality: ==/2 and =:=/2 . The difference is all about the integers that can be represented by floats. For example, 2 == 2.0 evaluates to true while 2 =:= 2.0 evaluates to false . Normally this is a minor issue, but the qlc module cannot ignore the difference, which affects the user's choice of operators in QLCs. If the qlc module at compile time can determine that some constant is free of integers, it does not matter which one of ==/2 or =:=/2 is used: 1 &gt; E1 = ets : new ( t , [ set ] ) , % uses =:=/2 for key equality Q1 = qlc : q ( [ K || { K } &lt;- ets : table ( E1 ) , K == 2.71 orelse K == a ] ) , io : format ( &quot; ~s ~n &quot; , [ qlc : info ( Q1 ) ] ) . ets : match_spec_run ( lists : flatmap ( fun ( V ) -&gt; ets : lookup ( # Ref &lt; 0.3098908599 . 2283929601.256025 &gt; , V ) end , [ a , 2.71 ] ) , ets : match_spec_compile ( [ { { &#39;$1&#39; } , [ ] , [ &#39;$1&#39; ] } ] ) ) In the example, operator ==/2 has been handled exactly as =:=/2 would have been handled. However, if it cannot be determined at compile time that some constant is free of integers, and the table uses =:=/2 when comparing keys for equality (see option key_equality ), then the qlc module does not try to look up the constant. The reason is that there is in the general case no upper limit on the number of key values that can compare equal to such a constant; every combination of integers and floats must be looked up: 2 &gt; E2 = ets : new ( t , [ set ] ) , true = ets : insert ( E2 , [ { { 2 , 2 } , a } , { { 2 , 2.0 } , b } , { { 2.0 , 2 } , c } ] ) , F2 = fun ( I ) -&gt; qlc : q ( [ V || { K , V } &lt;- ets : table ( E2 ) , K == I ] ) end , Q2 = F2 ( { 2 , 2 } ) , io : format ( &quot; ~s ~n &quot; , [ qlc : info ( Q2 ) ] ) . ets : table ( # Ref &lt; 0.3098908599 . 2283929601.256125 &gt; , [ { traverse , { select , [ { { &#39;$1&#39; , &#39;$2&#39; } , [ { &#39;==&#39; , &#39;$1&#39; , { const , { 2 , 2 } } } ] , [ &#39;$2&#39; ] } ] } } ] ) 3 &gt; lists : sort ( qlc : e ( Q2 ) ) . [ a , b , c ] Looking up only {2,2} would not return b and c . If the table uses ==/2 when comparing keys for equality, the qlc module looks up the constant regardless of which operator is used in the QLC. However, ==/2 is to be preferred: 4 &gt; E3 = ets : new ( t , [ ordered_set ] ) , % uses ==/2 for key equality true = ets : insert ( E3 , [ { { 2 , 2.0 } , b } ] ) , F3 = fun ( I ) -&gt; qlc : q ( [ V || { K , V } &lt;- ets : table ( E3 ) , K == I ] ) end , Q3 = F3 ( { 2 , 2 } ) , io : format ( &quot; ~s ~n &quot; , [ qlc : info ( Q3 ) ] ) . ets : match_spec_run ( ets : lookup ( # Ref &lt; 0.3098908599 . 2283929601.256211 &gt; , { 2 , 2 } ) , ets : match_spec_compile ( [ { { &#39;$1&#39; , &#39;$2&#39; } , [ ] , [ &#39;$2&#39; ] } ] ) ) 5 &gt; qlc : e ( Q3 ) . [ b ] Lookup join is handled analogously to lookup of constants in a table: if the join operator is ==/2 , and the table where constants are to be looked up uses =:=/2 when testing keys for equality, then the qlc module does not consider lookup join for that table. See Also dets(3) , erl_eval(3) , erlang(3) , error_logger(3) , ets(3) , file(3) , file_sorter(3) , mnesia(3) , shell(3) , Erlang Reference Manual, Programming Examples","ref":"qlc.html","title":"qlc","type":"module"},{"doc":"Returns a query handle. When evaluating query handle QH , all answers to the first query handle in QHL are returned, followed by all answers to the remaining query handles in QHL .","ref":"qlc.html#append/1","title":"qlc.append/1","type":"function"},{"doc":"Returns a query handle. When evaluating query handle QH3 , all answers to QH1 are returned, followed by all answers to QH2 . append(QH1, QH2) is equivalent to append([QH1, QH2]) .","ref":"qlc.html#append/2","title":"qlc.append/2","type":"function"},{"doc":"Creates a query cursor and makes the calling process the owner of the cursor. The cursor is to be used as argument to next_answers/1,2 and (eventually) delete_cursor/1 . Calls erlang:spawn_opt/2 to spawn and link to a process that evaluates the query handle. The value of option spawn_options is used as last argument when calling spawn_opt/2 . Defaults to [link] . Example: 1 &gt; QH = qlc : q ( [ { X , Y } || X &lt;- [ a , b ] , Y &lt;- [ 1 , 2 ] ] ) , QC = qlc : cursor ( QH ) , qlc : next_answers ( QC , 1 ) . [ { a , 1 } ] 2 &gt; qlc : next_answers ( QC , 1 ) . [ { a , 2 } ] 3 &gt; qlc : next_answers ( QC , all_remaining ) . [ { b , 1 } , { b , 2 } ] 4 &gt; qlc : delete_cursor ( QC ) . ok cursor(QH) is equivalent to cursor(QH, []) .","ref":"qlc.html#cursor/1","title":"qlc.cursor/1","type":"function"},{"doc":"","ref":"qlc.html#cursor/2","title":"qlc.cursor/2","type":"function"},{"doc":"Deletes a query cursor. Only the owner of the cursor can delete the cursor.","ref":"qlc.html#delete_cursor/1","title":"qlc.delete_cursor/1","type":"function"},{"doc":"Evaluates a query handle in the calling process and collects all answers in a list. Example: 1 &gt; QH = qlc : q ( [ { X , Y } || X &lt;- [ a , b ] , Y &lt;- [ 1 , 2 ] ] ) , qlc : eval ( QH ) . [ { a , 1 } , { a , 2 } , { b , 1 } , { b , 2 } ] eval(QH) is equivalent to eval(QH, []) .","ref":"qlc.html#e/1","title":"qlc.e/1","type":"function"},{"doc":"","ref":"qlc.html#e/2","title":"qlc.e/2","type":"function"},{"doc":"","ref":"qlc.html#eval/1","title":"qlc.eval/1","type":"function"},{"doc":"","ref":"qlc.html#eval/2","title":"qlc.eval/2","type":"function"},{"doc":"Calls Function on successive answers to the query handle together with an extra argument AccIn . The query handle and the function are evaluated in the calling process. Function must return a new accumulator, which is passed to the next call. Acc0 is returned if there are no answers to the query handle. Example: 1 &gt; QH = [ 1 , 2 , 3 , 4 , 5 , 6 ] , qlc : fold ( fun ( X , Sum ) -&gt; X + Sum end , 0 , QH ) . 21 fold(Function, Acc0, QH) is equivalent to fold(Function, Acc0, QH, []) .","ref":"qlc.html#fold/3","title":"qlc.fold/3","type":"function"},{"doc":"","ref":"qlc.html#fold/4","title":"qlc.fold/4","type":"function"},{"doc":"Returns a descriptive string in English of an error tuple returned by some of the functions of the qlc module or the parse transform. This function is mainly used by the compiler invoking the parse transform.","ref":"qlc.html#format_error/1","title":"qlc.format_error/1","type":"function"},{"doc":"Returns information about a query handle. The information describes the simplifications and optimizations that are the results of preparing the query for evaluation. This function is probably mainly useful during debugging. The information has the form of an Erlang expression where QLCs most likely occur. Depending on the format functions of mentioned QLC tables, it is not certain that the information is absolutely accurate. Options: The default is to return a sequence of QLCs in a block, but if option {flat, false} is specified, one single QLC is returned. The default is to return a string, but if option {format, abstract_code} is specified, abstract code is returned instead. In the abstract code, port identifiers, references, and pids are represented by strings. The default is to return all elements in lists, but if option {n_elements, NElements} is specified, only a limited number of elements are returned. The default is to show all parts of objects and match specifications, but if option {depth, Depth} is specified, parts of terms below a certain depth are replaced by '...' . info(QH) is equivalent to info(QH, []) . Examples: In the following example two simple QLCs are inserted only to hold option {unique, true} : 1 &gt; QH = qlc : q ( [ { X , Y } || X &lt;- [ x , y ] , Y &lt;- [ a , b ] ] ) , io : format ( &quot; ~s ~n &quot; , [ qlc : info ( QH , unique_all ) ] ) . begin V1 = qlc : q ( [ SQV || SQV &lt;- [ x , y ] ] , [ { unique , true } ] ) , V2 = qlc : q ( [ SQV || SQV &lt;- [ a , b ] ] , [ { unique , true } ] ) , qlc : q ( [ { X , Y } || X &lt;- V1 , Y &lt;- V2 ] , [ { unique , true } ] ) end In the following example QLC V2 has been inserted to show the joined generators and the join method chosen. A convention is used for lookup join: the first generator ( G2 ) is the one traversed, the second ( G1 ) is the table where constants are looked up. 1 &gt; E1 = ets : new ( e1 , [ ] ) , E2 = ets : new ( e2 , [ ] ) , true = ets : insert ( E1 , [ { 1 , a } , { 2 , b } ] ) , true = ets : insert ( E2 , [ { a , 1 } , { b , 2 } ] ) , Q = qlc : q ( [ { X , Z , W } || { X , Z } &lt;- ets : table ( E1 ) , { W , Y } &lt;- ets : table ( E2 ) , X =:= Y ] ) , io : format ( &quot; ~s ~n &quot; , [ qlc : info ( Q ) ] ) . begin V1 = qlc : q ( [ P0 || P0 = { W , Y } &lt;- ets : table ( # Ref &lt; 0.3098908599 . 2283929601.256549 &gt; ) ] ) , V2 = qlc : q ( [ [ G1 | G2 ] || G2 &lt;- V1 , G1 &lt;- ets : table ( # Ref &lt; 0.3098908599 . 2283929601.256548 &gt; ) , element ( 2 , G1 ) =:= element ( 1 , G2 ) ] , [ { join , lookup } ] ) , qlc : q ( [ { X , Z , W } || [ { X , Z } | { W , Y } ] &lt;- V2 ] ) end","ref":"qlc.html#info/1","title":"qlc.info/1","type":"function"},{"doc":"","ref":"qlc.html#info/2","title":"qlc.info/2","type":"function"},{"doc":"Returns a query handle. When evaluating query handle QH2 , the answers to query handle QH1 are sorted by file_sorter:keysort/4 according to the options. The sorter uses temporary files only if QH1 does not evaluate to a list and the size of the binary representation of the answers exceeds Size bytes, where Size is the value of option size . keysort(KeyPos, QH1) is equivalent to keysort(KeyPos, QH1, []) .","ref":"qlc.html#keysort/2","title":"qlc.keysort/2","type":"function"},{"doc":"","ref":"qlc.html#keysort/3","title":"qlc.keysort/3","type":"function"},{"doc":"Returns some or all of the remaining answers to a query cursor. Only the owner of QueryCursor can retrieve answers. Optional argument NumberOfAnswers determines the maximum number of answers returned. Defaults to 10 . If less than the requested number of answers is returned, subsequent calls to next_answers return [] .","ref":"qlc.html#next_answers/1","title":"qlc.next_answers/1","type":"function"},{"doc":"","ref":"qlc.html#next_answers/2","title":"qlc.next_answers/2","type":"function"},{"doc":"Returns a query handle for a QLC. The QLC must be the first argument to this function, otherwise it is evaluated as an ordinary list comprehension. It is also necessary to add the following line to the source code: -include_lib(&quot;stdlib/include/qlc.hrl&quot;). This causes a parse transform to substitute a fun for the QLC. The (compiled) fun is called when the query handle is evaluated. When calling qlc:q/1,2 from the Erlang shell, the parse transform is automatically called. When this occurs, the fun substituted for the QLC is not compiled but is evaluated by erl_eval(3) . This is also true when expressions are evaluated by file:eval/1,2 or in the debugger. To be explicit, this does not work: . . . A = [ X || { X } &lt;- [ { 1 } , { 2 } ] ] , QH = qlc : q ( A ) , . . . Variable A is bound to the evaluated value of the list comprehension ( [1,2] ). The compiler complains with an error message (&quot;argument is not a query list comprehension&quot;); the shell process stops with a badarg reason. q(QLC) is equivalent to q(QLC, []) . Options: Option {cache, ets} can be used to cache the answers to a QLC. The answers are stored in one ETS table for each cached QLC. When a cached QLC is evaluated again, answers are fetched from the table without any further computations. Therefore, when all answers to a cached QLC have been found, the ETS tables used for caching answers to the qualifiers of the QLC can be emptied. Option cache is equivalent to {cache, ets} . Option {cache, list} can be used to cache the answers to a QLC like {cache, ets} . The difference is that the answers are kept in a list (on the process heap). If the answers would occupy more than a certain amount of RAM memory, a temporary file is used for storing the answers. Option max_list_size sets the limit in bytes and the temporary file is put on the directory set by option tmpdir . Option cache has no effect if it is known that the QLC is to be evaluated at most once. This is always true for the top-most QLC and also for the list expression of the first generator in a list of qualifiers. Notice that in the presence of side effects in filters or callback functions, the answers to QLCs can be affected by option cache . Option {unique, true} can be used to remove duplicate answers to a QLC. The unique answers are stored in one ETS table for each QLC. The table is emptied every time it is known that there are no more answers to the QLC. Option unique is equivalent to {unique, true} . If option unique is combined with option {cache, ets} , two ETS tables are used, but the full answers are stored in one table only. If option unique is combined with option {cache, list} , the answers are sorted twice using keysort/3 ; once to remove duplicates and once to restore the order. Options cache and unique apply not only to the QLC itself but also to the results of looking up constants, running match specifications, and joining handles. Example: In the following example the cached results of the merge join are traversed for each value of A . Notice that without option cache the join would have been carried out three times, once for each value of A . 1 &gt; Q = qlc : q ( [ { A , X , Z , W } || A &lt;- [ a , b , c ] , { X , Z } &lt;- [ { a , 1 } , { b , 4 } , { c , 6 } ] , { W , Y } &lt;- [ { 2 , a } , { 3 , b } , { 4 , c } ] , X =:= Y ] , { cache , list } ) , io : format ( &quot; ~s ~n &quot; , [ qlc : info ( Q ) ] ) . begin V1 = qlc : q ( [ P0 || P0 = { X , Z } &lt;- qlc : keysort ( 1 , [ { a , 1 } , { b , 4 } , { c , 6 } ] , [ ] ) ] ) , V2 = qlc : q ( [ P0 || P0 = { W , Y } &lt;- qlc : keysort ( 2 , [ { 2 , a } , { 3 , b } , { 4 , c } ] , [ ] ) ] ) , V3 = qlc : q ( [ [ G1 | G2 ] || G1 &lt;- V1 , G2 &lt;- V2 , element ( 1 , G1 ) == element ( 2 , G2 ) ] , [ { join , merge } , { cache , list } ] ) , qlc : q ( [ { A , X , Z , W } || A &lt;- [ a , b , c ] , [ { X , Z } | { W , Y } ] &lt;- V3 , X =:= Y ] ) end sort/1,2 and keysort/2,3 can also be used for caching answers and for removing duplicates. When sorting answers are cached in a list, possibly stored on a temporary file, and no ETS tables are used. Sometimes (see table/2 ) traversal of tables can be done by looking up key values, which is assumed to be fast. Under certain (rare) circumstances there can be too many key values to look up. Option {max_lookup, MaxLookup} can then be used to limit the number of lookups: if more than MaxLookup lookups would be required, no lookups are done but the table is traversed instead. Defaults to infinity , which means that there is no limit on the number of keys to look up. Example: In the following example, using the gb_table module from section Implementing a QLC Table , there are six keys to look up: {1,a} , {1,b} , {1,c} , {2,a} , {2,b} , and {2,c} . The reason is that the two elements of key {X, Y} are compared separately. 1 &gt; T = gb_trees : empty ( ) , QH = qlc : q ( [ X || { { X , Y } , _ } &lt;- gb_table : table ( T ) , ( ( X == 1 ) or ( X == 2 ) ) andalso ( ( Y == a ) or ( Y == b ) or ( Y == c ) ) ] ) , io : format ( &quot; ~s ~n &quot; , [ qlc : info ( QH ) ] ) . ets : match_spec_run ( lists : flatmap ( fun ( K ) -&gt; case gb_trees : lookup ( K , gb_trees : from_orddict ( [ ] ) ) of { value , V } -&gt; [ { K , V } ] ; none -&gt; [ ] end end , [ { 1 , a } , { 1 , b } , { 1 , c } , { 2 , a } , { 2 , b } , { 2 , c } ] ) , ets : match_spec_compile ( [ { { { &#39;$1&#39; , &#39;$2&#39; } , &#39;_&#39; } , [ ] , [ &#39;$1&#39; ] } ] ) ) Options: Option {lookup, true} can be used to ensure that the qlc module looks up constants in some QLC table. If there are more than one QLC table among the list expressions of the generators, constants must be looked up in at least one of the tables. The evaluation of the query fails if there are no constants to look up. This option is useful when it would be unacceptable to traverse all objects in some table. Setting option lookup to false ensures that no constants are looked up ( {max_lookup, 0} has the same effect). Defaults to any , which means that constants are looked up whenever possible. Option {join, Join} can be used to ensure that a certain join method is used: {join, lookup} invokes the lookup join method. {join, merge} invokes the merge join method. {join, nested_loop} invokes the method of matching every pair of objects from two handles. This method is mostly very slow. The evaluation of the query fails if the qlc module cannot carry out the chosen join method. Defaults to any , which means that some fast join method is used if possible.","ref":"qlc.html#q/1","title":"qlc.q/1","type":"function"},{"doc":"","ref":"qlc.html#q/2","title":"qlc.q/2","type":"function"},{"doc":"Returns a query handle. When evaluating query handle QH2 , the answers to query handle QH1 are sorted by file_sorter:sort/3 according to the options. The sorter uses temporary files only if QH1 does not evaluate to a list and the size of the binary representation of the answers exceeds Size bytes, where Size is the value of option size . sort(QH1) is equivalent to sort(QH1, []) .","ref":"qlc.html#sort/1","title":"qlc.sort/1","type":"function"},{"doc":"","ref":"qlc.html#sort/2","title":"qlc.sort/2","type":"function"},{"doc":"A string version of q/1,2 . When the query handle is evaluated, the fun created by the parse transform is interpreted by erl_eval(3) . The query string is to be one single QLC terminated by a period. Example: 1 &gt; L = [ 1 , 2 , 3 ] , Bs = erl_eval : add_binding ( &#39;L&#39; , L , erl_eval : new_bindings ( ) ) , QH = qlc : string_to_handle ( &quot;[X+1 || X &lt;- L].&quot; , [ ] , Bs ) , qlc : eval ( QH ) . [ 2 , 3 , 4 ] string_to_handle(QueryString) is equivalent to string_to_handle(QueryString, []) . string_to_handle(QueryString, Options) is equivalent to string_to_handle(QueryString, Options, erl_eval:new_bindings()) . This function is probably mainly useful when called from outside of Erlang, for example from a driver written in C.","ref":"qlc.html#string_to_handle/1","title":"qlc.string_to_handle/1","type":"function"},{"doc":"","ref":"qlc.html#string_to_handle/2","title":"qlc.string_to_handle/2","type":"function"},{"doc":"","ref":"qlc.html#string_to_handle/3","title":"qlc.string_to_handle/3","type":"function"},{"doc":"Returns a query handle for a QLC table. In Erlang/OTP there is support for ETS, Dets, and Mnesia tables, but many other data structures can be turned into QLC tables. This is accomplished by letting function(s) in the module implementing the data structure create a query handle by calling qlc:table/2 . The different ways to traverse the table and properties of the table are handled by callback functions provided as options to qlc:table/2 . Callback function TraverseFun is used for traversing the table. It is to return a list of objects terminated by either [] or a nullary fun to be used for traversing the not yet traversed objects of the table. Any other return value is immediately returned as value of the query evaluation. Unary TraverseFun s are to accept a match specification as argument. The match specification is created by the parse transform by analyzing the pattern of the generator calling qlc:table/2 and filters using variables introduced in the pattern. If the parse transform cannot find a match specification equivalent to the pattern and filters, TraverseFun is called with a match specification returning every object. Modules that can use match specifications for optimized traversal of tables are to call qlc:table/2 with an unary TraverseFun . An example is ets:table/2 . Other modules can provide a nullary TraverseFun . An example is gb_table:table/1 in section Implementing a QLC Table . Unary callback function PreFun is called once before the table is read for the first time. If the call fails, the query evaluation fails. Argument PreArgs is a list of tagged values. There are two tags, parent_value and stop_fun , used by Mnesia for managing transactions. The value of parent_value is the value returned by ParentFun , or undefined if there is no ParentFun . ParentFun is called once just before the call of PreFun in the context of the process calling eval/1,2 , fold/3,4 , or cursor/1,2 . The value of stop_fun is a nullary fun that deletes the cursor if called from the parent, or undefined if there is no cursor. Nullary callback function PostFun is called once after the table was last read. The return value, which is caught, is ignored. If PreFun has been called for a table, PostFun is guaranteed to be called for that table, even if the evaluation of the query fails for some reason. The pre (post) functions for different tables are evaluated in unspecified order. Other table access than reading, such as calling InfoFun , is assumed to be OK at any time. Binary callback function LookupFun is used for looking up objects in the table. The first argument Position is the key position or an indexed position and the second argument Keys is a sorted list of unique values. The return value is to be a list of all objects (tuples), such that the element at Position is a member of Keys . Any other return value is immediately returned as value of the query evaluation. LookupFun is called instead of traversing the table if the parse transform at compile time can determine that the filters match and compare the element at Position in such a way that only Keys need to be looked up to find all potential answers. The key position is obtained by calling InfoFun(keypos) and the indexed positions by calling InfoFun(indices) . If the key position can be used for lookup, it is always chosen, otherwise the indexed position requiring the least number of lookups is chosen. If there is a tie between two indexed positions, the one occurring first in the list returned by InfoFun is chosen. Positions requiring more than max_lookup lookups are ignored. Unary callback function InfoFun is to return information about the table. undefined is to be returned if the value of some tag is unknown: indices Returns a list of indexed positions, a list of positive integers. is_unique_objects Returns true if the objects returned by TraverseFun are unique. keypos Returns the position of the table key, a positive integer. is_sorted_key Returns true if the objects returned by TraverseFun are sorted on the key. num_of_objects Returns the number of objects in the table, a non-negative integer. Unary callback function FormatFun is used by info/1,2 for displaying the call that created the query handle of the table. Defaults to undefined , which means that info/1,2 displays a call to '$MOD':'$FUN'/0 . It is up to FormatFun to present the selected objects of the table in a suitable way. However, if a character list is chosen for presentation, it must be an Erlang expression that can be scanned and parsed (a trailing dot is added by info/1,2 though). FormatFun is called with an argument that describes the selected objects based on optimizations done as a result of analyzing the filters of the QLC where the call to qlc:table/2 occurs. The argument can have the following values: {lookup, Position, Keys, NElements, DepthFun} . LookupFun is used for looking up objects in the table. {match_spec, MatchExpression} No way of finding all possible answers by looking up keys was found, but the filters could be transformed into a match specification. All answers are found by calling TraverseFun(MatchExpression) . {all, NElements, DepthFun} No optimization was found. A match specification matching all objects is used if TraverseFun is unary. NElements is the value of the info/1,2 option n_elements . DepthFun is a function that can be used for limiting the size of terms; calling DepthFun(Term) substitutes '...' for parts of Term below the depth specified by the info/1,2 option depth . If calling FormatFun with an argument including NElements and DepthFun fails, FormatFun is called once again with an argument excluding NElements and DepthFun ( {lookup, Position, Keys} or all ). The value of option key_equality is to be '=:=' if the table considers two keys equal if they match, and to be '==' if two keys are equal if they compare equal. Defaults to '=:=' . For the various options recognized by table/1,2 in respective module, see ets(3) , dets(3) , and mnesia(3) .","ref":"qlc.html#table/2","title":"qlc.table/2","type":"function"},{"doc":"Parse trees for Erlang expression, see section The Abstract Format in the ERTS User's Guide.","ref":"qlc.html#t:abstract_expr/0","title":"qlc.abstract_expr/0","type":"type"},{"doc":"","ref":"qlc.html#t:answer/0","title":"qlc.answer/0","type":"type"},{"doc":"","ref":"qlc.html#t:answers/0","title":"qlc.answers/0","type":"type"},{"doc":"","ref":"qlc.html#t:cache/0","title":"qlc.cache/0","type":"type"},{"doc":"","ref":"qlc.html#t:key_pos/0","title":"qlc.key_pos/0","type":"type"},{"doc":"Match specification, see section Match Specifications in Erlang in the ERTS User's Guide and ms_transform(3) .","ref":"qlc.html#t:match_expression/0","title":"qlc.match_expression/0","type":"type"},{"doc":"","ref":"qlc.html#t:max_list_size/0","title":"qlc.max_list_size/0","type":"type"},{"doc":"An integer &gt; 1.","ref":"qlc.html#t:no_files/0","title":"qlc.no_files/0","type":"type"},{"doc":"","ref":"qlc.html#t:order/0","title":"qlc.order/0","type":"type"},{"doc":"","ref":"qlc.html#t:order_fun/0","title":"qlc.order_fun/0","type":"type"},{"doc":"A query cursor .","ref":"qlc.html#t:query_cursor/0","title":"qlc.query_cursor/0","type":"opaque"},{"doc":"A query handle .","ref":"qlc.html#t:query_handle/0","title":"qlc.query_handle/0","type":"opaque"},{"doc":"","ref":"qlc.html#t:query_handle_or_list/0","title":"qlc.query_handle_or_list/0","type":"type"},{"doc":"A literal query list comprehension .","ref":"qlc.html#t:query_list_comprehension/0","title":"qlc.query_list_comprehension/0","type":"type"},{"doc":"See file_sorter(3) .","ref":"qlc.html#t:sort_option/0","title":"qlc.sort_option/0","type":"type"},{"doc":"","ref":"qlc.html#t:sort_options/0","title":"qlc.sort_options/0","type":"type"},{"doc":"","ref":"qlc.html#t:spawn_options/0","title":"qlc.spawn_options/0","type":"type"},{"doc":"","ref":"qlc.html#t:tmp_directory/0","title":"qlc.tmp_directory/0","type":"type"},{"doc":"","ref":"qlc.html#t:tmp_file_usage/0","title":"qlc.tmp_file_usage/0","type":"type"},{"doc":"This module provides (double-ended) FIFO queues in an efficient manner. All functions fail with reason badarg if arguments are of wrong type, for example, queue arguments are not queues, indexes are not integers, and list arguments are not lists. Improper lists cause internal crashes. An index out of range for a queue also causes a failure with reason badarg . Some functions, where noted, fail with reason empty for an empty queue. The data representing a queue as used by this module is to be regarded as opaque by other modules. Any code assuming knowledge of the format is running on thin ice. All operations have an amortized O(1) running time, except all/2 , any/2 , delete/2 , delete_r/2 , delete_with/2 , delete_with_r/2 , filter/2 , filtermap/2 , fold/3 , join/2 , len/1 , member/2 , split/2 that have O(n). To minimize the size of a queue minimizing the amount of garbage built by queue operations, the queues do not contain explicit length information, and that is why len/1 is O(n). If better performance for this particular operation is essential, it is easy for the caller to keep track of the length. Queues are double-ended. The mental picture of a queue is a line of people (items) waiting for their turn. The queue front is the end with the item that has waited the longest. The queue rear is the end an item enters when it starts to wait. If instead using the mental picture of a list, the front is called head and the rear is called tail. Entering at the front and exiting at the rear are reverse operations on the queue. This module has three sets of interface functions: the &quot;Original API&quot;, the &quot;Extended API&quot;, and the &quot;Okasaki API&quot;. The &quot;Original API&quot; and the &quot;Extended API&quot; both use the mental picture of a waiting line of items. Both have reverse operations suffixed &quot;_r&quot;. The &quot;Original API&quot; item removal functions return compound terms with both the removed item and the resulting queue. The &quot;Extended API&quot; contains alternative functions that build less garbage and functions for just inspecting the queue ends. Also the &quot;Okasaki API&quot; functions build less garbage. The &quot;Okasaki API&quot; is inspired by &quot;Purely Functional Data Structures&quot; by Chris Okasaki. It regards queues as lists. This API is by many regarded as strange and avoidable. For example, many reverse operations have lexically reversed names, some with more readable but perhaps less understandable aliases.","ref":"queue.html","title":"queue","type":"module"},{"doc":"Returns true if Pred(Item) returns true for all items Item in Q , otherwise false .","ref":"queue.html#all/2","title":"queue.all/2","type":"function"},{"doc":"Returns true if Pred(Item) returns true for at least one item Item in Q , otherwise false .","ref":"queue.html#any/2","title":"queue.any/2","type":"function"},{"doc":"Inserts Item at the head of queue Q1 . Returns the new queue Q2 .","ref":"queue.html#cons/2","title":"queue.cons/2","type":"function"},{"doc":"Returns the tail item of queue Q . Fails with reason empty if Q is empty.","ref":"queue.html#daeh/1","title":"queue.daeh/1","type":"function"},{"doc":"Returns a copy of Q1 where the first item matching Item is deleted, if there is such an item.","ref":"queue.html#delete/2","title":"queue.delete/2","type":"function"},{"doc":"Returns a copy of Q1 where the last item matching Item is deleted, if there is such an item.","ref":"queue.html#delete_r/2","title":"queue.delete_r/2","type":"function"},{"doc":"Returns a copy of Q1 where the first item for which Pred returns true is deleted, if there is such an item.","ref":"queue.html#delete_with/2","title":"queue.delete_with/2","type":"function"},{"doc":"Returns a copy of Q1 where the last item for which Pred returns true is deleted, if there is such an item.","ref":"queue.html#delete_with_r/2","title":"queue.delete_with_r/2","type":"function"},{"doc":"Returns a queue Q2 that is the result of removing the front item from Q1 . Fails with reason empty if Q1 is empty.","ref":"queue.html#drop/1","title":"queue.drop/1","type":"function"},{"doc":"Returns a queue Q2 that is the result of removing the rear item from Q1 . Fails with reason empty if Q1 is empty.","ref":"queue.html#drop_r/1","title":"queue.drop_r/1","type":"function"},{"doc":"Returns a queue Q2 that is the result of calling Fun(Item) on all items in Q1 . If Fun(Item) returns true , Item is copied to the result queue. If it returns false , Item is not copied. If it returns a list, the list elements are inserted instead of Item in the result queue. So, Fun(Item) returning [Item] is thereby semantically equivalent to returning true , just as returning [] is semantically equivalent to returning false . But returning a list builds more garbage than returning an atom.","ref":"queue.html#filter/2","title":"queue.filter/2","type":"function"},{"doc":"Returns a queue Q2 that is the result of calling Fun(Item) on all items in Q1 . If Fun(Item) returns true , Item is copied to the result queue. If it returns false , Item is not copied. If it returns {true, NewItem} , the queue element at this position is replaced with NewItem in the result queue.","ref":"queue.html#filtermap/2","title":"queue.filtermap/2","type":"function"},{"doc":"Calls Fun(Item, AccIn) on successive items Item of Queue , starting with AccIn == Acc0 . The queue is traversed in queue order, that is, from front to rear. Fun/2 must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. Acc0 is returned if the queue is empty. Example: &gt; queue : fold ( fun ( X , Sum ) -&gt; X + Sum end , 0 , queue : from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) ) . 15 &gt; queue : fold ( fun ( X , Prod ) -&gt; X * Prod end , 1 , queue : from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) ) . 120","ref":"queue.html#fold/3","title":"queue.fold/3","type":"function"},{"doc":"Returns a queue containing the items in L in the same order; the head item of the list becomes the front item of the queue.","ref":"queue.html#from_list/1","title":"queue.from_list/1","type":"function"},{"doc":"Returns Item at the front of queue Q . Fails with reason empty if Q is empty.","ref":"queue.html#get/1","title":"queue.get/1","type":"function"},{"doc":"Returns Item at the rear of queue Q . Fails with reason empty if Q is empty.","ref":"queue.html#get_r/1","title":"queue.get_r/1","type":"function"},{"doc":"Returns Item from the head of queue Q . Fails with reason empty if Q is empty.","ref":"queue.html#head/1","title":"queue.head/1","type":"function"},{"doc":"Inserts Item at the rear of queue Q1 . Returns the resulting queue Q2 .","ref":"queue.html#in/2","title":"queue.in/2","type":"function"},{"doc":"Inserts Item at the front of queue Q1 . Returns the resulting queue Q2 .","ref":"queue.html#in_r/2","title":"queue.in_r/2","type":"function"},{"doc":"Returns a queue Q2 that is the result of removing the tail item from Q1 . Fails with reason empty if Q1 is empty.","ref":"queue.html#init/1","title":"queue.init/1","type":"function"},{"doc":"Tests if Q is empty and returns true if so, otherwise false .","ref":"queue.html#is_empty/1","title":"queue.is_empty/1","type":"function"},{"doc":"Tests if Term is a queue and returns true if so, otherwise false .","ref":"queue.html#is_queue/1","title":"queue.is_queue/1","type":"function"},{"doc":"Returns a queue Q3 that is the result of joining Q1 and Q2 with Q1 in front of Q2 .","ref":"queue.html#join/2","title":"queue.join/2","type":"function"},{"doc":"Returns a queue Q2 that is the result of removing the tail item from Q1 . Fails with reason empty if Q1 is empty. The name lait/1 is a misspelling - do not use it anymore.","ref":"queue.html#lait/1","title":"queue.lait/1","type":"function"},{"doc":"Returns the tail item of queue Q . Fails with reason empty if Q is empty.","ref":"queue.html#last/1","title":"queue.last/1","type":"function"},{"doc":"Calculates and returns the length of queue Q .","ref":"queue.html#len/1","title":"queue.len/1","type":"function"},{"doc":"Returns a queue Q2 that is the result of removing the tail item from Q1 . Fails with reason empty if Q1 is empty.","ref":"queue.html#liat/1","title":"queue.liat/1","type":"function"},{"doc":"Returns true if Item matches some element in Q , otherwise false .","ref":"queue.html#member/2","title":"queue.member/2","type":"function"},{"doc":"Returns an empty queue.","ref":"queue.html#new/0","title":"queue.new/0","type":"function"},{"doc":"Removes the item at the front of queue Q1 . Returns tuple {{value, Item}, Q2} , where Item is the item removed and Q2 is the resulting queue. If Q1 is empty, tuple {empty, Q1} is returned.","ref":"queue.html#out/1","title":"queue.out/1","type":"function"},{"doc":"Removes the item at the rear of queue Q1 . Returns tuple {{value, Item}, Q2} , where Item is the item removed and Q2 is the new queue. If Q1 is empty, tuple {empty, Q1} is returned.","ref":"queue.html#out_r/1","title":"queue.out_r/1","type":"function"},{"doc":"Returns tuple {value, Item} , where Item is the front item of Q , or empty if Q is empty.","ref":"queue.html#peek/1","title":"queue.peek/1","type":"function"},{"doc":"Returns tuple {value, Item} , where Item is the rear item of Q , or empty if Q is empty.","ref":"queue.html#peek_r/1","title":"queue.peek_r/1","type":"function"},{"doc":"Returns a queue Q2 containing the items of Q1 in the reverse order.","ref":"queue.html#reverse/1","title":"queue.reverse/1","type":"function"},{"doc":"Inserts Item as the tail item of queue Q1 . Returns the new queue Q2 .","ref":"queue.html#snoc/2","title":"queue.snoc/2","type":"function"},{"doc":"Splits Q1 in two. The N front items are put in Q2 and the rest in Q3 .","ref":"queue.html#split/2","title":"queue.split/2","type":"function"},{"doc":"Returns a queue Q2 that is the result of removing the head item from Q1 . Fails with reason empty if Q1 is empty.","ref":"queue.html#tail/1","title":"queue.tail/1","type":"function"},{"doc":"Returns a list of the items in the queue in the same order; the front item of the queue becomes the head of the list.","ref":"queue.html#to_list/1","title":"queue.to_list/1","type":"function"},{"doc":"","ref":"queue.html#t:queue/0","title":"queue.queue/0","type":"type"},{"doc":"As returned by new/0 .","ref":"queue.html#t:queue/1","title":"queue.queue/1","type":"opaque"},{"doc":"This module provides a pseudo random number generator. The module contains a number of algorithms. The uniform distribution algorithms are based on the Xoroshiro and Xorshift algorithms by Sebastiano Vigna. The normal distribution algorithm uses the Ziggurat Method by Marsaglia and Tsang on top of the uniform distribution algorithm. For most algorithms, jump functions are provided for generating non-overlapping sequences for parallel computations. The jump functions perform calculations equivalent to perform a large number of repeated calls for calculating new states. The following algorithms are provided: exsss Xorshift116**, 58 bits precision and period of 2^116-1 Jump function: equivalent to 2^64 calls This is the Xorshift116 generator combined with the StarStar scrambler from the 2018 paper by David Blackman and Sebastiano Vigna: Scrambled Linear Pseudorandom Number Generators The generator does not need 58-bit rotates so it is faster than the Xoroshiro116 generator, and when combined with the StarStar scrambler it does not have any weak low bits like exrop (Xoroshiro116+). Alas, this combination is about 10% slower than exrop , but is despite that the default algorithm thanks to its statistical qualities. exro928ss Xoroshiro928**, 58 bits precision and a period of 2^928-1 Jump function: equivalent to 2^512 calls This is a 58 bit version of Xoroshiro1024**, from the 2018 paper by David Blackman and Sebastiano Vigna: Scrambled Linear Pseudorandom Number Generators that on a 64 bit Erlang system executes only about 40% slower than the default exsss algorithm but with much longer period and better statistical properties, but on the flip side a larger state. Many thanks to Sebastiano Vigna for his help with the 58 bit adaption. exrop Xoroshiro116+, 58 bits precision and period of 2^116-1 Jump function: equivalent to 2^64 calls exs1024s Xorshift1024*, 64 bits precision and a period of 2^1024-1 Jump function: equivalent to 2^512 calls exsp Xorshift116+, 58 bits precision and period of 2^116-1 Jump function: equivalent to 2^64 calls This is a corrected version of the previous default algorithm , that now has been superseded by Xoroshiro116+ ( exrop ). Since there is no native 58 bit rotate instruction this algorithm executes a little (say &lt; 15%) faster than exrop . See the algorithms' homepage . The current default algorithm is exsss (Xorshift116**). If a specific algorithm is required, ensure to always use seed/1 to initialize the state. Which algorithm that is the default may change between Erlang/OTP releases, and is selected to be one with high speed, small state and &quot;good enough&quot; statistical properties. Undocumented (old) algorithms are deprecated but still implemented so old code relying on them will produce the same pseudo random sequences as before. There were a number of problems in the implementation of the now undocumented algorithms, which is why they are deprecated. The new algorithms are a bit slower but do not have these problems: Uniform integer ranges had a skew in the probability distribution that was not noticable for small ranges but for large ranges less than the generator's precision the probability to produce a low number could be twice the probability for a high. Uniform integer ranges larger than or equal to the generator's precision used a floating point fallback that only calculated with 52 bits which is smaller than the requested range and therefore were not all numbers in the requested range even possible to produce. Uniform floats had a non-uniform density so small values i.e less than 0.5 had got smaller intervals decreasing as the generated value approached 0.0 although still uniformly distributed for sufficiently large subranges. The new algorithms produces uniformly distributed floats on the form N * 2.0^(-53) hence equally spaced. Every time a random number is requested, a state is used to calculate it and a new state is produced. The state can either be implicit or be an explicit argument and return value. The functions with implicit state use the process dictionary variable rand_seed to remember the current state. If a process calls uniform/0 , uniform/1 or uniform_real/0 without setting a seed first, seed/1 is called automatically with the default algorithm and creates a non-constant seed. The functions with explicit state never use the process dictionary. Examples: Simple use; creates and seeds the default algorithm with a non-constant seed if not already done: R0 = rand : uniform ( ) , R1 = rand : uniform ( ) , Use a specified algorithm: _ = rand : seed ( exs928ss ) , R2 = rand : uniform ( ) , Use a specified algorithm with a constant seed: _ = rand : seed ( exs928ss , { 123 , 123534 , 345345 } ) , R3 = rand : uniform ( ) , Use the functional API with a non-constant seed: S0 = rand : seed_s ( exsss ) , { R4 , S1 } = rand : uniform_s ( S0 ) , Textbook basic form Box-Muller standard normal deviate R5 = rand : uniform_real ( ) , R6 = rand : uniform ( ) , SND0 = math : sqrt ( - 2 * math : log ( R5 ) ) * math : cos ( math : pi ( ) * R6 ) Create a standard normal deviate: { SND1 , S2 } = rand : normal_s ( S1 ) , Create a normal deviate with mean -3 and variance 0.5: { ND0 , S3 } = rand : normal_s ( - 3 , 0.5 , S2 ) , The builtin random number generator algorithms are not cryptographically strong. If a cryptographically strong random number generator is needed, use something like crypto:rand_seed/0 . For all these generators except exro928ss and exsss the lowest bit(s) has got a slightly less random behaviour than all other bits. 1 bit for exrop (and exsp ), and 3 bits for exs1024s . See for example the explanation in the Xoroshiro128+ generator source code: Beside passing BigCrush , this generator passes the PractRand test suite up to ( and included ) 16 TB , with the exception of binary rank tests , which fail due to the lowest bit being an LFSR ; all other bits pass all tests . We suggest to use a sign test to extract a random Boolean value . If this is a problem; to generate a boolean with these algorithms use something like this: ( rand : uniform ( 16 ) &gt; 8 ) And for a general range, with N = 1 for exrop , and N = 3 for exs1024s : ( ( ( rand : uniform ( Range bsl N ) - 1 ) bsr N ) + 1 ) The floating point generating functions in this module waste the lowest bits when converting from an integer so they avoid this snag.","ref":"rand.html","title":"rand","type":"module"},{"doc":"Returns, for a specified integer N &gt;= 0 , a binary() with that number of random bytes. Generates as many random numbers as required using the selected algorithm to compose the binary, and updates the state in the process dictionary accordingly.","ref":"rand.html#bytes/1","title":"rand.bytes/1","type":"function"},{"doc":"Returns, for a specified integer N &gt;= 0 and a state, a binary() with that number of random bytes, and a new state. Generates as many random numbers as required using the selected algorithm to compose the binary, and the new state.","ref":"rand.html#bytes_s/2","title":"rand.bytes_s/2","type":"function"},{"doc":"Returns the random number state in an external format. To be used with seed/1 .","ref":"rand.html#export_seed/0","title":"rand.export_seed/0","type":"function"},{"doc":"Returns the random number generator state in an external format. To be used with seed/1 .","ref":"rand.html#export_seed_s/1","title":"rand.export_seed_s/1","type":"function"},{"doc":"Returns the state after performing jump calculation to the state in the process dictionary. This function generates a not_implemented error exception when the jump function is not implemented for the algorithm specified in the state in the process dictionary.","ref":"rand.html#jump/0","title":"rand.jump/0","type":"function"},{"doc":"Returns the state after performing jump calculation to the given state. This function generates a not_implemented error exception when the jump function is not implemented for the algorithm specified in the state.","ref":"rand.html#jump/1","title":"rand.jump/1","type":"function"},{"doc":"Returns a standard normal deviate float (that is, the mean is 0 and the standard deviation is 1) and updates the state in the process dictionary.","ref":"rand.html#normal/0","title":"rand.normal/0","type":"function"},{"doc":"Returns a normal N(Mean, Variance) deviate float and updates the state in the process dictionary.","ref":"rand.html#normal/2","title":"rand.normal/2","type":"function"},{"doc":"Returns, for a specified state, a standard normal deviate float (that is, the mean is 0 and the standard deviation is 1) and a new state.","ref":"rand.html#normal_s/1","title":"rand.normal_s/1","type":"function"},{"doc":"Returns, for a specified state, a normal N(Mean, Variance) deviate float and a new state.","ref":"rand.html#normal_s/3","title":"rand.normal_s/3","type":"function"},{"doc":"Seeds random number generation with the specifed algorithm and time-dependent data if AlgOrStateOrExpState is an algorithm. Alg = default is an alias for the default algorithm . Otherwise recreates the exported seed in the process dictionary, and returns the state. See also export_seed/0 .","ref":"rand.html#seed/1","title":"rand.seed/1","type":"function"},{"doc":"Seeds random number generation with the specified algorithm and integers in the process dictionary and returns the state. Alg = default is an alias for the default algorithm .","ref":"rand.html#seed/2","title":"rand.seed/2","type":"function"},{"doc":"Seeds random number generation with the specifed algorithm and time-dependent data if AlgOrStateOrExpState is an algorithm. Alg = default is an alias for the default algorithm . Otherwise recreates the exported seed and returns the state. See also export_seed/0 .","ref":"rand.html#seed_s/1","title":"rand.seed_s/1","type":"function"},{"doc":"Seeds random number generation with the specified algorithm and integers and returns the state. Alg = default is an alias for the default algorithm .","ref":"rand.html#seed_s/2","title":"rand.seed_s/2","type":"function"},{"doc":"Returns a random float uniformly distributed in the value range 0.0 =&lt; X &lt; 1.0 and updates the state in the process dictionary. The generated numbers are on the form N * 2.0^(-53), that is; equally spaced in the interval. This function may return exactly 0.0 which can be fatal for certain applications. If that is undesired you can use (1.0 - rand:uniform()) to get the interval 0.0 &lt; X =&lt; 1.0 , or instead use uniform_real/0 . If neither endpoint is desired you can test and re-try like this: my_uniform ( ) -&gt; case rand : uniform ( ) of 0.0 -&gt; my_uniform ( ) ; X -&gt; X end end .","ref":"rand.html#uniform/0","title":"rand.uniform/0","type":"function"},{"doc":"Returns, for a specified integer N &gt;= 1 , a random integer uniformly distributed in the value range 1 =&lt; X =&lt; N and updates the state in the process dictionary.","ref":"rand.html#uniform/1","title":"rand.uniform/1","type":"function"},{"doc":"Returns a random float uniformly distributed in the value range DBL_MIN =&lt; X &lt; 1.0 and updates the state in the process dictionary. Conceptually, a random real number R is generated from the interval 0 =&lt; R &lt; 1 and then the closest rounded down normalized number in the IEEE 754 Double precision format is returned. The generated numbers from this function has got better granularity for small numbers than the regular uniform/0 because all bits in the mantissa are random. This property, in combination with the fact that exactly zero is never returned is useful for algoritms doing for example 1.0 / X or math:log(X) . See uniform_real_s/1 for more explanation.","ref":"rand.html#uniform_real/0","title":"rand.uniform_real/0","type":"function"},{"doc":"Returns, for a specified state, a random float uniformly distributed in the value range DBL_MIN =&lt; X &lt; 1.0 and updates the state in the process dictionary. Conceptually, a random real number R is generated from the interval 0 =&lt; R &lt; 1 and then the closest rounded down normalized number in the IEEE 754 Double precision format is returned. The generated numbers from this function has got better granularity for small numbers than the regular uniform_s/1 because all bits in the mantissa are random. This property, in combination with the fact that exactly zero is never returned is useful for algoritms doing for example 1.0 / X or math:log(X) . The concept implicates that the probability to get exactly zero is extremely low; so low that this function is in fact guaranteed to never return zero. The smallest number that it might return is DBL_MIN , which is 2.0^(-1022). The value range stated at the top of this function description is technically correct, but 0.0 =&lt; X &lt; 1.0 is a better description of the generated numbers' statistical distribution. Except that exactly 0.0 is never returned, which is not possible to observe statistically. For example; for all sub ranges N*2.0^(-53) =&lt; X &lt; (N+1)*2.0^(-53) where 0 =&lt; integer(N) &lt; 2.0^53 the probability is the same. Compare that with the form of the numbers generated by uniform_s/1 . Having to generate extra random bits for small numbers costs a little performance. This function is about 20% slower than the regular uniform_s/1","ref":"rand.html#uniform_real_s/1","title":"rand.uniform_real_s/1","type":"function"},{"doc":"Returns, for a specified state, random float uniformly distributed in the value range 0.0 =&lt; X &lt; 1.0 and a new state. The generated numbers are on the form N * 2.0^(-53), that is; equally spaced in the interval. This function may return exactly 0.0 which can be fatal for certain applications. If that is undesired you can use (1.0 - rand:uniform(State)) to get the interval 0.0 &lt; X =&lt; 1.0 , or instead use uniform_real_s/1 . If neither endpoint is desired you can test and re-try like this: my_uniform ( State ) -&gt; case rand : uniform ( State ) of { 0.0 , NewState } -&gt; my_uniform ( NewState ) ; Result -&gt; Result end end .","ref":"rand.html#uniform_s/1","title":"rand.uniform_s/1","type":"function"},{"doc":"Returns, for a specified integer N &gt;= 1 and a state, a random integer uniformly distributed in the value range 1 =&lt; X =&lt; N and a new state.","ref":"rand.html#uniform_s/2","title":"rand.uniform_s/2","type":"function"},{"doc":"","ref":"rand.html#t:alg/0","title":"rand.alg/0","type":"type"},{"doc":"","ref":"rand.html#t:alg_handler/0","title":"rand.alg_handler/0","type":"type"},{"doc":"","ref":"rand.html#t:alg_state/0","title":"rand.alg_state/0","type":"type"},{"doc":"","ref":"rand.html#t:builtin_alg/0","title":"rand.builtin_alg/0","type":"type"},{"doc":"Algorithm-dependent state that can be printed or saved to file.","ref":"rand.html#t:export_state/0","title":"rand.export_state/0","type":"type"},{"doc":"Algorithm specific internal state","ref":"rand.html#t:exro928_state/0","title":"rand.exro928_state/0","type":"opaque"},{"doc":"Algorithm specific internal state","ref":"rand.html#t:exrop_state/0","title":"rand.exrop_state/0","type":"opaque"},{"doc":"Algorithm specific internal state","ref":"rand.html#t:exs1024_state/0","title":"rand.exs1024_state/0","type":"opaque"},{"doc":"Algorithm specific internal state","ref":"rand.html#t:exs64_state/0","title":"rand.exs64_state/0","type":"opaque"},{"doc":"Algorithm specific internal state","ref":"rand.html#t:exsplus_state/0","title":"rand.exsplus_state/0","type":"opaque"},{"doc":"A seed value for the generator. A list of integers sets the generator's internal state directly, after algorithm-dependent checks of the value and masking to the proper word size. The number of integers must be equal to the number of state words in the generator. An integer is used as the initial state for a SplitMix64 generator. The output values of that is then used for setting the generator's internal state after masking to the proper word size and if needed avoiding zero values. A traditional 3-tuple of integers seed is passed through algorithm-dependent hashing functions to create the generator's initial state.","ref":"rand.html#t:seed/0","title":"rand.seed/0","type":"type"},{"doc":"Algorithm-dependent state.","ref":"rand.html#t:state/0","title":"rand.state/0","type":"type"},{"doc":"This module provides a random number generator. The method is attributed to B.A. Wichmann and I.D. Hill in 'An efficient and portable pseudo-random number generator', Journal of Applied Statistics. AS183. 1982. Also Byte March 1987. The algorithm is a modification of the version attributed to Richard A. O'Keefe in the standard Prolog library. Every time a random number is requested, a state is used to calculate it, and a new state is produced. The state can either be implicit (kept in the process dictionary) or be an explicit argument and return value. In this implementation, the state (the type ran() ) consists of a tuple of three integers. This random number generator is not cryptographically strong. If a strong cryptographic random number generator is needed, use one of functions in the crypto module, for example, crypto:strong_rand_bytes/1 . The improved rand module is to be used instead of this module. Note Some of the functions use the process dictionary variable random_seed to remember the current seed. If a process calls uniform/0 or uniform/1 without setting a seed first, seed/0 is called automatically. The implementation changed in Erlang/OTP R15. Upgrading to R15 breaks applications that expect a specific output for a specified seed. The output is still deterministic number series, but different compared to releases older than R15. Seed {0,0,0} does, for example, no longer produce a flawed series of only zeros.","ref":"random.html","title":"random","type":"module"},{"doc":"Seeds random number generation with default (fixed) values in the process dictionary and returns the old state.","ref":"random.html#seed/0","title":"random.seed/0","type":"function"},{"doc":"seed({A1, A2, A3}) is equivalent to seed(A1, A2, A3) .","ref":"random.html#seed/1","title":"random.seed/1","type":"function"},{"doc":"Seeds random number generation with integer values in the process dictionary and returns the old state. The following is an easy way of obtaining a unique value to seed with: random:seed(erlang:phash2([node()]), erlang:monotonic_time(), erlang:unique_integer()) For details, see erlang:phash2/1 , erlang:node/0 , erlang:monotonic_time/0 , and erlang:unique_integer/0 .","ref":"random.html#seed/3","title":"random.seed/3","type":"function"},{"doc":"Returns the default state.","ref":"random.html#seed0/0","title":"random.seed0/0","type":"function"},{"doc":"Returns a random float uniformly distributed between 0.0 and 1.0 , updating the state in the process dictionary.","ref":"random.html#uniform/0","title":"random.uniform/0","type":"function"},{"doc":"Returns, for a specified integer N &gt;= 1 , a random integer uniformly distributed between 1 and N , updating the state in the process dictionary.","ref":"random.html#uniform/1","title":"random.uniform/1","type":"function"},{"doc":"Returns, for a specified state, a random float uniformly distributed between 0.0 and 1.0 , and a new state.","ref":"random.html#uniform_s/1","title":"random.uniform_s/1","type":"function"},{"doc":"Returns, for a specified integer N &gt;= 1 and a state, a random integer uniformly distributed between 1 and N , and a new state.","ref":"random.html#uniform_s/2","title":"random.uniform_s/2","type":"function"},{"doc":"The state.","ref":"random.html#t:ran/0","title":"random.ran/0","type":"type"},{"doc":"This module contains regular expression matching functions for strings and binaries. The regular expression syntax and semantics resemble that of Perl. The matching algorithms of the library are based on the PCRE library, but not all of the PCRE library is interfaced and some parts of the library go beyond what PCRE offers. Currently PCRE version 8.40 (release date 2017-01-11) is used. The sections of the PCRE documentation that are relevant to this module are included here. The Erlang literal syntax for strings uses the &quot;\\&quot; (backslash) character as an escape code. You need to escape backslashes in literal strings, both in your code and in the shell, with an extra backslash, that is, &quot;\\\\&quot;. Perl-Like Regular Expression Syntax The following sections contain reference material for the regular expressions used by this module. The information is based on the PCRE documentation, with changes where this module behaves differently to the PCRE library. PCRE Regular Expression Details The syntax and semantics of the regular expressions supported by PCRE are described in detail in the following sections. Perl's regular expressions are described in its own documentation, and regular expressions in general are covered in many books, some with copious examples. Jeffrey Friedl's &quot;Mastering Regular Expressions&quot;, published by O'Reilly, covers regular expressions in great detail. This description of the PCRE regular expressions is intended as reference material. The reference material is divided into the following sections: Special Start-of-Pattern Items Characters and Metacharacters Backslash Circumflex and Dollar Full Stop (Period, Dot) and \\N Matching a Single Data Unit Square Brackets and Character Classes Posix Character Classes Vertical Bar Internal Option Setting Subpatterns Duplicate Subpattern Numbers Named Subpatterns Repetition Atomic Grouping and Possessive Quantifiers Back References Assertions Conditional Subpatterns Comments Recursive Patterns Subpatterns as Subroutines Oniguruma Subroutine Syntax Backtracking Control Special Start-of-Pattern Items Some options that can be passed to compile/2 can also be set by special items at the start of a pattern. These are not Perl-compatible, but are provided to make these options accessible to pattern writers who are not able to change the program that processes the pattern. Any number of these items can appear, but they must all be together right at the start of the pattern string, and the letters must be in upper case. UTF Support Unicode support is basically UTF-8 based. To use Unicode characters, you either call compile/2 or run/3 with option unicode , or the pattern must start with one of these special sequences: ( * UTF8 ) ( * UTF ) Both options give the same effect, the input string is interpreted as UTF-8. Notice that with these instructions, the automatic conversion of lists to UTF-8 is not performed by the re functions. Therefore, using these sequences is not recommended. Add option unicode when running compile/2 instead. Some applications that allow their users to supply patterns can wish to restrict them to non-UTF data for security reasons. If option never_utf is set at compile time, (*UTF), and so on, are not allowed, and their appearance causes an error. Unicode Property Support The following is another special sequence that can appear at the start of a pattern: ( * UCP ) This has the same effect as setting option ucp : it causes sequences such as \\d and \\w to use Unicode properties to determine character types, instead of recognizing only characters with codes &lt; 256 through a lookup table. Disabling Startup Optimizations If a pattern starts with (*NO_START_OPT) , it has the same effect as setting option no_start_optimize at compile time. Newline Conventions PCRE supports five conventions for indicating line breaks in strings: a single CR (carriage return) character, a single LF (line feed) character, the two-character sequence CRLF, any of the three preceding, and any Unicode newline sequence. A newline convention can also be specified by starting a pattern string with one of the following five sequences: (*CR) Carriage return (*LF) Line feed (*CRLF) &gt;Carriage return followed by line feed (*ANYCRLF) Any of the three above (*ANY) All Unicode newline sequences These override the default and the options specified to compile/2 . For example, the following pattern changes the convention to CR: ( * CR ) a . b This pattern matches a\\nb , as LF is no longer a newline. If more than one of them is present, the last one is used. The newline convention affects where the circumflex and dollar assertions are true. It also affects the interpretation of the dot metacharacter when dotall is not set, and the behavior of \\N. However, it does not affect what the \\R escape sequence matches. By default, this is any Unicode newline sequence, for Perl compatibility. However, this can be changed; see the description of \\R in section Newline Sequences . A change of the \\R setting can be combined with a change of the newline convention. Setting Match and Recursion Limits The caller of run/3 can set a limit on the number of times the internal match() function is called and on the maximum depth of recursive calls. These facilities are provided to catch runaway matches that are provoked by patterns with huge matching trees (a typical example is a pattern with nested unlimited repeats) and to avoid running out of system stack by too much recursion. When one of these limits is reached, pcre_exec() gives an error return. The limits can also be set by items at the start of the pattern of the following forms: ( * LIMIT_MATCH = d ) ( * LIMIT_RECURSION = d ) Here d is any number of decimal digits. However, the value of the setting must be less than the value set by the caller of run/3 for it to have any effect. That is, the pattern writer can lower the limit set by the programmer, but not raise it. If there is more than one setting of one of these limits, the lower value is used. The default value for both the limits is 10,000,000 in the Erlang VM. Notice that the recursion limit does not affect the stack depth of the VM, as PCRE for Erlang is compiled in such a way that the match function never does recursion on the C stack. Note that LIMIT_MATCH and LIMIT_RECURSION can only reduce the value of the limits set by the caller, not increase them. Characters and Metacharacters A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern and match the corresponding characters in the subject. As a trivial example, the following pattern matches a portion of a subject string that is identical to itself: The quick brown fox When caseless matching is specified (option caseless ), letters are matched independently of case. The power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of metacharacters , which do not stand for themselves but instead are interpreted in some special way. Two sets of metacharacters exist: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized within square brackets. Outside square brackets, the metacharacters are as follows: \\ General escape character with many uses ^ Assert start of string (or line, in multiline mode) $ Assert end of string (or line, in multiline mode) . Match any character except newline (by default) [ Start character class definition | Start of alternative branch ( Start subpattern ) End subpattern ? Extends the meaning of (, also 0 or 1 quantifier, also quantifier minimizer * 0 or more quantifiers + 1 or more quantifier, also &quot;possessive quantifier&quot; { Start min/max quantifier Part of a pattern within square brackets is called a &quot;character class&quot;. The following are the only metacharacters in a character class: \\ General escape character ^ Negate the class, but only if the first character - Indicates character range [ Posix character class (only if followed by Posix syntax) ] Terminates the character class The following sections describe the use of each metacharacter. Backslash The backslash character has many uses. First, if it is followed by a character that is not a number or a letter, it takes away any special meaning that a character can have. This use of backslash as an escape character applies both inside and outside character classes. For example, if you want to match a * character, you write \\* in the pattern. This escaping action applies if the following character would otherwise be interpreted as a metacharacter, so it is always safe to precede a non-alphanumeric with backslash to specify that it stands for itself. In particular, if you want to match a backslash, write \\\\. In unicode mode, only ASCII numbers and letters have any special meaning after a backslash. All other characters (in particular, those whose code points are &gt; 127) are treated as literals. If a pattern is compiled with option extended , whitespace in the pattern (other than in a character class) and characters between a # outside a character class and the next newline are ignored. An escaping backslash can be used to include a whitespace or # character as part of the pattern. To remove the special meaning from a sequence of characters, put them between \\Q and \\E. This is different from Perl in that $ and @ are handled as literals in \\Q...\\E sequences in PCRE, while $ and @ cause variable interpolation in Perl. Notice the following examples: Pattern PCRE matches Perl matches \\Qabc$xyz\\E abc$xyz abc followed by the contents of $xyz \\Qabc\\$xyz\\E abc\\$xyz abc\\$xyz \\Qabc\\E\\$\\Qxyz\\E abc$xyz abc$xyz The \\Q...\\E sequence is recognized both inside and outside character classes. An isolated \\E that is not preceded by \\Q is ignored. If \\Q is not followed by \\E later in the pattern, the literal interpretation continues to the end of the pattern (that is, \\E is assumed at the end). If the isolated \\Q is inside a character class, this causes an error, as the character class is not terminated. Non-Printing Characters A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern. When a pattern is prepared by text editing, it is often easier to use one of the following escape sequences than the binary character it represents: \\a Alarm, that is, the BEL character (hex 07) \\cx &quot;Control-x&quot;, where x is any ASCII character \\e Escape (hex 1B) \\f Form feed (hex 0C) \\n Line feed (hex 0A) \\r Carriage return (hex 0D) \\t Tab (hex 09) \\0dd Character with octal code 0dd \\ddd Character with octal code ddd, or back reference \\o{ddd..} character with octal code ddd.. \\xhh Character with hex code hh \\x{hhh..} Character with hex code hhh.. Note that \\0dd is always an octal code, and that \\8 and \\9 are the literal characters &quot;8&quot; and &quot;9&quot;. The precise effect of \\cx on ASCII characters is as follows: if x is a lowercase letter, it is converted to upper case. Then bit 6 of the character (hex 40) is inverted. Thus \\cA to \\cZ become hex 01 to hex 1A (A is 41, Z is 5A), but \\c{ becomes hex 3B ({ is 7B), and \\c; becomes hex 7B (; is 3B). If the data item (byte or 16-bit value) following \\c has a value &gt; 127, a compile-time error occurs. This locks out non-ASCII characters in all modes. The \\c facility was designed for use with ASCII characters, but with the extension to Unicode it is even less useful than it once was. After \\0 up to two further octal digits are read. If there are fewer than two digits, just those that are present are used. Thus the sequence \\0\\x\\015 specifies two binary zeros followed by a CR character (code value 13). Make sure you supply two digits after the initial zero if the pattern character that follows is itself an octal digit. The escape \\o must be followed by a sequence of octal digits, enclosed in braces. An error occurs if this is not the case. This escape is a recent addition to Perl; it provides way of specifying character code points as octal numbers greater than 0777, and it also allows octal numbers and back references to be unambiguously specified. For greater clarity and unambiguity, it is best to avoid following \\ by a digit greater than zero. Instead, use \\o{} or \\x{} to specify character numbers, and \\g{} to specify back references. The following paragraphs describe the old, ambiguous syntax. The handling of a backslash followed by a digit other than 0 is complicated, and Perl has changed in recent releases, causing PCRE also to change. Outside a character class, PCRE reads the digit and any following digits as a decimal number. If the number is &lt; 8, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a back reference . A description of how this works is provided later, following the discussion of parenthesized subpatterns. Inside a character class, or if the decimal number following \\ is &gt; 7 and there have not been that many capturing subpatterns, PCRE handles \\8 and \\9 as the literal characters &quot;8&quot; and &quot;9&quot;, and otherwise re-reads up to three octal digits following the backslash, and using them to generate a data character. Any subsequent digits stand for themselves. For example: \\040 Another way of writing an ASCII space \\40 The same, provided there are &lt; 40 previous capturing subpatterns \\7 Always a back reference \\11 Can be a back reference, or another way of writing a tab \\011 Always a tab \\0113 A tab followed by character &quot;3&quot; \\113 Can be a back reference, otherwise the character with octal code 113 \\377 Can be a back reference, otherwise value 255 (decimal) \\81 Either a back reference, or the two characters &quot;8&quot; and &quot;1&quot; Notice that octal values &gt;= 100 that are specified using this syntax must not be introduced by a leading zero, as no more than three octal digits are ever read. By default, after \\x that is not followed by {, from zero to two hexadecimal digits are read (letters can be in upper or lower case). Any number of hexadecimal digits may appear between \\x{ and }. If a character other than a hexadecimal digit appears between \\x{ and }, or if there is no terminating }, an error occurs. Characters whose value is less than 256 can be defined by either of the two syntaxes for \\x. There is no difference in the way they are handled. For example, \\xdc is exactly the same as \\x{dc}. Constraints on character values Characters that are specified using octal or hexadecimal numbers are limited to certain values, as follows: 8-bit non-UTF mode &lt; 0x100 8-bit UTF-8 mode &lt; 0x10ffff and a valid codepoint Invalid Unicode codepoints are the range 0xd800 to 0xdfff (the so-called &quot;surrogate&quot; codepoints), and 0xffef. Escape sequences in character classes All the sequences that define a single character value can be used both inside and outside character classes. Also, inside a character class, \\b is interpreted as the backspace character (hex 08). \\N is not allowed in a character class. \\B, \\R, and \\X are not special inside a character class. Like other unrecognized escape sequences, they are treated as the literal characters &quot;B&quot;, &quot;R&quot;, and &quot;X&quot;. Outside a character class, these sequences have different meanings. Unsupported Escape Sequences In Perl, the sequences \\l, \\L, \\u, and \\U are recognized by its string handler and used to modify the case of following characters. PCRE does not support these escape sequences. Absolute and Relative Back References The sequence \\g followed by an unsigned or a negative number, optionally enclosed in braces, is an absolute or relative back reference. A named back reference can be coded as \\g{name}. Back references are discussed later, following the discussion of parenthesized subpatterns. Absolute and Relative Subroutine Calls For compatibility with Oniguruma, the non-Perl syntax \\g followed by a name or a number enclosed either in angle brackets or single quotes, is alternative syntax for referencing a subpattern as a &quot;subroutine&quot;. Details are discussed later. Notice that \\g{...} (Perl syntax) and \\g&lt;...&gt; (Oniguruma syntax) are not synonymous. The former is a back reference and the latter is a subroutine call. Generic Character Types Another use of backslash is for specifying generic character types: \\d Any decimal digit \\D Any character that is not a decimal digit \\h Any horizontal whitespace character \\H Any character that is not a horizontal whitespace character \\s Any whitespace character \\S Any character that is not a whitespace character \\v Any vertical whitespace character \\V Any character that is not a vertical whitespace character \\w Any &quot;word&quot; character \\W Any &quot;non-word&quot; character There is also the single sequence \\N, which matches a non-newline character. This is the same as the &quot;.&quot; metacharacter when dotall is not set. Perl also uses \\N to match characters by name, but PCRE does not support this. Each pair of lowercase and uppercase escape sequences partitions the complete set of characters into two disjoint sets. Any given character matches one, and only one, of each pair. The sequences can appear both inside and outside character classes. They each match one character of the appropriate type. If the current matching point is at the end of the subject string, all fail, as there is no character to match. For compatibility with Perl, \\s did not used to match the VT character (code 11), which made it different from the the POSIX &quot;space&quot; class. However, Perl added VT at release 5.18, and PCRE followed suit at release 8.34. The default \\s characters are now HT (9), LF (10), VT (11), FF (12), CR (13), and space (32), which are defined as white space in the &quot;C&quot; locale. This list may vary if locale-specific matching is taking place. For example, in some locales the &quot;non-breaking space&quot; character (\\xA0) is recognized as white space, and in others the VT character is not. A &quot;word&quot; character is an underscore or any character that is a letter or a digit. By default, the definition of letters and digits is controlled by the PCRE low-valued character tables, in Erlang's case (and without option unicode ), the ISO Latin-1 character set. By default, in unicode mode, characters with values &gt; 255, that is, all characters outside the ISO Latin-1 character set, never match \\d, \\s, or \\w, and always match \\D, \\S, and \\W. These sequences retain their original meanings from before UTF support was available, mainly for efficiency reasons. However, if option ucp is set, the behavior is changed so that Unicode properties are used to determine character types, as follows: \\d Any character that \\p{Nd} matches (decimal digit) \\s Any character that \\p{Z} or \\h or \\v \\w Any character that matches \\p{L} or \\p{N} matches, plus underscore The uppercase escapes match the inverse sets of characters. Notice that \\d matches only decimal digits, while \\w matches any Unicode digit, any Unicode letter, and underscore. Notice also that ucp affects \\b and \\B, as they are defined in terms of \\w and \\W. Matching these sequences is noticeably slower when ucp is set. The sequences \\h, \\H, \\v, and \\V are features that were added to Perl in release 5.10. In contrast to the other sequences, which match only ASCII characters by default, these always match certain high-valued code points, regardless if ucp is set. The following are the horizontal space characters: U+0009 Horizontal tab (HT) U+0020 Space U+00A0 Non-break space U+1680 Ogham space mark U+180E Mongolian vowel separator U+2000 En quad U+2001 Em quad U+2002 En space U+2003 Em space U+2004 Three-per-em space U+2005 Four-per-em space U+2006 Six-per-em space U+2007 Figure space U+2008 Punctuation space U+2009 Thin space U+200A Hair space U+202F Narrow no-break space U+205F Medium mathematical space U+3000 Ideographic space The following are the vertical space characters: U+000A Line feed (LF) U+000B Vertical tab (VT) U+000C Form feed (FF) U+000D Carriage return (CR) U+0085 Next line (NEL) U+2028 Line separator U+2029 Paragraph separator In 8-bit, non-UTF-8 mode, only the characters with code points &lt; 256 are relevant. Newline Sequences Outside a character class, by default, the escape sequence \\R matches any Unicode newline sequence. In non-UTF-8 mode, \\R is equivalent to the following: ( ? &gt; \\ r \\ n | \\ n | \\ x0b | \\ f | \\ r | \\ x85 ) This is an example of an &quot;atomic group&quot;, details are provided below. This particular group matches either the two-character sequence CR followed by LF, or one of the single characters LF (line feed, U+000A), VT (vertical tab, U+000B), FF (form feed, U+000C), CR (carriage return, U+000D), or NEL (next line, U+0085). The two-character sequence is treated as a single unit that cannot be split. In Unicode mode, two more characters whose code points are &gt; 255 are added: LS (line separator, U+2028) and PS (paragraph separator, U+2029). Unicode character property support is not needed for these characters to be recognized. \\R can be restricted to match only CR, LF, or CRLF (instead of the complete set of Unicode line endings) by setting option bsr_anycrlf either at compile time or when the pattern is matched. (BSR is an acronym for &quot;backslash R&quot;.) This can be made the default when PCRE is built; if so, the other behavior can be requested through option bsr_unicode . These settings can also be specified by starting a pattern string with one of the following sequences: (*BSR_ANYCRLF) CR, LF, or CRLF only (*BSR_UNICODE) Any Unicode newline sequence These override the default and the options specified to the compiling function, but they can themselves be overridden by options specified to a matching function. Notice that these special settings, which are not Perl-compatible, are recognized only at the very start of a pattern, and that they must be in upper case. If more than one of them is present, the last one is used. They can be combined with a change of newline convention; for example, a pattern can start with: ( * ANY ) ( * BSR_ANYCRLF ) They can also be combined with the (*UTF8), (*UTF), or (*UCP) special sequences. Inside a character class, \\R is treated as an unrecognized escape sequence, and so matches the letter &quot;R&quot; by default. Unicode Character Properties Three more escape sequences that match characters with specific properties are available. When in 8-bit non-UTF-8 mode, these sequences are limited to testing characters whose code points are &lt; 256, but they do work in this mode. The following are the extra escape sequences: \\p{ xx } A character with property xx \\P{ xx } A character without property xx \\X A Unicode extended grapheme cluster The property names represented by xx above are limited to the Unicode script names, the general category properties, &quot;Any&quot;, which matches any character (including newline), and some special PCRE properties (described in the next section). Other Perl properties, such as &quot;InMusicalSymbols&quot;, are currently not supported by PCRE. Notice that \\P{Any} does not match any characters and always causes a match failure. Sets of Unicode characters are defined as belonging to certain scripts. A character from one of these sets can be matched using a script name, for example: \\ p { Greek } \\ P { Han } Those that are not part of an identified script are lumped together as &quot;Common&quot;. The following is the current list of scripts: Arabic Armenian Avestan Balinese Bamum Bassa_Vah Batak Bengali Bopomofo Braille Buginese Buhid Canadian_Aboriginal Carian Caucasian_Albanian Chakma Cham Cherokee Common Coptic Cuneiform Cypriot Cyrillic Deseret Devanagari Duployan Egyptian_Hieroglyphs Elbasan Ethiopic Georgian Glagolitic Gothic Grantha Greek Gujarati Gurmukhi Han Hangul Hanunoo Hebrew Hiragana Imperial_Aramaic Inherited Inscriptional_Pahlavi Inscriptional_Parthian Javanese Kaithi Kannada Katakana Kayah_Li Kharoshthi Khmer Khojki Khudawadi Lao Latin Lepcha Limbu Linear_A Linear_B Lisu Lycian Lydian Mahajani Malayalam Mandaic Manichaean Meetei_Mayek Mende_Kikakui Meroitic_Cursive Meroitic_Hieroglyphs Miao Modi Mongolian Mro Myanmar Nabataean New_Tai_Lue Nko Ogham Ol_Chiki Old_Italic Old_North_Arabian Old_Permic Old_Persian Oriya Old_South_Arabian Old_Turkic Osmanya Pahawh_Hmong Palmyrene Pau_Cin_Hau Phags_Pa Phoenician Psalter_Pahlavi Rejang Runic Samaritan Saurashtra Sharada Shavian Siddham Sinhala Sora_Sompeng Sundanese Syloti_Nagri Syriac Tagalog Tagbanwa Tai_Le Tai_Tham Tai_Viet Takri Tamil Telugu Thaana Thai Tibetan Tifinagh Tirhuta Ugaritic Vai Warang_Citi Yi Each character has exactly one Unicode general category property, specified by a two-letter acronym. For compatibility with Perl, negation can be specified by including a circumflex between the opening brace and the property name. For example, \\p{^Lu} is the same as \\P{Lu}. If only one letter is specified with \\p or \\P, it includes all the general category properties that start with that letter. In this case, in the absence of negation, the curly brackets in the escape sequence are optional. The following two examples have the same effect: \\ p { L } \\ pL The following general category property codes are supported: C Other Cc Control Cf Format Cn Unassigned Co Private use Cs Surrogate L Letter Ll Lowercase letter Lm Modifier letter Lo Other letter Lt Title case letter Lu Uppercase letter M Mark Mc Spacing mark Me Enclosing mark Mn Non-spacing mark N Number Nd Decimal number Nl Letter number No Other number P Punctuation Pc Connector punctuation Pd Dash punctuation Pe Close punctuation Pf Final punctuation Pi Initial punctuation Po Other punctuation Ps Open punctuation S Symbol Sc Currency symbol Sk Modifier symbol Sm Mathematical symbol So Other symbol Z Separator Zl Line separator Zp Paragraph separator Zs Space separator The special property L&amp; is also supported. It matches a character that has the Lu, Ll, or Lt property, that is, a letter that is not classified as a modifier or &quot;other&quot;. The Cs (Surrogate) property applies only to characters in the range U+D800 to U+DFFF. Such characters are invalid in Unicode strings and so cannot be tested by PCRE. Perl does not support the Cs property. The long synonyms for property names supported by Perl (such as \\p{Letter}) are not supported by PCRE. It is not permitted to prefix any of these properties with &quot;Is&quot;. No character in the Unicode table has the Cn (unassigned) property. This property is instead assumed for any code point that is not in the Unicode table. Specifying caseless matching does not affect these escape sequences. For example, \\p{Lu} always matches only uppercase letters. This is different from the behavior of current versions of Perl. Matching characters by Unicode property is not fast, as PCRE must do a multistage table lookup to find a character property. That is why the traditional escape sequences such as \\d and \\w do not use Unicode properties in PCRE by default. However, you can make them do so by setting option ucp or by starting the pattern with (*UCP). Extended Grapheme Clusters The \\X escape matches any number of Unicode characters that form an &quot;extended grapheme cluster&quot;, and treats the sequence as an atomic group (see below). Up to and including release 8.31, PCRE matched an earlier, simpler definition that was equivalent to (?&gt;\\PM\\pM*) . That is, it matched a character without the &quot;mark&quot; property, followed by zero or more characters with the &quot;mark&quot; property. Characters with the &quot;mark&quot; property are typically non-spacing accents that affect the preceding character. This simple definition was extended in Unicode to include more complicated kinds of composite character by giving each character a grapheme breaking property, and creating rules that use these properties to define the boundaries of extended grapheme clusters. In PCRE releases later than 8.31, \\X matches one of these clusters. \\X always matches at least one character. Then it decides whether to add more characters according to the following rules for ending a cluster: End at the end of the subject string. Do not end between CR and LF; otherwise end after any control character. Do not break Hangul (a Korean script) syllable sequences. Hangul characters are of five types: L, V, T, LV, and LVT. An L character can be followed by an L, V, LV, or LVT character. An LV or V character can be followed by a V or T character. An LVT or T character can be followed only by a T character. Do not end before extending characters or spacing marks. Characters with the &quot;mark&quot; property always have the &quot;extend&quot; grapheme breaking property. Do not end after prepend characters. Otherwise, end the cluster. PCRE Additional Properties In addition to the standard Unicode properties described earlier, PCRE supports four more that make it possible to convert traditional escape sequences, such as \\w and \\s to use Unicode properties. PCRE uses these non-standard, non-Perl properties internally when the ucp option is passed. However, they can also be used explicitly. The properties are as follows: Xan Any alphanumeric character. Matches characters that have either the L (letter) or the N (number) property. Xps Any Posix space character. Matches the characters tab, line feed, vertical tab, form feed, carriage return, and any other character that has the Z (separator) property. Xsp Any Perl space character. Matches the same as Xps, except that vertical tab is excluded. Xwd Any Perl &quot;word&quot; character. Matches the same characters as Xan, plus underscore. Perl and POSIX space are now the same. Perl added VT to its space character set at release 5.18 and PCRE changed at release 8.34. Xan matches characters that have either the L (letter) or the N (number) property. Xps matches the characters tab, linefeed, vertical tab, form feed, or carriage return, and any other character that has the Z (separator) property. Xsp is the same as Xps; it used to exclude vertical tab, for Perl compatibility, but Perl changed, and so PCRE followed at release 8.34. Xwd matches the same characters as Xan, plus underscore. There is another non-standard property, Xuc, which matches any character that can be represented by a Universal Character Name in C++ and other programming languages. These are the characters $, @, ` (grave accent), and all characters with Unicode code points &gt;= U+00A0, except for the surrogates U+D800 to U+DFFF. Notice that most base (ASCII) characters are excluded. (Universal Character Names are of the form \\uHHHH or \\UHHHHHHHH, where H is a hexadecimal digit. Notice that the Xuc property does not match these sequences but the characters that they represent.) Resetting the Match Start The escape sequence \\K causes any previously matched characters not to be included in the final matched sequence. For example, the following pattern matches &quot;foobar&quot;, but reports that it has matched &quot;bar&quot;: foo \\ Kbar This feature is similar to a lookbehind assertion (described below). However, in this case, the part of the subject before the real match does not have to be of fixed length, as lookbehind assertions do. The use of \\K does not interfere with the setting of captured substrings. For example, when the following pattern matches &quot;foobar&quot;, the first substring is still set to &quot;foo&quot;: ( foo ) \\ Kbar Perl documents that the use of \\K within assertions is &quot;not well defined&quot;. In PCRE, \\K is acted upon when it occurs inside positive assertions, but is ignored in negative assertions. Note that when a pattern such as (?=ab\\K) matches, the reported start of the match can be greater than the end of the match. Simple Assertions The final use of backslash is for certain simple assertions. An assertion specifies a condition that must be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The following are the backslashed assertions: \\b Matches at a word boundary. \\B Matches when not at a word boundary. \\A Matches at the start of the subject. \\Z Matches at the end of the subject, and before a newline at the end of the subject. \\z Matches only at the end of the subject. \\G Matches at the first matching position in the subject. Inside a character class, \\b has a different meaning; it matches the backspace character. If any other of these assertions appears in a character class, by default it matches the corresponding literal character (for example, \\B matches the letter B). A word boundary is a position in the subject string where the current character and the previous character do not both match \\w or \\W (that is, one matches \\w and the other matches \\W), or the start or end of the string if the first or last character matches \\w, respectively. In UTF mode, the meanings of \\w and \\W can be changed by setting option ucp . When this is done, it also affects \\b and \\B. PCRE and Perl do not have a separate &quot;start of word&quot; or &quot;end of word&quot; metasequence. However, whatever follows \\b normally determines which it is. For example, the fragment \\ba matches &quot;a&quot; at the start of a word. The \\A, \\Z, and \\z assertions differ from the traditional circumflex and dollar (described in the next section) in that they only ever match at the very start and end of the subject string, whatever options are set. Thus, they are independent of multiline mode. These three assertions are not affected by options notbol or noteol , which affect only the behavior of the circumflex and dollar metacharacters. However, if argument startoffset of run/3 is non-zero, indicating that matching is to start at a point other than the beginning of the subject, \\A can never match. The difference between \\Z and \\z is that \\Z matches before a newline at the end of the string and at the very end, while \\z matches only at the end. The \\G assertion is true only when the current matching position is at the start point of the match, as specified by argument startoffset of run/3 . It differs from \\A when the value of startoffset is non-zero. By calling run/3 multiple times with appropriate arguments, you can mimic the Perl option /g , and it is in this kind of implementation where \\G can be useful. Notice, however, that the PCRE interpretation of \\G, as the start of the current match, is subtly different from Perl, which defines it as the end of the previous match. In Perl, these can be different when the previously matched string was empty. As PCRE does only one match at a time, it cannot reproduce this behavior. If all the alternatives of a pattern begin with \\G, the expression is anchored to the starting match position, and the &quot;anchored&quot; flag is set in the compiled regular expression. Circumflex and Dollar The circumflex and dollar metacharacters are zero-width assertions. That is, they test for a particular condition to be true without consuming any characters from the subject string. Outside a character class, in the default matching mode, the circumflex character is an assertion that is true only if the current matching point is at the start of the subject string. If argument startoffset of run/3 is non-zero, circumflex can never match if option multiline is unset. Inside a character class, circumflex has an entirely different meaning (see below). Circumflex needs not to be the first character of the pattern if some alternatives are involved, but it is to be the first thing in each alternative in which it appears if the pattern is ever to match that branch. If all possible alternatives start with a circumflex, that is, if the pattern is constrained to match only at the start of the subject, it is said to be an &quot;anchored&quot; pattern. (There are also other constructs that can cause a pattern to be anchored.) The dollar character is an assertion that is true only if the current matching point is at the end of the subject string, or immediately before a newline at the end of the string (by default). Notice however that it does not match the newline. Dollar needs not to be the last character of the pattern if some alternatives are involved, but it is to be the last item in any branch in which it appears. Dollar has no special meaning in a character class. The meaning of dollar can be changed so that it matches only at the very end of the string, by setting option dollar_endonly at compile time. This does not affect the \\Z assertion. The meanings of the circumflex and dollar characters are changed if option multiline is set. When this is the case, a circumflex matches immediately after internal newlines and at the start of the subject string. It does not match after a newline that ends the string. A dollar matches before any newlines in the string, and at the very end, when multiline is set. When newline is specified as the two-character sequence CRLF, isolated CR and LF characters do not indicate newlines. For example, the pattern /^abc$/ matches the subject string &quot;def\\nabc&quot; (where \\n represents a newline) in multiline mode, but not otherwise. So, patterns that are anchored in single-line mode because all branches start with ^ are not anchored in multiline mode, and a match for circumflex is possible when argument startoffset of run/3 is non-zero. Option dollar_endonly is ignored if multiline is set. Notice that the sequences \\A, \\Z, and \\z can be used to match the start and end of the subject in both modes. If all branches of a pattern start with \\A, it is always anchored, regardless if multiline is set. Full Stop (Period, Dot) and \\N Outside a character class, a dot in the pattern matches any character in the subject string except (by default) a character that signifies the end of a line. When a line ending is defined as a single character, dot never matches that character. When the two-character sequence CRLF is used, dot does not match CR if it is immediately followed by LF, otherwise it matches all characters (including isolated CRs and LFs). When any Unicode line endings are recognized, dot does not match CR, LF, or any of the other line-ending characters. The behavior of dot regarding newlines can be changed. If option dotall is set, a dot matches any character, without exception. If the two-character sequence CRLF is present in the subject string, it takes two dots to match it. The handling of dot is entirely independent of the handling of circumflex and dollar, the only relationship is that both involve newlines. Dot has no special meaning in a character class. The escape sequence \\N behaves like a dot, except that it is not affected by option PCRE_DOTALL . That is, it matches any character except one that signifies the end of a line. Perl also uses \\N to match characters by name but PCRE does not support this. Matching a Single Data Unit Outside a character class, the escape sequence \\C matches any data unit, regardless if a UTF mode is set. One data unit is one byte. Unlike a dot, \\C always matches line-ending characters. The feature is provided in Perl to match individual bytes in UTF-8 mode, but it is unclear how it can usefully be used. As \\C breaks up characters into individual data units, matching one unit with \\C in a UTF mode means that the remaining string can start with a malformed UTF character. This has undefined results, as PCRE assumes that it deals with valid UTF strings. PCRE does not allow \\C to appear in lookbehind assertions (described below) in a UTF mode, as this would make it impossible to calculate the length of the lookbehind. The \\C escape sequence is best avoided. However, one way of using it that avoids the problem of malformed UTF characters is to use a lookahead to check the length of the next character, as in the following pattern, which can be used with a UTF-8 string (ignore whitespace and line breaks): (?| (?=[\\x00-\\x7f])(\\C) | (?=[\\x80-\\x{7ff}])(\\C)(\\C) | (?=[\\x{800}-\\x{ffff}])(\\C)(\\C)(\\C) | (?=[\\x{10000}-\\x{1fffff}])(\\C)(\\C)(\\C)(\\C)) A group that starts with (?| resets the capturing parentheses numbers in each alternative (see section Duplicate Subpattern Numbers ). The assertions at the start of each branch check the next UTF-8 character for values whose encoding uses 1, 2, 3, or 4 bytes, respectively. The individual bytes of the character are then captured by the appropriate number of groups. Square Brackets and Character Classes An opening square bracket introduces a character class, terminated by a closing square bracket. A closing square bracket on its own is not special by default. However, if option PCRE_JAVASCRIPT_COMPAT is set, a lone closing square bracket causes a compile-time error. If a closing square bracket is required as a member of the class, it is to be the first data character in the class (after an initial circumflex, if present) or escaped with a backslash. A character class matches a single character in the subject. In a UTF mode, the character can be more than one data unit long. A matched character must be in the set of characters defined by the class, unless the first character in the class definition is a circumflex, in which case the subject character must not be in the set defined by the class. If a circumflex is required as a member of the class, ensure that it is not the first character, or escape it with a backslash. For example, the character class [aeiou] matches any lowercase vowel, while [^aeiou] matches any character that is not a lowercase vowel. Notice that a circumflex is just a convenient notation for specifying the characters that are in the class by enumerating those that are not. A class that starts with a circumflex is not an assertion; it still consumes a character from the subject string, and therefore it fails if the current pointer is at the end of the string. In UTF-8 mode, characters with values &gt; 255 (0xffff) can be included in a class as a literal string of data units, or by using the \\x{ escaping mechanism. When caseless matching is set, any letters in a class represent both their uppercase and lowercase versions. For example, a caseless [aeiou] matches &quot;A&quot; and &quot;a&quot;, and a caseless [^aeiou] does not match &quot;A&quot;, but a caseful version would. In a UTF mode, PCRE always understands the concept of case for characters whose values are &lt; 256, so caseless matching is always possible. For characters with higher values, the concept of case is supported only if PCRE is compiled with Unicode property support. If you want to use caseless matching in a UTF mode for characters &gt;=, ensure that PCRE is compiled with Unicode property support and with UTF support. Characters that can indicate line breaks are never treated in any special way when matching character classes, whatever line-ending sequence is in use, and whatever setting of options PCRE_DOTALL and PCRE_MULTILINE is used. A class such as [^a] always matches one of these characters. The minus (hyphen) character can be used to specify a range of characters in a character class. For example, [d-m] matches any letter between d and m, inclusive. If a minus character is required in a class, it must be escaped with a backslash or appear in a position where it cannot be interpreted as indicating a range, typically as the first or last character in the class, or immediately after a range. For example, [b-d-z] matches letters in the range b to d, a hyphen character, or z. The literal character &quot;]&quot; cannot be the end character of a range. A pattern such as [W-]46] is interpreted as a class of two characters (&quot;W&quot; and &quot;-&quot;) followed by a literal string &quot;46]&quot;, so it would match &quot;W46]&quot; or &quot;-46]&quot;. However, if &quot;]&quot; is escaped with a backslash, it is interpreted as the end of range, so [W-\\]46] is interpreted as a class containing a range followed by two other characters. The octal or hexadecimal representation of &quot;]&quot; can also be used to end a range. An error is generated if a POSIX character class (see below) or an escape sequence other than one that defines a single character appears at a point where a range ending character is expected. For example, [z-\\xff] is valid, but [A-\\d] and [A-[:digit:]] are not. Ranges operate in the collating sequence of character values. They can also be used for characters specified numerically, for example, [\\000-\\037]. Ranges can include any characters that are valid for the current mode. If a range that includes letters is used when caseless matching is set, it matches the letters in either case. For example, [W-c] is equivalent to [][\\\\^_`wxyzabc], matched caselessly. In a non-UTF mode, if character tables for a French locale are in use, [\\xc8-\\xcb] matches accented E characters in both cases. In UTF modes, PCRE supports the concept of case for characters with values &gt; 255 only when it is compiled with Unicode property support. The character escape sequences \\d, \\D, \\h, \\H, \\p, \\P, \\s, \\S, \\v, \\V, \\w, and \\W can appear in a character class, and add the characters that they match to the class. For example, [\\dABCDEF] matches any hexadecimal digit. In UTF modes, option ucp affects the meanings of \\d, \\s, \\w and their uppercase partners, just as it does when they appear outside a character class, as described in section Generic Character Types earlier. The escape sequence \\b has a different meaning inside a character class; it matches the backspace character. The sequences \\B, \\N, \\R, and \\X are not special inside a character class. Like any other unrecognized escape sequences, they are treated as the literal characters &quot;B&quot;, &quot;N&quot;, &quot;R&quot;, and &quot;X&quot;. A circumflex can conveniently be used with the uppercase character types to specify a more restricted set of characters than the matching lowercase type. For example, class [^\\W_] matches any letter or digit, but not underscore, while [\\w] includes underscore. A positive character class is to be read as &quot;something OR something OR ...&quot; and a negative class as &quot;NOT something AND NOT something AND NOT ...&quot;. Only the following metacharacters are recognized in character classes: Backslash Hyphen (only where it can be interpreted as specifying a range) Circumflex (only at the start) Opening square bracket (only when it can be interpreted as introducing a Posix class name, or for a special compatibility feature; see the next two sections) Terminating closing square bracket However, escaping other non-alphanumeric characters does no harm. Posix Character Classes Perl supports the Posix notation for character classes. This uses names enclosed by [: and :] within the enclosing square brackets. PCRE also supports this notation. For example, the following matches &quot;0&quot;, &quot;1&quot;, any alphabetic character, or &quot;%&quot;: [ 01 [ : alpha : ] %] The following are the supported class names: alnum Letters and digits alpha Letters blank Space or tab only cntrl Control characters digit Decimal digits (same as \\d) graph Printing characters, excluding space lower Lowercase letters print Printing characters, including space punct Printing characters, excluding letters, digits, and space space Whitespace (the same as \\s from PCRE 8.34) upper Uppercase letters word &quot;Word&quot; characters (same as \\w) xdigit Hexadecimal digits There is another character class, ascii , that erroneously matches Latin-1 characters instead of the 0-127 range specified by POSIX. This cannot be fixed without altering the behaviour of other classes, so we recommend matching the range with [\\\\0-\\x7f] instead. The default &quot;space&quot; characters are HT (9), LF (10), VT (11), FF (12), CR (13), and space (32). If locale-specific matching is taking place, the list of space characters may be different; there may be fewer or more of them. &quot;Space&quot; used to be different to \\s, which did not include VT, for Perl compatibility. However, Perl changed at release 5.18, and PCRE followed at release 8.34. &quot;Space&quot; and \\s now match the same set of characters. The name &quot;word&quot; is a Perl extension, and &quot;blank&quot; is a GNU extension from Perl 5.8. Another Perl extension is negation, which is indicated by a ^ character after the colon. For example, the following matches &quot;1&quot;, &quot;2&quot;, or any non-digit: [ 12 [ : ^ digit : ] ] PCRE (and Perl) also recognize the Posix syntax [.ch.] and [=ch=] where &quot;ch&quot; is a &quot;collating element&quot;, but these are not supported, and an error is given if they are encountered. By default, characters with values &gt; 255 do not match any of the Posix character classes. However, if option PCRE_UCP is passed to pcre_compile() , some of the classes are changed so that Unicode character properties are used. This is achieved by replacing certain Posix classes by other sequences, as follows: [:alnum:] Becomes \\p{Xan} [:alpha:] Becomes \\p{L} [:blank:] Becomes \\h [:digit:] Becomes \\p{Nd} [:lower:] Becomes \\p{Ll} [:space:] Becomes \\p{Xps} [:upper:] Becomes \\p{Lu} [:word:] Becomes \\p{Xwd} Negated versions, such as [:^alpha:], use \\P instead of \\p. Three other POSIX classes are handled specially in UCP mode: [:graph:] This matches characters that have glyphs that mark the page when printed. In Unicode property terms, it matches all characters with the L, M, N, P, S, or Cf properties, except for: U+061C Arabic Letter Mark U+180E Mongolian Vowel Separator U+2066 - U+2069 Various &quot;isolate&quot;s [:print:] This matches the same characters as [:graph:] plus space characters that are not controls, that is, characters with the Zs property. [:punct:] This matches all characters that have the Unicode P (punctuation) property, plus those characters whose code points are less than 128 that have the S (Symbol) property. The other POSIX classes are unchanged, and match only characters with code points less than 128. Compatibility Feature for Word Boundaries In the POSIX.2 compliant library that was included in 4.4BSD Unix, the ugly syntax [[:&lt;:]] and [[:&gt;:]] is used for matching &quot;start of word&quot; and &quot;end of word&quot;. PCRE treats these items as follows: [[:&lt;:]] is converted to \\b(?=\\w) [[:&gt;:]] is converted to \\b(?&lt;=\\w) Only these exact character sequences are recognized. A sequence such as [a[:&lt;:]b] provokes error for an unrecognized POSIX class name. This support is not compatible with Perl. It is provided to help migrations from other environments, and is best not used in any new patterns. Note that \\b matches at the start and the end of a word (see &quot;Simple assertions&quot; above), and in a Perl-style pattern the preceding or following character normally shows which is wanted, without the need for the assertions that are used above in order to give exactly the POSIX behaviour. Vertical Bar Vertical bar characters are used to separate alternative patterns. For example, the following pattern matches either &quot;gilbert&quot; or &quot;sullivan&quot;: gilbert | sullivan Any number of alternatives can appear, and an empty alternative is permitted (matching the empty string). The matching process tries each alternative in turn, from left to right, and the first that succeeds is used. If the alternatives are within a subpattern (defined in section Subpatterns ), &quot;succeeds&quot; means matching the remaining main pattern and the alternative in the subpattern. Internal Option Setting The settings of the Perl-compatible options caseless , multiline , dotall , and extended can be changed from within the pattern by a sequence of Perl option letters enclosed between &quot;(?&quot; and &quot;)&quot;. The option letters are as follows: i For caseless m For multiline s For dotall x For extended For example, (?im) sets caseless, multiline matching. These options can also be unset by preceding the letter with a hyphen. A combined setting and unsetting such as (?im-sx) , which sets caseless and multiline , while unsetting dotall and extended , is also permitted. If a letter appears both before and after the hyphen, the option is unset. The PCRE-specific options dupnames , ungreedy , and extra can be changed in the same way as the Perl-compatible options by using the characters J, U, and X respectively. When one of these option changes occurs at top-level (that is, not inside subpattern parentheses), the change applies to the remainder of the pattern that follows. An option change within a subpattern (see section Subpatterns ) affects only that part of the subpattern that follows it. So, the following matches abc and aBc and no other strings (assuming caseless is not used): ( a ( ? i ) b ) c By this means, options can be made to have different settings in different parts of the pattern. Any changes made in one alternative do carry on into subsequent branches within the same subpattern. For example: ( a ( ? i ) b | c ) matches &quot;ab&quot;, &quot;aB&quot;, &quot;c&quot;, and &quot;C&quot;, although when matching &quot;C&quot; the first branch is abandoned before the option setting. This is because the effects of option settings occur at compile time. There would be some weird behavior otherwise. Other PCRE-specific options can be set by the application when the compiling or matching functions are called. Sometimes the pattern can contain special leading sequences, such as (*CRLF), to override what the application has set or what has been defaulted. Details are provided in section Newline Sequences earlier. The (*UTF8) and (*UCP) leading sequences can be used to set UTF and Unicode property modes. They are equivalent to setting options unicode and ucp , respectively. The (*UTF) sequence is a generic version that can be used with any of the libraries. However, the application can set option never_utf , which locks out the use of the (*UTF) sequences. Subpatterns Subpatterns are delimited by parentheses (round brackets), which can be nested. Turning part of a pattern into a subpattern does two things: 1. It localizes a set of alternatives. For example, the following pattern matches &quot;cataract&quot;, &quot;caterpillar&quot;, or &quot;cat&quot;: cat ( aract | erpillar | ) Without the parentheses, it would match &quot;cataract&quot;, &quot;erpillar&quot;, or an empty string. 2. It sets up the subpattern as a capturing subpattern. That is, when the complete pattern matches, that portion of the subject string that matched the subpattern is passed back to the caller through the return value of run/3 . Opening parentheses are counted from left to right (starting from 1) to obtain numbers for the capturing subpatterns. For example, if the string &quot;the red king&quot; is matched against the following pattern, the captured substrings are &quot;red king&quot;, &quot;red&quot;, and &quot;king&quot;, and are numbered 1, 2, and 3, respectively: the ( ( red | white ) ( king | queen ) ) It is not always helpful that plain parentheses fulfill two functions. Often a grouping subpattern is required without a capturing requirement. If an opening parenthesis is followed by a question mark and a colon, the subpattern does not do any capturing, and is not counted when computing the number of any subsequent capturing subpatterns. For example, if the string &quot;the white queen&quot; is matched against the following pattern, the captured substrings are &quot;white queen&quot; and &quot;queen&quot;, and are numbered 1 and 2: the ( ( ? : red | white ) ( king | queen ) ) The maximum number of capturing subpatterns is 65535. As a convenient shorthand, if any option settings are required at the start of a non-capturing subpattern, the option letters can appear between &quot;?&quot; and &quot;:&quot;. Thus, the following two patterns match the same set of strings: ( ? i : saturday | sunday ) ( ? : ( ? i ) saturday | sunday ) As alternative branches are tried from left to right, and options are not reset until the end of the subpattern is reached, an option setting in one branch does affect subsequent branches, so the above patterns match both &quot;SUNDAY&quot; and &quot;Saturday&quot;. Duplicate Subpattern Numbers Perl 5.10 introduced a feature where each alternative in a subpattern uses the same numbers for its capturing parentheses. Such a subpattern starts with (?| and is itself a non-capturing subpattern. For example, consider the following pattern: ( ? | ( Sat ) ur | ( Sun ) ) day As the two alternatives are inside a (?| group, both sets of capturing parentheses are numbered one. Thus, when the pattern matches, you can look at captured substring number one, whichever alternative matched. This construct is useful when you want to capture a part, but not all, of one of many alternatives. Inside a (?| group, parentheses are numbered as usual, but the number is reset at the start of each branch. The numbers of any capturing parentheses that follow the subpattern start after the highest number used in any branch. The following example is from the Perl documentation; the numbers underneath show in which buffer the captured content is stored: # before ---------------branch-reset----------- after / ( a ) (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x # 1 2 2 3 2 3 4 A back reference to a numbered subpattern uses the most recent value that is set for that number by any subpattern. The following pattern matches &quot;abcabc&quot; or &quot;defdef&quot;: / ( ? | ( abc ) | ( def ) ) \\ 1 / In contrast, a subroutine call to a numbered subpattern always refers to the first one in the pattern with the given number. The following pattern matches &quot;abcabc&quot; or &quot;defabc&quot;: / ( ? | ( abc ) | ( def ) ) ( ? 1 ) / If a condition test for a subpattern having matched refers to a non-unique number, the test is true if any of the subpatterns of that number have matched. An alternative approach using this &quot;branch reset&quot; feature is to use duplicate named subpatterns, as described in the next section. Named Subpatterns Identifying capturing parentheses by number is simple, but it can be hard to keep track of the numbers in complicated regular expressions. Also, if an expression is modified, the numbers can change. To help with this difficulty, PCRE supports the naming of subpatterns. This feature was not added to Perl until release 5.10. Python had the feature earlier, and PCRE introduced it at release 4.0, using the Python syntax. PCRE now supports both the Perl and the Python syntax. Perl allows identically numbered subpatterns to have different names, but PCRE does not. In PCRE, a subpattern can be named in one of three ways: (?&lt;name&gt;...) or (?'name'...) as in Perl, or (?P&lt;name&gt;...) as in Python. References to capturing parentheses from other parts of the pattern, such as back references, recursion, and conditions, can be made by name and by number. Names consist of up to 32 alphanumeric characters and underscores, but must start with a non-digit. Named capturing parentheses are still allocated numbers as well as names, exactly as if the names were not present. The capture specification to run/3 can use named values if they are present in the regular expression. By default, a name must be unique within a pattern, but this constraint can be relaxed by setting option dupnames at compile time. (Duplicate names are also always permitted for subpatterns with the same number, set up as described in the previous section.) Duplicate names can be useful for patterns where only one instance of the named parentheses can match. Suppose that you want to match the name of a weekday, either as a 3-letter abbreviation or as the full name, and in both cases you want to extract the abbreviation. The following pattern (ignoring the line breaks) does the job: (?&lt;DN&gt;Mon|Fri|Sun)(?:day)?| (?&lt;DN&gt;Tue)(?:sday)?| (?&lt;DN&gt;Wed)(?:nesday)?| (?&lt;DN&gt;Thu)(?:rsday)?| (?&lt;DN&gt;Sat)(?:urday)? There are five capturing substrings, but only one is ever set after a match. (An alternative way of solving this problem is to use a &quot;branch reset&quot; subpattern, as described in the previous section.) For capturing named subpatterns which names are not unique, the first matching occurrence (counted from left to right in the subject) is returned from run/3 , if the name is specified in the values part of the capture statement. The all_names capturing value matches all the names in the same way. You cannot use different names to distinguish between two subpatterns with the same number, as PCRE uses only the numbers when matching. For this reason, an error is given at compile time if different names are specified to subpatterns with the same number. However, you can specify the same name to subpatterns with the same number, even when dupnames is not set. Repetition Repetition is specified by quantifiers, which can follow any of the following items: A literal data character The dot metacharacter The \\C escape sequence The \\X escape sequence The \\R escape sequence An escape such as \\d or \\pL that matches a single character A character class A back reference (see the next section) A parenthesized subpattern (including assertions) A subroutine call to a subpattern (recursive or otherwise) The general repetition quantifier specifies a minimum and maximum number of permitted matches, by giving the two numbers in curly brackets (braces), separated by a comma. The numbers must be &lt; 65536, and the first must be less than or equal to the second. For example, the following matches &quot;zz&quot;, &quot;zzz&quot;, or &quot;zzzz&quot;: z { 2 , 4 } A closing brace on its own is not a special character. If the second number is omitted, but the comma is present, there is no upper limit. If the second number and the comma are both omitted, the quantifier specifies an exact number of required matches. Thus, the following matches at least three successive vowels, but can match many more: [ aeiou ] { 3 , } The following matches exactly eight digits: \\ d { 8 } An opening curly bracket that appears in a position where a quantifier is not allowed, or one that does not match the syntax of a quantifier, is taken as a literal character. For example, {,6} is not a quantifier, but a literal string of four characters. In Unicode mode, quantifiers apply to characters rather than to individual data units. Thus, for example, \\x{100}{2} matches two characters, each of which is represented by a 2-byte sequence in a UTF-8 string. Similarly, \\X{3} matches three Unicode extended grapheme clusters, each of which can be many data units long (and they can be of different lengths). The quantifier {0} is permitted, causing the expression to behave as if the previous item and the quantifier were not present. This can be useful for subpatterns that are referenced as subroutines from elsewhere in the pattern (but see also section Defining Subpatterns for Use by Reference Only ). Items other than subpatterns that have a {0} quantifier are omitted from the compiled pattern. For convenience, the three most common quantifiers have single-character abbreviations: * Equivalent to {0,} + Equivalent to {1,} ? Equivalent to {0,1} Infinite loops can be constructed by following a subpattern that can match no characters with a quantifier that has no upper limit, for example: ( a ? ) * Earlier versions of Perl and PCRE used to give an error at compile time for such patterns. However, as there are cases where this can be useful, such patterns are now accepted. However, if any repetition of the subpattern matches no characters, the loop is forcibly broken. By default, the quantifiers are &quot;greedy&quot;, that is, they match as much as possible (up to the maximum number of permitted times), without causing the remaining pattern to fail. The classic example of where this gives problems is in trying to match comments in C programs. These appear between /* and */. Within the comment, individual * and / characters can appear. An attempt to match C comments by applying the pattern / \\ * . * \\ * / to the string / * first comment * / not comment / * second comment * / fails, as it matches the entire string owing to the greediness of the .* item. However, if a quantifier is followed by a question mark, it ceases to be greedy, and instead matches the minimum number of times possible, so the following pattern does the right thing with the C comments: / \\ * . * ? \\ * / The meaning of the various quantifiers is not otherwise changed, only the preferred number of matches. Do not confuse this use of question mark with its use as a quantifier in its own right. As it has two uses, it can sometimes appear doubled, as in \\ d ? ? \\ d which matches one digit by preference, but can match two if that is the only way the remaining pattern matches. If option ungreedy is set (an option that is not available in Perl), the quantifiers are not greedy by default, but individual ones can be made greedy by following them with a question mark. That is, it inverts the default behavior. When a parenthesized subpattern is quantified with a minimum repeat count that is &gt; 1 or with a limited maximum, more memory is required for the compiled pattern, in proportion to the size of the minimum or maximum. If a pattern starts with .* or .{0,} and option dotall (equivalent to Perl option /s ) is set, thus allowing the dot to match newlines, the pattern is implicitly anchored, because whatever follows is tried against every character position in the subject string. So, there is no point in retrying the overall match at any position after the first. PCRE normally treats such a pattern as if it was preceded by \\A. In cases where it is known that the subject string contains no newlines, it is worth setting dotall to obtain this optimization, or alternatively using ^ to indicate anchoring explicitly. However, there are some cases where the optimization cannot be used. When .* is inside capturing parentheses that are the subject of a back reference elsewhere in the pattern, a match at the start can fail where a later one succeeds. Consider, for example: ( . * ) abc \\ 1 If the subject is &quot;xyz123abc123&quot;, the match point is the fourth character. Therefore, such a pattern is not implicitly anchored. Another case where implicit anchoring is not applied is when the leading .* is inside an atomic group. Once again, a match at the start can fail where a later one succeeds. Consider the following pattern: ( ? &gt; . * ? a ) b It matches &quot;ab&quot; in the subject &quot;aab&quot;. The use of the backtracking control verbs (*PRUNE) and (*SKIP) also disable this optimization. When a capturing subpattern is repeated, the value captured is the substring that matched the final iteration. For example, after ( tweedle [ dume ] { 3 } \\ s * ) + has matched &quot;tweedledum tweedledee&quot;, the value of the captured substring is &quot;tweedledee&quot;. However, if there are nested capturing subpatterns, the corresponding captured values can have been set in previous iterations. For example, after / ( a | ( b ) ) + / matches &quot;aba&quot;, the value of the second captured substring is &quot;b&quot;. Atomic Grouping and Possessive Quantifiers With both maximizing (&quot;greedy&quot;) and minimizing (&quot;ungreedy&quot; or &quot;lazy&quot;) repetition, failure of what follows normally causes the repeated item to be re-evaluated to see if a different number of repeats allows the remaining pattern to match. Sometimes it is useful to prevent this, either to change the nature of the match, or to cause it to fail earlier than it otherwise might, when the author of the pattern knows that there is no point in carrying on. Consider, for example, the pattern \\d+foo when applied to the following subject line: 123456 bar After matching all six digits and then failing to match &quot;foo&quot;, the normal action of the matcher is to try again with only five digits matching item \\d+, and then with four, and so on, before ultimately failing. &quot;Atomic grouping&quot; (a term taken from Jeffrey Friedl's book) provides the means for specifying that once a subpattern has matched, it is not to be re-evaluated in this way. If atomic grouping is used for the previous example, the matcher gives up immediately on failing to match &quot;foo&quot; the first time. The notation is a kind of special parenthesis, starting with (?&gt; as in the following example: ( ? &gt; \\ d + ) foo This kind of parenthesis &quot;locks up&quot; the part of the pattern it contains once it has matched, and a failure further into the pattern is prevented from backtracking into it. Backtracking past it to previous items, however, works as normal. An alternative description is that a subpattern of this type matches the string of characters that an identical standalone pattern would match, if anchored at the current point in the subject string. Atomic grouping subpatterns are not capturing subpatterns. Simple cases such as the above example can be thought of as a maximizing repeat that must swallow everything it can. So, while both \\d+ and \\d+? are prepared to adjust the number of digits they match to make the remaining pattern match, (?&gt;\\d+) can only match an entire sequence of digits. Atomic groups in general can contain any complicated subpatterns, and can be nested. However, when the subpattern for an atomic group is just a single repeated item, as in the example above, a simpler notation, called a &quot;possessive quantifier&quot; can be used. This consists of an extra + character following a quantifier. Using this notation, the previous example can be rewritten as \\ d ++ foo Notice that a possessive quantifier can be used with an entire group, for example: ( abc | xyz ) { 2 , 3 } + Possessive quantifiers are always greedy; the setting of option ungreedy is ignored. They are a convenient notation for the simpler forms of an atomic group. However, there is no difference in the meaning of a possessive quantifier and the equivalent atomic group, but there can be a performance difference; possessive quantifiers are probably slightly faster. The possessive quantifier syntax is an extension to the Perl 5.8 syntax. Jeffrey Friedl originated the idea (and the name) in the first edition of his book. Mike McCloskey liked it, so implemented it when he built the Sun Java package, and PCRE copied it from there. It ultimately found its way into Perl at release 5.10. PCRE has an optimization that automatically &quot;possessifies&quot; certain simple pattern constructs. For example, the sequence A+B is treated as A++B, as there is no point in backtracking into a sequence of A:s when B must follow. When a pattern contains an unlimited repeat inside a subpattern that can itself be repeated an unlimited number of times, the use of an atomic group is the only way to avoid some failing matches taking a long time. The pattern ( \\ D + | &lt; \\ d + &gt; ) * [ ! ? ] matches an unlimited number of substrings that either consist of non-digits, or digits enclosed in &lt;&gt;, followed by ! or ?. When it matches, it runs quickly. However, if it is applied to aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa it takes a long time before reporting failure. This is because the string can be divided between the internal \\D+ repeat and the external * repeat in many ways, and all must be tried. (The example uses [!?] rather than a single character at the end, as both PCRE and Perl have an optimization that allows for fast failure when a single character is used. They remember the last single character that is required for a match, and fail early if it is not present in the string.) If the pattern is changed so that it uses an atomic group, like the following, sequences of non-digits cannot be broken, and failure happens quickly: ( ( ? &gt; \\ D + ) | &lt; \\ d + &gt; ) * [ ! ? ] Back References Outside a character class, a backslash followed by a digit &gt; 0 (and possibly further digits) is a back reference to a capturing subpattern earlier (that is, to its left) in the pattern, provided there have been that many previous capturing left parentheses. However, if the decimal number following the backslash is &lt; 10, it is always taken as a back reference, and causes an error only if there are not that many capturing left parentheses in the entire pattern. That is, the parentheses that are referenced do need not be to the left of the reference for numbers &lt; 10. A &quot;forward back reference&quot; of this type can make sense when a repetition is involved and the subpattern to the right has participated in an earlier iteration. It is not possible to have a numerical &quot;forward back reference&quot; to a subpattern whose number is 10 or more using this syntax, as a sequence such as \\50 is interpreted as a character defined in octal. For more details of the handling of digits following a backslash, see section Non-Printing Characters earlier. There is no such problem when named parentheses are used. A back reference to any subpattern is possible using named parentheses (see below). Another way to avoid the ambiguity inherent in the use of digits following a backslash is to use the \\g escape sequence. This escape must be followed by an unsigned number or a negative number, optionally enclosed in braces. The following examples are identical: ( ring ) , \\ 1 ( ring ) , \\ g1 ( ring ) , \\ g { 1 } An unsigned number specifies an absolute reference without the ambiguity that is present in the older syntax. It is also useful when literal digits follow the reference. A negative number is a relative reference. Consider the following example: ( abc ( def ) ghi ) \\ g { - 1 } The sequence \\g{-1} is a reference to the most recently started capturing subpattern before \\g, that is, it is equivalent to \\2 in this example. Similarly, \\g{-2} would be equivalent to \\1. The use of relative references can be helpful in long patterns, and also in patterns that are created by joining fragments containing references within themselves. A back reference matches whatever matched the capturing subpattern in the current subject string, rather than anything matching the subpattern itself (section Subpattern as Subroutines describes a way of doing that). So, the following pattern matches &quot;sense and sensibility&quot; and &quot;response and responsibility&quot;, but not &quot;sense and responsibility&quot;: ( sens | respons ) e and \\ 1 ibility If caseful matching is in force at the time of the back reference, the case of letters is relevant. For example, the following matches &quot;rah rah&quot; and &quot;RAH RAH&quot;, but not &quot;RAH rah&quot;, although the original capturing subpattern is matched caselessly: ( ( ? i ) rah ) \\ s + \\ 1 There are many different ways of writing back references to named subpatterns. The .NET syntax \\k{name} and the Perl syntax \\k&lt;name&gt; or \\k'name' are supported, as is the Python syntax (?P=name) . The unified back reference syntax in Perl 5.10, in which \\g can be used for both numeric and named references, is also supported. The previous example can be rewritten in the following ways: ( ? &lt; p1 &gt; ( ? i ) rah ) \\ s + \\ k &lt; p1 &gt; ( ? &#39;p1&#39; ( ? i ) rah ) \\ s + \\ k { p1 } ( ? P &lt; p1 &gt; ( ? i ) rah ) \\ s + ( ? P = p1 ) ( ? &lt; p1 &gt; ( ? i ) rah ) \\ s + \\ g { p1 } A subpattern that is referenced by name can appear in the pattern before or after the reference. There can be more than one back reference to the same subpattern. If a subpattern has not been used in a particular match, any back references to it always fails. For example, the following pattern always fails if it starts to match &quot;a&quot; rather than &quot;bc&quot;: ( a | ( bc ) ) \\ 2 As there can be many capturing parentheses in a pattern, all digits following the backslash are taken as part of a potential back reference number. If the pattern continues with a digit character, some delimiter must be used to terminate the back reference. If option extended is set, this can be whitespace. Otherwise an empty comment (see section Comments ) can be used. Recursive Back References A back reference that occurs inside the parentheses to which it refers fails when the subpattern is first used, so, for example, (a\\1) never matches. However, such references can be useful inside repeated subpatterns. For example, the following pattern matches any number of &quot;a&quot;s and also &quot;aba&quot;, &quot;ababbaa&quot;, and so on: ( a | b \\ 1 ) + At each iteration of the subpattern, the back reference matches the character string corresponding to the previous iteration. In order for this to work, the pattern must be such that the first iteration does not need to match the back reference. This can be done using alternation, as in the example above, or by a quantifier with a minimum of zero. Back references of this type cause the group that they reference to be treated as an atomic group. Once the whole group has been matched, a subsequent matching failure cannot cause backtracking into the middle of the group. Assertions An assertion is a test on the characters following or preceding the current matching point that does not consume any characters. The simple assertions coded as \\b, \\B, \\A, \\G, \\Z, \\z, ^, and $ are described in the previous sections. More complicated assertions are coded as subpatterns. There are two kinds: those that look ahead of the current position in the subject string, and those that look behind it. An assertion subpattern is matched in the normal way, except that it does not cause the current matching position to be changed. Assertion subpatterns are not capturing subpatterns. If such an assertion contains capturing subpatterns within it, these are counted for the purposes of numbering the capturing subpatterns in the whole pattern. However, substring capturing is done only for positive assertions. (Perl sometimes, but not always, performs capturing in negative assertions.) If a positive assertion containing one or more capturing subpatterns succeeds, but failure to match later in the pattern causes backtracking over this assertion, the captures within the assertion are reset only if no higher numbered captures are already set. This is, unfortunately, a fundamental limitation of the current implementation, and as PCRE1 is now in maintenance-only status, it is unlikely ever to change. For compatibility with Perl, assertion subpatterns can be repeated. However, it makes no sense to assert the same thing many times, the side effect of capturing parentheses can occasionally be useful. In practice, there are only three cases: If the quantifier is {0}, the assertion is never obeyed during matching. However, it can contain internal capturing parenthesized groups that are called from elsewhere through the subroutine mechanism. If quantifier is {0,n}, where n &gt; 0, it is treated as if it was {0,1}. At runtime, the remaining pattern match is tried with and without the assertion, the order depends on the greediness of the quantifier. If the minimum repetition is &gt; 0, the quantifier is ignored. The assertion is obeyed only once when encountered during matching. Lookahead Assertions Lookahead assertions start with (?= for positive assertions and (?! for negative assertions. For example, the following matches a word followed by a semicolon, but does not include the semicolon in the match: \\ w + ( ? = ; ) The following matches any occurrence of &quot;foo&quot; that is not followed by &quot;bar&quot;: foo ( ?! bar ) Notice that the apparently similar pattern ( ?! foo ) bar does not find an occurrence of &quot;bar&quot; that is preceded by something other than &quot;foo&quot;. It finds any occurrence of &quot;bar&quot; whatsoever, as the assertion (?!foo) is always true when the next three characters are &quot;bar&quot;. A lookbehind assertion is needed to achieve the other effect. If you want to force a matching failure at some point in a pattern, the most convenient way to do it is with (?!), as an empty string always matches. So, an assertion that requires there is not to be an empty string must always fail. The backtracking control verb (*FAIL) or (*F) is a synonym for (?!). Lookbehind Assertions Lookbehind assertions start with (?&lt;= for positive assertions and (?&lt;! for negative assertions. For example, the following finds an occurrence of &quot;bar&quot; that is not preceded by &quot;foo&quot;: ( ? &lt; ! foo ) bar The contents of a lookbehind assertion are restricted such that all the strings it matches must have a fixed length. However, if there are many top-level alternatives, they do not all have to have the same fixed length. Thus, the following is permitted: ( ? &lt; = bullock | donkey ) The following causes an error at compile time: ( ? &lt; ! dogs ? | cats ? ) Branches that match different length strings are permitted only at the top-level of a lookbehind assertion. This is an extension compared with Perl, which requires all branches to match the same length of string. An assertion such as the following is not permitted, as its single top-level branch can match two different lengths: ( ? &lt; = ab ( c | de ) ) However, it is acceptable to PCRE if rewritten to use two top-level branches: ( ? &lt; = abc | abde ) Sometimes the escape sequence \\K (see above) can be used instead of a lookbehind assertion to get round the fixed-length restriction. The implementation of lookbehind assertions is, for each alternative, to move the current position back temporarily by the fixed length and then try to match. If there are insufficient characters before the current position, the assertion fails. In a UTF mode, PCRE does not allow the \\C escape (which matches a single data unit even in a UTF mode) to appear in lookbehind assertions, as it makes it impossible to calculate the length of the lookbehind. The \\X and \\R escapes, which can match different numbers of data units, are not permitted either. &quot;Subroutine&quot; calls (see below), such as (?2) or (?&amp;X), are permitted in lookbehinds, as long as the subpattern matches a fixed-length string. Recursion, however, is not supported. Possessive quantifiers can be used with lookbehind assertions to specify efficient matching of fixed-length strings at the end of subject strings. Consider the following simple pattern when applied to a long string that does not match: abcd $ As matching proceeds from left to right, PCRE looks for each &quot;a&quot; in the subject and then sees if what follows matches the remaining pattern. If the pattern is specified as ^ . * abcd $ the initial .* matches the entire string at first. However, when this fails (as there is no following &quot;a&quot;), it backtracks to match all but the last character, then all but the last two characters, and so on. Once again the search for &quot;a&quot; covers the entire string, from right to left, so we are no better off. However, if the pattern is written as ^ . * + ( ? &lt; = abcd ) there can be no backtracking for the .*+ item; it can match only the entire string. The subsequent lookbehind assertion does a single test on the last four characters. If it fails, the match fails immediately. For long strings, this approach makes a significant difference to the processing time. Using Multiple Assertions Many assertions (of any sort) can occur in succession. For example, the following matches &quot;foo&quot; preceded by three digits that are not &quot;999&quot;: ( ? &lt; = \\ d { 3 } ) ( ? &lt; ! 999 ) foo Notice that each of the assertions is applied independently at the same point in the subject string. First there is a check that the previous three characters are all digits, and then there is a check that the same three characters are not &quot;999&quot;. This pattern does not match &quot;foo&quot; preceded by six characters, the first of which are digits and the last three of which are not &quot;999&quot;. For example, it does not match &quot;123abcfoo&quot;. A pattern to do that is the following: ( ? &lt; = \\ d { 3 } . . . ) ( ? &lt; ! 999 ) foo This time the first assertion looks at the preceding six characters, checks that the first three are digits, and then the second assertion checks that the preceding three characters are not &quot;999&quot;. Assertions can be nested in any combination. For example, the following matches an occurrence of &quot;baz&quot; that is preceded by &quot;bar&quot;, which in turn is not preceded by &quot;foo&quot;: ( ? &lt; = ( ? &lt; ! foo ) bar ) baz The following pattern matches &quot;foo&quot; preceded by three digits and any three characters that are not &quot;999&quot;: ( ? &lt; = \\ d { 3 } ( ?! 999 ) . . . ) foo Conditional Subpatterns It is possible to cause the matching process to obey a subpattern conditionally or to choose between two alternative subpatterns, depending on the result of an assertion, or whether a specific capturing subpattern has already been matched. The following are the two possible forms of conditional subpattern: ( ? ( condition ) yes - pattern ) ( ? ( condition ) yes - pattern | no - pattern ) If the condition is satisfied, the yes-pattern is used, otherwise the no-pattern (if present). If more than two alternatives exist in the subpattern, a compile-time error occurs. Each of the two alternatives can itself contain nested subpatterns of any form, including conditional subpatterns; the restriction to two alternatives applies only at the level of the condition. The following pattern fragment is an example where the alternatives are complex: ( ? ( 1 ) ( A | B | C ) | ( D | ( ? ( 2 ) E | F ) | E ) ) There are four kinds of condition: references to subpatterns, references to recursion, a pseudo-condition called DEFINE, and assertions. Checking for a Used Subpattern By Number If the text between the parentheses consists of a sequence of digits, the condition is true if a capturing subpattern of that number has previously matched. If more than one capturing subpattern with the same number exists (see section Duplicate Subpattern Numbers earlier), the condition is true if any of them have matched. An alternative notation is to precede the digits with a plus or minus sign. In this case, the subpattern number is relative rather than absolute. The most recently opened parentheses can be referenced by (?(-1), the next most recent by (?(-2), and so on. Inside loops, it can also make sense to refer to subsequent groups. The next parentheses to be opened can be referenced as (?(+1), and so on. (The value zero in any of these forms is not used; it provokes a compile-time error.) Consider the following pattern, which contains non-significant whitespace to make it more readable (assume option extended ) and to divide it into three parts for ease of discussion: ( \\ ( ) ? [ ^ ( ) ] + ( ? ( 1 ) \\ ) ) The first part matches an optional opening parenthesis, and if that character is present, sets it as the first captured substring. The second part matches one or more characters that are not parentheses. The third part is a conditional subpattern that tests whether the first set of parentheses matched or not. If they did, that is, if subject started with an opening parenthesis, the condition is true, and so the yes-pattern is executed and a closing parenthesis is required. Otherwise, as no-pattern is not present, the subpattern matches nothing. That is, this pattern matches a sequence of non-parentheses, optionally enclosed in parentheses. If this pattern is embedded in a larger one, a relative reference can be used: . . . other stuff . . . ( \\ ( ) ? [ ^ ( ) ] + ( ? ( - 1 ) \\ ) ) . . . This makes the fragment independent of the parentheses in the larger pattern. Checking for a Used Subpattern By Name Perl uses the syntax (?(&lt;name&gt;)...) or (?('name')...) to test for a used subpattern by name. For compatibility with earlier versions of PCRE, which had this facility before Perl, the syntax (?(name)...) is also recognized. Rewriting the previous example to use a named subpattern gives: ( ? &lt; OPEN &gt; \\ ( ) ? [ ^ ( ) ] + ( ? ( &lt; OPEN &gt; ) \\ ) ) If the name used in a condition of this kind is a duplicate, the test is applied to all subpatterns of the same name, and is true if any one of them has matched. Checking for Pattern Recursion If the condition is the string (R), and there is no subpattern with the name R, the condition is true if a recursive call to the whole pattern or any subpattern has been made. If digits or a name preceded by ampersand follow the letter R, for example: ( ? ( R3 ) . . . ) or ( ? ( R &amp; name ) . . . ) the condition is true if the most recent recursion is into a subpattern whose number or name is given. This condition does not check the entire recursion stack. If the name used in a condition of this kind is a duplicate, the test is applied to all subpatterns of the same name, and is true if any one of them is the most recent recursion. At &quot;top-level&quot;, all these recursion test conditions are false. The syntax for recursive patterns is described below. Defining Subpatterns for Use By Reference Only If the condition is the string (DEFINE), and there is no subpattern with the name DEFINE, the condition is always false. In this case, there can be only one alternative in the subpattern. It is always skipped if control reaches this point in the pattern. The idea of DEFINE is that it can be used to define &quot;subroutines&quot; that can be referenced from elsewhere. (The use of subroutines is described below.) For example, a pattern to match an IPv4 address, such as &quot;192.168.23.245&quot;, can be written like this (ignore whitespace and line breaks): ( ? ( DEFINE ) ( ? &lt; byte &gt; 2 [ 0 - 4 ] \\ d | 25 [ 0 - 5 ] | 1 \\ d \\ d | [ 1 - 9 ] ? \\ d ) ) \\ b ( ? &amp; byte ) ( \\ . ( ? &amp; byte ) ) { 3 } \\ b The first part of the pattern is a DEFINE group inside which is a another group named &quot;byte&quot; is defined. This matches an individual component of an IPv4 address (a number &lt; 256). When matching takes place, this part of the pattern is skipped, as DEFINE acts like a false condition. The remaining pattern uses references to the named group to match the four dot-separated components of an IPv4 address, insisting on a word boundary at each end. Assertion Conditions If the condition is not in any of the above formats, it must be an assertion. This can be a positive or negative lookahead or lookbehind assertion. Consider the following pattern, containing non-significant whitespace, and with the two alternatives on the second line: (?(?=[^a-z]*[a-z]) \\d{2}-[a-z]{3}-\\d{2} | \\d{2}-\\d{2}-\\d{2} ) The condition is a positive lookahead assertion that matches an optional sequence of non-letters followed by a letter. That is, it tests for the presence of at least one letter in the subject. If a letter is found, the subject is matched against the first alternative, otherwise it is matched against the second. This pattern matches strings in one of the two forms dd-aaa-dd or dd-dd-dd, where aaa are letters and dd are digits. Comments There are two ways to include comments in patterns that are processed by PCRE. In both cases, the start of the comment must not be in a character class, or in the middle of any other sequence of related characters such as (?: or a subpattern name or number. The characters that make up a comment play no part in the pattern matching. The sequence (?# marks the start of a comment that continues up to the next closing parenthesis. Nested parentheses are not permitted. If option PCRE_EXTENDED is set, an unescaped # character also introduces a comment, which in this case continues to immediately after the next newline character or character sequence in the pattern. Which characters are interpreted as newlines is controlled by the options passed to a compiling function or by a special sequence at the start of the pattern, as described in section Newline Conventions earlier. Notice that the end of this type of comment is a literal newline sequence in the pattern; escape sequences that happen to represent a newline do not count. For example, consider the following pattern when extended is set, and the default newline convention is in force: abc # comment \\ n still comment On encountering character #, pcre_compile() skips along, looking for a newline in the pattern. The sequence \\n is still literal at this stage, so it does not terminate the comment. Only a character with code value 0x0a (the default newline) does so. Recursive Patterns Consider the problem of matching a string in parentheses, allowing for unlimited nested parentheses. Without the use of recursion, the best that can be done is to use a pattern that matches up to some fixed depth of nesting. It is not possible to handle an arbitrary nesting depth. For some time, Perl has provided a facility that allows regular expressions to recurse (among other things). It does this by interpolating Perl code in the expression at runtime, and the code can refer to the expression itself. A Perl pattern using code interpolation to solve the parentheses problem can be created like this: $r e = qr { \\ ( ( ? : ( ? &gt; [ ^ ( ) ] + ) | ( ? p { $r e } ) ) * \\ ) } x ; Item (?p{...}) interpolates Perl code at runtime, and in this case refers recursively to the pattern in which it appears. Obviously, PCRE cannot support the interpolation of Perl code. Instead, it supports special syntax for recursion of the entire pattern, and for individual subpattern recursion. After its introduction in PCRE and Python, this kind of recursion was later introduced into Perl at release 5.10. A special item that consists of (? followed by a number &gt; 0 and a closing parenthesis is a recursive subroutine call of the subpattern of the given number, if it occurs inside that subpattern. (If not, it is a non-recursive subroutine call, which is described in the next section.) The special item (?R) or (?0) is a recursive call of the entire regular expression. This PCRE pattern solves the nested parentheses problem (assume that option extended is set so that whitespace is ignored): \\ ( ( [ ^ ( ) ] ++ | ( ? R ) ) * \\ ) First it matches an opening parenthesis. Then it matches any number of substrings, which can either be a sequence of non-parentheses or a recursive match of the pattern itself (that is, a correctly parenthesized substring). Finally there is a closing parenthesis. Notice the use of a possessive quantifier to avoid backtracking into sequences of non-parentheses. If this was part of a larger pattern, you would not want to recurse the entire pattern, so instead you can use: ( \\ ( ( [ ^ ( ) ] ++ | ( ? 1 ) ) * \\ ) ) The pattern is here within parentheses so that the recursion refers to them instead of the whole pattern. In a larger pattern, keeping track of parenthesis numbers can be tricky. This is made easier by the use of relative references. Instead of (?1) in the pattern above, you can write (?-2) to refer to the second most recently opened parentheses preceding the recursion. That is, a negative number counts capturing parentheses leftwards from the point at which it is encountered. It is also possible to refer to later opened parentheses, by writing references such as (?+2). However, these cannot be recursive, as the reference is not inside the parentheses that are referenced. They are always non-recursive subroutine calls, as described in the next section. An alternative approach is to use named parentheses instead. The Perl syntax for this is (?&amp;name). The earlier PCRE syntax (?P&gt;name) is also supported. We can rewrite the above example as follows: ( ? &lt; pn &gt; \\ ( ( [ ^ ( ) ] ++ | ( ? &amp; pn ) ) * \\ ) ) If there is more than one subpattern with the same name, the earliest one is used. This particular example pattern that we have studied contains nested unlimited repeats, and so the use of a possessive quantifier for matching strings of non-parentheses is important when applying the pattern to strings that do not match. For example, when this pattern is applied to ( aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ( ) it gives &quot;no match&quot; quickly. However, if a possessive quantifier is not used, the match runs for a long time, as there are so many different ways the + and * repeats can carve up the subject, and all must be tested before failure can be reported. At the end of a match, the values of capturing parentheses are those from the outermost level. If the pattern above is matched against ( ab ( cd ) ef ) the value for the inner capturing parentheses (numbered 2) is &quot;ef&quot;, which is the last value taken on at the top-level. If a capturing subpattern is not matched at the top level, its final captured value is unset, even if it was (temporarily) set at a deeper level during the matching process. Do not confuse item (?R) with condition (R), which tests for recursion. Consider the following pattern, which matches text in angle brackets, allowing for arbitrary nesting. Only digits are allowed in nested brackets (that is, when recursing), while any characters are permitted at the outer level. &lt; ( ? : ( ? ( R ) \\ d ++ | [ ^ &lt; &gt; ] * + ) | ( ? R ) ) * &gt; Here (?(R) is the start of a conditional subpattern, with two different alternatives for the recursive and non-recursive cases. Item (?R) is the actual recursive call. Differences in Recursion Processing between PCRE and Perl Recursion processing in PCRE differs from Perl in two important ways. In PCRE (like Python, but unlike Perl), a recursive subpattern call is always treated as an atomic group. That is, once it has matched some of the subject string, it is never re-entered, even if it contains untried alternatives and there is a subsequent matching failure. This can be illustrated by the following pattern, which means to match a palindromic string containing an odd number of characters (for example, &quot;a&quot;, &quot;aba&quot;, &quot;abcba&quot;, &quot;abcdcba&quot;): ^ ( . | ( . ) ( ? 1 ) \\ 2 ) $ The idea is that it either matches a single character, or two identical characters surrounding a subpalindrome. In Perl, this pattern works; in PCRE it does not work if the pattern is longer than three characters. Consider the subject string &quot;abcba&quot;. At the top level, the first character is matched, but as it is not at the end of the string, the first alternative fails, the second alternative is taken, and the recursion kicks in. The recursive call to subpattern 1 successfully matches the next character (&quot;b&quot;). (Notice that the beginning and end of line tests are not part of the recursion.) Back at the top level, the next character (&quot;c&quot;) is compared with what subpattern 2 matched, which was &quot;a&quot;. This fails. As the recursion is treated as an atomic group, there are now no backtracking points, and so the entire match fails. (Perl can now re-enter the recursion and try the second alternative.) However, if the pattern is written with the alternatives in the other order, things are different: ^ ( ( . ) ( ? 1 ) \\ 2 | . ) $ This time, the recursing alternative is tried first, and continues to recurse until it runs out of characters, at which point the recursion fails. But this time we have another alternative to try at the higher level. That is the significant difference: in the previous case the remaining alternative is at a deeper recursion level, which PCRE cannot use. To change the pattern so that it matches all palindromic strings, not only those with an odd number of characters, it is tempting to change the pattern to this: ^ ( ( . ) ( ? 1 ) \\ 2 | . ? ) $ Again, this works in Perl, but not in PCRE, and for the same reason. When a deeper recursion has matched a single character, it cannot be entered again to match an empty string. The solution is to separate the two cases, and write out the odd and even cases as alternatives at the higher level: ^ ( ? : ( ( . ) ( ? 1 ) \\ 2 | ) | ( ( . ) ( ? 3 ) \\ 4 | . ) ) If you want to match typical palindromic phrases, the pattern must ignore all non-word characters, which can be done as follows: ^ \\ W * + ( ? : ( ( . ) \\ W * + ( ? 1 ) \\ W * + \\ 2 | ) | ( ( . ) \\ W * + ( ? 3 ) \\ W * + \\ 4 | \\ W * + . \\ W * + ) ) \\ W * + $ If run with option caseless , this pattern matches phrases such as &quot;A man, a plan, a canal: Panama!&quot; and it works well in both PCRE and Perl. Notice the use of the possessive quantifier *+ to avoid backtracking into sequences of non-word characters. Without this, PCRE takes much longer (10 times or more) to match typical phrases, and Perl takes so long that you think it has gone into a loop. The palindrome-matching patterns above work only if the subject string does not start with a palindrome that is shorter than the entire string. For example, although &quot;abcba&quot; is correctly matched, if the subject is &quot;ababa&quot;, PCRE finds palindrome &quot;aba&quot; at the start, and then fails at top level, as the end of the string does not follow. Once again, it cannot jump back into the recursion to try other alternatives, so the entire match fails. The second way in which PCRE and Perl differ in their recursion processing is in the handling of captured values. In Perl, when a subpattern is called recursively or as a subpattern (see the next section), it has no access to any values that were captured outside the recursion. In PCRE these values can be referenced. Consider the following pattern: ^ ( . ) ( \\ 1 | a ( ? 2 ) ) In PCRE, it matches &quot;bab&quot;. The first capturing parentheses match &quot;b&quot;, then in the second group, when the back reference \\1 fails to match &quot;b&quot;, the second alternative matches &quot;a&quot;, and then recurses. In the recursion, \\1 does now match &quot;b&quot; and so the whole match succeeds. In Perl, the pattern fails to match because inside the recursive call \\1 cannot access the externally set value. Subpatterns as Subroutines If the syntax for a recursive subpattern call (either by number or by name) is used outside the parentheses to which it refers, it operates like a subroutine in a programming language. The called subpattern can be defined before or after the reference. A numbered reference can be absolute or relative, as in the following examples: ( . . . ( absolute ) . . . ) . . . ( ? 2 ) . . . ( . . . ( relative ) . . . ) . . . ( ? - 1 ) . . . ( . . . ( ? + 1 ) . . . ( relative ) . . . An earlier example pointed out that the following pattern matches &quot;sense and sensibility&quot; and &quot;response and responsibility&quot;, but not &quot;sense and responsibility&quot;: ( sens | respons ) e and \\ 1 ibility If instead the following pattern is used, it matches &quot;sense and responsibility&quot; and the other two strings: ( sens | respons ) e and ( ? 1 ) ibility Another example is provided in the discussion of DEFINE earlier. All subroutine calls, recursive or not, are always treated as atomic groups. That is, once a subroutine has matched some of the subject string, it is never re-entered, even if it contains untried alternatives and there is a subsequent matching failure. Any capturing parentheses that are set during the subroutine call revert to their previous values afterwards. Processing options such as case-independence are fixed when a subpattern is defined, so if it is used as a subroutine, such options cannot be changed for different calls. For example, the following pattern matches &quot;abcabc&quot; but not &quot;abcABC&quot;, as the change of processing option does not affect the called subpattern: ( abc ) ( ? i : ( ? - 1 ) ) Oniguruma Subroutine Syntax For compatibility with Oniguruma, the non-Perl syntax \\g followed by a name or a number enclosed either in angle brackets or single quotes, is alternative syntax for referencing a subpattern as a subroutine, possibly recursively. Here follows two of the examples used above, rewritten using this syntax: ( ? &lt; pn &gt; \\ ( ( ( ? &gt; [ ^ ( ) ] + ) | \\ g &lt; pn &gt; ) * \\ ) ) ( sens | respons ) e and \\ g &#39;1&#39; ibility PCRE supports an extension to Oniguruma: if a number is preceded by a plus or minus sign, it is taken as a relative reference, for example: ( abc ) ( ? i : \\ g &lt;- 1 &gt; ) Notice that \\g{...} (Perl syntax) and \\g&lt;...&gt; (Oniguruma syntax) are not synonymous. The former is a back reference; the latter is a subroutine call. Backtracking Control Perl 5.10 introduced some &quot;Special Backtracking Control Verbs&quot;, which are still described in the Perl documentation as &quot;experimental and subject to change or removal in a future version of Perl&quot;. It goes on to say: &quot;Their usage in production code should be noted to avoid problems during upgrades.&quot; The same remarks apply to the PCRE features described in this section. The new verbs make use of what was previously invalid syntax: an opening parenthesis followed by an asterisk. They are generally of the form (*VERB) or (*VERB:NAME). Some can take either form, possibly behaving differently depending on whether a name is present. A name is any sequence of characters that does not include a closing parenthesis. The maximum name length is 255 in the 8-bit library and 65535 in the 16-bit and 32-bit libraries. If the name is empty, that is, if the closing parenthesis immediately follows the colon, the effect is as if the colon was not there. Any number of these verbs can occur in a pattern. The behavior of these verbs in repeated groups, assertions, and in subpatterns called as subroutines (whether or not recursively) is described below. Optimizations That Affect Backtracking Verbs PCRE contains some optimizations that are used to speed up matching by running some checks at the start of each match attempt. For example, it can know the minimum length of matching subject, or that a particular character must be present. When one of these optimizations bypasses the running of a match, any included backtracking verbs are not processed. processed. You can suppress the start-of-match optimizations by setting option no_start_optimize when calling compile/2 or run/3 , or by starting the pattern with (*NO_START_OPT). Experiments with Perl suggest that it too has similar optimizations, sometimes leading to anomalous results. Verbs That Act Immediately The following verbs act as soon as they are encountered. They must not be followed by a name. ( * ACCEPT ) This verb causes the match to end successfully, skipping the remainder of the pattern. However, when it is inside a subpattern that is called as a subroutine, only that subpattern is ended successfully. Matching then continues at the outer level. If (*ACCEPT) is triggered in a positive assertion, the assertion succeeds; in a negative assertion, the assertion fails. If (*ACCEPT) is inside capturing parentheses, the data so far is captured. For example, the following matches &quot;AB&quot;, &quot;AAD&quot;, or &quot;ACD&quot;. When it matches &quot;AB&quot;, &quot;B&quot; is captured by the outer parentheses. A ( ( ? : A | B ( * ACCEPT ) | C ) D ) The following verb causes a matching failure, forcing backtracking to occur. It is equivalent to (?!) but easier to read. ( * FAIL ) or ( * F ) The Perl documentation states that it is probably useful only when combined with (?{}) or (??{}). Those are Perl features that are not present in PCRE. A match with the string &quot;aaaa&quot; always fails, but the callout is taken before each backtrack occurs (in this example, 10 times). Recording Which Path Was Taken The main purpose of this verb is to track how a match was arrived at, although it also has a secondary use in with advancing the match starting point (see (*SKIP) below). In Erlang, there is no interface to retrieve a mark with run/2,3 , so only the secondary purpose is relevant to the Erlang programmer. The rest of this section is therefore deliberately not adapted for reading by the Erlang programmer, but the examples can help in understanding NAMES as they can be used by (*SKIP). ( * MARK : NAME ) or ( * : NAME ) A name is always required with this verb. There can be as many instances of (*MARK) as you like in a pattern, and their names do not have to be unique. When a match succeeds, the name of the last encountered (*MARK:NAME), (*PRUNE:NAME), or (*THEN:NAME) on the matching path is passed back to the caller as described in section &quot;Extra data for pcre_exec() &quot; in the pcreapi documentation. In the following example of pcretest output, the /K modifier requests the retrieval and outputting of (*MARK) data: re &gt; / X ( * MARK : A ) Y | X ( * MARK : B ) Z / K data &gt; XY 0 : XY MK : A XZ 0 : XZ MK : B The (*MARK) name is tagged with &quot;MK:&quot; in this output, and in this example it indicates which of the two alternatives matched. This is a more efficient way of obtaining this information than putting each alternative in its own capturing parentheses. If a verb with a name is encountered in a positive assertion that is true, the name is recorded and passed back if it is the last encountered. This does not occur for negative assertions or failing positive assertions. After a partial match or a failed match, the last encountered name in the entire match process is returned, for example: re &gt; / X ( * MARK : A ) Y | X ( * MARK : B ) Z / K data &gt; XP No match , mark = B Notice that in this unanchored example, the mark is retained from the match attempt that started at letter &quot;X&quot; in the subject. Subsequent match attempts starting at &quot;P&quot; and then with an empty string do not get as far as the (*MARK) item, nevertheless do not reset it. Verbs That Act after Backtracking The following verbs do nothing when they are encountered. Matching continues with what follows, but if there is no subsequent match, causing a backtrack to the verb, a failure is forced. That is, backtracking cannot pass to the left of the verb. However, when one of these verbs appears inside an atomic group or an assertion that is true, its effect is confined to that group, as once the group has been matched, there is never any backtracking into it. In this situation, backtracking can &quot;jump back&quot; to the left of the entire atomic group or assertion. (Remember also, as stated above, that this localization also applies in subroutine calls.) These verbs differ in exactly what kind of failure occurs when backtracking reaches them. The behavior described below is what occurs when the verb is not in a subroutine or an assertion. Subsequent sections cover these special cases. The following verb, which must not be followed by a name, causes the whole match to fail outright if there is a later matching failure that causes backtracking to reach it. Even if the pattern is unanchored, no further attempts to find a match by advancing the starting point take place. ( * COMMIT ) If (*COMMIT) is the only backtracking verb that is encountered, once it has been passed, run/2,3 is committed to find a match at the current starting point, or not at all, for example: a + ( * COMMIT ) b This matches &quot;xxaab&quot; but not &quot;aacaab&quot;. It can be thought of as a kind of dynamic anchor, or &quot;I've started, so I must finish&quot;. The name of the most recently passed (*MARK) in the path is passed back when (*COMMIT) forces a match failure. If more than one backtracking verb exists in a pattern, a different one that follows (*COMMIT) can be triggered first, so merely passing (*COMMIT) during a match does not always guarantee that a match must be at this starting point. Notice that (*COMMIT) at the start of a pattern is not the same as an anchor, unless the PCRE start-of-match optimizations are turned off, as shown in the following example: 1&gt; re:run(&quot;xyzabc&quot;,&quot;(*COMMIT)abc&quot;,[{capture,all,list}]). {match,[&quot;abc&quot;]} 2&gt; re:run(&quot;xyzabc&quot;,&quot;(*COMMIT)abc&quot;,[{capture,all,list},no_start_optimize]). nomatch For this pattern, PCRE knows that any match must start with &quot;a&quot;, so the optimization skips along the subject to &quot;a&quot; before applying the pattern to the first set of data. The match attempt then succeeds. In the second call the no_start_optimize disables the optimization that skips along to the first character. The pattern is now applied starting at &quot;x&quot;, and so the (*COMMIT) causes the match to fail without trying any other starting points. The following verb causes the match to fail at the current starting position in the subject if there is a later matching failure that causes backtracking to reach it: ( * PRUNE ) or ( * PRUNE : NAME ) If the pattern is unanchored, the normal &quot;bumpalong&quot; advance to the next starting character then occurs. Backtracking can occur as usual to the left of (*PRUNE), before it is reached, or when matching to the right of (*PRUNE), but if there is no match to the right, backtracking cannot cross (*PRUNE). In simple cases, the use of (*PRUNE) is just an alternative to an atomic group or possessive quantifier, but there are some uses of (*PRUNE) that cannot be expressed in any other way. In an anchored pattern, (*PRUNE) has the same effect as (*COMMIT). The behavior of (*PRUNE:NAME) is the not the same as (*MARK:NAME)(*PRUNE). It is like (*MARK:NAME) in that the name is remembered for passing back to the caller. However, (*SKIP:NAME) searches only for names set with (*MARK). The fact that (*PRUNE:NAME) remembers the name is useless to the Erlang programmer, as names cannot be retrieved. The following verb, when specified without a name, is like (*PRUNE), except that if the pattern is unanchored, the &quot;bumpalong&quot; advance is not to the next character, but to the position in the subject where (*SKIP) was encountered. ( * SKIP ) (*SKIP) signifies that whatever text was matched leading up to it cannot be part of a successful match. Consider: a + ( * SKIP ) b If the subject is &quot;aaaac...&quot;, after the first match attempt fails (starting at the first character in the string), the starting point skips on to start the next attempt at &quot;c&quot;. Notice that a possessive quantifier does not have the same effect as this example; although it would suppress backtracking during the first match attempt, the second attempt would start at the second character instead of skipping on to &quot;c&quot;. When (*SKIP) has an associated name, its behavior is modified: ( * SKIP : NAME ) When this is triggered, the previous path through the pattern is searched for the most recent (*MARK) that has the same name. If one is found, the &quot;bumpalong&quot; advance is to the subject position that corresponds to that (*MARK) instead of to where (*SKIP) was encountered. If no (*MARK) with a matching name is found, (*SKIP) is ignored. Notice that (*SKIP:NAME) searches only for names set by (*MARK:NAME). It ignores names that are set by (*PRUNE:NAME) or (*THEN:NAME). The following verb causes a skip to the next innermost alternative when backtracking reaches it. That is, it cancels any further backtracking within the current alternative. ( * THEN ) or ( * THEN : NAME ) The verb name comes from the observation that it can be used for a pattern-based if-then-else block: ( COND1 ( * THEN ) FOO | COND2 ( * THEN ) BAR | COND3 ( * THEN ) BAZ ) . . . If the COND1 pattern matches, FOO is tried (and possibly further items after the end of the group if FOO succeeds). On failure, the matcher skips to the second alternative and tries COND2, without backtracking into COND1. If that succeeds and BAR fails, COND3 is tried. If BAZ then fails, there are no more alternatives, so there is a backtrack to whatever came before the entire group. If (*THEN) is not inside an alternation, it acts like (*PRUNE). The behavior of (*THEN:NAME) is the not the same as (*MARK:NAME)(*THEN). It is like (*MARK:NAME) in that the name is remembered for passing back to the caller. However, (*SKIP:NAME) searches only for names set with (*MARK). The fact that (*THEN:NAME) remembers the name is useless to the Erlang programmer, as names cannot be retrieved. A subpattern that does not contain a | character is just a part of the enclosing alternative; it is not a nested alternation with only one alternative. The effect of (*THEN) extends beyond such a subpattern to the enclosing alternative. Consider the following pattern, where A, B, and so on, are complex pattern fragments that do not contain any | characters at this level: A ( B ( * THEN ) C ) | D If A and B are matched, but there is a failure in C, matching does not backtrack into A; instead it moves to the next alternative, that is, D. However, if the subpattern containing (*THEN) is given an alternative, it behaves differently: A ( B ( * THEN ) C | ( * FAIL ) ) | D The effect of (*THEN) is now confined to the inner subpattern. After a failure in C, matching moves to (*FAIL), which causes the whole subpattern to fail, as there are no more alternatives to try. In this case, matching does now backtrack into A. Notice that a conditional subpattern is not considered as having two alternatives, as only one is ever used. That is, the | character in a conditional subpattern has a different meaning. Ignoring whitespace, consider: ^ . * ? ( ? ( ? = a ) a | b ( * THEN ) c ) If the subject is &quot;ba&quot;, this pattern does not match. As .*? is ungreedy, it initially matches zero characters. The condition (?=a) then fails, the character &quot;b&quot; is matched, but &quot;c&quot; is not. At this point, matching does not backtrack to .*? as can perhaps be expected from the presence of the | character. The conditional subpattern is part of the single alternative that comprises the whole pattern, and so the match fails. (If there was a backtrack into .*?, allowing it to match &quot;b&quot;, the match would succeed.) The verbs described above provide four different &quot;strengths&quot; of control when subsequent matching fails: (*THEN) is the weakest, carrying on the match at the next alternative. (*PRUNE) comes next, fails the match at the current starting position, but allows an advance to the next character (for an unanchored pattern). (*SKIP) is similar, except that the advance can be more than one character. (*COMMIT) is the strongest, causing the entire match to fail. More than One Backtracking Verb If more than one backtracking verb is present in a pattern, the one that is backtracked onto first acts. For example, consider the following pattern, where A, B, and so on, are complex pattern fragments: ( A ( * COMMIT ) B ( * THEN ) C | ABD ) If A matches but B fails, the backtrack to (*COMMIT) causes the entire match to fail. However, if A and B match, but C fails, the backtrack to (*THEN) causes the next alternative (ABD) to be tried. This behavior is consistent, but is not always the same as in Perl. It means that if two or more backtracking verbs appear in succession, the last of them has no effect. Consider the following example: . . . ( * COMMIT ) ( * PRUNE ) . . . If there is a matching failure to the right, backtracking onto (*PRUNE) causes it to be triggered, and its action is taken. There can never be a backtrack onto (*COMMIT). Backtracking Verbs in Repeated Groups PCRE differs from Perl in its handling of backtracking verbs in repeated groups. For example, consider: / ( a ( * COMMIT ) b ) + ac / If the subject is &quot;abac&quot;, Perl matches, but PCRE fails because the (*COMMIT) in the second repeat of the group acts. Backtracking Verbs in Assertions (*FAIL) in an assertion has its normal effect: it forces an immediate backtrack. (*ACCEPT) in a positive assertion causes the assertion to succeed without any further processing. In a negative assertion, (*ACCEPT) causes the assertion to fail without any further processing. The other backtracking verbs are not treated specially if they appear in a positive assertion. In particular, (*THEN) skips to the next alternative in the innermost enclosing group that has alternations, regardless if this is within the assertion. Negative assertions are, however, different, to ensure that changing a positive assertion into a negative assertion changes its result. Backtracking into (*COMMIT), (*SKIP), or (*PRUNE) causes a negative assertion to be true, without considering any further alternative branches in the assertion. Backtracking into (*THEN) causes it to skip to the next enclosing alternative within the assertion (the normal behavior), but if the assertion does not have such an alternative, (*THEN) behaves like (*PRUNE). Backtracking Verbs in Subroutines These behaviors occur regardless if the subpattern is called recursively. The treatment of subroutines in Perl is different in some cases. (*FAIL) in a subpattern called as a subroutine has its normal effect: it forces an immediate backtrack. (*ACCEPT) in a subpattern called as a subroutine causes the subroutine match to succeed without any further processing. Matching then continues after the subroutine call. (*COMMIT), (*SKIP), and (*PRUNE) in a subpattern called as a subroutine cause the subroutine match to fail. (*THEN) skips to the next alternative in the innermost enclosing group within the subpattern that has alternatives. If there is no such group within the subpattern, (*THEN) causes the subroutine match to fail.","ref":"re.html","title":"re","type":"module"},{"doc":"The same as compile(Regexp,[])","ref":"re.html#compile/1","title":"re.compile/1","type":"function"},{"doc":"Compiles a regular expression, with the syntax described below, into an internal format to be used later as a parameter to run/2 and run/3 . Compiling the regular expression before matching is useful if the same expression is to be used in matching against multiple subjects during the lifetime of the program. Compiling once and executing many times is far more efficient than compiling each time one wants to match. When option unicode is specified, the regular expression is to be specified as a valid Unicode charlist() , otherwise as any valid iodata() . Options: unicode The regular expression is specified as a Unicode charlist() and the resulting regular expression code is to be run against a valid Unicode charlist() subject. Also consider option ucp when using Unicode characters. anchored The pattern is forced to be &quot;anchored&quot;, that is, it is constrained to match only at the first matching point in the string that is searched (the &quot;subject string&quot;). This effect can also be achieved by appropriate constructs in the pattern itself. caseless Letters in the pattern match both uppercase and lowercase letters. It is equivalent to Perl option /i and can be changed within a pattern by a (?i) option setting. Uppercase and lowercase letters are defined as in the ISO 8859-1 character set. dollar_endonly A dollar metacharacter in the pattern matches only at the end of the subject string. Without this option, a dollar also matches immediately before a newline at the end of the string (but not before any other newlines). This option is ignored if option multiline is specified. There is no equivalent option in Perl, and it cannot be set within a pattern. dotall A dot in the pattern matches all characters, including those indicating newline. Without it, a dot does not match when the current position is at a newline. This option is equivalent to Perl option /s and it can be changed within a pattern by a (?s) option setting. A negative class, such as [^a] , always matches newline characters, independent of the setting of this option. extended If this option is set, most white space characters in the pattern are totally ignored except when escaped or inside a character class. However, white space is not allowed within sequences such as (?&gt; that introduce various parenthesized subpatterns, nor within a numerical quantifier such as {1,3} . However, ignorable white space is permitted between an item and a following quantifier and between a quantifier and a following + that indicates possessiveness. White space did not used to include the VT character (code 11), because Perl did not treat this character as white space. However, Perl changed at release 5.18, so PCRE followed at release 8.34, and VT is now treated as white space. This also causes characters between an unescaped # outside a character class and the next newline, inclusive, to be ignored. This is equivalent to Perl's /x option, and it can be changed within a pattern by a (?x) option setting. With this option, comments inside complicated patterns can be included. However, notice that this applies only to data characters. Whitespace characters can never appear within special character sequences in a pattern, for example within sequence (?( that introduces a conditional subpattern. firstline An unanchored pattern is required to match before or at the first newline in the subject string, although the matched text can continue over the newline. multiline By default, PCRE treats the subject string as consisting of a single line of characters (even if it contains newlines). The &quot;start of line&quot; metacharacter ( ^ ) matches only at the start of the string, while the &quot;end of line&quot; metacharacter ( $ ) matches only at the end of the string, or before a terminating newline (unless option dollar_endonly is specified). This is the same as in Perl. When this option is specified, the &quot;start of line&quot; and &quot;end of line&quot; constructs match immediately following or immediately before internal newlines in the subject string, respectively, as well as at the very start and end. This is equivalent to Perl option /m and can be changed within a pattern by a (?m) option setting. If there are no newlines in a subject string, or no occurrences of ^ or $ in a pattern, setting multiline has no effect. no_auto_capture Disables the use of numbered capturing parentheses in the pattern. Any opening parenthesis that is not followed by ? behaves as if it is followed by ?: . Named parentheses can still be used for capturing (and they acquire numbers in the usual way). There is no equivalent option in Perl. dupnames Names used to identify capturing subpatterns need not be unique. This can be helpful for certain types of pattern when it is known that only one instance of the named subpattern can ever be matched. More details of named subpatterns are provided below. ungreedy Inverts the &quot;greediness&quot; of the quantifiers so that they are not greedy by default, but become greedy if followed by &quot;?&quot;. It is not compatible with Perl. It can also be set by a (?U) option setting within the pattern. {newline, NLSpec} Overrides the default definition of a newline in the subject string, which is LF (ASCII 10) in Erlang. cr Newline is indicated by a single character cr (ASCII 13). lf Newline is indicated by a single character LF (ASCII 10), the default. crlf Newline is indicated by the two-character CRLF (ASCII 13 followed by ASCII 10) sequence. anycrlf Any of the three preceding sequences is to be recognized. any Any of the newline sequences above, and the Unicode sequences VT (vertical tab, U+000B), FF (formfeed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029). bsr_anycrlf Specifies specifically that \\R is to match only the CR, LF, or CRLF sequences, not the Unicode-specific newline characters. bsr_unicode Specifies specifically that \\R is to match all the Unicode newline characters (including CRLF, and so on, the default). no_start_optimize Disables optimization that can malfunction if &quot;Special start-of-pattern items&quot; are present in the regular expression. A typical example would be when matching &quot;DEFABC&quot; against &quot;(*COMMIT)ABC&quot;, where the start optimization of PCRE would skip the subject up to &quot;A&quot; and never realize that the (*COMMIT) instruction is to have made the matching fail. This option is only relevant if you use &quot;start-of-pattern items&quot;, as discussed in section PCRE Regular Expression Details . ucp Specifies that Unicode character properties are to be used when resolving \\B, \\b, \\D, \\d, \\S, \\s, \\W and \\w. Without this flag, only ISO Latin-1 properties are used. Using Unicode properties hurts performance, but is semantically correct when working with Unicode characters beyond the ISO Latin-1 range. never_utf Specifies that the (*UTF) and/or (*UTF8) &quot;start-of-pattern items&quot; are forbidden. This flag cannot be combined with option unicode . Useful if ISO Latin-1 patterns from an external source are to be compiled.","ref":"re.html#compile/2","title":"re.compile/2","type":"function"},{"doc":"Takes a compiled regular expression and an item, and returns the relevant data from the regular expression. The only supported item is namelist , which returns the tuple {namelist, [binary()]} , containing the names of all (unique) named subpatterns in the regular expression. For example: 1&gt; {ok,MP} = re:compile(&quot;(?&lt;A&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;). {ok,{re_pattern,3,0,0, &lt;&lt;69,82,67,80,119,0,0,0,0,0,0,0,1,0,0,0,255,255,255,255, 255,255,...&gt;&gt;}} 2&gt; re:inspect(MP,namelist). {namelist,[&lt;&lt;&quot;A&quot;&gt;&gt;,&lt;&lt;&quot;B&quot;&gt;&gt;,&lt;&lt;&quot;C&quot;&gt;&gt;]} 3&gt; {ok,MPD} = re:compile(&quot;(?&lt;C&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;,[dupnames]). {ok,{re_pattern,3,0,0, &lt;&lt;69,82,67,80,119,0,0,0,0,0,8,0,1,0,0,0,255,255,255,255, 255,255,...&gt;&gt;}} 4&gt; re:inspect(MPD,namelist). {namelist,[&lt;&lt;&quot;B&quot;&gt;&gt;,&lt;&lt;&quot;C&quot;&gt;&gt;]} Notice in the second example that the duplicate name only occurs once in the returned list, and that the list is in alphabetical order regardless of where the names are positioned in the regular expression. The order of the names is the same as the order of captured subexpressions if {capture, all_names} is specified as an option to run/3 . You can therefore create a name-to-value mapping from the result of run/3 like this: 1 &gt; { ok , MP } = re : compile ( &quot;(?&lt;A&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot; ) . { ok , { re_pattern , 3 , 0 , 0 , &lt;&lt; 69 , 82 , 67 , 80 , 119 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 255 , 255 , 255 , 255 , 255 , 255 , . . . &gt;&gt; } } 2 &gt; { namelist , N } = re : inspect ( MP , namelist ) . { namelist , [ &lt;&lt; &quot;A&quot; &gt;&gt; , &lt;&lt; &quot;B&quot; &gt;&gt; , &lt;&lt; &quot;C&quot; &gt;&gt; ] } 3 &gt; { match , L } = re : run ( &quot;AA&quot; , MP , [ { capture , all_names , binary } ] ) . { match , [ &lt;&lt; &quot;A&quot; &gt;&gt; , &lt;&lt; &gt;&gt; , &lt;&lt; &gt;&gt; ] } 4 &gt; NameMap = lists : zip ( N , L ) . [ { &lt;&lt; &quot;A&quot; &gt;&gt; , &lt;&lt; &quot;A&quot; &gt;&gt; } , { &lt;&lt; &quot;B&quot; &gt;&gt; , &lt;&lt; &gt;&gt; } , { &lt;&lt; &quot;C&quot; &gt;&gt; , &lt;&lt; &gt;&gt; } ]","ref":"re.html#inspect/2","title":"re.inspect/2","type":"function"},{"doc":"Same as replace(Subject, RE, Replacement, []) .","ref":"re.html#replace/3","title":"re.replace/3","type":"function"},{"doc":"Replaces the matched part of the Subject string with the contents of Replacement . The permissible options are the same as for run/3 , except that option capture is not allowed. Instead a {return, ReturnType} is present. The default return type is iodata , constructed in a way to minimize copying. The iodata result can be used directly in many I/O operations. If a flat list() is desired, specify {return, list} . If a binary is desired, specify {return, binary} . As in function run/3 , an mp() compiled with option unicode requires Subject to be a Unicode charlist() . If compilation is done implicitly and the unicode compilation option is specified to this function, both the regular expression and Subject are to specified as valid Unicode charlist() s. The replacement string can contain the special character &amp; , which inserts the whole matching expression in the result, and the special sequence \\ N (where N is an integer &gt; 0), \\g N, or \\g{ N } , resulting in the subexpression number N, is inserted in the result. If no subexpression with that number is generated by the regular expression, nothing is inserted. To insert an &amp; or a \\ in the result, precede it with a \\. Notice that Erlang already gives a special meaning to \\ in literal strings, so a single \\ must be written as &quot;\\\\&quot; and therefore a double \\ as &quot;\\\\\\\\&quot; . Example: re : replace ( &quot;abcd&quot; , &quot;c&quot; , &quot;[&amp;]&quot; , [ { return , list } ] ) . gives &quot;ab[c]d&quot; while re : replace ( &quot;abcd&quot; , &quot;c&quot; , &quot;[\\\\&amp;]&quot; , [ { return , list } ] ) . gives &quot;ab[&amp;]d&quot; As with run/3 , compilation errors raise the badarg exception. compile/2 can be used to get more information about the error.","ref":"re.html#replace/4","title":"re.replace/4","type":"function"},{"doc":"Same as run(Subject,RE,[]) .","ref":"re.html#run/2","title":"re.run/2","type":"function"},{"doc":"Executes a regular expression matching, and returns match/{match, Captured} or nomatch . The regular expression can be specified either as iodata() in which case it is automatically compiled (as by compile/2 ) and executed, or as a precompiled mp() in which case it is executed against the subject directly. When compilation is involved, exception badarg is thrown if a compilation error occurs. Call compile/2 to get information about the location of the error in the regular expression. If the regular expression is previously compiled, the option list can only contain the following options: anchored {capture, ValueSpec}/{capture, ValueSpec, Type} global {match_limit, integer() &gt;= 0} {match_limit_recursion, integer() &gt;= 0} {newline, NLSpec} notbol notempty notempty_atstart noteol {offset, integer() &gt;= 0} report_errors Otherwise all options valid for function compile/2 are also allowed. Options allowed both for compilation and execution of a match, namely anchored and {newline, NLSpec} , affect both the compilation and execution if present together with a non-precompiled regular expression. If the regular expression was previously compiled with option unicode , Subject is to be provided as a valid Unicode charlist() , otherwise any iodata() will do. If compilation is involved and option unicode is specified, both Subject and the regular expression are to be specified as valid Unicode charlists() . {capture, ValueSpec}/{capture, ValueSpec, Type} defines what to return from the function upon successful matching. The capture tuple can contain both a value specification, telling which of the captured substrings are to be returned, and a type specification, telling how captured substrings are to be returned (as index tuples, lists, or binaries). The options are described in detail below. If the capture options describe that no substring capturing is to be done ( {capture, none} ), the function returns the single atom match upon successful matching, otherwise the tuple {match, ValueList} . Disabling capturing can be done either by specifying none or an empty list as ValueSpec . Option report_errors adds the possibility that an error tuple is returned. The tuple either indicates a matching error ( match_limit or match_limit_recursion ), or a compilation error, where the error tuple has the format {error, {compile, CompileErr}} . Notice that if option report_errors is not specified, the function never returns error tuples, but reports compilation errors as a badarg exception and failed matches because of exceeded match limits simply as nomatch . The following options are relevant for execution: anchored Limits run/3 to matching at the first matching position. If a pattern was compiled with anchored , or turned out to be anchored by virtue of its contents, it cannot be made unanchored at matching time, hence there is no unanchored option. global Implements global (repetitive) search (flag g in Perl). Each match is returned as a separate list() containing the specific match and any matching subexpressions (or as specified by option capture . The Captured part of the return value is hence a list() of list() s when this option is specified. The interaction of option global with a regular expression that matches an empty string surprises some users. When option global is specified, run/3 handles empty matches in the same way as Perl: a zero-length match at any point is also retried with options [anchored, notempty_atstart] . If that search gives a result of length &gt; 0, the result is included. Example: re : run ( &quot;cat&quot; , &quot;(|at)&quot; , [ global ] ) . The following matchings are performed: At offset 0 The regular expression (|at) first match at the initial position of string cat , giving the result set [{0,0},{0,0}] (the second {0,0} is because of the subexpression marked by the parentheses). As the length of the match is 0, we do not advance to the next position yet. At offset 0 with [anchored, notempty_atstart] The search is retried with options [anchored, notempty_atstart] at the same position, which does not give any interesting result of longer length, so the search position is advanced to the next character ( a ). At offset 1 The search results in [{1,0},{1,0}] , so this search is also repeated with the extra options. At offset 1 with [anchored, notempty_atstart] Alternative ab is found and the result is [{1,2},{1,2}]. The result is added to the list of results and the position in the search string is advanced two steps. At offset 3 The search once again matches the empty string, giving [{3,0},{3,0}] . At offset 1 with [anchored, notempty_atstart] This gives no result of length &gt; 0 and we are at the last position, so the global search is complete. The result of the call is: { match , [ [ { 0 , 0 } , { 0 , 0 } ] , [ { 1 , 0 } , { 1 , 0 } ] , [ { 1 , 2 } , { 1 , 2 } ] , [ { 3 , 0 } , { 3 , 0 } ] ] } notempty An empty string is not considered to be a valid match if this option is specified. If alternatives in the pattern exist, they are tried. If all the alternatives match the empty string, the entire match fails. Example: If the following pattern is applied to a string not beginning with &quot;a&quot; or &quot;b&quot;, it would normally match the empty string at the start of the subject: a ? b ? With option notempty , this match is invalid, so run/3 searches further into the string for occurrences of &quot;a&quot; or &quot;b&quot;. notempty_atstart Like notempty , except that an empty string match that is not at the start of the subject is permitted. If the pattern is anchored, such a match can occur only if the pattern contains \\K. Perl has no direct equivalent of notempty or notempty_atstart , but it does make a special case of a pattern match of the empty string within its split() function, and when using modifier /g . The Perl behavior can be emulated after matching a null string by first trying the match again at the same offset with notempty_atstart and anchored , and then, if that fails, by advancing the starting offset (see below) and trying an ordinary match again. notbol Specifies that the first character of the subject string is not the beginning of a line, so the circumflex metacharacter is not to match before it. Setting this without multiline (at compile time) causes circumflex never to match. This option only affects the behavior of the circumflex metacharacter. It does not affect \\A. noteol Specifies that the end of the subject string is not the end of a line, so the dollar metacharacter is not to match it nor (except in multiline mode) a newline immediately before it. Setting this without multiline (at compile time) causes dollar never to match. This option affects only the behavior of the dollar metacharacter. It does not affect \\Z or \\z. report_errors Gives better control of the error handling in run/3 . When specified, compilation errors (if the regular expression is not already compiled) and runtime errors are explicitly returned as an error tuple. The following are the possible runtime errors: match_limit The PCRE library sets a limit on how many times the internal match function can be called. Defaults to 10,000,000 in the library compiled for Erlang. If {error, match_limit} is returned, the execution of the regular expression has reached this limit. This is normally to be regarded as a nomatch , which is the default return value when this occurs, but by specifying report_errors , you are informed when the match fails because of too many internal calls. match_limit_recursion This error is very similar to match_limit , but occurs when the internal match function of PCRE is &quot;recursively&quot; called more times than the match_limit_recursion limit, which defaults to 10,000,000 as well. Notice that as long as the match_limit and match_limit_default values are kept at the default values, the match_limit_recursion error cannot occur, as the match_limit error occurs before that (each recursive call is also a call, but not conversely). Both limits can however be changed, either by setting limits directly in the regular expression string (see section PCRE Regular Eexpression Details ) or by specifying options to run/3 . It is important to understand that what is referred to as &quot;recursion&quot; when limiting matches is not recursion on the C stack of the Erlang machine or on the Erlang process stack. The PCRE version compiled into the Erlang VM uses machine &quot;heap&quot; memory to store values that must be kept over recursion in regular expression matches. {match_limit, integer() &gt;= 0} Limits the execution time of a match in an implementation-specific way. It is described as follows by the PCRE documentation: The match_limit field provides a means of preventing PCRE from using up a vast amount of resources when running patterns that are not going to match , but which have a very large number of possibilities in their search trees . The classic example is a pattern that uses nested unlimited repeats . Internally , pcre_exec ( ) uses a function called match ( ) , which it calls repeatedly ( sometimes recursively ) . The limit set by match_limit is imposed on the number of times this function is called during a match , which has the effect of limiting the amount of backtracking that can take place . For patterns that are not anchored , the count restarts from zero for each position in the subject string . This means that runaway regular expression matches can fail faster if the limit is lowered using this option. The default value 10,000,000 is compiled into the Erlang VM. This option does in no way affect the execution of the Erlang VM in terms of &quot;long running BIFs&quot;. run/3 always gives control back to the scheduler of Erlang processes at intervals that ensures the real-time properties of the Erlang system. {match_limit_recursion, integer() &gt;= 0} Limits the execution time and memory consumption of a match in an implementation-specific way, very similar to match_limit . It is described as follows by the PCRE documentation: The match_limit_recursion field is similar to match_limit , but instead of limiting the total number of times that match ( ) is called , it limits the depth of recursion . The recursion depth is a smaller number than the total number of calls , because not all calls to match ( ) are recursive . This limit is of use only if it is set smaller than match_limit . Limiting the recursion depth limits the amount of machine stack that can be used , or , when PCRE has been compiled to use memory on the heap instead of the stack , the amount of heap memory that can be used . The Erlang VM uses a PCRE library where heap memory is used when regular expression match recursion occurs. This therefore limits the use of machine heap, not C stack. Specifying a lower value can result in matches with deep recursion failing, when they should have matched: 1&gt; re:run(&quot;aaaaaaaaaaaaaz&quot;,&quot;(a+)*z&quot;). {match,[{0,14},{0,13}]} 2&gt; re:run(&quot;aaaaaaaaaaaaaz&quot;,&quot;(a+)*z&quot;,[{match_limit_recursion,5}]). nomatch 3&gt; re:run(&quot;aaaaaaaaaaaaaz&quot;,&quot;(a+)*z&quot;,[{match_limit_recursion,5},report_errors]). {error,match_limit_recursion} This option and option match_limit are only to be used in rare cases. Understanding of the PCRE library internals is recommended before tampering with these limits. {offset, integer() &gt;= 0} Start matching at the offset (position) specified in the subject string. The offset is zero-based, so that the default is {offset,0} (all of the subject string). {newline, NLSpec} Overrides the default definition of a newline in the subject string, which is LF (ASCII 10) in Erlang. cr Newline is indicated by a single character CR (ASCII 13). lf Newline is indicated by a single character LF (ASCII 10), the default. crlf Newline is indicated by the two-character CRLF (ASCII 13 followed by ASCII 10) sequence. anycrlf Any of the three preceding sequences is be recognized. any Any of the newline sequences above, and the Unicode sequences VT (vertical tab, U+000B), FF (formfeed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029). bsr_anycrlf Specifies specifically that \\R is to match only the CR LF, or CRLF sequences, not the Unicode-specific newline characters. (Overrides the compilation option.) bsr_unicode Specifies specifically that \\R is to match all the Unicode newline characters (including CRLF, and so on, the default). (Overrides the compilation option.) {capture, ValueSpec} / {capture, ValueSpec, Type} Specifies which captured substrings are returned and in what format. By default, run/3 captures all of the matching part of the substring and all capturing subpatterns (all of the pattern is automatically captured). The default return type is (zero-based) indexes of the captured parts of the string, specified as {Offset,Length} pairs (the index Type of capturing). As an example of the default behavior, the following call returns, as first and only captured string, the matching part of the subject (&quot;abcd&quot; in the middle) as an index pair {3,4} , where character positions are zero-based, just as in offsets: re : run ( &quot;ABCabcdABC&quot; , &quot;abcd&quot; , [ ] ) . The return value of this call is: { match , [ { 3 , 4 } ] } Another (and quite common) case is where the regular expression matches all of the subject: re : run ( &quot;ABCabcdABC&quot; , &quot;.*abcd.*&quot; , [ ] ) . Here the return value correspondingly points out all of the string, beginning at index 0, and it is 10 characters long: { match , [ { 0 , 10 } ] } If the regular expression contains capturing subpatterns, like in: re : run ( &quot;ABCabcdABC&quot; , &quot;.*(abcd).*&quot; , [ ] ) . all of the matched subject is captured, as well as the captured substrings: { match , [ { 0 , 10 } , { 3 , 4 } ] } The complete matching pattern always gives the first return value in the list and the remaining subpatterns are added in the order they occurred in the regular expression. The capture tuple is built up as follows: ValueSpec Specifies which captured (sub)patterns are to be returned. ValueSpec can either be an atom describing a predefined set of return values, or a list containing the indexes or the names of specific subpatterns to return. The following are the predefined sets of subpatterns: all All captured subpatterns including the complete matching string. This is the default. all_names All named subpatterns in the regular expression, as if a list() of all the names in alphabetical order was specified. The list of all names can also be retrieved with inspect/2 . first Only the first captured subpattern, which is always the complete matching part of the subject. All explicitly captured subpatterns are discarded. all_but_first All but the first matching subpattern, that is, all explicitly captured subpatterns, but not the complete matching part of the subject string. This is useful if the regular expression as a whole matches a large part of the subject, but the part you are interested in is in an explicitly captured subpattern. If the return type is list or binary , not returning subpatterns you are not interested in is a good way to optimize. none Returns no matching subpatterns, gives the single atom match as the return value of the function when matching successfully instead of the {match, list()} return. Specifying an empty list gives the same behavior. The value list is a list of indexes for the subpatterns to return, where index 0 is for all of the pattern, and 1 is for the first explicit capturing subpattern in the regular expression, and so on. When using named captured subpatterns (see below) in the regular expression, one can use atom() s or string() s to specify the subpatterns to be returned. For example, consider the regular expression: &quot;.*(abcd).*&quot; matched against string &quot;ABCabcdABC&quot;, capturing only the &quot;abcd&quot; part (the first explicit subpattern): re : run ( &quot;ABCabcdABC&quot; , &quot;.*(abcd).*&quot; , [ { capture , [ 1 ] } ] ) . The call gives the following result, as the first explicitly captured subpattern is &quot;(abcd)&quot;, matching &quot;abcd&quot; in the subject, at (zero-based) position 3, of length 4: { match , [ { 3 , 4 } ] } Consider the same regular expression, but with the subpattern explicitly named 'FOO': &quot;.*(?&lt;FOO&gt;abcd).*&quot; With this expression, we could still give the index of the subpattern with the following call: re : run ( &quot;ABCabcdABC&quot; , &quot;.*(?&lt;FOO&gt;abcd).*&quot; , [ { capture , [ 1 ] } ] ) . giving the same result as before. But, as the subpattern is named, we can also specify its name in the value list: re : run ( &quot;ABCabcdABC&quot; , &quot;.*(?&lt;FOO&gt;abcd).*&quot; , [ { capture , [ &#39;FOO&#39; ] } ] ) . This would give the same result as the earlier examples, namely: { match , [ { 3 , 4 } ] } The values list can specify indexes or names not present in the regular expression, in which case the return values vary depending on the type. If the type is index , the tuple {-1,0} is returned for values with no corresponding subpattern in the regular expression, but for the other types ( binary and list ), the values are the empty binary or list, respectively. Type Optionally specifies how captured substrings are to be returned. If omitted, the default of index is used. Type can be one of the following: index Returns captured substrings as pairs of byte indexes into the subject string and length of the matching string in the subject (as if the subject string was flattened with erlang:iolist_to_binary/1 or unicode:characters_to_binary/2 before matching). Notice that option unicode results in byte-oriented indexes in a (possibly virtual) UTF-8 encoded binary. A byte index tuple {0,2} can therefore represent one or two characters when unicode is in effect. This can seem counter-intuitive, but has been deemed the most effective and useful way to do it. To return lists instead can result in simpler code if that is desired. This return type is the default. list Returns matching substrings as lists of characters (Erlang string() s). It option unicode is used in combination with the \\C sequence in the regular expression, a captured subpattern can contain bytes that are not valid UTF-8 (\\C matches bytes regardless of character encoding). In that case the list capturing can result in the same types of tuples that unicode:characters_to_list/2 can return, namely three-tuples with tag incomplete or error , the successfully converted characters and the invalid UTF-8 tail of the conversion as a binary. The best strategy is to avoid using the \\C sequence when capturing lists. binary Returns matching substrings as binaries. If option unicode is used, these binaries are in UTF-8. If the \\C sequence is used together with unicode , the binaries can be invalid UTF-8. In general, subpatterns that were not assigned a value in the match are returned as the tuple {-1,0} when type is index . Unassigned subpatterns are returned as the empty binary or list, respectively, for other return types. Consider the following regular expression: &quot;.*((?&lt;FOO&gt;abdd)|a(..d)).*&quot; There are three explicitly capturing subpatterns, where the opening parenthesis position determines the order in the result, hence ((?&lt;FOO&gt;abdd)|a(..d)) is subpattern index 1, (?&lt;FOO&gt;abdd) is subpattern index 2, and (..d) is subpattern index 3. When matched against the following string: &quot;ABCabcdABC&quot; the subpattern at index 2 does not match, as &quot;abdd&quot; is not present in the string, but the complete pattern matches (because of the alternative a(..d) ). The subpattern at index 2 is therefore unassigned and the default return value is: { match , [ { 0 , 10 } , { 3 , 4 } , { - 1 , 0 } , { 4 , 3 } ] } Setting the capture Type to binary gives: { match , [ &lt;&lt; &quot;ABCabcdABC&quot; &gt;&gt; , &lt;&lt; &quot;abcd&quot; &gt;&gt; , &lt;&lt; &gt;&gt; , &lt;&lt; &quot;bcd&quot; &gt;&gt; ] } Here the empty binary ( &lt;&lt;&gt;&gt; ) represents the unassigned subpattern. In the binary case, some information about the matching is therefore lost, as &lt;&lt;&gt;&gt; can also be an empty string captured. If differentiation between empty matches and non-existing subpatterns is necessary, use the type index and do the conversion to the final type in Erlang code. When option global is speciified, the capture specification affects each match separately, so that: re : run ( &quot;cacb&quot; , &quot;c(a|b)&quot; , [ global , { capture , [ 1 ] , list } ] ) . gives { match , [ [ &quot;a&quot; ] , [ &quot;b&quot; ] ] } For a descriptions of options only affecting the compilation step, see compile/2 .","ref":"re.html#run/3","title":"re.run/3","type":"function"},{"doc":"Same as split(Subject, RE, []) .","ref":"re.html#split/2","title":"re.split/2","type":"function"},{"doc":"Splits the input into parts by finding tokens according to the regular expression supplied. The splitting is basically done by running a global regular expression match and dividing the initial string wherever a match occurs. The matching part of the string is removed from the output. As in run/3 , an mp() compiled with option unicode requires Subject to be a Unicode charlist() . If compilation is done implicitly and the unicode compilation option is specified to this function, both the regular expression and Subject are to be specified as valid Unicode charlist() s. The result is given as a list of &quot;strings&quot;, the preferred data type specified in option return (default iodata ). If subexpressions are specified in the regular expression, the matching subexpressions are returned in the resulting list as well. For example: re : split ( &quot;Erlang&quot; , &quot;[ln]&quot; , [ { return , list } ] ) . gives [ &quot;Er&quot; , &quot;a&quot; , &quot;g&quot; ] while re : split ( &quot;Erlang&quot; , &quot;([ln])&quot; , [ { return , list } ] ) . gives [ &quot;Er&quot; , &quot;l&quot; , &quot;a&quot; , &quot;n&quot; , &quot;g&quot; ] The text matching the subexpression (marked by the parentheses in the regular expression) is inserted in the result list where it was found. This means that concatenating the result of a split where the whole regular expression is a single subexpression (as in the last example) always results in the original string. As there is no matching subexpression for the last part in the example (the &quot;g&quot;), nothing is inserted after that. To make the group of strings and the parts matching the subexpressions more obvious, one can use option group , which groups together the part of the subject string with the parts matching the subexpressions when the string was split: re : split ( &quot;Erlang&quot; , &quot;([ln])&quot; , [ { return , list } , group ] ) . gives [ [ &quot;Er&quot; , &quot;l&quot; ] , [ &quot;a&quot; , &quot;n&quot; ] , [ &quot;g&quot; ] ] Here the regular expression first matched the &quot;l&quot;, causing &quot;Er&quot; to be the first part in the result. When the regular expression matched, the (only) subexpression was bound to the &quot;l&quot;, so the &quot;l&quot; is inserted in the group together with &quot;Er&quot;. The next match is of the &quot;n&quot;, making &quot;a&quot; the next part to be returned. As the subexpression is bound to substring &quot;n&quot; in this case, the &quot;n&quot; is inserted into this group. The last group consists of the remaining string, as no more matches are found. By default, all parts of the string, including the empty strings, are returned from the function, for example: re : split ( &quot;Erlang&quot; , &quot;[lg]&quot; , [ { return , list } ] ) . gives [ &quot;Er&quot; , &quot;an&quot; , [ ] ] as the matching of the &quot;g&quot; in the end of the string leaves an empty rest, which is also returned. This behavior differs from the default behavior of the split function in Perl, where empty strings at the end are by default removed. To get the &quot;trimming&quot; default behavior of Perl, specify trim as an option: re : split ( &quot;Erlang&quot; , &quot;[lg]&quot; , [ { return , list } , trim ] ) . gives [ &quot;Er&quot; , &quot;an&quot; ] The &quot;trim&quot; option says; &quot;give me as many parts as possible except the empty ones&quot;, which sometimes can be useful. You can also specify how many parts you want, by specifying {parts, N } : re : split ( &quot;Erlang&quot; , &quot;[lg]&quot; , [ { return , list } , { parts , 2 } ] ) . gives [ &quot;Er&quot; , &quot;ang&quot; ] Notice that the last part is &quot;ang&quot;, not &quot;an&quot;, as splitting was specified into two parts, and the splitting stops when enough parts are given, which is why the result differs from that of trim . More than three parts are not possible with this indata, so re : split ( &quot;Erlang&quot; , &quot;[lg]&quot; , [ { return , list } , { parts , 4 } ] ) . gives the same result as the default, which is to be viewed as &quot;an infinite number of parts&quot;. Specifying 0 as the number of parts gives the same effect as option trim . If subexpressions are captured, empty subexpressions matched at the end are also stripped from the result if trim or {parts,0} is specified. The trim behavior corresponds exactly to the Perl default. {parts,N} , where N is a positive integer, corresponds exactly to the Perl behavior with a positive numerical third parameter. The default behavior of split/3 corresponds to the Perl behavior when a negative integer is specified as the third parameter for the Perl routine. Summary of options not previously described for function run/3 : {return,ReturnType} Specifies how the parts of the original string are presented in the result list. Valid types: iodata The variant of iodata() that gives the least copying of data with the current implementation (often a binary, but do not depend on it). binary All parts returned as binaries. list All parts returned as lists of characters (&quot;strings&quot;). group Groups together the part of the string with the parts of the string matching the subexpressions of the regular expression. The return value from the function is in this case a list() of list() s. Each sublist begins with the string picked out of the subject string, followed by the parts matching each of the subexpressions in order of occurrence in the regular expression. {parts,N} Specifies the number of parts the subject string is to be split into. The number of parts is to be a positive integer for a specific maximum number of parts, and infinity for the maximum number of parts possible (the default). Specifying {parts,0} gives as many parts as possible disregarding empty parts at the end, the same as specifying trim . trim Specifies that empty parts at the end of the result list are to be disregarded. The same as specifying {parts,0} . This corresponds to the default behavior of the split built-in function in Perl.","ref":"re.html#split/3","title":"re.split/3","type":"function"},{"doc":"The return of this function is a string with the PCRE version of the system that was used in the Erlang/OTP compilation.","ref":"re.html#version/0","title":"re.version/0","type":"function"},{"doc":"","ref":"re.html#t:compile_option/0","title":"re.compile_option/0","type":"type"},{"doc":"Opaque data type containing a compiled regular expression. mp() is guaranteed to be a tuple() having the atom re_pattern as its first element, to allow for matching in guards. The arity of the tuple or the content of the other fields can change in future Erlang/OTP releases.","ref":"re.html#t:mp/0","title":"re.mp/0","type":"type"},{"doc":"","ref":"re.html#t:nl_spec/0","title":"re.nl_spec/0","type":"type"},{"doc":"Sets are collections of elements with no duplicate elements. The representation of a set is undefined. This module provides the same interface as the ordsets(3) module but with an undefined representation. One difference is that while this module considers two elements as different if they do not match ( =:= ), ordsets considers two elements as different if and only if they do not compare equal ( == ). Erlang/OTP 24.0 introduced a new internal representation for sets which is more performant. Developers can use this new representation by passing the {version, 2} flag to new/1 and from_list/2 , such as sets:new([{version, 2}]) . This new representation will become the default in future Erlang/OTP versions. Functions that work on two sets, such as union/2 and similar, will work with sets of different versions. In such cases, there is no guarantee about the version of the returned set. Explicit conversion from the old version to the new one can be done with sets:from_list(sets:to_list(Old), [{version,2}]) . See Also gb_sets(3) , ordsets(3)","ref":"sets.html","title":"sets","type":"module"},{"doc":"Returns a new set formed from Set1 with Element inserted.","ref":"sets.html#add_element/2","title":"sets.add_element/2","type":"function"},{"doc":"Returns Set1 , but with Element removed.","ref":"sets.html#del_element/2","title":"sets.del_element/2","type":"function"},{"doc":"Filters elements in Set1 with boolean function Pred .","ref":"sets.html#filter/2","title":"sets.filter/2","type":"function"},{"doc":"Folds Function over every element in Set and returns the final value of the accumulator. The evaluation order is undefined.","ref":"sets.html#fold/3","title":"sets.fold/3","type":"function"},{"doc":"Returns a set of the elements in List .","ref":"sets.html#from_list/1","title":"sets.from_list/1","type":"function"},{"doc":"Returns a set of the elements in List at the given version.","ref":"sets.html#from_list/2","title":"sets.from_list/2","type":"function"},{"doc":"Returns the intersection of the non-empty list of sets.","ref":"sets.html#intersection/1","title":"sets.intersection/1","type":"function"},{"doc":"Returns the intersection of Set1 and Set2 .","ref":"sets.html#intersection/2","title":"sets.intersection/2","type":"function"},{"doc":"Returns true if Set1 and Set2 are disjoint (have no elements in common), otherwise false .","ref":"sets.html#is_disjoint/2","title":"sets.is_disjoint/2","type":"function"},{"doc":"Returns true if Element is an element of Set , otherwise false .","ref":"sets.html#is_element/2","title":"sets.is_element/2","type":"function"},{"doc":"Returns true if Set is an empty set, otherwise false .","ref":"sets.html#is_empty/1","title":"sets.is_empty/1","type":"function"},{"doc":"Returns true if Set is a set of elements, otherwise false .","ref":"sets.html#is_set/1","title":"sets.is_set/1","type":"function"},{"doc":"Returns true when every element of Set1 is also a member of Set2 , otherwise false .","ref":"sets.html#is_subset/2","title":"sets.is_subset/2","type":"function"},{"doc":"Returns a new empty set.","ref":"sets.html#new/0","title":"sets.new/0","type":"function"},{"doc":"Returns a new empty set at the given version.","ref":"sets.html#new/1","title":"sets.new/1","type":"function"},{"doc":"Returns the number of elements in Set .","ref":"sets.html#size/1","title":"sets.size/1","type":"function"},{"doc":"Returns only the elements of Set1 that are not also elements of Set2 .","ref":"sets.html#subtract/2","title":"sets.subtract/2","type":"function"},{"doc":"Returns the elements of Set as a list. The order of the returned elements is undefined.","ref":"sets.html#to_list/1","title":"sets.to_list/1","type":"function"},{"doc":"Returns the merged (union) set of the list of sets.","ref":"sets.html#union/1","title":"sets.union/1","type":"function"},{"doc":"Returns the merged (union) set of Set1 and Set2 .","ref":"sets.html#union/2","title":"sets.union/2","type":"function"},{"doc":"","ref":"sets.html#t:set/0","title":"sets.set/0","type":"type"},{"doc":"As returned by new/0 .","ref":"sets.html#t:set/1","title":"sets.set/1","type":"opaque"},{"doc":"This module provides an Erlang shell. The shell is a user interface program for entering expression sequences. The expressions are evaluated and a value is returned. A history mechanism saves previous commands and their values, which can then be incorporated in later commands. How many commands and results to save can be determined by the user, either interactively, by calling history/1 and results/1 , or by setting the application configuration parameters shell_history_length and shell_saved_results for the STDLIB application. The shell uses a helper process for evaluating commands to protect the history mechanism from exceptions. By default the evaluator process is killed when an exception occurs, but by calling catch_exception/1 or by setting the application configuration parameter shell_catch_exception for the STDLIB application this behavior can be changed. See also the example below. Variable bindings, and local process dictionary changes that are generated in user expressions are preserved, and the variables can be used in later commands to access their values. The bindings can also be forgotten so the variables can be reused. The special shell commands all have the syntax of (local) function calls. They are evaluated as normal function calls and many commands can be used in one expression sequence. If a command (local function call) is not recognized by the shell, an attempt is first made to find the function in module user_default , where customized local commands can be placed. If found, the function is evaluated, otherwise an attempt is made to evaluate the function in module shell_default . Module user_default must be explicitly loaded. The shell also permits the user to start multiple concurrent jobs. A job can be regarded as a set of processes that can communicate with the shell. There is some support for reading and printing records in the shell. During compilation record expressions are translated to tuple expressions. In runtime it is not known whether a tuple represents a record, and the record definitions used by the compiler are unavailable at runtime. So, to read the record syntax and print tuples as records when possible, record definitions must be maintained by the shell itself. The shell commands for reading, defining, forgetting, listing, and printing records are described below. Notice that each job has its own set of record definitions. To facilitate matters, record definitions in modules shell_default and user_default (if loaded) are read each time a new job is started. For example, adding the following line to user_default makes the definition of file_info readily available in the shell: -include_lib(&quot;kernel/include/file.hrl&quot;). The shell runs in two modes: Normal (possibly restricted) mode, in which commands can be edited and expressions evaluated Job Control Mode, JCL , in which jobs can be started, killed, detached, and connected Only the currently connected job can 'talk' to the shell. Shell Commands The commands below are the built-in shell commands that are always available. In most system the commands listed in the c(3) module are also available in the shell. b() Prints the current variable bindings. f() Removes all variable bindings. f(X) Removes the binding of variable X . h() Prints the history list. history(N) Sets the number of previous commands to keep in the history list to N . The previous number is returned. Defaults to 20. results(N) Sets the number of results from previous commands to keep in the history list to N . The previous number is returned. Defaults to 20. e(N) Repeats command N , if N is positive. If it is negative, the N th previous command is repeated (that is, e(-1) repeats the previous command). v(N) Uses the return value of command N in the current command, if N is positive. If it is negative, the return value of the N th previous command is used (that is, v(-1) uses the value of the previous command). help() Evaluates shell_default:help() . c(Mod) Evaluates shell_default:c(Mod) . This compiles and loads the module Mod and purges old versions of the code, if necessary. Mod can be either a module name or a a source file path, with or without .erl extension. catch_exception(Bool) Sets the exception handling of the evaluator process. The previous exception handling is returned. The default ( false ) is to kill the evaluator process when an exception occurs, which causes the shell to create a new evaluator process. When the exception handling is set to true , the evaluator process lives on. This means, for example, that ports and ETS tables as well as processes linked to the evaluator process survive the exception. rd(RecordName, RecordDefinition) Defines a record in the shell. RecordName is an atom and RecordDefinition lists the field names and the default values. Usually record definitions are made known to the shell by use of the rr/1,2,3 commands described below, but sometimes it is handy to define records on the fly. rf() Removes all record definitions, then reads record definitions from the modules shell_default and user_default (if loaded). Returns the names of the records defined. rf(RecordNames) Removes selected record definitions. RecordNames is a record name or a list of record names. To remove all record definitions, use '_' . rl() Prints all record definitions. rl(RecordNames) Prints selected record definitions. RecordNames is a record name or a list of record names. rp(Term) Prints a term using the record definitions known to the shell. All of Term is printed; the depth is not limited as is the case when a return value is printed. rr(Module) Reads record definitions from a module's BEAM file. If there are no record definitions in the BEAM file, the source file is located and read instead. Returns the names of the record definitions read. Module is an atom. rr(Wildcard) Reads record definitions from files. Existing definitions of any of the record names read are replaced. Wildcard is a wildcard string as defined in filelib(3) , but not an atom. rr(WildcardOrModule, RecordNames) Reads record definitions from files but discards record names not mentioned in RecordNames (a record name or a list of record names). rr(WildcardOrModule, RecordNames, Options) Reads record definitions from files. The compiler options {i, Dir} , {d, Macro} , and {d, Macro, Value} are recognized and used for setting up the include path and macro definitions. To read all record definitions, use '_' as value of RecordNames . Example The following example is a long dialog with the shell. Commands starting with &gt; are inputs to the shell. All other lines are output from the shell. strider 1 &gt; erl Erlang ( BEAM ) emulator version 5.3 [ hipe ] [ threads : 0 ] Eshell V5 . 3 ( abort with ^ G ) 1 &gt; Str = &quot;abcd&quot; . &quot;abcd&quot; Command 1 sets variable Str to string &quot;abcd&quot; . 2 &gt; L = length ( Str ) . 4 Command 2 sets L to the length of string Str . 3 &gt; Descriptor = { L , list_to_atom ( Str ) } . { 4 , abcd } Command 3 builds the tuple Descriptor , evaluating the BIF list_to_atom/1 . 4 &gt; L . 4 Command 4 prints the value of variable L . 5 &gt; b ( ) . Descriptor = { 4 , abcd } L = 4 Str = &quot;abcd&quot; ok Command 5 evaluates the internal shell command b() , which is an abbreviation of &quot;bindings&quot;. This prints the current shell variables and their bindings. ok at the end is the return value of function b() . 6 &gt; f ( L ) . ok Command 6 evaluates the internal shell command f(L) (abbreviation of &quot;forget&quot;). The value of variable L is removed. 7 &gt; b ( ) . Descriptor = { 4 , abcd } Str = &quot;abcd&quot; ok Command 7 prints the new bindings. 8 &gt; f ( L ) . ok Command 8 has no effect, as L has no value. 9 &gt; { L , _ } = Descriptor . { 4 , abcd } Command 9 performs a pattern matching operation on Descriptor , binding a new value to L . 10 &gt; L . 4 Command 10 prints the current value of L . 11 &gt; { P , Q , R } = Descriptor . * * exception error : no match of right hand side value { 4 , abcd } Command 11 tries to match {P, Q, R} against Descriptor , which is {4, abc} . The match fails and none of the new variables become bound. The printout starting with &quot; ** exception error: &quot; is not the value of the expression (the expression had no value because its evaluation failed), but a warning printed by the system to inform the user that an error has occurred. The values of the other variables ( L , Str , and so on) are unchanged. 12 &gt; P . * 1 : 1 : variable &#39;P&#39; is unbound 13 &gt; Descriptor . { 4 , abcd } Commands 12 and 13 show that P is unbound because the previous command failed, and that Descriptor has not changed. 14 &gt; { P , Q } = Descriptor . { 4 , abcd } 15 &gt; P . 4 Commands 14 and 15 show a correct match where P and Q are bound. 16 &gt; f ( ) . ok Command 16 clears all bindings. The next few commands assume that test1:demo(X) is defined as follows: demo(X) -&gt;      put(aa, worked),      X = 1,      X + 10. 17 &gt; put ( aa , hello ) . undefined 18 &gt; get ( aa ) . hello Commands 17 and 18 set and inspect the value of item aa in the process dictionary. 19 &gt; Y = test1 : demo ( 1 ) . 11 Command 19 evaluates test1:demo(1) . The evaluation succeeds and the changes made in the process dictionary become visible to the shell. The new value of dictionary item aa can be seen in command 20. 20 &gt; get ( ) . [ { aa , worked } ] 21 &gt; put ( aa , hello ) . worked 22 &gt; Z = test1 : demo ( 2 ) . * * exception error : no match of right hand side value 1 in function test1 : demo / 1 Commands 21 and 22 change the value of dictionary item aa to hello and call test1:demo(2) . Evaluation fails and the changes made to the dictionary in test1:demo(2) , before the error occurred, are discarded. 23 &gt; Z . * 1 : 1 : variable &#39;Z&#39; is unbound 24 &gt; get ( aa ) . hello Commands 23 and 24 show that Z was not bound and that dictionary item aa has retained its original value. 25 &gt; erase ( ) , put ( aa , hello ) . undefined 26 &gt; spawn ( test1 , demo , [ 1 ] ) . &lt; 0.57 . 0 &gt; 27 &gt; get ( aa ) . hello Commands 25, 26, and 27 show the effect of evaluating test1:demo(1) in the background. In this case, the expression is evaluated in a newly spawned process. Any changes made in the process dictionary are local to the newly spawned process and therefore not visible to the shell. 28 &gt; io : format ( &quot;hello hello\\n&quot; ) . hello hello ok 29 &gt; e ( 28 ) . hello hello ok 30 &gt; v ( 28 ) . ok Commands 28, 29 and 30 use the history facilities of the shell. Command 29 re-evaluates command 28. Command 30 uses the value (result) of command 28. In the cases of a pure function (a function with no side effects), the result is the same. For a function with side effects, the result can be different. The next few commands show some record manipulation. It is assumed that ex.erl defines a record as follows: -record(rec, {a, b = val()}). val() -&gt;      3. 31 &gt; c ( ex ) . { ok , ex } 32 &gt; rr ( ex ) . [ rec ] Commands 31 and 32 compile file ex.erl and read the record definitions in ex.beam . If the compiler did not output any record definitions on the BEAM file, rr(ex) tries to read record definitions from the source file instead. 33 &gt; rl ( rec ) . - record ( rec , { a , b = val ( ) } ) . ok Command 33 prints the definition of the record named rec . 34 &gt; # rec { } . * * exception error : undefined shell command val / 0 Command 34 tries to create a rec record, but fails as function val/0 is undefined. 35 &gt; # rec { b = 3 } . # rec { a = undefined , b = 3 } Command 35 shows the workaround: explicitly assign values to record fields that cannot otherwise be initialized. 36 &gt; rp ( v ( - 1 ) ) . # rec { a = undefined , b = 3 } ok Command 36 prints the newly created record using record definitions maintained by the shell. 37 &gt; rd ( rec , { f = orddict : new ( ) } ) . rec Command 37 defines a record directly in the shell. The definition replaces the one read from file ex.beam . 38 &gt; # rec { } . # rec { f = [ ] } ok Command 38 creates a record using the new definition, and prints the result. 39 &gt; rd ( rec , { c } ) , A . * 1 : 15 : variable &#39;A&#39; is unbound 40 &gt; # rec { } . # rec { c = undefined } ok Command 39 and 40 show that record definitions are updated as side effects. The evaluation of the command fails, but the definition of rec has been carried out. For the next command, it is assumed that test1:loop(N) is defined as follows: loop(N) -&gt;      io:format(&quot;Hello Number: ~w~n&quot;, [N]),      loop(N+1). 41 &gt; test1 : loop ( 0 ) . Hello Number : 0 Hello Number : 1 Hello Number : 2 Hello Number : 3 User switch command -- &gt; i -- &gt; c . . . Hello Number : 3374 Hello Number : 3375 Hello Number : 3376 Hello Number : 3377 Hello Number : 3378 * * exception exit : killed Command 41 evaluates test1:loop(0) , which puts the system into an infinite loop. At this point the user types ^G (Control G), which suspends output from the current process, which is stuck in a loop, and activates JCL mode. In JCL mode the user can start and stop jobs. In this particular case, command i (&quot;interrupt&quot;) terminates the looping program, and command c connects to the shell again. As the process was running in the background before we killed it, more printouts occur before message &quot; ** exception exit: killed &quot; is shown. 42 &gt; E = ets : new ( t , [ ] ) . # Ref &lt; 0.1662103692 . 2407923716.214192 &gt; Command 42 creates an ETS table. 43 &gt; ets : insert ( { d , 1 , 2 } ) . * * exception error : undefined function ets : insert / 1 Command 43 tries to insert a tuple into the ETS table, but the first argument (the table) is missing. The exception kills the evaluator process. 44 &gt; ets : insert ( E , { d , 1 , 2 } ) . * * exception error : argument is of wrong type in function ets : insert / 2 called as ets : insert ( 16 , { d , 1 , 2 } ) Command 44 corrects the mistake, but the ETS table has been destroyed as it was owned by the killed evaluator process. 45 &gt; f ( E ) . ok 46 &gt; catch_exception ( true ) . false Command 46 sets the exception handling of the evaluator process to true . The exception handling can also be set when starting Erlang by erl -stdlib shell_catch_exception true . 47 &gt; E = ets : new ( t , [ ] ) . # Ref &lt; 0.1662103692 . 2407923716.214197 &gt; 48 &gt; ets : insert ( { d , 1 , 2 } ) . * exception error : undefined function ets : insert / 1 Command 48 makes the same mistake as in command 43, but this time the evaluator process lives on. The single star at the beginning of the printout signals that the exception has been caught. 49 &gt; ets : insert ( E , { d , 1 , 2 } ) . true Command 49 successfully inserts the tuple into the ETS table. 50 &gt; ets : insert ( # Ref &lt; 0.1662103692 . 2407923716.214197 &gt; , { e , 3 , 4 } ) . true Command 50 inserts another tuple into the ETS table. This time the first argument is the table identifier itself. The shell can parse commands with pids ( &lt;0.60.0&gt; ), ports ( #Port&lt;0.536&gt; ), references ( #Ref&lt;0.1662103692.2407792644.214210&gt; ), and external functions ( #Fun&lt;a.b.1&gt; ), but the command fails unless the corresponding pid, port, reference, or function can be created in the running system. 51 &gt; halt ( ) . strider 2 &gt; Command 51 exits the Erlang runtime system. JCL Mode When the shell starts, it starts a single evaluator process. This process, together with any local processes that it spawns, is referred to as a job . Only the current job, which is said to be connected , can perform operations with standard I/O. All other jobs, which are said to be detached , are blocked if they attempt to use standard I/O. All jobs that do not use standard I/O run in the normal way. The shell escape key ^G (Control G) detaches the current job and activates JCL mode. The JCL mode prompt is &quot;--&gt;&quot; . If &quot;?&quot; is entered at the prompt, the following help message is displayed: -- &gt; ? c [ nn ] - connect to job i [ nn ] - interrupt job k [ nn ] - kill job j - list all jobs s [ shell ] - start local shell r [ node [ shell ] ] - start remote shell q - quit erlang ? | h - this message The JCL commands have the following meaning: c [nn] Connects to job number &lt;nn&gt; or the current job. The standard shell is resumed. Operations that use standard I/O by the current job are interleaved with user inputs to the shell. i [nn] Stops the current evaluator process for job number nn or the current job, but does not kill the shell process. So, any variable bindings and the process dictionary are preserved and the job can be connected again. This command can be used to interrupt an endless loop. k [nn] Kills job number nn or the current job. All spawned processes in the job are killed, provided they have not evaluated the group_leader/1 BIF and are located on the local machine. Processes spawned on remote nodes are not killed. j Lists all jobs. A list of all known jobs is printed. The current job name is prefixed with '*'. s Starts a new job. This is assigned the new index [nn] , which can be used in references. s [shell] Starts a new job. This is assigned the new index [nn] , which can be used in references. If optional argument shell is specified, it is assumed to be a module that implements an alternative shell. r [node] Starts a remote job on node . This is used in distributed Erlang to allow a shell running on one node to control a number of applications running on a network of nodes. If optional argument shell is specified, it is assumed to be a module that implements an alternative shell. q Quits Erlang. Notice that this option is disabled if Erlang is started with the ignore break, +Bi , system flag (which can be useful, for example when running a restricted shell, see the next section). ? Displays the help message above. The behavior of shell escape can be changed by the STDLIB application variable shell_esc . The value of the variable can be either jcl ( erl -stdlib shell_esc jcl ) or abort ( erl -stdlib shell_esc abort ). The first option sets ^G to activate JCL mode (which is also default behavior). The latter sets ^G to terminate the current shell and start a new one. JCL mode cannot be invoked when shell_esc is set to abort . If you want an Erlang node to have a remote job active from the start (rather than the default local job), start Erlang with flag -remsh , for example, erl -remsh other_node@other_host Restricted Shell The shell can be started in a restricted mode. In this mode, the shell evaluates a function call only if allowed. This feature makes it possible to, for example, prevent a user from accidentally calling a function from the prompt that could harm a running system (useful in combination with system flag +Bi ). When the restricted shell evaluates an expression and encounters a function call or an operator application, it calls a callback function (with information about the function call in question). This callback function returns true to let the shell go ahead with the evaluation, or false to abort it. There are two possible callback functions for the user to implement: local_allowed(Func, ArgList, State) -&gt; {boolean(),NewState} This is used to determine if the call to the local function Func with arguments ArgList is to be allowed. non_local_allowed(FuncSpec, ArgList, State) -&gt; {boolean(),NewState} | {{redirect,NewFuncSpec,NewArgList},NewState} This is used to determine if the call to non-local function FuncSpec ( {Module,Func} or a fun) with arguments ArgList is to be allowed. The return value {redirect,NewFuncSpec,NewArgList} can be used to let the shell evaluate some other function than the one specified by FuncSpec and ArgList . These callback functions are called from local and non-local evaluation function handlers, described in the erl_eval manual page. (Arguments in ArgList are evaluated before the callback functions are called.) Argument State is a tuple {ShellState,ExprState} . The return value NewState has the same form. This can be used to carry a state between calls to the callback functions. Data saved in ShellState lives through an entire shell session. Data saved in ExprState lives only through the evaluation of the current expression. There are two ways to start a restricted shell session: Use STDLIB application variable restricted_shell and specify, as its value, the name of the callback module. Example (with callback functions implemented in callback_mod.erl ): $ erl -stdlib restricted_shell callback_mod . From a normal shell session, call function start_restricted/1 . This exits the current evaluator and starts a new one in restricted mode. Notes: When restricted shell mode is activated or deactivated, new jobs started on the node run in restricted or normal mode, respectively. If restricted mode has been enabled on a particular node, remote shells connecting to this node also run in restricted mode. The callback functions cannot be used to allow or disallow execution of functions called from compiled code (only functions called from expressions entered at the shell prompt). Errors when loading the callback module is handled in different ways depending on how the restricted shell is activated: If the restricted shell is activated by setting the STDLIB variable during emulator startup, and the callback module cannot be loaded, a default restricted shell allowing only the commands q() and init:stop() is used as fallback. If the restricted shell is activated using start_restricted/1 and the callback module cannot be loaded, an error report is sent to the error logger and the call returns {error,Reason} . Prompting The default shell prompt function displays the name of the node (if the node can be part of a distributed system) and the current command number. The user can customize the prompt function by calling prompt_func/1 or by setting application configuration parameter shell_prompt_func for the STDLIB application. A customized prompt function is stated as a tuple {Mod, Func} . The function is called as Mod:Func(L) , where L is a list of key-value pairs created by the shell. Currently there is only one pair: {history, N} , where N is the current command number. The function is to return a list of characters or an atom. This constraint is because of the Erlang I/O protocol. Unicode characters beyond code point 255 are allowed in the list and the atom. Notice that in restricted mode the call Mod:Func(L) must be allowed or the default shell prompt function is called.","ref":"shell.html","title":"shell","type":"module"},{"doc":"Bool = boolean() Sets the exception handling of the evaluator process. The previous exception handling is returned. The default ( false ) is to kill the evaluator process when an exception occurs, which causes the shell to create a new evaluator process. When the exception handling is set to true , the evaluator process lives on, which means that, for example, ports and ETS tables as well as processes linked to the evaluator process survive the exception.","ref":"shell.html#catch_exception/1","title":"shell.catch_exception/1","type":"function"},{"doc":"Sets the number of previous commands to keep in the history list to N . The previous number is returned. Defaults to 20.","ref":"shell.html#history/1","title":"shell.history/1","type":"function"},{"doc":"Sets the shell prompt function to PromptFunc . The previous prompt function is returned.","ref":"shell.html#prompt_func/1","title":"shell.prompt_func/1","type":"function"},{"doc":"Sets the number of results from previous commands to keep in the history list to N . The previous number is returned. Defaults to 20.","ref":"shell.html#results/1","title":"shell.results/1","type":"function"},{"doc":"Exits a normal shell and starts a restricted shell. Module specifies the callback module for the functions local_allowed/3 and non_local_allowed/3 . The function is meant to be called from the shell. If the callback module cannot be loaded, an error tuple is returned. The Reason in the error tuple is the one returned by the code loader when trying to load the code of the callback module.","ref":"shell.html#start_restricted/1","title":"shell.start_restricted/1","type":"function"},{"doc":"Exits a restricted shell and starts a normal shell. The function is meant to be called from the shell.","ref":"shell.html#stop_restricted/0","title":"shell.stop_restricted/0","type":"function"},{"doc":"Sets pretty printing of lists to Strings . The previous value of the flag is returned. The flag can also be set by the STDLIB application variable shell_strings . Defaults to true , which means that lists of integers are printed using the string syntax, when possible. Value false means that no lists are printed using the string syntax.","ref":"shell.html#strings/1","title":"shell.strings/1","type":"function"},{"doc":"The functions in this module are called when no module name is specified in a shell command. Consider the following shell dialog: 1 &gt; lists : reverse ( &quot;abc&quot; ) . &quot;cba&quot; 2 &gt; c ( foo ) . { ok , foo } In command one, module lists is called. In command two, no module name is specified. The shell searches module user_default followed by module shell_default for function c/1 . shell_default is intended for &quot;system wide&quot; customizations to the shell. user_default is intended for &quot;local&quot; or individual user customizations. Hint To add your own commands to the shell, create a module called user_default and add the commands you want. Then add the following line as the first line in your .erlang file in your home directory. code : load_abs ( &quot;$PATH/user_default&quot; ) . $PATH is the directory where your user_default module can be found.","ref":"shell_default.html","title":"shell_default","type":"module"},{"doc":"This module can be used to render function and type documentation to be printed in a shell. This is the module that is used to render the docs accessed through the shell through c:h/1,2,3 . Example: 1 &gt; h ( maps , new , 0 ) . - spec new ( ) -&gt; Map when Map : : \#{ } . Since : OTP 17.0 Returns a new empty map . Example : &gt; maps : new ( ) . \#{ } This module formats and renders EEP-48 documentation of the format application/erlang+html . For more information about this format see Documentation Storage in Erl_Docgen's User's Guide. It can also render any other format of &quot;text&quot; type, although those will be rendered as is.","ref":"shell_docs.html","title":"shell_docs","type":"module"},{"doc":"This function can be used to do whitespace normalization of application/erlang+html documentation.","ref":"shell_docs.html#normalize/1","title":"shell_docs.normalize/1","type":"function"},{"doc":"Render the documentation for a module or function.","ref":"shell_docs.html#render/2","title":"shell_docs.render/2","type":"function"},{"doc":"","ref":"shell_docs.html#render/3","title":"shell_docs.render/3","type":"function"},{"doc":"","ref":"shell_docs.html#render/4","title":"shell_docs.render/4","type":"function"},{"doc":"","ref":"shell_docs.html#render/5","title":"shell_docs.render/5","type":"function"},{"doc":"Render the documentation of a callback in a module.","ref":"shell_docs.html#render_callback/2","title":"shell_docs.render_callback/2","type":"function"},{"doc":"","ref":"shell_docs.html#render_callback/3","title":"shell_docs.render_callback/3","type":"function"},{"doc":"","ref":"shell_docs.html#render_callback/4","title":"shell_docs.render_callback/4","type":"function"},{"doc":"","ref":"shell_docs.html#render_callback/5","title":"shell_docs.render_callback/5","type":"function"},{"doc":"Render the documentation of a type in a module.","ref":"shell_docs.html#render_type/2","title":"shell_docs.render_type/2","type":"function"},{"doc":"","ref":"shell_docs.html#render_type/3","title":"shell_docs.render_type/3","type":"function"},{"doc":"","ref":"shell_docs.html#render_type/4","title":"shell_docs.render_type/4","type":"function"},{"doc":"","ref":"shell_docs.html#render_type/5","title":"shell_docs.render_type/5","type":"function"},{"doc":"This function can be used to find out which tags are supported by application/erlang+html documentation.","ref":"shell_docs.html#supported_tags/0","title":"shell_docs.supported_tags/0","type":"function"},{"doc":"This function can be used to do a basic validation of the doc content of application/erlang+html format.","ref":"shell_docs.html#validate/1","title":"shell_docs.validate/1","type":"function"},{"doc":"","ref":"shell_docs.html#t:chunk_element/0","title":"shell_docs.chunk_element/0","type":"type"},{"doc":"","ref":"shell_docs.html#t:chunk_element_attr/0","title":"shell_docs.chunk_element_attr/0","type":"type"},{"doc":"","ref":"shell_docs.html#t:chunk_element_attrs/0","title":"shell_docs.chunk_element_attrs/0","type":"type"},{"doc":"The HTML tags allowed in application/erlang+html .","ref":"shell_docs.html#t:chunk_element_block_type/0","title":"shell_docs.chunk_element_block_type/0","type":"type"},{"doc":"The HTML tags allowed in application/erlang+html .","ref":"shell_docs.html#t:chunk_element_inline_type/0","title":"shell_docs.chunk_element_inline_type/0","type":"type"},{"doc":"The HTML tags allowed in application/erlang+html .","ref":"shell_docs.html#t:chunk_element_type/0","title":"shell_docs.chunk_element_type/0","type":"type"},{"doc":"","ref":"shell_docs.html#t:chunk_elements/0","title":"shell_docs.chunk_elements/0","type":"type"},{"doc":"The configuration of how the documentation should be rendered. encoding Configure the encoding that should be used by the renderer for graphical details such as bullet-points. By default shell_docs uses the value returned by io:getopts() . ansi Configure whether ansi escape codes should be used to render graphical details such as bold and underscore. By default shell_docs will try to determine if the receiving shell supports ansi escape codes. It is possible to override the automated check by setting the kernel configuration parameter shell_docs_ansi to a boolean() value. columns Configure how wide the target documentation should be rendered. By default shell_docs used the value returned by io:columns() .","ref":"shell_docs.html#t:config/0","title":"shell_docs.config/0","type":"type"},{"doc":"The record holding EEP-48 documentation for a module. You can use code:get_doc/1 to fetch this information from a module.","ref":"shell_docs.html#t:docs_v1/0","title":"shell_docs.docs_v1/0","type":"type"},{"doc":"This module provides functions for starting Erlang slave nodes. All slave nodes that are started by a master terminate automatically when the master terminates. All terminal output produced at the slave is sent back to the master node. File I/O is done through the master. Slave nodes on other hosts than the current one are started with the ssh program. The user must be allowed to ssh to the remote hosts without being prompted for a password. This can be arranged in a number of ways (for details, see the ssh documentation). A slave node started on the same host as the master inherits certain environment values from the master, such as the current directory and the environment variables. For what can be assumed about the environment when a slave is started on another host, see the documentation for the ssh program. An alternative to the ssh program can be specified on the command line to erl(1) as follows: - rsh Program Note that the command specified with the -rsh flag is treated as a file name which may contain spaces. It is thus not possible to include any command line options. The remote node will be launched as &quot;$RSH&quot; &quot;$REMOTE_HOSTNAME&quot; erl -detached -noinput ... , so the erl command must be found in the path on the remote host. The slave node is to use the same file system at the master. At least, Erlang/OTP is to be installed in the same place on both computers and the same version of Erlang is to be used. A node running on Windows can only start slave nodes on the host on which it is running. The master node must be alive.","ref":"slave.html","title":"slave","type":"module"},{"doc":"Master = node() ServerList = [atom()] Calls pseudo(Master, ServerList) . If you want to start a node from the command line and set up a number of pseudo servers, an Erlang runtime system can be started as follows: % erl -name abc -s slave pseudo klacke@super x --","ref":"slave.html#pseudo/1","title":"slave.pseudo/1","type":"function"},{"doc":"Starts a number of pseudo servers. A pseudo server is a server with a registered name that does nothing but pass on all message to the real server that executes at a master node. A pseudo server is an intermediary that only has the same registered name as the real server. For example, if you have started a slave node N and want to execute pxw graphics code on this node, you can start server pxw_server as a pseudo server at the slave node. This is illustrated as follows: rpc:call(N, slave, pseudo, [node(), [pxw_server]]).","ref":"slave.html#pseudo/2","title":"slave.pseudo/2","type":"function"},{"doc":"Runs a pseudo server. This function never returns any value and the process that executes the function receives messages. All messages received are simply passed on to Pid .","ref":"slave.html#relay/1","title":"slave.relay/1","type":"function"},{"doc":"Starts a slave node on host Host . Host names need not necessarily be specified as fully qualified names; short names can also be used. This is the same condition that applies to names of distributed Erlang nodes. The name of the started node becomes Name@Host . If no name is provided, the name becomes the same as the node that executes the call (except the host name part of the node name). The slave node resets its user process so that all terminal I/O that is produced at the slave is automatically relayed to the master. Also, the file process is relayed to the master. Argument Args is used to set erl command-line arguments. If provided, it is passed to the new node and can be used for a variety of purposes; see erl(1) . As an example, suppose that you want to start a slave node at host H with node name Name@H and want the slave node to have the following properties: Directory Dir is to be added to the code path. The Mnesia directory is to be set to M . The Unix DISPLAY environment variable is to be set to the display of the master node. The following code is executed to achieve this: E = &quot; -env DISPLAY &quot; ++ net_adm:localhost() ++ &quot;:0 &quot;, Arg = &quot;-mnesia_dir &quot; ++ M ++ &quot; -pa &quot; ++ Dir ++ E, slave:start(H, Name, Arg). The function returns {ok, Node} , where Node is the name of the new node, otherwise {error, Reason} , where Reason can be one of: timeout The master node failed to get in contact with the slave node. This can occur in a number of circumstances: Erlang/OTP is not installed on the remote host. The file system on the other host has a different structure to the the master. The Erlang nodes have different cookies. no_rsh No remote shell program was found on the computer. Note that ssh is used by default, but this can be overridden with the -rsh flag. {already_running, Node} A node with name Name@Host already exists.","ref":"slave.html#start/1","title":"slave.start/1","type":"function"},{"doc":"","ref":"slave.html#start/2","title":"slave.start/2","type":"function"},{"doc":"","ref":"slave.html#start/3","title":"slave.start/3","type":"function"},{"doc":"Starts a slave node in the same way as start/1,2,3 , except that the slave node is linked to the currently executing process. If that process terminates, the slave node also terminates. For a description of arguments and return values, see start/1,2,3 .","ref":"slave.html#start_link/1","title":"slave.start_link/1","type":"function"},{"doc":"","ref":"slave.html#start_link/2","title":"slave.start_link/2","type":"function"},{"doc":"","ref":"slave.html#start_link/3","title":"slave.start_link/3","type":"function"},{"doc":"Stops (kills) a node.","ref":"slave.html#stop/1","title":"slave.stop/1","type":"function"},{"doc":"This module provides operations on finite sets and relations represented as sets. Intuitively, a set is a collection of elements; every element belongs to the set, and the set contains every element. Given a set A and a sentence S(x), where x is a free variable, a new set B whose elements are exactly those elements of A for which S(x) holds can be formed, this is denoted B = {x in A : S(x)}. Sentences are expressed using the logical operators &quot;for some&quot; (or &quot;there exists&quot;), &quot;for all&quot;, &quot;and&quot;, &quot;or&quot;, &quot;not&quot;. If the existence of a set containing all the specified elements is known (as is always the case in this module), this is denoted B = {x : S(x)}. The unordered set containing the elements a, b, and c is denoted {a, b, c}. This notation is not to be confused with tuples. The ordered pair of a and b, with first coordinate a and second coordinate b, is denoted (a, b). An ordered pair is an ordered set of two elements. In this module, ordered sets can contain one, two, or more elements, and parentheses are used to enclose the elements. Unordered sets and ordered sets are orthogonal, again in this module; there is no unordered set equal to any ordered set. The empty set contains no elements. Set A is equal to set B if they contain the same elements, which is denoted A = B. Two ordered sets are equal if they contain the same number of elements and have equal elements at each coordinate. Set B is a subset of set A if A contains all elements that B contains. The union of two sets A and B is the smallest set that contains all elements of A and all elements of B. The intersection of two sets A and B is the set that contains all elements of A that belong to B. Two sets are disjoint if their intersection is the empty set. The difference of two sets A and B is the set that contains all elements of A that do not belong to B. The symmetric difference of two sets is the set that contains those element that belong to either of the two sets, but not both. The union of a collection of sets is the smallest set that contains all the elements that belong to at least one set of the collection. The intersection of a non-empty collection of sets is the set that contains all elements that belong to every set of the collection. The Cartesian product of two sets X and Y, denoted X × Y, is the set {a : a = (x, y) for some x in X and for some y in Y}. A relation is a subset of X × Y. Let R be a relation. The fact that (x, y) belongs to R is written as x R y. As relations are sets, the definitions of the last item (subset, union, and so on) apply to relations as well. The domain of R is the set {x : x R y for some y in Y}. The range of R is the set {y : x R y for some x in X}. The converse of R is the set {a : a = (y, x) for some (x, y) in R}. If A is a subset of X, the image of A under R is the set {y : x R y for some x in A}. If B is a subset of Y, the inverse image of B is the set {x : x R y for some y in B}. If R is a relation from X to Y, and S is a relation from Y to Z, the relative product of R and S is the relation T from X to Z defined so that x T z if and only if there exists an element y in Y such that x R y and y S z. The restriction of R to A is the set S defined so that x S y if and only if there exists an element x in A such that x R y. If S is a restriction of R to A, then R is an extension of S to X. If X = Y, then R is called a relation in X. The field of a relation R in X is the union of the domain of R and the range of R. If R is a relation in X, and if S is defined so that x S y if x R y and not x = y, then S is the strict relation corresponding to R. Conversely, if S is a relation in X, and if R is defined so that x R y if x S y or x = y, then R is the weak relation corresponding to S. A relation R in X is reflexive if x R x for every element x of X, it is symmetric if x R y implies that y R x, and it is transitive if x R y and y R z imply that x R z. A function F is a relation, a subset of X × Y, such that the domain of F is equal to X and such that for every x in X there is a unique element y in Y with (x, y) in F. The latter condition can be formulated as follows: if x F y and x F z, then y = z. In this module, it is not required that the domain of F is equal to X for a relation to be considered a function. Instead of writing (x, y) in F or x F y, we write F(x) = y when F is a function, and say that F maps x onto y, or that the value of F at x is y. As functions are relations, the definitions of the last item (domain, range, and so on) apply to functions as well. If the converse of a function F is a function F', then F' is called the inverse of F. The relative product of two functions F1 and F2 is called the composite of F1 and F2 if the range of F1 is a subset of the domain of F2. Sometimes, when the range of a function is more important than the function itself, the function is called a family . The domain of a family is called the index set , and the range is called the indexed set . If x is a family from I to X, then x[i] denotes the value of the function at index i. The notation &quot;a family in X&quot; is used for such a family. When the indexed set is a set of subsets of a set X, we call x a family of subsets of X. If x is a family of subsets of X, the union of the range of x is called the union of the family x. If x is non-empty (the index set is non-empty), the intersection of the family x is the intersection of the range of x. In this module, the only families that are considered are families of subsets of some set X; in the following, the word &quot;family&quot; is used for such families of subsets. A partition of a set X is a collection S of non-empty subsets of X whose union is X and whose elements are pairwise disjoint. A relation in a set is an equivalence relation if it is reflexive, symmetric, and transitive. If R is an equivalence relation in X, and x is an element of X, the equivalence class of x with respect to R is the set of all those elements y of X for which x R y holds. The equivalence classes constitute a partitioning of X. Conversely, if C is a partition of X, the relation that holds for any two elements of X if they belong to the same equivalence class, is an equivalence relation induced by the partition C. If R is an equivalence relation in X, the canonical map is the function that maps every element of X onto its equivalence class. Relations as defined above (as sets of ordered pairs) are from now on referred to as binary relations . We call a set of ordered sets (x[1], ..., x[n]) an (n-ary) relation , and say that the relation is a subset of the Cartesian product X[1] × ... × X[n], where x[i] is an element of X[i], 1 &lt;= i &lt;= n. The projection of an n-ary relation R onto coordinate i is the set {x[i] : (x[1], ..., x[i], ..., x[n]) in R for some x[j] in X[j], 1 &lt;= j &lt;= n and not i = j}. The projections of a binary relation R onto the first and second coordinates are the domain and the range of R, respectively. The relative product of binary relations can be generalized to n-ary relations as follows. Let TR be an ordered set (R[1], ..., R[n]) of binary relations from X to Y[i] and S a binary relation from (Y[1] × ... × Y[n]) to Z. The relative product of TR and S is the binary relation T from X to Z defined so that x T z if and only if there exists an element y[i] in Y[i] for each 1 &lt;= i &lt;= n such that x R[i] y[i] and (y[1], ..., y[n]) S z. Now let TR be a an ordered set (R[1], ..., R[n]) of binary relations from X[i] to Y[i] and S a subset of X[1] × ... × X[n]. The multiple relative product of TR and S is defined to be the set {z : z = ((x[1], ..., x[n]), (y[1],...,y[n])) for some (x[1], ..., x[n]) in S and for some (x[i], y[i]) in R[i], 1 &lt;= i &lt;= n}. The natural join of an n-ary relation R and an m-ary relation S on coordinate i and j is defined to be the set {z : z = (x[1], ..., x[n],  y[1], ..., y[j-1], y[j+1], ..., y[m]) for some (x[1], ..., x[n]) in R and for some (y[1], ..., y[m]) in S such that x[i] = y[j]}. The sets recognized by this module are represented by elements of the relation Sets, which is defined as the smallest set such that: For every atom T, except '_', and for every term X, (T, X) belongs to Sets ( atomic sets ). (['_'], []) belongs to Sets (the untyped empty set ). For every tuple T = {T[1], ..., T[n]} and for every tuple X = {X[1], ..., X[n]}, if (T[i], X[i]) belongs to Sets for every 1 &lt;= i &lt;= n, then (T, X) belongs to Sets ( ordered sets ). For every term T, if X is the empty list or a non-empty sorted list [X[1], ..., X[n]] without duplicates such that (T, X[i]) belongs to Sets for every 1 &lt;= i &lt;= n, then ([T], X) belongs to Sets ( typed unordered sets ). An external set is an element of the range of Sets. A type is an element of the domain of Sets. If S is an element (T, X) of Sets, then T is a valid type of X, T is the type of S, and X is the external set of S. from_term/2 creates a set from a type and an Erlang term turned into an external set. The sets represented by Sets are the elements of the range of function Set from Sets to Erlang terms and sets of Erlang terms: Set(T,Term) = Term, where T is an atom Set({T[1], ..., T[n]}, {X[1], ...,  X[n]}) = (Set(T[1], X[1]), ...,  Set(T[n], X[n])) Set([T], [X[1], ..., X[n]]) = {Set(T, X[1]), ..., Set(T, X[n])} Set([T], []) = {} When there is no risk of confusion, elements of Sets are identified with the sets they represent. For example, if U is the result of calling union/2 with S1 and S2 as arguments, then U is said to be the union of S1 and S2. A more precise formulation is that Set(U) is the union of Set(S1) and Set(S2). The types are used to implement the various conditions that sets must fulfill. As an example, consider the relative product of two sets R and S, and recall that the relative product of R and S is defined if R is a binary relation to Y and S is a binary relation from Y. The function that implements the relative product, relative_product/2 , checks that the arguments represent binary relations by matching [{A,B}] against the type of the first argument (Arg1 say), and [{C,D}] against the type of the second argument (Arg2 say). The fact that [{A,B}] matches the type of Arg1 is to be interpreted as Arg1 representing a binary relation from X to Y, where X is defined as all sets Set(x) for some element x in Sets the type of which is A, and similarly for Y. In the same way Arg2 is interpreted as representing a binary relation from W to Z. Finally it is checked that B matches C, which is sufficient to ensure that W is equal to Y. The untyped empty set is handled separately: its type, ['_'], matches the type of any unordered set. A few functions of this module ( drestriction/3 , family_projection/2 , partition/2 , partition_family/2 , projection/2 , restriction/3 , substitution/2 ) accept an Erlang function as a means to modify each element of a given unordered set. Such a function, called SetFun in the following, can be specified as a functional object (fun), a tuple {external, Fun} , or an integer: If SetFun is specified as a fun, the fun is applied to each element of the given set and the return value is assumed to be a set. If SetFun is specified as a tuple {external, Fun} , Fun is applied to the external set of each element of the given set and the return value is assumed to be an external set. Selecting the elements of an unordered set as external sets and assembling a new unordered set from a list of external sets is in the present implementation more efficient than modifying each element as a set. However, this optimization can only be used when the elements of the unordered set are atomic or ordered sets. It must also be the case that the type of the elements matches some clause of Fun (the type of the created set is the result of applying Fun to the type of the given set), and that Fun does nothing but selecting, duplicating, or rearranging parts of the elements. Specifying a SetFun as an integer I is equivalent to specifying {external, fun(X) -&gt; element(I, X) end} , but is to be preferred, as it makes it possible to handle this case even more efficiently. Examples of SetFuns: fun sofs : union / 1 fun ( S ) -&gt; sofs : partition ( 1 , S ) end { external , fun ( A ) -&gt; A end } { external , fun ( { A , _ , C } ) -&gt; { C , A } end } { external , fun ( { _ , { _ , C } } ) -&gt; C end } { external , fun ( { _ , { _ , { _ , E } = C } } ) -&gt; { E , { E , C } } end } 2 The order in which a SetFun is applied to the elements of an unordered set is not specified, and can change in future versions of this module. The execution time of the functions of this module is dominated by the time it takes to sort lists. When no sorting is needed, the execution time is in the worst case proportional to the sum of the sizes of the input arguments and the returned value. A few functions execute in constant time: from_external/2 , is_empty_set/1 , is_set/1 , is_sofs_set/1 , to_external/1 type/1 . The functions of this module exit the process with a badarg , bad_function , or type_mismatch message when given badly formed arguments or sets the types of which are not compatible. When comparing external sets, operator ==/2 is used. See Also dict(3) , digraph(3) , orddict(3) , ordsets(3) , sets(3)","ref":"sofs.html","title":"sofs","type":"module"},{"doc":"Creates a function . a_function(F, T) is equivalent to from_term(F, T) if the result is a function. If no type is explicitly specified, [{atom, atom}] is used as the function type.","ref":"sofs.html#a_function/1","title":"sofs.a_function/1","type":"function"},{"doc":"","ref":"sofs.html#a_function/2","title":"sofs.a_function/2","type":"function"},{"doc":"Returns the binary relation containing the elements (E, Set) such that Set belongs to SetOfSets and E belongs to Set. If SetOfSets is a partition of a set X and R is the equivalence relation in X induced by SetOfSets , then the returned relation is the canonical map from X onto the equivalence classes with respect to R. 1 &gt; Ss = sofs : from_term ( [ [ a , b ] , [ b , c ] ] ) , CR = sofs : canonical_relation ( Ss ) , sofs : to_external ( CR ) . [ { a , [ a , b ] } , { b , [ a , b ] } , { b , [ b , c ] } , { c , [ b , c ] } ]","ref":"sofs.html#canonical_relation/1","title":"sofs.canonical_relation/1","type":"function"},{"doc":"Returns the composite of the functions Function1 and Function2 . 1 &gt; F1 = sofs : a_function ( [ { a , 1 } , { b , 2 } , { c , 2 } ] ) , F2 = sofs : a_function ( [ { 1 , x } , { 2 , y } , { 3 , z } ] ) , F = sofs : composite ( F1 , F2 ) , sofs : to_external ( F ) . [ { a , x } , { b , y } , { c , y } ]","ref":"sofs.html#composite/2","title":"sofs.composite/2","type":"function"},{"doc":"Creates the function that maps each element of set Set onto AnySet . 1 &gt; S = sofs : set ( [ a , b ] ) , E = sofs : from_term ( 1 ) , R = sofs : constant_function ( S , E ) , sofs : to_external ( R ) . [ { a , 1 } , { b , 1 } ]","ref":"sofs.html#constant_function/2","title":"sofs.constant_function/2","type":"function"},{"doc":"Returns the converse of the binary relation BinRel1 . 1 &gt; R1 = sofs : relation ( [ { 1 , a } , { 2 , b } , { 3 , a } ] ) , R2 = sofs : converse ( R1 ) , sofs : to_external ( R2 ) . [ { a , 1 } , { a , 3 } , { b , 2 } ]","ref":"sofs.html#converse/1","title":"sofs.converse/1","type":"function"},{"doc":"Returns the difference of the sets Set1 and Set2 .","ref":"sofs.html#difference/2","title":"sofs.difference/2","type":"function"},{"doc":"Creates a family from the directed graph Graph . Each vertex a of Graph is represented by a pair (a, {b[1], ..., b[n]}), where the b[i]:s are the out-neighbors of a. If no type is explicitly specified, [{atom, [atom]}] is used as type of the family. It is assumed that Type is a valid type of the external set of the family. If G is a directed graph, it holds that the vertices and edges of G are the same as the vertices and edges of family_to_digraph(digraph_to_family(G)) .","ref":"sofs.html#digraph_to_family/1","title":"sofs.digraph_to_family/1","type":"function"},{"doc":"","ref":"sofs.html#digraph_to_family/2","title":"sofs.digraph_to_family/2","type":"function"},{"doc":"Returns the domain of the binary relation BinRel . 1 &gt; R = sofs : relation ( [ { 1 , a } , { 1 , b } , { 2 , b } , { 2 , c } ] ) , S = sofs : domain ( R ) , sofs : to_external ( S ) . [ 1 , 2 ]","ref":"sofs.html#domain/1","title":"sofs.domain/1","type":"function"},{"doc":"Returns the difference between the binary relation BinRel1 and the restriction of BinRel1 to Set . 1 &gt; R1 = sofs : relation ( [ { 1 , a } , { 2 , b } , { 3 , c } ] ) , S = sofs : set ( [ 2 , 4 , 6 ] ) , R2 = sofs : drestriction ( R1 , S ) , sofs : to_external ( R2 ) . [ { 1 , a } , { 3 , c } ] drestriction(R, S) is equivalent to difference(R, restriction(R, S)) .","ref":"sofs.html#drestriction/2","title":"sofs.drestriction/2","type":"function"},{"doc":"Returns a subset of Set1 containing those elements that do not give an element in Set2 as the result of applying SetFun . 1 &gt; SetFun = { external , fun ( { _ A , B , C } ) -&gt; { B , C } end } , R1 = sofs : relation ( [ { a , aa , 1 } , { b , bb , 2 } , { c , cc , 3 } ] ) , R2 = sofs : relation ( [ { bb , 2 } , { cc , 3 } , { dd , 4 } ] ) , R3 = sofs : drestriction ( SetFun , R1 , R2 ) , sofs : to_external ( R3 ) . [ { a , aa , 1 } ] drestriction(F, S1, S2) is equivalent to difference(S1, restriction(F, S1, S2)) .","ref":"sofs.html#drestriction/3","title":"sofs.drestriction/3","type":"function"},{"doc":"Returns the untyped empty set . empty_set() is equivalent to from_term([], ['_']) .","ref":"sofs.html#empty_set/0","title":"sofs.empty_set/0","type":"function"},{"doc":"Returns the extension of BinRel1 such that for each element E in Set that does not belong to the domain of BinRel1 , BinRel2 contains the pair (E,  AnySet ). 1 &gt; S = sofs : set ( [ b , c ] ) , A = sofs : empty_set ( ) , R = sofs : family ( [ { a , [ 1 , 2 ] } , { b , [ 3 ] } ] ) , X = sofs : extension ( R , S , A ) , sofs : to_external ( X ) . [ { a , [ 1 , 2 ] } , { b , [ 3 ] } , { c , [ ] } ]","ref":"sofs.html#extension/3","title":"sofs.extension/3","type":"function"},{"doc":"Creates a family of subsets . family(F, T) is equivalent to from_term(F, T) if the result is a family. If no type is explicitly specified, [{atom, [atom]}] is used as the family type.","ref":"sofs.html#family/1","title":"sofs.family/1","type":"function"},{"doc":"","ref":"sofs.html#family/2","title":"sofs.family/2","type":"function"},{"doc":"If Family1 and Family2 are families , then Family3 is the family such that the index set is equal to the index set of Family1 , and Family3 [i] is the difference between Family1 [i] and Family2 [i] if Family2 maps i, otherwise Family1[i] . 1 &gt; F1 = sofs : family ( [ { a , [ 1 , 2 ] } , { b , [ 3 , 4 ] } ] ) , F2 = sofs : family ( [ { b , [ 4 , 5 ] } , { c , [ 6 , 7 ] } ] ) , F3 = sofs : family_difference ( F1 , F2 ) , sofs : to_external ( F3 ) . [ { a , [ 1 , 2 ] } , { b , [ 3 ] } ]","ref":"sofs.html#family_difference/2","title":"sofs.family_difference/2","type":"function"},{"doc":"If Family1 is a family and Family1 [i] is a binary relation for every i in the index set of Family1 , then Family2 is the family with the same index set as Family1 such that Family2 [i] is the domain of Family1[i] . 1 &gt; FR = sofs : from_term ( [ { a , [ { 1 , a } , { 2 , b } , { 3 , c } ] } , { b , [ ] } , { c , [ { 4 , d } , { 5 , e } ] } ] ) , F = sofs : family_domain ( FR ) , sofs : to_external ( F ) . [ { a , [ 1 , 2 , 3 ] } , { b , [ ] } , { c , [ 4 , 5 ] } ]","ref":"sofs.html#family_domain/1","title":"sofs.family_domain/1","type":"function"},{"doc":"If Family1 is a family and Family1 [i] is a binary relation for every i in the index set of Family1 , then Family2 is the family with the same index set as Family1 such that Family2 [i] is the field of Family1 [i]. 1 &gt; FR = sofs : from_term ( [ { a , [ { 1 , a } , { 2 , b } , { 3 , c } ] } , { b , [ ] } , { c , [ { 4 , d } , { 5 , e } ] } ] ) , F = sofs : family_field ( FR ) , sofs : to_external ( F ) . [ { a , [ 1 , 2 , 3 , a , b , c ] } , { b , [ ] } , { c , [ 4 , 5 , d , e ] } ] family_field(Family1) is equivalent to family_union(family_domain(Family1), family_range(Family1)) .","ref":"sofs.html#family_field/1","title":"sofs.family_field/1","type":"function"},{"doc":"If Family1 is a family and Family1 [i] is a set of sets for every i in the index set of Family1 , then Family2 is the family with the same index set as Family1 such that Family2 [i] is the intersection of Family1 [i]. If Family1 [i] is an empty set for some i, the process exits with a badarg message. 1 &gt; F1 = sofs : from_term ( [ { a , [ [ 1 , 2 , 3 ] , [ 2 , 3 , 4 ] ] } , { b , [ [ x , y , z ] , [ x , y ] ] } ] ) , F2 = sofs : family_intersection ( F1 ) , sofs : to_external ( F2 ) . [ { a , [ 2 , 3 ] } , { b , [ x , y ] } ]","ref":"sofs.html#family_intersection/1","title":"sofs.family_intersection/1","type":"function"},{"doc":"If Family1 and Family2 are families , then Family3 is the family such that the index set is the intersection of Family1 :s and Family2 :s index sets, and Family3 [i] is the intersection of Family1 [i] and Family2 [i]. 1 &gt; F1 = sofs : family ( [ { a , [ 1 , 2 ] } , { b , [ 3 , 4 ] } , { c , [ 5 , 6 ] } ] ) , F2 = sofs : family ( [ { b , [ 4 , 5 ] } , { c , [ 7 , 8 ] } , { d , [ 9 , 10 ] } ] ) , F3 = sofs : family_intersection ( F1 , F2 ) , sofs : to_external ( F3 ) . [ { b , [ 4 ] } , { c , [ ] } ]","ref":"sofs.html#family_intersection/2","title":"sofs.family_intersection/2","type":"function"},{"doc":"If Family1 is a family , then Family2 is the family with the same index set as Family1 such that Family2 [i] is the result of calling SetFun with Family1 [i] as argument. 1 &gt; F1 = sofs : from_term ( [ { a , [ [ 1 , 2 ] , [ 2 , 3 ] ] } , { b , [ [ ] ] } ] ) , F2 = sofs : family_projection ( fun sofs : union / 1 , F1 ) , sofs : to_external ( F2 ) . [ { a , [ 1 , 2 , 3 ] } , { b , [ ] } ]","ref":"sofs.html#family_projection/2","title":"sofs.family_projection/2","type":"function"},{"doc":"If Family1 is a family and Family1 [i] is a binary relation for every i in the index set of Family1 , then Family2 is the family with the same index set as Family1 such that Family2 [i] is the range of Family1 [i]. 1 &gt; FR = sofs : from_term ( [ { a , [ { 1 , a } , { 2 , b } , { 3 , c } ] } , { b , [ ] } , { c , [ { 4 , d } , { 5 , e } ] } ] ) , F = sofs : family_range ( FR ) , sofs : to_external ( F ) . [ { a , [ a , b , c ] } , { b , [ ] } , { c , [ d , e ] } ]","ref":"sofs.html#family_range/1","title":"sofs.family_range/1","type":"function"},{"doc":"If Family1 is a family , then Family2 is the restriction of Family1 to those elements i of the index set for which Fun applied to Family1 [i] returns true . If Fun is a tuple {external, Fun2} , then Fun2 is applied to the external set of Family1 [i], otherwise Fun is applied to Family1 [i]. 1 &gt; F1 = sofs : family ( [ { a , [ 1 , 2 , 3 ] } , { b , [ 1 , 2 ] } , { c , [ 1 ] } ] ) , SpecFun = fun ( S ) -&gt; sofs : no_elements ( S ) =:= 2 end , F2 = sofs : family_specification ( SpecFun , F1 ) , sofs : to_external ( F2 ) . [ { b , [ 1 , 2 ] } ]","ref":"sofs.html#family_specification/2","title":"sofs.family_specification/2","type":"function"},{"doc":"Creates a directed graph from family Family . For each pair (a, {b[1], ..., b[n]}) of Family , vertex a and the edges (a, b[i]) for 1 &lt;= i &lt;= n are added to a newly created directed graph. If no graph type is specified, digraph:new/0 is used for creating the directed graph, otherwise argument GraphType is passed on as second argument to digraph:new/1 . It F is a family, it holds that F is a subset of digraph_to_family(family_to_digraph(F), type(F)) . Equality holds if union_of_family(F) is a subset of domain(F) . Creating a cycle in an acyclic graph exits the process with a cyclic message.","ref":"sofs.html#family_to_digraph/1","title":"sofs.family_to_digraph/1","type":"function"},{"doc":"","ref":"sofs.html#family_to_digraph/2","title":"sofs.family_to_digraph/2","type":"function"},{"doc":"If Family is a family , then BinRel is the binary relation containing all pairs (i, x) such that i belongs to the index set of Family and x belongs to Family [i]. 1 &gt; F = sofs : family ( [ { a , [ ] } , { b , [ 1 ] } , { c , [ 2 , 3 ] } ] ) , R = sofs : family_to_relation ( F ) , sofs : to_external ( R ) . [ { b , 1 } , { c , 2 } , { c , 3 } ]","ref":"sofs.html#family_to_relation/1","title":"sofs.family_to_relation/1","type":"function"},{"doc":"If Family1 is a family and Family1 [i] is a set of sets for each i in the index set of Family1 , then Family2 is the family with the same index set as Family1 such that Family2 [i] is the union of Family1 [i]. 1 &gt; F1 = sofs : from_term ( [ { a , [ [ 1 , 2 ] , [ 2 , 3 ] ] } , { b , [ [ ] ] } ] ) , F2 = sofs : family_union ( F1 ) , sofs : to_external ( F2 ) . [ { a , [ 1 , 2 , 3 ] } , { b , [ ] } ] family_union(F) is equivalent to family_projection(fun sofs:union/1, F) .","ref":"sofs.html#family_union/1","title":"sofs.family_union/1","type":"function"},{"doc":"If Family1 and Family2 are families , then Family3 is the family such that the index set is the union of Family1 :s and Family2 :s index sets, and Family3 [i] is the union of Family1 [i] and Family2 [i] if both map i, otherwise Family1 [i] or Family2 [i]. 1 &gt; F1 = sofs : family ( [ { a , [ 1 , 2 ] } , { b , [ 3 , 4 ] } , { c , [ 5 , 6 ] } ] ) , F2 = sofs : family ( [ { b , [ 4 , 5 ] } , { c , [ 7 , 8 ] } , { d , [ 9 , 10 ] } ] ) , F3 = sofs : family_union ( F1 , F2 ) , sofs : to_external ( F3 ) . [ { a , [ 1 , 2 ] } , { b , [ 3 , 4 , 5 ] } , { c , [ 5 , 6 , 7 , 8 ] } , { d , [ 9 , 10 ] } ]","ref":"sofs.html#family_union/2","title":"sofs.family_union/2","type":"function"},{"doc":"Returns the field of the binary relation BinRel . 1 &gt; R = sofs : relation ( [ { 1 , a } , { 1 , b } , { 2 , b } , { 2 , c } ] ) , S = sofs : field ( R ) , sofs : to_external ( S ) . [ 1 , 2 , a , b , c ] field(R) is equivalent to union(domain(R), range(R)) .","ref":"sofs.html#field/1","title":"sofs.field/1","type":"function"},{"doc":"Creates a set from the external set ExternalSet and the type Type . It is assumed that Type is a valid type of ExternalSet .","ref":"sofs.html#from_external/2","title":"sofs.from_external/2","type":"function"},{"doc":"Returns the unordered set containing the sets of list ListOfSets . 1 &gt; S1 = sofs : relation ( [ { a , 1 } , { b , 2 } ] ) , S2 = sofs : relation ( [ { x , 3 } , { y , 4 } ] ) , S = sofs : from_sets ( [ S1 , S2 ] ) , sofs : to_external ( S ) . [ [ { a , 1 } , { b , 2 } ] , [ { x , 3 } , { y , 4 } ] ]","ref":"sofs.html#from_sets/1","title":"sofs.from_sets/1","type":"function"},{"doc":"Returns the ordered set containing the sets of the non-empty tuple TupleOfSets .","ref":"sofs.html#from_sets/1","title":"sofs.from_sets/1","type":"function"},{"doc":"Creates an element of Sets by traversing term Term , sorting lists, removing duplicates, and deriving or verifying a valid type for the so obtained external set. An explicitly specified type Type can be used to limit the depth of the traversal; an atomic type stops the traversal, as shown by the following example where &quot;foo&quot; and {&quot;foo&quot;} are left unmodified: 1 &gt; S = sofs : from_term ( [ { { &quot;foo&quot; } , [ 1 , 1 ] } , { &quot;foo&quot; , [ 2 , 2 ] } ] , [ { atom , [ atom ] } ] ) , sofs : to_external ( S ) . [ { { &quot;foo&quot; } , [ 1 ] } , { &quot;foo&quot; , [ 2 ] } ] from_term can be used for creating atomic or ordered sets. The only purpose of such a set is that of later building unordered sets, as all functions in this module that do anything operate on unordered sets. Creating unordered sets from a collection of ordered sets can be the way to go if the ordered sets are big and one does not want to waste heap by rebuilding the elements of the unordered set. The following example shows that a set can be built &quot;layer by layer&quot;: 1 &gt; A = sofs : from_term ( a ) , S = sofs : set ( [ 1 , 2 , 3 ] ) , P1 = sofs : from_sets ( { A , S } ) , P2 = sofs : from_term ( { b , [ 6 , 5 , 4 ] } ) , Ss = sofs : from_sets ( [ P1 , P2 ] ) , sofs : to_external ( Ss ) . [ { a , [ 1 , 2 , 3 ] } , { b , [ 4 , 5 , 6 ] } ] Other functions that create sets are from_external/2 and from_sets/1 . Special cases of from_term/2 are a_function/1,2 , empty_set/0 , family/1,2 , relation/1,2 , and set/1,2 .","ref":"sofs.html#from_term/1","title":"sofs.from_term/1","type":"function"},{"doc":"","ref":"sofs.html#from_term/2","title":"sofs.from_term/2","type":"function"},{"doc":"Returns the image of set Set1 under the binary relation BinRel . 1 &gt; R = sofs : relation ( [ { 1 , a } , { 2 , b } , { 2 , c } , { 3 , d } ] ) , S1 = sofs : set ( [ 1 , 2 ] ) , S2 = sofs : image ( R , S1 ) , sofs : to_external ( S2 ) . [ a , b , c ]","ref":"sofs.html#image/2","title":"sofs.image/2","type":"function"},{"doc":"Returns the intersection of the set of sets SetOfSets . Intersecting an empty set of sets exits the process with a badarg message.","ref":"sofs.html#intersection/1","title":"sofs.intersection/1","type":"function"},{"doc":"Returns the intersection of Set1 and Set2 .","ref":"sofs.html#intersection/2","title":"sofs.intersection/2","type":"function"},{"doc":"Returns the intersection of family Family . Intersecting an empty family exits the process with a badarg message. 1 &gt; F = sofs : family ( [ { a , [ 0 , 2 , 4 ] } , { b , [ 0 , 1 , 2 ] } , { c , [ 2 , 3 ] } ] ) , S = sofs : intersection_of_family ( F ) , sofs : to_external ( S ) . [ 2 ]","ref":"sofs.html#intersection_of_family/1","title":"sofs.intersection_of_family/1","type":"function"},{"doc":"Returns the inverse of function Function1 . 1 &gt; R1 = sofs : relation ( [ { 1 , a } , { 2 , b } , { 3 , c } ] ) , R2 = sofs : inverse ( R1 ) , sofs : to_external ( R2 ) . [ { a , 1 } , { b , 2 } , { c , 3 } ]","ref":"sofs.html#inverse/1","title":"sofs.inverse/1","type":"function"},{"doc":"Returns the inverse image of Set1 under the binary relation BinRel . 1 &gt; R = sofs : relation ( [ { 1 , a } , { 2 , b } , { 2 , c } , { 3 , d } ] ) , S1 = sofs : set ( [ c , d , e ] ) , S2 = sofs : inverse_image ( R , S1 ) , sofs : to_external ( S2 ) . [ 2 , 3 ]","ref":"sofs.html#inverse_image/2","title":"sofs.inverse_image/2","type":"function"},{"doc":"Returns true if the binary relation BinRel is a function or the untyped empty set, otherwise false .","ref":"sofs.html#is_a_function/1","title":"sofs.is_a_function/1","type":"function"},{"doc":"Returns true if Set1 and Set2 are disjoint , otherwise false .","ref":"sofs.html#is_disjoint/2","title":"sofs.is_disjoint/2","type":"function"},{"doc":"Returns true if AnySet is an empty unordered set, otherwise false .","ref":"sofs.html#is_empty_set/1","title":"sofs.is_empty_set/1","type":"function"},{"doc":"Returns true if AnySet1 and AnySet2 are equal , otherwise false . The following example shows that ==/2 is used when comparing sets for equality: 1 &gt; S1 = sofs : set ( [ 1.0 ] ) , S2 = sofs : set ( [ 1 ] ) , sofs : is_equal ( S1 , S2 ) . true","ref":"sofs.html#is_equal/2","title":"sofs.is_equal/2","type":"function"},{"doc":"Returns true if AnySet is an unordered set , and false if AnySet is an ordered set or an atomic set.","ref":"sofs.html#is_set/1","title":"sofs.is_set/1","type":"function"},{"doc":"Returns true if Term is an unordered set , an ordered set, or an atomic set, otherwise false .","ref":"sofs.html#is_sofs_set/1","title":"sofs.is_sofs_set/1","type":"function"},{"doc":"Returns true if Set1 is a subset of Set2 , otherwise false .","ref":"sofs.html#is_subset/2","title":"sofs.is_subset/2","type":"function"},{"doc":"Returns true if term Term is a type .","ref":"sofs.html#is_type/1","title":"sofs.is_type/1","type":"function"},{"doc":"Returns the natural join of the relations Relation1 and Relation2 on coordinates I and J . 1 &gt; R1 = sofs : relation ( [ { a , x , 1 } , { b , y , 2 } ] ) , R2 = sofs : relation ( [ { 1 , f , g } , { 1 , h , i } , { 2 , 3 , 4 } ] ) , J = sofs : join ( R1 , 3 , R2 , 1 ) , sofs : to_external ( J ) . [ { a , x , 1 , f , g } , { a , x , 1 , h , i } , { b , y , 2 , 3 , 4 } ]","ref":"sofs.html#join/4","title":"sofs.join/4","type":"function"},{"doc":"If TupleOfBinRels is a non-empty tuple {R[1], ..., R[n]} of binary relations and BinRel1 is a binary relation, then BinRel2 is the multiple relative product of the ordered set (R[i], ..., R[n]) and BinRel1 . 1 &gt; Ri = sofs : relation ( [ { a , 1 } , { b , 2 } , { c , 3 } ] ) , R = sofs : relation ( [ { a , b } , { b , c } , { c , a } ] ) , MP = sofs : multiple_relative_product ( { Ri , Ri } , R ) , sofs : to_external ( sofs : range ( MP ) ) . [ { 1 , 2 } , { 2 , 3 } , { 3 , 1 } ]","ref":"sofs.html#multiple_relative_product/2","title":"sofs.multiple_relative_product/2","type":"function"},{"doc":"Returns the number of elements of the ordered or unordered set ASet .","ref":"sofs.html#no_elements/1","title":"sofs.no_elements/1","type":"function"},{"doc":"Returns the partition of the union of the set of sets SetOfSets such that two elements are considered equal if they belong to the same elements of SetOfSets . 1 &gt; Sets1 = sofs : from_term ( [ [ a , b , c ] , [ d , e , f ] , [ g , h , i ] ] ) , Sets2 = sofs : from_term ( [ [ b , c , d ] , [ e , f , g ] , [ h , i , j ] ] ) , P = sofs : partition ( sofs : union ( Sets1 , Sets2 ) ) , sofs : to_external ( P ) . [ [ a ] , [ b , c ] , [ d ] , [ e , f ] , [ g ] , [ h , i ] , [ j ] ]","ref":"sofs.html#partition/1","title":"sofs.partition/1","type":"function"},{"doc":"Returns the partition of Set such that two elements are considered equal if the results of applying SetFun are equal. 1 &gt; Ss = sofs : from_term ( [ [ a ] , [ b ] , [ c , d ] , [ e , f ] ] ) , SetFun = fun ( S ) -&gt; sofs : from_term ( sofs : no_elements ( S ) ) end , P = sofs : partition ( SetFun , Ss ) , sofs : to_external ( P ) . [ [ [ a ] , [ b ] ] , [ [ c , d ] , [ e , f ] ] ]","ref":"sofs.html#partition/2","title":"sofs.partition/2","type":"function"},{"doc":"Returns a pair of sets that, regarded as constituting a set, forms a partition of Set1 . If the result of applying SetFun to an element of Set1 gives an element in Set2 , the element belongs to Set3 , otherwise the element belongs to Set4 . 1 &gt; R1 = sofs : relation ( [ { 1 , a } , { 2 , b } , { 3 , c } ] ) , S = sofs : set ( [ 2 , 4 , 6 ] ) , { R2 , R3 } = sofs : partition ( 1 , R1 , S ) , { sofs : to_external ( R2 ) , sofs : to_external ( R3 ) } . { [ { 2 , b } ] , [ { 1 , a } , { 3 , c } ] } partition(F, S1, S2) is equivalent to {restriction(F, S1, S2), drestriction(F, S1, S2)} .","ref":"sofs.html#partition/3","title":"sofs.partition/3","type":"function"},{"doc":"Returns family Family where the indexed set is a partition of Set such that two elements are considered equal if the results of applying SetFun are the same value i. This i is the index that Family maps onto the equivalence class . 1 &gt; S = sofs : relation ( [ { a , a , a , a } , { a , a , b , b } , { a , b , b , b } ] ) , SetFun = { external , fun ( { A , _ , C , _ } ) -&gt; { A , C } end } , F = sofs : partition_family ( SetFun , S ) , sofs : to_external ( F ) . [ { { a , a } , [ { a , a , a , a } ] } , { { a , b } , [ { a , a , b , b } , { a , b , b , b } ] } ]","ref":"sofs.html#partition_family/2","title":"sofs.partition_family/2","type":"function"},{"doc":"Returns the Cartesian product of the non-empty tuple of sets TupleOfSets . If (x[1], ..., x[n]) is an element of the n-ary relation Relation , then x[i] is drawn from element i of TupleOfSets . 1 &gt; S1 = sofs : set ( [ a , b ] ) , S2 = sofs : set ( [ 1 , 2 ] ) , S3 = sofs : set ( [ x , y ] ) , P3 = sofs : product ( { S1 , S2 , S3 } ) , sofs : to_external ( P3 ) . [ { a , 1 , x } , { a , 1 , y } , { a , 2 , x } , { a , 2 , y } , { b , 1 , x } , { b , 1 , y } , { b , 2 , x } , { b , 2 , y } ]","ref":"sofs.html#product/1","title":"sofs.product/1","type":"function"},{"doc":"Returns the Cartesian product of Set1 and Set2 . 1 &gt; S1 = sofs : set ( [ 1 , 2 ] ) , S2 = sofs : set ( [ a , b ] ) , R = sofs : product ( S1 , S2 ) , sofs : to_external ( R ) . [ { 1 , a } , { 1 , b } , { 2 , a } , { 2 , b } ] product(S1, S2) is equivalent to product({S1, S2}) .","ref":"sofs.html#product/2","title":"sofs.product/2","type":"function"},{"doc":"Returns the set created by substituting each element of Set1 by the result of applying SetFun to the element. If SetFun is a number i &gt;= 1 and Set1 is a relation, then the returned set is the projection of Set1 onto coordinate i. 1 &gt; S1 = sofs : from_term ( [ { 1 , a } , { 2 , b } , { 3 , a } ] ) , S2 = sofs : projection ( 2 , S1 ) , sofs : to_external ( S2 ) . [ a , b ]","ref":"sofs.html#projection/2","title":"sofs.projection/2","type":"function"},{"doc":"Returns the range of the binary relation BinRel . 1 &gt; R = sofs : relation ( [ { 1 , a } , { 1 , b } , { 2 , b } , { 2 , c } ] ) , S = sofs : range ( R ) , sofs : to_external ( S ) . [ a , b , c ]","ref":"sofs.html#range/1","title":"sofs.range/1","type":"function"},{"doc":"Creates a relation . relation(R, T) is equivalent to from_term(R, T) , if T is a type and the result is a relation. If Type is an integer N, then [{atom, ..., atom}]) , where the tuple size is N, is used as type of the relation. If no type is explicitly specified, the size of the first tuple of Tuples is used if there is such a tuple. relation([]) is equivalent to relation([], 2) .","ref":"sofs.html#relation/1","title":"sofs.relation/1","type":"function"},{"doc":"","ref":"sofs.html#relation/2","title":"sofs.relation/2","type":"function"},{"doc":"Returns family Family such that the index set is equal to the domain of the binary relation BinRel , and Family [i] is the image of the set of i under BinRel . 1 &gt; R = sofs : relation ( [ { b , 1 } , { c , 2 } , { c , 3 } ] ) , F = sofs : relation_to_family ( R ) , sofs : to_external ( F ) . [ { b , [ 1 ] } , { c , [ 2 , 3 ] } ]","ref":"sofs.html#relation_to_family/1","title":"sofs.relation_to_family/1","type":"function"},{"doc":"If ListOfBinRels is a non-empty list [R[1], ..., R[n]] of binary relations and BinRel1 is a binary relation, then BinRel2 is the relative product of the ordered set (R[i], ..., R[n]) and BinRel1 . If BinRel1 is omitted, the relation of equality between the elements of the Cartesian product of the ranges of R[i], range R[1] × ... × range R[n], is used instead (intuitively, nothing is &quot;lost&quot;). 1 &gt; TR = sofs : relation ( [ { 1 , a } , { 1 , aa } , { 2 , b } ] ) , R1 = sofs : relation ( [ { 1 , u } , { 2 , v } , { 3 , c } ] ) , R2 = sofs : relative_product ( [ TR , R1 ] ) , sofs : to_external ( R2 ) . [ { 1 , { a , u } } , { 1 , { aa , u } } , { 2 , { b , v } } ] Notice that relative_product([R1], R2) is different from relative_product(R1, R2) ; the list of one element is not identified with the element itself.","ref":"sofs.html#relative_product/1","title":"sofs.relative_product/1","type":"function"},{"doc":"","ref":"sofs.html#relative_product/2","title":"sofs.relative_product/2","type":"function"},{"doc":"Returns the relative product of the binary relations BinRel1 and BinRel2 .","ref":"sofs.html#relative_product/2","title":"sofs.relative_product/2","type":"function"},{"doc":"Returns the relative product of the converse of the binary relation BinRel1 and the binary relation BinRel2 . 1 &gt; R1 = sofs : relation ( [ { 1 , a } , { 1 , aa } , { 2 , b } ] ) , R2 = sofs : relation ( [ { 1 , u } , { 2 , v } , { 3 , c } ] ) , R3 = sofs : relative_product1 ( R1 , R2 ) , sofs : to_external ( R3 ) . [ { a , u } , { aa , u } , { b , v } ] relative_product1(R1, R2) is equivalent to relative_product(converse(R1), R2) .","ref":"sofs.html#relative_product1/2","title":"sofs.relative_product1/2","type":"function"},{"doc":"Returns the restriction of the binary relation BinRel1 to Set . 1 &gt; R1 = sofs : relation ( [ { 1 , a } , { 2 , b } , { 3 , c } ] ) , S = sofs : set ( [ 1 , 2 , 4 ] ) , R2 = sofs : restriction ( R1 , S ) , sofs : to_external ( R2 ) . [ { 1 , a } , { 2 , b } ]","ref":"sofs.html#restriction/2","title":"sofs.restriction/2","type":"function"},{"doc":"Returns a subset of Set1 containing those elements that gives an element in Set2 as the result of applying SetFun . 1 &gt; S1 = sofs : relation ( [ { 1 , a } , { 2 , b } , { 3 , c } ] ) , S2 = sofs : set ( [ b , c , d ] ) , S3 = sofs : restriction ( 2 , S1 , S2 ) , sofs : to_external ( S3 ) . [ { 2 , b } , { 3 , c } ]","ref":"sofs.html#restriction/3","title":"sofs.restriction/3","type":"function"},{"doc":"Creates an unordered set . set(L, T) is equivalent to from_term(L, T) , if the result is an unordered set. If no type is explicitly specified, [atom] is used as the set type.","ref":"sofs.html#set/1","title":"sofs.set/1","type":"function"},{"doc":"","ref":"sofs.html#set/2","title":"sofs.set/2","type":"function"},{"doc":"Returns the set containing every element of Set1 for which Fun returns true . If Fun is a tuple {external, Fun2} , Fun2 is applied to the external set of each element, otherwise Fun is applied to each element. 1 &gt; R1 = sofs : relation ( [ { a , 1 } , { b , 2 } ] ) , R2 = sofs : relation ( [ { x , 1 } , { x , 2 } , { y , 3 } ] ) , S1 = sofs : from_sets ( [ R1 , R2 ] ) , S2 = sofs : specification ( fun sofs : is_a_function / 1 , S1 ) , sofs : to_external ( S2 ) . [ [ { a , 1 } , { b , 2 } ] ]","ref":"sofs.html#specification/2","title":"sofs.specification/2","type":"function"},{"doc":"Returns the strict relation corresponding to the binary relation BinRel1 . 1 &gt; R1 = sofs : relation ( [ { 1 , 1 } , { 1 , 2 } , { 2 , 1 } , { 2 , 2 } ] ) , R2 = sofs : strict_relation ( R1 ) , sofs : to_external ( R2 ) . [ { 1 , 2 } , { 2 , 1 } ]","ref":"sofs.html#strict_relation/1","title":"sofs.strict_relation/1","type":"function"},{"doc":"Returns a function, the domain of which is Set1 . The value of an element of the domain is the result of applying SetFun to the element. 1 &gt; L = [ { a , 1 } , { b , 2 } ] . [ { a , 1 } , { b , 2 } ] 2 &gt; sofs : to_external ( sofs : projection ( 1 , sofs : relation ( L ) ) ) . [ a , b ] 3 &gt; sofs : to_external ( sofs : substitution ( 1 , sofs : relation ( L ) ) ) . [ { { a , 1 } , a } , { { b , 2 } , b } ] 4 &gt; SetFun = { external , fun ( { A , _ } = E ) -&gt; { E , A } end } , sofs : to_external ( sofs : projection ( SetFun , sofs : relation ( L ) ) ) . [ { { a , 1 } , a } , { { b , 2 } , b } ] The relation of equality between the elements of {a,b,c}: 1 &gt; I = sofs : substitution ( fun ( A ) -&gt; A end , sofs : set ( [ a , b , c ] ) ) , sofs : to_external ( I ) . [ { a , a } , { b , b } , { c , c } ] Let SetOfSets be a set of sets and BinRel a binary relation. The function that maps each element Set of SetOfSets onto the image of Set under BinRel is returned by the following function: images ( SetOfSets , BinRel ) -&gt; Fun = fun ( Set ) -&gt; sofs : image ( BinRel , Set ) end , sofs : substitution ( Fun , SetOfSets ) . External unordered sets are represented as sorted lists. So, creating the image of a set under a relation R can traverse all elements of R (to that comes the sorting of results, the image). In image/2 , BinRel is traversed once for each element of SetOfSets , which can take too long. The following efficient function can be used instead under the assumption that the image of each element of SetOfSets under BinRel is non-empty: images2 ( SetOfSets , BinRel ) -&gt; CR = sofs : canonical_relation ( SetOfSets ) , R = sofs : relative_product1 ( CR , BinRel ) , sofs : relation_to_family ( R ) .","ref":"sofs.html#substitution/2","title":"sofs.substitution/2","type":"function"},{"doc":"Returns the symmetric difference (or the Boolean sum) of Set1 and Set2 . 1 &gt; S1 = sofs : set ( [ 1 , 2 , 3 ] ) , S2 = sofs : set ( [ 2 , 3 , 4 ] ) , P = sofs : symdiff ( S1 , S2 ) , sofs : to_external ( P ) . [ 1 , 4 ]","ref":"sofs.html#symdiff/2","title":"sofs.symdiff/2","type":"function"},{"doc":"Returns a triple of sets: Set3 contains the elements of Set1 that do not belong to Set2 . Set4 contains the elements of Set1 that belong to Set2 . Set5 contains the elements of Set2 that do not belong to Set1 .","ref":"sofs.html#symmetric_partition/2","title":"sofs.symmetric_partition/2","type":"function"},{"doc":"Returns the external set of an atomic, ordered, or unordered set.","ref":"sofs.html#to_external/1","title":"sofs.to_external/1","type":"function"},{"doc":"Returns the elements of the ordered set ASet as a tuple of sets, and the elements of the unordered set ASet as a sorted list of sets without duplicates.","ref":"sofs.html#to_sets/1","title":"sofs.to_sets/1","type":"function"},{"doc":"Returns the type of an atomic, ordered, or unordered set.","ref":"sofs.html#type/1","title":"sofs.type/1","type":"function"},{"doc":"Returns the union of the set of sets SetOfSets .","ref":"sofs.html#union/1","title":"sofs.union/1","type":"function"},{"doc":"Returns the union of Set1 and Set2 .","ref":"sofs.html#union/2","title":"sofs.union/2","type":"function"},{"doc":"Returns the union of family Family . 1 &gt; F = sofs : family ( [ { a , [ 0 , 2 , 4 ] } , { b , [ 0 , 1 , 2 ] } , { c , [ 2 , 3 ] } ] ) , S = sofs : union_of_family ( F ) , sofs : to_external ( S ) . [ 0 , 1 , 2 , 3 , 4 ]","ref":"sofs.html#union_of_family/1","title":"sofs.union_of_family/1","type":"function"},{"doc":"Returns a subset S of the weak relation W corresponding to the binary relation BinRel1 . Let F be the field of BinRel1 . The subset S is defined so that x S y if x W y for some x in F and for some y in F. 1 &gt; R1 = sofs : relation ( [ { 1 , 1 } , { 1 , 2 } , { 3 , 1 } ] ) , R2 = sofs : weak_relation ( R1 ) , sofs : to_external ( R2 ) . [ { 1 , 1 } , { 1 , 2 } , { 2 , 2 } , { 3 , 1 } , { 3 , 3 } ]","ref":"sofs.html#weak_relation/1","title":"sofs.weak_relation/1","type":"function"},{"doc":"A function .","ref":"sofs.html#t:a_function/0","title":"sofs.a_function/0","type":"type"},{"doc":"An unordered set .","ref":"sofs.html#t:a_set/0","title":"sofs.a_set/0","type":"opaque"},{"doc":"Any kind of set (also included are the atomic sets).","ref":"sofs.html#t:anyset/0","title":"sofs.anyset/0","type":"type"},{"doc":"A binary relation .","ref":"sofs.html#t:binary_relation/0","title":"sofs.binary_relation/0","type":"type"},{"doc":"An external set .","ref":"sofs.html#t:external_set/0","title":"sofs.external_set/0","type":"type"},{"doc":"A family (of subsets).","ref":"sofs.html#t:family/0","title":"sofs.family/0","type":"type"},{"doc":"An ordered set .","ref":"sofs.html#t:ordset/0","title":"sofs.ordset/0","type":"opaque"},{"doc":"An n-ary relation .","ref":"sofs.html#t:relation/0","title":"sofs.relation/0","type":"type"},{"doc":"A SetFun .","ref":"sofs.html#t:set_fun/0","title":"sofs.set_fun/0","type":"type"},{"doc":"An unordered set of unordered sets.","ref":"sofs.html#t:set_of_sets/0","title":"sofs.set_of_sets/0","type":"type"},{"doc":"","ref":"sofs.html#t:spec_fun/0","title":"sofs.spec_fun/0","type":"type"},{"doc":"A tuple where the elements are of type T .","ref":"sofs.html#t:tuple_of/1","title":"sofs.tuple_of/1","type":"type"},{"doc":"A type .","ref":"sofs.html#t:type/0","title":"sofs.type/0","type":"type"},{"doc":"This module provides functions for string processing. A string in this module is represented by unicode:chardata() , that is, a list of codepoints, binaries with UTF-8-encoded codepoints ( UTF-8 binaries ), or a mix of the two. &quot;abcd&quot; is a valid string &lt;&lt; &quot;abcd&quot; &gt;&gt; is a valid string [ &quot;abcd&quot; ] is a valid string &lt;&lt; &quot;abc..åäö&quot; / utf8 &gt;&gt; is a valid string &lt;&lt; &quot;abc..åäö&quot; &gt;&gt; is NOT a valid string , but a binary with Latin - 1 - encoded codepoints [ &lt;&lt; &quot;abc&quot; &gt;&gt; , &quot;..åäö&quot; ] is a valid string [ atom ] is NOT a valid string This module operates on grapheme clusters. A grapheme cluster is a user-perceived character, which can be represented by several codepoints. &quot;å&quot; [ 229 ] or [ 97 , 778 ] &quot;e̊&quot; [ 101 , 778 ] The string length of &quot;ß↑e̊&quot; is 3, even though it is represented by the codepoints [223,8593,101,778] or the UTF-8 binary &lt;&lt;195,159,226,134,145,101,204,138&gt;&gt; . Grapheme clusters for codepoints of class prepend and non-modern (or decomposed) Hangul is not handled for performance reasons in find/3 , replace/3 , split/2 , split/2 and trim/3 . Splitting and appending strings is to be done on grapheme clusters borders. There is no verification that the results of appending strings are valid or normalized. Most of the functions expect all input to be normalized to one form, see for example unicode:characters_to_nfc_list/1 . Language or locale specific handling of input is not considered in any function. The functions can crash for non-valid input strings. For example, the functions expect UTF-8 binaries but not all functions verify that all binaries are encoded correctly. Unless otherwise specified the return value type is the same as the input type. That is, binary input returns binary output, list input returns a list output, and mixed input can return a mixed output. 1 &gt; string : trim ( &quot; sarah &quot; ) . &quot;sarah&quot; 2 &gt; string : trim ( &lt;&lt; &quot; sarah &quot; &gt;&gt; ) . &lt;&lt; &quot;sarah&quot; &gt;&gt; 3 &gt; string : lexemes ( &quot;foo bar&quot; , &quot; &quot; ) . [ &quot;foo&quot; , &quot;bar&quot; ] 4 &gt; string : lexemes ( &lt;&lt; &quot;foo bar&quot; &gt;&gt; , &quot; &quot; ) . [ &lt;&lt; &quot;foo&quot; &gt;&gt; , &lt;&lt; &quot;bar&quot; &gt;&gt; ] This module has been reworked in Erlang/OTP 20 to handle unicode:chardata() and operate on grapheme clusters. The old functions that only work on Latin-1 lists as input are still available but should not be used, they will be deprecated in a future release. Notes Some of the general string functions can seem to overlap each other. The reason is that this string package is the combination of two earlier packages and all functions of both packages have been retained.","ref":"string.html","title":"string","type":"module"},{"doc":"Converts String to a case-agnostic comparable string. Function casefold/1 is preferred over lowercase/1 when two strings are to be compared for equality. See also equal/4 . Example: 1 &gt; string : casefold ( &quot;Ω and ẞ SHARP S&quot; ) . &quot;ω and ss sharp s&quot;","ref":"string.html#casefold/1","title":"string.casefold/1","type":"function"},{"doc":"Returns a string, where String is centered in the string and surrounded by blanks or Character . The resulting string has length Number . This function is obsolete . Use pad/3 .","ref":"string.html#centre/2","title":"string.centre/2","type":"function"},{"doc":"","ref":"string.html#centre/3","title":"string.centre/3","type":"function"},{"doc":"Returns a string consisting of Number characters Character . Optionally, the string can end with string Tail . This function is obsolete . Use lists:duplicate/2 .","ref":"string.html#chars/2","title":"string.chars/2","type":"function"},{"doc":"","ref":"string.html#chars/3","title":"string.chars/3","type":"function"},{"doc":"Returns a string where any trailing \\n or \\r\\n have been removed from String . Example: 182 &gt; string : chomp ( &lt;&lt; &quot;\\nHello\\n\\n&quot; &gt;&gt; ) . &lt;&lt; &quot;\\nHello&quot; &gt;&gt; 183 &gt; string : chomp ( &quot;\\nHello\\r\\r\\n&quot; ) . &quot;\\nHello\\r&quot;","ref":"string.html#chomp/1","title":"string.chomp/1","type":"function"},{"doc":"Returns the index of the first occurrence of Character in String . Returns 0 if Character does not occur. This function is obsolete . Use find/2 .","ref":"string.html#chr/2","title":"string.chr/2","type":"function"},{"doc":"Concatenates String1 and String2 to form a new string String3 , which is returned. This function is obsolete . Use [String1, String2] as Data argument, and call unicode:characters_to_list/2 or unicode:characters_to_binary/2 to flatten the output.","ref":"string.html#concat/2","title":"string.concat/2","type":"function"},{"doc":"Returns a string containing String repeated Number times. This function is obsolete . Use lists:duplicate/2 .","ref":"string.html#copies/2","title":"string.copies/2","type":"function"},{"doc":"Returns the length of the maximum initial segment of String , which consists entirely of characters not from Chars . This function is obsolete . Use take/3 . Example: &gt; string:cspan(&quot;\\t abcdef&quot;, &quot; \\t&quot;). 0","ref":"string.html#cspan/2","title":"string.cspan/2","type":"function"},{"doc":"Returns true if A and B are equal, otherwise false . If IgnoreCase is true the function does casefold ing on the fly before the equality test. If Norm is not none the function applies normalization on the fly before the equality test. There are four available normalization forms: nfc , nfd , nfkc , and nfkd . By default, IgnoreCase is false and Norm is none . Example: 1 &gt; string : equal ( &quot;åäö&quot; , &lt;&lt; &quot;åäö&quot; / utf8 &gt;&gt; ) . true 2 &gt; string : equal ( &quot;åäö&quot; , unicode : characters_to_nfd_binary ( &quot;åäö&quot; ) ) . false 3 &gt; string : equal ( &quot;åäö&quot; , unicode : characters_to_nfd_binary ( &quot;ÅÄÖ&quot; ) , true , nfc ) . true","ref":"string.html#equal/2","title":"string.equal/2","type":"function"},{"doc":"","ref":"string.html#equal/3","title":"string.equal/3","type":"function"},{"doc":"","ref":"string.html#equal/4","title":"string.equal/4","type":"function"},{"doc":"Removes anything before SearchPattern in String and returns the remainder of the string or nomatch if SearchPattern is not found. Dir , which can be leading or trailing , indicates from which direction characters are to be searched. By default, Dir is leading . Example: 1 &gt; string : find ( &quot;ab..cd..ef&quot; , &quot;.&quot; ) . &quot;..cd..ef&quot; 2 &gt; string : find ( &lt;&lt; &quot;ab..cd..ef&quot; &gt;&gt; , &quot;..&quot; , trailing ) . &lt;&lt; &quot;..ef&quot; &gt;&gt; 3 &gt; string : find ( &lt;&lt; &quot;ab..cd..ef&quot; &gt;&gt; , &quot;x&quot; , leading ) . nomatch 4 &gt; string : find ( &quot;ab..cd..ef&quot; , &quot;x&quot; , trailing ) . nomatch","ref":"string.html#find/2","title":"string.find/2","type":"function"},{"doc":"","ref":"string.html#find/3","title":"string.find/3","type":"function"},{"doc":"Returns true if String is the empty string, otherwise false . Example: 1 &gt; string : is_empty ( &quot;foo&quot; ) . false 2 &gt; string : is_empty ( [ &quot;&quot; , &lt;&lt; &gt;&gt; ] ) . true","ref":"string.html#is_empty/1","title":"string.is_empty/1","type":"function"},{"doc":"Returns a string with the elements of StringList separated by the string in Separator . This function is obsolete . Use lists:join/2 . Example: &gt; join([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;], &quot;, &quot;). &quot;one, two, three&quot;","ref":"string.html#join/2","title":"string.join/2","type":"function"},{"doc":"Returns String with the length adjusted in accordance with Number . The left margin is fixed. If length(String) &lt; Number , then String is padded with blanks or Character s. This function is obsolete . Use pad/2 or pad/3 . Example: &gt; string:left(&quot;Hello&quot;,10,$.). &quot;Hello.....&quot;","ref":"string.html#left/2","title":"string.left/2","type":"function"},{"doc":"","ref":"string.html#left/3","title":"string.left/3","type":"function"},{"doc":"Returns the number of characters in String . This function is obsolete . Use length/1 .","ref":"string.html#len/1","title":"string.len/1","type":"function"},{"doc":"Returns the number of grapheme clusters in String . Example: 1 &gt; string : length ( &quot;ß↑e̊&quot; ) . 3 2 &gt; string : length ( &lt;&lt; 195 , 159 , 226 , 134 , 145 , 101 , 204 , 138 &gt;&gt; ) . 3","ref":"string.html#length/1","title":"string.length/1","type":"function"},{"doc":"Returns a list of lexemes in String , separated by the grapheme clusters in SeparatorList . Notice that, as shown in this example, two or more adjacent separator graphemes clusters in String are treated as one. That is, there are no empty strings in the resulting list of lexemes. See also split/3 which returns empty strings. Notice that [$\\r,$\\n] is one grapheme cluster. Example: 1 &gt; string : lexemes ( &quot;abc de̊fxxghix jkl\\r\\nfoo&quot; , &quot;x e&quot; ++ [ [ $\\ r , $\\ n ] ] ) . [ &quot;abc&quot; , &quot;de̊f&quot; , &quot;ghi&quot; , &quot;jkl&quot; , &quot;foo&quot; ] 2 &gt; string : lexemes ( &lt;&lt; &quot;abc de̊fxxghix jkl\\r\\nfoo&quot; / utf8 &gt;&gt; , &quot;x e&quot; ++ [ $\\ r , $\\ n ] ) . [ &lt;&lt; &quot;abc&quot; &gt;&gt; , &lt;&lt; &quot;de̊f&quot; / utf8 &gt;&gt; , &lt;&lt; &quot;ghi&quot; &gt;&gt; , &lt;&lt; &quot;jkl\\r\\nfoo&quot; &gt;&gt; ]","ref":"string.html#lexemes/2","title":"string.lexemes/2","type":"function"},{"doc":"Converts String to lowercase. Notice that function casefold/1 should be used when converting a string to be tested for equality. Example: 2 &gt; string : lowercase ( string : uppercase ( &quot;Michał&quot; ) ) . &quot;michał&quot;","ref":"string.html#lowercase/1","title":"string.lowercase/1","type":"function"},{"doc":"Returns the first codepoint in String and the rest of String in the tail. Returns an empty list if String is empty or an {error, String} tuple if the next byte is invalid. Example: 1 &gt; string : next_codepoint ( unicode : characters_to_binary ( &quot;e̊fg&quot; ) ) . [ 101 | &lt;&lt; &quot;̊fg&quot; / utf8 &gt;&gt; ]","ref":"string.html#next_codepoint/1","title":"string.next_codepoint/1","type":"function"},{"doc":"Returns the first grapheme cluster in String and the rest of String in the tail. Returns an empty list if String is empty or an {error, String} tuple if the next byte is invalid. Example: 1 &gt; string : next_grapheme ( unicode : characters_to_binary ( &quot;e̊fg&quot; ) ) . [ &quot;e̊&quot; | &lt;&lt; &quot;fg&quot; &gt;&gt; ]","ref":"string.html#next_grapheme/1","title":"string.next_grapheme/1","type":"function"},{"doc":"Returns lexeme number N in String , where lexemes are separated by the grapheme clusters in SeparatorList . Example: 1 &gt; string : nth_lexeme ( &quot;abc.de̊f.ghiejkl&quot; , 3 , &quot;.e&quot; ) . &quot;ghi&quot;","ref":"string.html#nth_lexeme/3","title":"string.nth_lexeme/3","type":"function"},{"doc":"Pads String to Length with grapheme cluster Char . Dir , which can be leading , trailing , or both , indicates where the padding should be added. By default, Char is $\\s and Dir is trailing . Example: 1 &gt; string : pad ( &lt;&lt; &quot;He̊llö&quot; / utf8 &gt;&gt; , 8 ) . [ &lt;&lt; 72 , 101 , 204 , 138 , 108 , 108 , 195 , 182 &gt;&gt; , 32 , 32 , 32 ] 2 &gt; io : format ( &quot;&#39;~ts&#39; ~n &quot; , [ string : pad ( &quot;He̊llö&quot; , 8 , leading ) ] ) . &#39; He̊llö&#39; 3 &gt; io : format ( &quot;&#39;~ts&#39; ~n &quot; , [ string : pad ( &quot;He̊llö&quot; , 8 , both ) ] ) . &#39; He̊llö &#39;","ref":"string.html#pad/2","title":"string.pad/2","type":"function"},{"doc":"","ref":"string.html#pad/3","title":"string.pad/3","type":"function"},{"doc":"","ref":"string.html#pad/4","title":"string.pad/4","type":"function"},{"doc":"If Prefix is the prefix of String , removes it and returns the remainder of String , otherwise returns nomatch . Example: 1 &gt; string : prefix ( &lt;&lt; &quot;prefix of string&quot; &gt;&gt; , &quot;pre&quot; ) . &lt;&lt; &quot;fix of string&quot; &gt;&gt; 2 &gt; string : prefix ( &quot;pre&quot; , &quot;prefix&quot; ) . nomatch","ref":"string.html#prefix/2","title":"string.prefix/2","type":"function"},{"doc":"Returns the index of the last occurrence of Character in String . Returns 0 if Character does not occur. This function is obsolete . Use find/3 .","ref":"string.html#rchr/2","title":"string.rchr/2","type":"function"},{"doc":"Replaces SearchPattern in String with Replacement . Where , default leading , indicates whether the leading , the trailing or all encounters of SearchPattern are to be replaced. Can be implemented as: lists : join ( Replacement , split ( String , SearchPattern , Where ) ) . Example: 1 &gt; string : replace ( &lt;&lt; &quot;ab..cd..ef&quot; &gt;&gt; , &quot;..&quot; , &quot;*&quot; ) . [ &lt;&lt; &quot;ab&quot; &gt;&gt; , &quot;*&quot; , &lt;&lt; &quot;cd..ef&quot; &gt;&gt; ] 2 &gt; string : replace ( &lt;&lt; &quot;ab..cd..ef&quot; &gt;&gt; , &quot;..&quot; , &quot;*&quot; , all ) . [ &lt;&lt; &quot;ab&quot; &gt;&gt; , &quot;*&quot; , &lt;&lt; &quot;cd&quot; &gt;&gt; , &quot;*&quot; , &lt;&lt; &quot;ef&quot; &gt;&gt; ]","ref":"string.html#replace/3","title":"string.replace/3","type":"function"},{"doc":"","ref":"string.html#replace/4","title":"string.replace/4","type":"function"},{"doc":"Returns the reverse list of the grapheme clusters in String . Example: 1 &gt; Reverse = string : reverse ( unicode : characters_to_nfd_binary ( &quot;ÅÄÖ&quot; ) ) . [ [ 79 , 776 ] , [ 65 , 776 ] , [ 65 , 778 ] ] 2 &gt; io : format ( &quot;~ts ~n &quot; , [ Reverse ] ) . O ̈ A ̈ A ̊","ref":"string.html#reverse/1","title":"string.reverse/1","type":"function"},{"doc":"Returns String with the length adjusted in accordance with Number . The right margin is fixed. If the length of (String) &lt; Number , then String is padded with blanks or Character s. This function is obsolete . Use pad/3 . Example: &gt; string:right(&quot;Hello&quot;, 10, $.). &quot;.....Hello&quot;","ref":"string.html#right/2","title":"string.right/2","type":"function"},{"doc":"","ref":"string.html#right/3","title":"string.right/3","type":"function"},{"doc":"Returns the position where the last occurrence of SubString begins in String . Returns 0 if SubString does not exist in String . This function is obsolete . Use find/3 . Example: &gt; string:rstr(&quot; Hello Hello World World &quot;, &quot;Hello World&quot;). 8","ref":"string.html#rstr/2","title":"string.rstr/2","type":"function"},{"doc":"Returns a substring of String of at most Length grapheme clusters, starting at position Start . By default, Length is infinity . Example: 1 &gt; string : slice ( &lt;&lt; &quot;He̊llö Wörld&quot; / utf8 &gt;&gt; , 4 ) . &lt;&lt; &quot;ö Wörld&quot; / utf8 &gt;&gt; 2 &gt; string : slice ( [ &quot;He̊llö &quot; , &lt;&lt; &quot;Wörld&quot; / utf8 &gt;&gt; ] , 4 , 4 ) . &quot;ö Wö&quot; 3 &gt; string : slice ( [ &quot;He̊llö &quot; , &lt;&lt; &quot;Wörld&quot; / utf8 &gt;&gt; ] , 4 , 50 ) . &quot;ö Wörld&quot;","ref":"string.html#slice/2","title":"string.slice/2","type":"function"},{"doc":"","ref":"string.html#slice/3","title":"string.slice/3","type":"function"},{"doc":"Returns the length of the maximum initial segment of String , which consists entirely of characters from Chars . This function is obsolete . Use take/2 . Example: &gt; string:span(&quot;\\t abcdef&quot;, &quot; \\t&quot;). 5","ref":"string.html#span/2","title":"string.span/2","type":"function"},{"doc":"Splits String where SearchPattern is encountered and return the remaining parts. Where , default leading , indicates whether the leading , the trailing or all encounters of SearchPattern will split String . Example: 0 &gt; string : split ( &quot;ab..bc..cd&quot; , &quot;..&quot; ) . [ &quot;ab&quot; , &quot;bc..cd&quot; ] 1 &gt; string : split ( &lt;&lt; &quot;ab..bc..cd&quot; &gt;&gt; , &quot;..&quot; , trailing ) . [ &lt;&lt; &quot;ab..bc&quot; &gt;&gt; , &lt;&lt; &quot;cd&quot; &gt;&gt; ] 2 &gt; string : split ( &lt;&lt; &quot;ab..bc....cd&quot; &gt;&gt; , &quot;..&quot; , all ) . [ &lt;&lt; &quot;ab&quot; &gt;&gt; , &lt;&lt; &quot;bc&quot; &gt;&gt; , &lt;&lt; &gt;&gt; , &lt;&lt; &quot;cd&quot; &gt;&gt; ]","ref":"string.html#split/2","title":"string.split/2","type":"function"},{"doc":"","ref":"string.html#split/3","title":"string.split/3","type":"function"},{"doc":"Returns the position where the first occurrence of SubString begins in String . Returns 0 if SubString does not exist in String . This function is obsolete . Use find/2 . Example: &gt; string:str(&quot; Hello Hello World World &quot;, &quot;Hello World&quot;). 8","ref":"string.html#str/2","title":"string.str/2","type":"function"},{"doc":"Returns a string, where leading or trailing, or both, blanks or a number of Character have been removed. Direction , which can be left , right , or both , indicates from which direction blanks are to be removed. strip/1 is equivalent to strip(String, both) . This function is obsolete . Use trim/3 . Example: &gt; string:strip(&quot;...Hello.....&quot;, both, $.). &quot;Hello&quot;","ref":"string.html#strip/1","title":"string.strip/1","type":"function"},{"doc":"","ref":"string.html#strip/2","title":"string.strip/2","type":"function"},{"doc":"","ref":"string.html#strip/3","title":"string.strip/3","type":"function"},{"doc":"Returns a substring of String , starting at position Start to the end of the string, or to and including position Stop . This function is obsolete . Use slice/3 . Example: sub_string(&quot;Hello World&quot;, 4, 8). &quot;lo Wo&quot;","ref":"string.html#sub_string/2","title":"string.sub_string/2","type":"function"},{"doc":"","ref":"string.html#sub_string/3","title":"string.sub_string/3","type":"function"},{"doc":"Returns the word in position Number of String . Words are separated by blanks or Character s. This function is obsolete . Use nth_lexeme/3 . Example: &gt; string:sub_word(&quot; Hello old boy !&quot;,3,$o). &quot;ld b&quot;","ref":"string.html#sub_word/2","title":"string.sub_word/2","type":"function"},{"doc":"","ref":"string.html#sub_word/3","title":"string.sub_word/3","type":"function"},{"doc":"Returns a substring of String , starting at position Start , and ending at the end of the string or at length Length . This function is obsolete . Use slice/3 . Example: &gt; substr(&quot;Hello World&quot;, 4, 5). &quot;lo Wo&quot;","ref":"string.html#substr/2","title":"string.substr/2","type":"function"},{"doc":"","ref":"string.html#substr/3","title":"string.substr/3","type":"function"},{"doc":"Takes characters from String as long as the characters are members of set Characters or the complement of set Characters . Dir , which can be leading or trailing , indicates from which direction characters are to be taken. Example: 5 &gt; string : take ( &quot;abc0z123&quot; , lists : seq ( $a , $z ) ) . { &quot;abc&quot; , &quot;0z123&quot; } 6 &gt; string : take ( &lt;&lt; &quot;abc0z123&quot; &gt;&gt; , lists : seq ( $0 , $9 ) , true , leading ) . { &lt;&lt; &quot;abc&quot; &gt;&gt; , &lt;&lt; &quot;0z123&quot; &gt;&gt; } 7 &gt; string : take ( &quot;abc0z123&quot; , lists : seq ( $0 , $9 ) , false , trailing ) . { &quot;abc0z&quot; , &quot;123&quot; } 8 &gt; string : take ( &lt;&lt; &quot;abc0z123&quot; &gt;&gt; , lists : seq ( $a , $z ) , true , trailing ) . { &lt;&lt; &quot;abc0z&quot; &gt;&gt; , &lt;&lt; &quot;123&quot; &gt;&gt; }","ref":"string.html#take/2","title":"string.take/2","type":"function"},{"doc":"","ref":"string.html#take/3","title":"string.take/3","type":"function"},{"doc":"","ref":"string.html#take/4","title":"string.take/4","type":"function"},{"doc":"Converts String to titlecase. Example: 1 &gt; string : titlecase ( &quot;ß is a SHARP s&quot; ) . &quot;Ss is a SHARP s&quot;","ref":"string.html#titlecase/1","title":"string.titlecase/1","type":"function"},{"doc":"Argument String is expected to start with a valid text represented float (the digits are ASCII values). Remaining characters in the string after the float are returned in Rest . Example: &gt; { F1 , Fs } = string : to_float ( &quot;1.0-1.0e-1&quot; ) , &gt; { F2 , [ ] } = string : to_float ( Fs ) , &gt; F1 + F2 . 0.9 &gt; string : to_float ( &quot;3/2=1.5&quot; ) . { error , no_float } &gt; string : to_float ( &quot;-1.5eX&quot; ) . { - 1.5 , &quot;eX&quot; }","ref":"string.html#to_float/1","title":"string.to_float/1","type":"function"},{"doc":"Converts String to a list of grapheme clusters. Example: 1 &gt; string : to_graphemes ( &quot;ß↑e̊&quot; ) . [ 223 , 8593 , [ 101 , 778 ] ] 2 &gt; string : to_graphemes ( &lt;&lt; &quot;ß↑e̊&quot; / utf8 &gt;&gt; ) . [ 223 , 8593 , [ 101 , 778 ] ]","ref":"string.html#to_graphemes/1","title":"string.to_graphemes/1","type":"function"},{"doc":"Argument String is expected to start with a valid text represented integer (the digits are ASCII values). Remaining characters in the string after the integer are returned in Rest . Example: &gt; { I1 , Is } = string : to_integer ( &quot;33+22&quot; ) , &gt; { I2 , [ ] } = string : to_integer ( Is ) , &gt; I1 - I2 . 11 &gt; string : to_integer ( &quot;0.5&quot; ) . { 0 , &quot;.5&quot; } &gt; string : to_integer ( &quot;x=2&quot; ) . { error , no_integer }","ref":"string.html#to_integer/1","title":"string.to_integer/1","type":"function"},{"doc":"The specified string or character is case-converted. Notice that the supported character set is ISO/IEC 8859-1 (also called Latin 1); all values outside this set are unchanged This function is obsolete use lowercase/1 , uppercase/1 , titlecase/1 or casefold/1 .","ref":"string.html#to_lower/1","title":"string.to_lower/1","type":"function"},{"doc":"","ref":"string.html#to_upper/1","title":"string.to_upper/1","type":"function"},{"doc":"Returns a list of tokens in String , separated by the characters in SeparatorList . Example: &gt; tokens(&quot;abc defxxghix jkl&quot;, &quot;x &quot;). [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;] Notice that, as shown in this example, two or more adjacent separator characters in String are treated as one. That is, there are no empty strings in the resulting list of tokens. This function is obsolete . Use lexemes/2 .","ref":"string.html#tokens/2","title":"string.tokens/2","type":"function"},{"doc":"Returns a string, where leading or trailing, or both, Characters have been removed. Dir which can be leading , trailing , or both , indicates from which direction characters are to be removed. Default Characters is the set of nonbreakable whitespace codepoints, defined as Pattern_White_Space in Unicode Standard Annex #31 . By default, Dir is both . Notice that [$\\r,$\\n] is one grapheme cluster according to the Unicode Standard. Example: 1 &gt; string : trim ( &quot;\\t Hello \\n&quot; ) . &quot;Hello&quot; 2 &gt; string : trim ( &lt;&lt; &quot;\\t Hello \\n&quot; &gt;&gt; , leading ) . &lt;&lt; &quot;Hello \\n&quot; &gt;&gt; 3 &gt; string : trim ( &lt;&lt; &quot;.Hello.\\n&quot; &gt;&gt; , trailing , &quot;\\n.&quot; ) . &lt;&lt; &quot;.Hello&quot; &gt;&gt;","ref":"string.html#trim/1","title":"string.trim/1","type":"function"},{"doc":"","ref":"string.html#trim/2","title":"string.trim/2","type":"function"},{"doc":"","ref":"string.html#trim/3","title":"string.trim/3","type":"function"},{"doc":"Converts String to uppercase. See also titlecase/1 . Example: 1 &gt; string : uppercase ( &quot;Michał&quot; ) . &quot;MICHAŁ&quot;","ref":"string.html#uppercase/1","title":"string.uppercase/1","type":"function"},{"doc":"Returns the number of words in String , separated by blanks or Character . This function is obsolete . Use lexemes/2 . Example: &gt; words(&quot; Hello old boy!&quot;, $o). 4","ref":"string.html#words/1","title":"string.words/1","type":"function"},{"doc":"","ref":"string.html#words/2","title":"string.words/2","type":"function"},{"doc":"A user-perceived character, consisting of one or more codepoints.","ref":"string.html#t:direction/0","title":"string.direction/0","type":"type"},{"doc":"A user-perceived character, consisting of one or more codepoints.","ref":"string.html#t:grapheme_cluster/0","title":"string.grapheme_cluster/0","type":"type"},{"doc":"This behavior module provides a supervisor, a process that supervises other processes called child processes. A child process can either be another supervisor or a worker process. Worker processes are normally implemented using one of the gen_event , gen_server , or gen_statem behaviors. A supervisor implemented using this module has a standard set of interface functions and include functionality for tracing and error reporting. Supervisors are used to build a hierarchical process structure called a supervision tree, a nice way to structure a fault-tolerant application. For more information, see Supervisor Behaviour in OTP Design Principles. A supervisor expects the definition of which child processes to supervise to be specified in a callback module exporting a predefined set of functions. Unless otherwise stated, all functions in this module fail if the specified supervisor does not exist or if bad arguments are specified. Supervision Principles The supervisor is responsible for starting, stopping, and monitoring its child processes. The basic idea of a supervisor is that it must keep its child processes alive by restarting them when necessary. The children of a supervisor are defined as a list of child specifications . When the supervisor is started, the child processes are started in order from left to right according to this list. When the supervisor terminates, it first terminates its child processes in reversed start order, from right to left. Supervisor flags The supervisor properties are defined by the supervisor flags. The type definition for the supervisor flags is as follows: sup_flags ( ) = \#{ strategy =&gt; strategy ( ) , % optional intensity =&gt; non_neg_integer ( ) , % optional period =&gt; pos_integer ( ) , % optional auto_shutdown =&gt; auto_shutdown ( ) } % optional Restart Strategies A supervisor can have one of the following restart strategies specified with the strategy key in the above map: one_for_one - If one child process terminates and is to be restarted, only that child process is affected. This is the default restart strategy. one_for_all - If one child process terminates and is to be restarted, all other child processes are terminated and then all child processes are restarted. rest_for_one - If one child process terminates and is to be restarted, the 'rest' of the child processes (that is, the child processes after the terminated child process in the start order) are terminated. Then the terminated child process and all child processes after it are restarted. simple_one_for_one - A simplified one_for_one supervisor, where all child processes are dynamically added instances of the same process type, that is, running the same code. Functions delete_child/2 and restart_child/2 are invalid for simple_one_for_one supervisors and return {error,simple_one_for_one} if the specified supervisor uses this restart strategy. Function terminate_child/2 can be used for children under simple_one_for_one supervisors by specifying the child's pid() as the second argument. If instead the child specification identifier is used, terminate_child/2 return {error,simple_one_for_one} . As a simple_one_for_one supervisor can have many children, it shuts them all down asynchronously. This means that the children do their cleanup in parallel, and therefore the order in which they are stopped is not defined. Restart intensity and period To prevent a supervisor from getting into an infinite loop of child process terminations and restarts, a maximum restart intensity is defined using two integer values specified with keys intensity and period in the above map. Assuming the values MaxR for intensity and MaxT for period , then, if more than MaxR restarts occur within MaxT seconds, the supervisor terminates all child processes and then itself. The termination reason for the supervisor itself in that case will be shutdown . intensity defaults to 1 and period defaults to 5 . Automatic Shutdown A supervisor can be configured to automatically shut itself down with exit reason shutdown when significant children terminate with the auto_shutdown key in the above map: never - Automic shutdown is disabled. This is the default setting. With auto_shutdown set to never , child specs with the significant flag set to true are considered invalid and will be rejected. any_significant - The supervisor will shut itself down when any significant child terminates, that is, when a transient significant child terminates normally or when a temporary significant child terminates normally or abnormally. all_significant - The supervisor will shut itself down when all significant children have terminated, that is, when the last active significant child terminates. The same rules as for any_significant apply. For more information, see the section Automatic Shutdown in Supervisor Behavior in OTP Design Principles. The automatic shutdown feature appeared in OTP 24.0, but applications using this feature will also compile and run with older OTP versions. However, such applications, when compiled with an OTP version that predates the appearance of the automatic shutdown feature, will leak processes because the automatic shutdowns they rely on will not happen. It is up to implementors to take proper precautions if they expect that their applications may be compiled with older OTP versions. Child specification The type definition of a child specification is as follows: child_spec ( ) = \#{ id =&gt; child_id ( ) , % mandatory start =&gt; mfargs ( ) , % mandatory restart =&gt; restart ( ) , % optional significant =&gt; significant ( ) , % optional shutdown =&gt; shutdown ( ) , % optional type =&gt; worker ( ) , % optional modules =&gt; modules ( ) } % optional The old tuple format is kept for backwards compatibility, see child_spec() , but the map is preferred. id is used to identify the child specification internally by the supervisor. The id key is mandatory. Notice that this identifier on occations has been called &quot;name&quot;. As far as possible, the terms &quot;identifier&quot; or &quot;id&quot; are now used but to keep backward compatibility, some occurences of &quot;name&quot; can still be found, for example in error messages. start defines the function call used to start the child process. It must be a module-function-arguments tuple {M,F,A} used as apply(M,F,A) . The start function must create and link to the child process, and must return {ok,Child} or {ok,Child,Info} , where Child is the pid of the child process and Info any term that is ignored by the supervisor. The start function can also return ignore if the child process for some reason cannot be started, in which case the child specification is kept by the supervisor (unless it is a temporary child) but the non-existing child process is ignored. If something goes wrong, the function can also return an error tuple {error,Error} . Notice that the start_link functions of the different behavior modules fulfill the above requirements. The start key is mandatory. restart defines when a terminated child process must be restarted. A permanent child process is always restarted. A temporary child process is never restarted (even when the supervisor's restart strategy is rest_for_one or one_for_all and a sibling's death causes the temporary process to be terminated). A transient child process is restarted only if it terminates abnormally, that is, with another exit reason than normal , shutdown , or {shutdown,Term} . The restart key is optional. If it is not specified, it defaults to permanent . significant defines if a child is considered significant for automatic self-shutdown of the supervisor. Setting this option to true when the restart type is permanent is invalid. Also, it is considered invalid to start children with this option set to true in a supervisor when the auto_shutdown supervisor flag is set to never . The significant key is optional. If it is not specified, it defaults to false . shutdown defines how a child process must be terminated. brutal_kill means that the child process is unconditionally terminated using exit(Child,kill) . An integer time-out value means that the supervisor tells the child process to terminate by calling exit(Child,shutdown) and then wait for an exit signal with reason shutdown back from the child process. If no exit signal is received within the specified number of milliseconds, the child process is unconditionally terminated using exit(Child,kill) . If the child process is another supervisor, the shutdown time must be set to infinity to give the subtree ample time to shut down. Setting the shutdown time to anything other than infinity for a child of type supervisor can cause a race condition where the child in question unlinks its own children, but fails to terminate them before it is killed. It is also allowed to set it to infinity , if the child process is a worker. Be careful when setting the shutdown time to infinity when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process, it must be implemented in a safe way and its cleanup procedure must always return. Notice that all child processes implemented using the standard OTP behavior modules automatically adhere to the shutdown protocol. The shutdown key is optional. If it is not specified, it defaults to 5000 if the child is of type worker and it defaults to infinity if the child is of type supervisor . type specifies if the child process is a supervisor or a worker. The type key is optional. If it is not specified, it defaults to worker . modules is used by the release handler during code replacement to determine which processes are using a certain module. As a rule of thumb, if the child process is a supervisor , gen_server or, gen_statem , this is to be a list with one element [Module] , where Module is the callback module. If the child process is an event manager ( gen_event ) with a dynamic set of callback modules, value dynamic must be used. For more information about release handling, see Release Handling in OTP Design Principles. The modules key is optional. If it is not specified, it defaults to [M] , where M comes from the child's start {M,F,A} . Internally, the supervisor also keeps track of the pid Child of the child process, or undefined if no pid exists. See Also gen_event(3) , gen_statem(3) , gen_server(3) , sys(3)","ref":"supervisor.html","title":"supervisor","type":"behaviour"},{"doc":"Takes a list of child specification as argument and returns ok if all of them are syntactically correct, otherwise {error,Error} . If the optional AutoShutdown argument is given and not undefined , also checks if the child specifications are allowed for the given auto_shutdown option.","ref":"supervisor.html#check_childspecs/1","title":"supervisor.check_childspecs/1","type":"function"},{"doc":"","ref":"supervisor.html#check_childspecs/2","title":"supervisor.check_childspecs/2","type":"function"},{"doc":"Returns a property list (see proplists ) containing the counts for each of the following elements of the supervisor's child specifications and managed processes: specs - The total count of children, dead or alive. active - The count of all actively running child processes managed by this supervisor. For a simple_one_for_one supervisors, no check is done to ensure that each child process is still alive, although the result provided here is likely to be very accurate unless the supervisor is heavily overloaded. supervisors - The count of all children marked as child_type = supervisor in the specification list, regardless if the child process is still alive. workers - The count of all children marked as child_type = worker in the specification list, regardless if the child process is still alive. For a description of SupRef , see start_child/2 .","ref":"supervisor.html#count_children/1","title":"supervisor.count_children/1","type":"function"},{"doc":"Tells supervisor SupRef to delete the child specification identified by Id . The corresponding child process must not be running. Use terminate_child/2 to terminate it. For a description of SupRef , see start_child/2 . If successful, the function returns ok . If the child specification identified by Id exists but the corresponding child process is running or is about to be restarted, the function returns {error,running} or {error,restarting} , respectively. If the child specification identified by Id does not exist, the function returns {error,not_found} .","ref":"supervisor.html#delete_child/2","title":"supervisor.delete_child/2","type":"function"},{"doc":"Returns the child specification map for the child identified by Id under supervisor SupRef . The returned map contains all keys, both mandatory and optional. For a description of SupRef , see start_child/2 .","ref":"supervisor.html#get_childspec/2","title":"supervisor.get_childspec/2","type":"function"},{"doc":"Args = term() Result = {ok,{SupFlags,[ChildSpec]}} | ignore  SupFlags = sup_flags()  ChildSpec = child_spec() Whenever a supervisor is started using start_link/2,3 , this function is called by the new process to find out about restart strategy, maximum restart intensity, and child specifications. Args is the Args argument provided to the start function. SupFlags is the supervisor flags defining the restart strategy and maximum restart intensity for the supervisor. [ChildSpec] is a list of valid child specifications defining which child processes the supervisor must start and monitor. See the discussion in section Supervision Principles earlier. Notice that when the restart strategy is simple_one_for_one , the list of child specifications must be a list with one child specification only. (The child specification identifier is ignored.) No child process is then started during the initialization phase, but all children are assumed to be started dynamically using start_child/2 . The function can also return ignore . Notice that this function can also be called as a part of a code upgrade procedure. Therefore, the function is not to have any side effects. For more information about code upgrade of supervisors, see section Changing a Supervisor in OTP Design Principles.","ref":"supervisor.html#c:init/1","title":"supervisor.init/1","type":"callback"},{"doc":"Tells supervisor SupRef to restart a child process corresponding to the child specification identified by Id . The child specification must exist, and the corresponding child process must not be running. Notice that for temporary children, the child specification is automatically deleted when the child terminates; thus, it is not possible to restart such children. For a description of SupRef , see start_child/2 . If the child specification identified by Id does not exist, the function returns {error,not_found} . If the child specification exists but the corresponding process is already running, the function returns {error,running} . If the child process start function returns {ok,Child} or {ok,Child,Info} , the pid is added to the supervisor and the function returns the same value. If the child process start function returns ignore , the pid remains set to undefined and the function returns {ok,undefined} . If the child process start function returns an error tuple or an erroneous value, or if it fails, the function returns {error,Error} , where Error is a term containing information about the error.","ref":"supervisor.html#restart_child/2","title":"supervisor.restart_child/2","type":"function"},{"doc":"Dynamically adds a child specification to supervisor SupRef , which starts the corresponding child process. SupRef can be any of the following: The pid Name , if the supervisor is locally registered {Name,Node} , if the supervisor is locally registered at another node {global,Name} , if the supervisor is globally registered {via,Module,Name} , if the supervisor is registered through an alternative process registry ChildSpec must be a valid child specification (unless the supervisor is a simple_one_for_one supervisor; see below). The child process is started by using the start function as defined in the child specification. For a simple_one_for_one supervisor, the child specification defined in Module:init/1 is used, and ChildSpec must instead be an arbitrary list of terms List . The child process is then started by appending List to the existing start function arguments, that is, by calling apply(M, F, A++List) , where {M,F,A} is the start function defined in the child specification. If there already exists a child specification with the specified identifier, ChildSpec is discarded, and the function returns {error,already_present} or {error,{already_started,Child}} , depending on if the corresponding child process is running or not. If the child process start function returns {ok,Child} or {ok,Child,Info} , the child specification and pid are added to the supervisor and the function returns the same value. If the child process start function returns ignore , the child specification is added to the supervisor (unless the supervisor is a simple_one_for_one supervisor, see below), the pid is set to undefined , and the function returns {ok,undefined} . For a simple_one_for_one supervisor, when a child process start function returns ignore , the functions returns {ok,undefined} and no child is added to the supervisor. If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded, and the function returns {error,Error} , where Error is a term containing information about the error and child specification.","ref":"supervisor.html#start_child/2","title":"supervisor.start_child/2","type":"function"},{"doc":"Creates a supervisor process as part of a supervision tree. For example, the function ensures that the supervisor is linked to the calling process (its supervisor). The created supervisor process calls Module:init/1 to find out about restart strategy, maximum restart intensity, and child processes. To ensure a synchronized startup procedure, start_link/2,3 does not return until Module:init/1 has returned and all child processes have been started. If SupName={local,Name} , the supervisor is registered locally as Name using register/2 . If SupName={global,Name} , the supervisor is registered globally as Name using global:register_name/2 . If SupName={via,Module,Name} , the supervisor is registered as Name using the registry represented by Module . The Module callback must export the functions register_name/2 , unregister_name/1 , and send/2 , which must behave like the corresponding functions in global . Thus, {via,global,Name} is a valid reference. If no name is provided, the supervisor is not registered. Module is the name of the callback module. Args is any term that is passed as the argument to Module:init/1 . If the supervisor and its child processes are successfully created (that is, if all child process start functions return {ok,Child} , {ok,Child,Info} , or ignore ), the function returns {ok,Pid} , where Pid is the pid of the supervisor. If there already exists a process with the specified SupName , the function returns {error,{already_started,Pid}} , where Pid is the pid of that process. If Module:init/1 returns ignore , this function returns ignore as well, and the supervisor terminates with reason normal . If Module:init/1 fails or returns an incorrect value, this function returns {error,Term} , where Term is a term with information about the error, and the supervisor terminates with reason Term . If any child process start function fails or returns an error tuple or an erroneous value, the supervisor first terminates all already started child processes with reason shutdown and then terminate itself and returns {error, {shutdown, Reason}} .","ref":"supervisor.html#start_link/2","title":"supervisor.start_link/2","type":"function"},{"doc":"","ref":"supervisor.html#start_link/3","title":"supervisor.start_link/3","type":"function"},{"doc":"Tells supervisor SupRef to terminate the specified child. If the supervisor is not simple_one_for_one , Id must be the child specification identifier. The process, if any, is terminated and, unless it is a temporary child, the child specification is kept by the supervisor. The child process can later be restarted by the supervisor. The child process can also be restarted explicitly by calling restart_child/2 . Use delete_child/2 to remove the child specification. If the child is temporary, the child specification is deleted as soon as the process terminates. This means that delete_child/2 has no meaning and restart_child/2 cannot be used for these children. If the supervisor is simple_one_for_one , Id must be the pid() of the child process. If the specified process is alive, but is not a child of the specified supervisor, the function returns {error,not_found} . If the child specification identifier is specified instead of a pid() , the function returns {error,simple_one_for_one} . If successful, the function returns ok . If there is no child specification with the specified Id , the function returns {error,not_found} . For a description of SupRef , see start_child/2 .","ref":"supervisor.html#terminate_child/2","title":"supervisor.terminate_child/2","type":"function"},{"doc":"Returns a newly created list with information about all child specifications and child processes belonging to supervisor SupRef . Notice that calling this function when supervising many children under low memory conditions can cause an out of memory exception. For a description of SupRef , see start_child/2 . The following information is given for each child specification/process: Id - As defined in the child specification or undefined for a simple_one_for_one supervisor. Child - The pid of the corresponding child process, the atom restarting if the process is about to be restarted, or undefined if there is no such process. Type - As defined in the child specification. Modules - As defined in the child specification.","ref":"supervisor.html#which_children/1","title":"supervisor.which_children/1","type":"function"},{"doc":"","ref":"supervisor.html#t:auto_shutdown/0","title":"supervisor.auto_shutdown/0","type":"type"},{"doc":"","ref":"supervisor.html#t:child/0","title":"supervisor.child/0","type":"type"},{"doc":"Not a pid() .","ref":"supervisor.html#t:child_id/0","title":"supervisor.child_id/0","type":"type"},{"doc":"The tuple format is kept for backward compatibility only. A map is preferred; see more details above .","ref":"supervisor.html#t:child_spec/0","title":"supervisor.child_spec/0","type":"type"},{"doc":"Value undefined for A (the argument list) is only to be used internally in supervisor . If the restart type of the child is temporary , the process is never to be restarted and therefore there is no need to store the real argument list. Value undefined is then stored instead.","ref":"supervisor.html#t:mfargs/0","title":"supervisor.mfargs/0","type":"type"},{"doc":"","ref":"supervisor.html#t:modules/0","title":"supervisor.modules/0","type":"type"},{"doc":"","ref":"supervisor.html#t:restart/0","title":"supervisor.restart/0","type":"type"},{"doc":"","ref":"supervisor.html#t:shutdown/0","title":"supervisor.shutdown/0","type":"type"},{"doc":"","ref":"supervisor.html#t:significant/0","title":"supervisor.significant/0","type":"type"},{"doc":"","ref":"supervisor.html#t:startchild_err/0","title":"supervisor.startchild_err/0","type":"type"},{"doc":"","ref":"supervisor.html#t:startchild_ret/0","title":"supervisor.startchild_ret/0","type":"type"},{"doc":"","ref":"supervisor.html#t:startlink_err/0","title":"supervisor.startlink_err/0","type":"type"},{"doc":"","ref":"supervisor.html#t:startlink_ret/0","title":"supervisor.startlink_ret/0","type":"type"},{"doc":"","ref":"supervisor.html#t:strategy/0","title":"supervisor.strategy/0","type":"type"},{"doc":"The tuple format is kept for backward compatibility only. A map is preferred; see more details above .","ref":"supervisor.html#t:sup_flags/0","title":"supervisor.sup_flags/0","type":"type"},{"doc":"","ref":"supervisor.html#t:sup_ref/0","title":"supervisor.sup_ref/0","type":"type"},{"doc":"","ref":"supervisor.html#t:worker/0","title":"supervisor.worker/0","type":"type"},{"doc":"This behavior module provides a supervisor bridge, a process that connects a subsystem not designed according to the OTP design principles to a supervision tree. The supervisor bridge sits between a supervisor and the subsystem. It behaves like a real supervisor to its own supervisor, but has a different interface than a real supervisor to the subsystem. For more information, see Supervisor Behaviour in OTP Design Principles. A supervisor bridge assumes the functions for starting and stopping the subsystem to be located in a callback module exporting a predefined set of functions. The sys(3) module can be used for debugging a supervisor bridge. Unless otherwise stated, all functions in this module fail if the specified supervisor bridge does not exist or if bad arguments are specified. See Also supervisor(3) , sys(3)","ref":"supervisor_bridge.html","title":"supervisor_bridge","type":"behaviour"},{"doc":"Args = term() Result = {ok,Pid,State} | ignore | {error,Error}  Pid = pid()  State = term()  Error = term() Whenever a supervisor bridge is started using start_link/2,3 , this function is called by the new process to start the subsystem and initialize. Args is the Args argument provided to the start function. The function is to return {ok,Pid,State} , where Pid is the pid of the main process in the subsystem and State is any term. If later Pid terminates with a reason Reason , the supervisor bridge terminates with reason Reason as well. If later the supervisor bridge is stopped by its supervisor with reason Reason , it calls Module:terminate(Reason,State) to terminate. If the initialization fails, the function is to return {error,Error} , where Error is any term, or ignore .","ref":"supervisor_bridge.html#c:init/1","title":"supervisor_bridge.init/1","type":"callback"},{"doc":"Creates a supervisor bridge process, linked to the calling process, which calls Module:init/1 to start the subsystem. To ensure a synchronized startup procedure, this function does not return until Module:init/1 has returned. If SupBridgeName={local,Name} , the supervisor bridge is registered locally as Name using register/2 . If SupBridgeName={global,Name} , the supervisor bridge is registered globally as Name using global:register_name/2 . If SupBridgeName={via,Module,Name} , the supervisor bridge is registered as Name using a registry represented by Module. The Module callback is to export functions register_name/2 , unregister_name/1 , and send/2 , which are to behave like the corresponding functions in global . Thus, {via,global,GlobalName} is a valid reference. If no name is provided, the supervisor bridge is not registered. Module is the name of the callback module. Args is an arbitrary term that is passed as the argument to Module:init/1 . If the supervisor bridge and the subsystem are successfully started, the function returns {ok,Pid} , where Pid is is the pid of the supervisor bridge. If there already exists a process with the specified SupBridgeName , the function returns {error,{already_started,Pid}} , where Pid is the pid of that process. If Module:init/1 returns ignore , this function returns ignore as well and the supervisor bridge terminates with reason normal . If Module:init/1 fails or returns an error tuple or an incorrect value, this function returns {error,Errorr} , where Error is a term with information about the error, and the supervisor bridge terminates with reason Error .","ref":"supervisor_bridge.html#start_link/2","title":"supervisor_bridge.start_link/2","type":"function"},{"doc":"","ref":"supervisor_bridge.html#start_link/3","title":"supervisor_bridge.start_link/3","type":"function"},{"doc":"Reason = shutdown | term() State = term() This function is called by the supervisor bridge when it is about to terminate. It is to be the opposite of Module:init/1 and stop the subsystem and do any necessary cleaning up. The return value is ignored. Reason is shutdown if the supervisor bridge is terminated by its supervisor. If the supervisor bridge terminates because a a linked process (apart from the main process of the subsystem) has terminated with reason Term , then Reason becomes Term . State is taken from the return value of Module:init/1 .","ref":"supervisor_bridge.html#c:terminate/2","title":"supervisor_bridge.terminate/2","type":"callback"},{"doc":"This module contains functions for sending system messages used by programs, and messages used for debugging purposes. Functions used for implementation of processes are also expected to understand system messages, such as debug messages and code change. These functions must be used to implement the use of system messages for a process; either directly, or through standard behaviors, such as gen_server . The default time-out is 5000 ms, unless otherwise specified. timeout defines the time to wait for the process to respond to a request. If the process does not respond, the function evaluates exit({timeout, {M, F, A}}) . The functions make references to a debug structure. The debug structure is a list of dbg_opt() , which is an internal data type used by function handle_system_msg/6 . No debugging is performed if it is an empty list. System Messages Processes that are not implemented as one of the standard behaviors must still understand system messages. The following three messages must be understood: Plain system messages. These are received as {system, From, Msg} . The content and meaning of this message are not interpreted by the receiving process module. When a system message is received, function handle_system_msg/6 is called to handle the request. Shutdown messages. If the process traps exits, it must be able to handle a shutdown request from its parent, the supervisor. The message {'EXIT', Parent, Reason} from the parent is an order to terminate. The process must terminate when this message is received, normally with the same Reason as Parent . If the modules used to implement the process change dynamically during runtime, the process must understand one more message. An example is the gen_event processes. The message is {_Label, {From, Ref}, get_modules} . The reply to this message is From ! {Ref, Modules} , where Modules is a list of the currently active modules in the process. This message is used by the release handler to find which processes that execute a certain module. The process can later be suspended and ordered to perform a code change for one of its modules. System Events When debugging a process with the functions of this module, the process generates system_events , which are then treated in the debug function. For example, trace formats the system events to the terminal. Four predefined system events are used when a process receives or sends a message. The process can also define its own system events. It is always up to the process itself to format these events.","ref":"sys.html","title":"sys","type":"module"},{"doc":"Tells the process to change code. The process must be suspended to handle this message. Argument Extra is reserved for each process to use as its own. Function Module:system_code_change/4 is called. OldVsn is the old version of the Module .","ref":"sys.html#change_code/4","title":"sys.change_code/4","type":"function"},{"doc":"","ref":"sys.html#change_code/5","title":"sys.change_code/5","type":"function"},{"doc":"Can be used by a process that initiates a debug structure from a list of options. The values of argument Opt are the same as for the corresponding functions.","ref":"sys.html#debug_options/1","title":"sys.debug_options/1","type":"function"},{"doc":"get_debug/3 is deprecated since it returns data of an internal type only useful for debugging. Gets the data associated with a debug option. Default is returned if Item is not found. Can be used by the process to retrieve debug data for printing before it terminates.","ref":"sys.html#get_debug/3","title":"sys.get_debug/3","type":"function"},{"doc":"Returns the logged system events in the debug structure, that is the last argument to handle_debug/4 .","ref":"sys.html#get_log/1","title":"sys.get_log/1","type":"function"},{"doc":"Gets the state of the process. These functions are intended only to help with debugging. They are provided for convenience, allowing developers to avoid having to create their own state extraction functions and also avoid having to interactively extract the state from the return values of get_status/1 or get_status/2 while debugging. The value of State varies for different types of processes, as follows: For a gen_server process, the returned State is the state of the callback module. For a gen_statem process, State is the tuple {CurrentState,CurrentData} . For a gen_event process, State is a list of tuples, where each tuple corresponds to an event handler registered in the process and contains {Module, Id, HandlerState} , as follows: Module The module name of the event handler. Id The ID of the handler (which is false if it was registered without an ID). HandlerState The state of the handler. If the callback module exports a function system_get_state/1 , it is called in the target process to get its state. Its argument is the same as the Misc value returned by get_status/1,2 , and function Module:system_get_state/1 is expected to extract the state of the callback module from it. Function system_get_state/1 must return {ok, State} , where State is the state of the callback module. If the callback module does not export a system_get_state/1 function, get_state/1,2 assumes that the Misc value is the state of the callback module and returns it directly instead. If the callback module's system_get_state/1 function crashes or throws an exception, the caller exits with error {callback_failed, {Module, system_get_state}, {Class, Reason}} , where Module is the name of the callback module and Class and Reason indicate details of the exception. Function system_get_state/1 is primarily useful for user-defined behaviors and modules that implement OTP special processes . The gen_server , gen_statem , and gen_event OTP behavior modules export this function, so callback modules for those behaviors need not to supply their own. For more information about a process, including its state, see get_status/1 and get_status/2 .","ref":"sys.html#get_state/1","title":"sys.get_state/1","type":"function"},{"doc":"","ref":"sys.html#get_state/2","title":"sys.get_state/2","type":"function"},{"doc":"Gets the status of the process. The value of Misc varies for different types of processes, for example: A gen_server process returns the state of the callback module. A gen_statem process returns information, such as its current state name and state data. A gen_event process returns information about each of its registered handlers. Callback modules for gen_server , gen_statem , and gen_event can also change the value of Misc by exporting a function format_status/2 , which contributes module-specific information. For details, see gen_server:format_status/2 , gen_statem:format_status/2 , and gen_event:format_status/2 .","ref":"sys.html#get_status/1","title":"sys.get_status/1","type":"function"},{"doc":"","ref":"sys.html#get_status/2","title":"sys.get_status/2","type":"function"},{"doc":"This function is called by a process when it generates a system event. FormFunc is a formatting function, called as FormFunc(Device, Event, Extra) to print the events, which is necessary if tracing is activated. Extra is any extra information that the process needs in the format function, for example, the process name.","ref":"sys.html#handle_debug/4","title":"sys.handle_debug/4","type":"function"},{"doc":"This function is used by a process module to take care of system messages. The process receives a {system, From, Msg} message and passes Msg and From to this function. This function never returns. It calls either of the following functions: Module:system_continue(Parent, NDebug, Misc) , where the process continues the execution. Module:system_terminate(Reason, Parent, Debug, Misc) , if the process is to terminate. Module must export the following: system_continue/3 system_terminate/4 system_code_change/4 system_get_state/1 system_replace_state/2 Argument Misc can be used to save internal data in a process, for example, its state. It is sent to Module:system_continue/3 or Module:system_terminate/4 .","ref":"sys.html#handle_system_msg/6","title":"sys.handle_system_msg/6","type":"function"},{"doc":"Enables installation of alternative debug functions. An example of such a function is a trigger, a function that waits for some special event and performs some action when the event is generated. For example, turning on low-level tracing. Func is called whenever a system event is generated. This function is to return done , or a new Func state. In the first case, the function is removed. It is also removed if the function fails. If one debug function should be installed more times, a unique FuncId must be specified for each installation.","ref":"sys.html#install/2","title":"sys.install/2","type":"function"},{"doc":"","ref":"sys.html#install/3","title":"sys.install/3","type":"function"},{"doc":"Turns the logging of system events on or off. If on, a maximum of N events are kept in the debug structure (default is 10). If Flag is get , a list of all logged events is returned. If Flag is print , the logged events are printed to standard_io . The events are formatted with a function that is defined by the process that generated the event (with a call to handle_debug/4 ) .","ref":"sys.html#log/2","title":"sys.log/2","type":"function"},{"doc":"","ref":"sys.html#log/3","title":"sys.log/3","type":"function"},{"doc":"Enables or disables the logging of all system events in text format to the file. The events are formatted with a function that is defined by the process that generated the event (with a call to handle_debug/4 ). The file is opened with encoding UTF-8.","ref":"sys.html#log_to_file/2","title":"sys.log_to_file/2","type":"function"},{"doc":"","ref":"sys.html#log_to_file/3","title":"sys.log_to_file/3","type":"function"},{"doc":"Turns off all debugging for the process. This includes functions that are installed explicitly with function install/2,3 , for example, triggers.","ref":"sys.html#no_debug/1","title":"sys.no_debug/1","type":"function"},{"doc":"","ref":"sys.html#no_debug/2","title":"sys.no_debug/2","type":"function"},{"doc":"Prints the logged system events in the debug structure, using FormFunc as defined when the event was generated by a call to handle_debug/4 .","ref":"sys.html#print_log/1","title":"sys.print_log/1","type":"function"},{"doc":"Removes an installed debug function from the process. Func or FuncId must be the same as previously installed.","ref":"sys.html#remove/2","title":"sys.remove/2","type":"function"},{"doc":"","ref":"sys.html#remove/3","title":"sys.remove/3","type":"function"},{"doc":"Replaces the state of the process, and returns the new state. These functions are intended only to help with debugging, and are not to be called from normal code. They are provided for convenience, allowing developers to avoid having to create their own custom state replacement functions. Function StateFun provides a new state for the process. Argument State and the NewState return value of StateFun vary for different types of processes as follows: For a gen_server process, State is the state of the callback module and NewState is a new instance of that state. For a gen_statem process, State is the tuple {CurrentState,CurrentData} , and NewState is a similar tuple, which can contain a new current state, new state data, or both. For a gen_event process, State is the tuple {Module, Id, HandlerState} as follows: Module The module name of the event handler. Id The ID of the handler (which is false if it was registered without an ID). HandlerState The state of the handler. NewState is a similar tuple where Module and Id are to have the same values as in State , but the value of HandlerState can be different. Returning a NewState , whose Module or Id values differ from those of State , leaves the state of the event handler unchanged. For a gen_event process, StateFun is called once for each event handler registered in the gen_event process. If a StateFun function decides not to effect any change in process state, then regardless of process type, it can return its State argument. If a StateFun function crashes or throws an exception, the original state of the process is unchanged for gen_server , and gen_statem processes. For gen_event processes, a crashing or failing StateFun function means that only the state of the particular event handler it was working on when it failed or crashed is unchanged; it can still succeed in changing the states of other event handlers registered in the same gen_event process. If the callback module exports a system_replace_state/2 function, it is called in the target process to replace its state using StateFun . Its two arguments are StateFun and Misc , where Misc is the same as the Misc value returned by get_status/1,2 . A system_replace_state/2 function is expected to return {ok, NewState, NewMisc} , where NewState is the new state of the callback module, obtained by calling StateFun , and NewMisc is a possibly new value used to replace the original Misc (required as Misc often contains the state of the callback module within it). If the callback module does not export a system_replace_state/2 function, replace_state/2,3 assumes that Misc is the state of the callback module, passes it to StateFun and uses the return value as both the new state and as the new value of Misc . If the callback module's function system_replace_state/2 crashes or throws an exception, the caller exits with error {callback_failed, {Module, system_replace_state}, {Class, Reason}} , where Module is the name of the callback module and Class and Reason indicate details of the exception. If the callback module does not provide a system_replace_state/2 function and StateFun crashes or throws an exception, the caller exits with error {callback_failed, StateFun, {Class, Reason}} . Function system_replace_state/2 is primarily useful for user-defined behaviors and modules that implement OTP special processes . The OTP behavior modules gen_server , gen_statem , and gen_event export this function, so callback modules for those behaviors need not to supply their own.","ref":"sys.html#replace_state/2","title":"sys.replace_state/2","type":"function"},{"doc":"","ref":"sys.html#replace_state/3","title":"sys.replace_state/3","type":"function"},{"doc":"Resumes a suspended process.","ref":"sys.html#resume/1","title":"sys.resume/1","type":"function"},{"doc":"","ref":"sys.html#resume/2","title":"sys.resume/2","type":"function"},{"doc":"Enables or disables the collection of statistics. If Flag is get , the statistical collection is returned.","ref":"sys.html#statistics/2","title":"sys.statistics/2","type":"function"},{"doc":"","ref":"sys.html#statistics/3","title":"sys.statistics/3","type":"function"},{"doc":"Suspends the process. When the process is suspended, it only responds to other system messages, but not other messages.","ref":"sys.html#suspend/1","title":"sys.suspend/1","type":"function"},{"doc":"","ref":"sys.html#suspend/2","title":"sys.suspend/2","type":"function"},{"doc":"Orders the process to terminate with the specified Reason . The termination is done asynchronously, so it is not guaranteed that the process is terminated when the function returns.","ref":"sys.html#terminate/2","title":"sys.terminate/2","type":"function"},{"doc":"","ref":"sys.html#terminate/3","title":"sys.terminate/3","type":"function"},{"doc":"Prints all system events on standard_io . The events are formatted with a function that is defined by the process that generated the event (with a call to handle_debug/4 ).","ref":"sys.html#trace/2","title":"sys.trace/2","type":"function"},{"doc":"","ref":"sys.html#trace/3","title":"sys.trace/3","type":"function"},{"doc":"","ref":"sys.html#t:dbg_fun/0","title":"sys.dbg_fun/0","type":"type"},{"doc":"See the introduction of this manual page.","ref":"sys.html#t:dbg_opt/0","title":"sys.dbg_opt/0","type":"opaque"},{"doc":"","ref":"sys.html#t:debug_option/0","title":"sys.debug_option/0","type":"type"},{"doc":"","ref":"sys.html#t:format_fun/0","title":"sys.format_fun/0","type":"type"},{"doc":"","ref":"sys.html#t:name/0","title":"sys.name/0","type":"type"},{"doc":"{in,Msg} Is produced by gen_server and gen_event when the message Msg arrives. {in,Msg,State} Is produced by gen_statem when the message Msg arrives in state State . For gen_statem the Msg term is an {EventType,EventContent} tuple. {out,Msg,To} Is produced by gen_statem when the reply Msg is sent back to To by returning a {reply,To,Msg} action from the callback module. To is of the same type as the first argument to gen_statem:reply/2 . {out,Msg,To,State} Is produced by gen_server when the reply Msg is sent back to To by returning a {reply,...} tuple from the callback module. To is of the same type as the first argument to gen_server:reply/2 . State is the new server state. {noreply,State} Is produced by gen_server when a {noreply,...} tuple is returned from the callback module. State is the new server state. {continue,Continuation} Is produced by gen_server when a {continue,Continuation} tuple is returned from the callback module. {code_change,Event,State} Is produced by gen_statem when the message Event arrives in state State as the first event after a code change. Event is an {EventType,EventContent} tuple. {postpone,Event,State,NextState} Is produced by gen_statem when the message Event is postponed in state State . NextState is the new state. Event is an {EventType,EventContent} tuple. {consume,Event,State,NextState} Is produced by gen_statem when the message Event is consumed in state State . NextState is the new state. Event is an {EventType,EventContent} tuple. {start_timer,Action,State} Is produced by gen_statem when the action Action starts a timer in state State . {insert_timeout,Event,State} Is produced by gen_statem when a timeout zero action inserts event Event in state State . Event is an {EventType,EventContent} tuple. {enter,State} Is produced by gen_statem when the first state State is entered. {terminate,Reason,State} Is produced by gen_statem when it terminates with reason Reason in state State .","ref":"sys.html#t:system_event/0","title":"sys.system_event/0","type":"type"},{"doc":"This module provides useful functions related to time. Unless otherwise stated, time is always measured in milliseconds . All timer functions return immediately, regardless of work done by another process. Successful evaluations of the timer functions give return values containing a timer reference, denoted TRef . By using cancel/1 , the returned reference can be used to cancel any requested action. A TRef is an Erlang term, which contents must not be changed. The time-outs are not exact, but are at least as long as requested. Creating timers using erlang:send_after/3 and erlang:start_timer/3 is more efficient than using the timers provided by this module. However, the timer module has been improved in OTP 25, making it more efficient and less susceptible to being overloaded. See the Timer Module section in the Efficiency Guide. Examples Example 1 The following example shows how to print &quot;Hello World!&quot; in 5 seconds: 1 &gt; timer : apply_after ( 5000 , io , format , [ &quot; ~n Hello World! ~n &quot; , [ ] ] ) . { ok , TRef } Hello World ! Example 2 The following example shows a process performing a certain action, and if this action is not completed within a certain limit, the process is killed: Pid = spawn(mod, fun, [foo, bar]), %% If pid is not finished in 10 seconds, kill him {ok, R} = timer:kill_after(timer:seconds(10), Pid), ... %% We change our mind... timer:cancel(R), ... Notes A timer can always be removed by calling cancel/1 . An interval timer, that is, a timer created by evaluating any of the functions apply_interval/4 , send_interval/3 , and send_interval/2 is linked to the process to which the timer performs its task. A one-shot timer, that is, a timer created by evaluating any of the functions apply_after/4 , send_after/3 , send_after/2 , exit_after/3 , exit_after/2 , kill_after/2 , and kill_after/1 is not linked to any process. Hence, such a timer is removed only when it reaches its time-out, or if it is explicitly removed by a call to cancel/1 .","ref":"timer.html","title":"timer","type":"module"},{"doc":"Evaluates apply(Module, Function, Arguments) after Time milliseconds. Returns {ok, TRef} or {error, Reason} .","ref":"timer.html#apply_after/4","title":"timer.apply_after/4","type":"function"},{"doc":"Evaluates apply(Module, Function, Arguments) repeatedly at intervals of Time . Returns {ok, TRef} or {error, Reason} .","ref":"timer.html#apply_interval/4","title":"timer.apply_interval/4","type":"function"},{"doc":"Cancels a previously requested time-out. TRef is a unique timer reference returned by the related timer function. Returns {ok, cancel} , or {error, Reason} when TRef is not a timer reference.","ref":"timer.html#cancel/1","title":"timer.cancel/1","type":"function"},{"doc":"exit_after/2 is the same as exit_after(Time, self(), Reason1) . exit_after/3 sends an exit signal with reason Reason1 to Target , which can be a local process identifier or an atom of a registered name. Returns {ok, TRef} or {error, Reason2} .","ref":"timer.html#exit_after/2","title":"timer.exit_after/2","type":"function"},{"doc":"","ref":"timer.html#exit_after/3","title":"timer.exit_after/3","type":"function"},{"doc":"Returns the number of milliseconds in Hours + Minutes + Seconds .","ref":"timer.html#hms/3","title":"timer.hms/3","type":"function"},{"doc":"Returns the number of milliseconds in Hours .","ref":"timer.html#hours/1","title":"timer.hours/1","type":"function"},{"doc":"kill_after/1 is the same as exit_after(Time, self(), kill) . kill_after/2 is the same as exit_after(Time, Target, kill) .","ref":"timer.html#kill_after/1","title":"timer.kill_after/1","type":"function"},{"doc":"","ref":"timer.html#kill_after/2","title":"timer.kill_after/2","type":"function"},{"doc":"Returns the number of milliseconds in Minutes .","ref":"timer.html#minutes/1","title":"timer.minutes/1","type":"function"},{"doc":"Calculates the time difference Tdiff = T2 - T1 in microseconds , where T1 and T2 are time-stamp tuples on the same format as returned from erlang:timestamp/0 or os:timestamp/0 .","ref":"timer.html#now_diff/2","title":"timer.now_diff/2","type":"function"},{"doc":"Returns the number of milliseconds in Seconds .","ref":"timer.html#seconds/1","title":"timer.seconds/1","type":"function"},{"doc":"send_after/3 Evaluates Destination ! Message after Time milliseconds. ( Destination can be a remote or local process identifier, an atom of a registered name or a tuple {RegName, Node} for a registered name at another node.) Returns {ok, TRef} or {error, Reason} . See also the Timer Module section in the Efficiency Guide. send_after/2 Same as send_after(Time, self(), Message) .","ref":"timer.html#send_after/2","title":"timer.send_after/2","type":"function"},{"doc":"","ref":"timer.html#send_after/3","title":"timer.send_after/3","type":"function"},{"doc":"send_interval/3 Evaluates Destination ! Message repeatedly after Time milliseconds. ( Destination can be a remote or local process identifier, an atom of a registered name or a tuple {RegName, Node} for a registered name at another node.) Returns {ok, TRef} or {error, Reason} . send_interval/2 Same as send_interval(Time, self(), Message) .","ref":"timer.html#send_interval/2","title":"timer.send_interval/2","type":"function"},{"doc":"","ref":"timer.html#send_interval/3","title":"timer.send_interval/3","type":"function"},{"doc":"Suspends the process calling this function for Time milliseconds and then returns ok , or suspends the process forever if Time is the atom infinity . Naturally, this function does not return immediately. Before OTP 25, timer:sleep/1 did not accept integer timeout values greater than 16#ffffffff , that is, 2^32-1 . Since OTP 25, arbitrarily high integer values are accepted.","ref":"timer.html#sleep/1","title":"timer.sleep/1","type":"function"},{"doc":"Starts the timer server. Normally, the server does not need to be started explicitly. It is started dynamically if it is needed. This is useful during development, but in a target system the server is to be started explicitly. Use configuration parameters for Kernel for this.","ref":"timer.html#start/0","title":"timer.start/0","type":"function"},{"doc":"tc/3 Evaluates apply(Module, Function, Arguments) and measures the elapsed real time as reported by erlang:monotonic_time/0 . Returns {Time, Value} , where Time is the elapsed real time in microseconds , and Value is what is returned from the apply. tc/2 Evaluates apply(Fun, Arguments) . Otherwise the same as tc/3 . tc/1 Evaluates Fun() . Otherwise the same as tc/2 .","ref":"timer.html#tc/1","title":"timer.tc/1","type":"function"},{"doc":"","ref":"timer.html#tc/2","title":"timer.tc/2","type":"function"},{"doc":"","ref":"timer.html#tc/3","title":"timer.tc/3","type":"function"},{"doc":"Time in milliseconds.","ref":"timer.html#t:time/0","title":"timer.time/0","type":"type"},{"doc":"A timer reference.","ref":"timer.html#t:tref/0","title":"timer.tref/0","type":"opaque"},{"doc":"This module contains functions for converting between different character representations. It converts between ISO Latin-1 characters and Unicode characters, but it can also convert between different Unicode encodings (like UTF-8, UTF-16, and UTF-32). The default Unicode encoding in Erlang is in binaries UTF-8, which is also the format in which built-in functions and libraries in OTP expect to find binary Unicode data. In lists, Unicode data is encoded as integers, each integer representing one character and encoded simply as the Unicode code point for the character. Other Unicode encodings than integers representing code points or UTF-8 in binaries are referred to as &quot;external encodings&quot;. The ISO Latin-1 encoding is in binaries and lists referred to as latin1-encoding. It is recommended to only use external encodings for communication with external entities where this is required. When working inside the Erlang/OTP environment, it is recommended to keep binaries in UTF-8 when representing Unicode characters. ISO Latin-1 encoding is supported both for backward compatibility and for communication with external entities not supporting Unicode character sets. Programs should always operate on a normalized form and compare canonical-equivalent Unicode characters as equal. All characters should thus be normalized to one form once on the system borders. One of the following functions can convert characters to their normalized forms characters_to_nfc_list/1 , characters_to_nfc_binary/1 , characters_to_nfd_list/1 or characters_to_nfd_binary/1 . For general text characters_to_nfc_list/1 or characters_to_nfc_binary/1 is preferred, and for identifiers one of the compatibility normalization functions, such as characters_to_nfkc_list/1 , is preferred for security reasons. The normalization functions where introduced in OTP 20. Additional information on normalization can be found in the Unicode FAQ .","ref":"unicode.html","title":"unicode","type":"module"},{"doc":"Checks for a UTF Byte Order Mark (BOM) in the beginning of a binary. If the supplied binary Bin begins with a valid BOM for either UTF-8, UTF-16, or UTF-32, the function returns the encoding identified along with the BOM length in bytes. If no BOM is found, the function returns {latin1,0} .","ref":"unicode.html#bom_to_encoding/1","title":"unicode.bom_to_encoding/1","type":"function"},{"doc":"Same as characters_to_binary(Data, unicode, unicode) .","ref":"unicode.html#characters_to_binary/1","title":"unicode.characters_to_binary/1","type":"function"},{"doc":"Same as characters_to_binary(Data, InEncoding, unicode) .","ref":"unicode.html#characters_to_binary/2","title":"unicode.characters_to_binary/2","type":"function"},{"doc":"Behaves as characters_to_list/2 , but produces a binary instead of a Unicode list. InEncoding defines how input is to be interpreted if binaries are present in Data OutEncoding defines in what format output is to be generated. Options: unicode An alias for utf8 , as this is the preferred encoding for Unicode characters in binaries. utf16 An alias for {utf16,big} . utf32 An alias for {utf32,big} . The atoms big and little denote big- or little-endian encoding. Errors and exceptions occur as in characters_to_list/2 , but the second element in tuple error or incomplete is a binary() and not a list() .","ref":"unicode.html#characters_to_binary/3","title":"unicode.characters_to_binary/3","type":"function"},{"doc":"Same as characters_to_list(Data, unicode) .","ref":"unicode.html#characters_to_list/1","title":"unicode.characters_to_list/1","type":"function"},{"doc":"Converts a possibly deep list of integers and binaries into a list of integers representing Unicode characters. The binaries in the input can have characters encoded as one of the following: ISO Latin-1 (0-255, one character per byte). Here, case parameter InEncoding is to be specified as latin1 . One of the UTF-encodings, which is specified as parameter InEncoding . Note that integers in the list always represent code points regardless of InEncoding passed. If InEncoding latin1 is passed, only code points &lt; 256 are allowed; otherwise, all valid unicode code points are allowed. If InEncoding is latin1 , parameter Data corresponds to the iodata() type, but for unicode , parameter Data can contain integers &gt; 255 (Unicode characters beyond the ISO Latin-1 range), which makes it invalid as iodata() . The purpose of the function is mainly to convert combinations of Unicode characters into a pure Unicode string in list representation for further processing. For writing the data to an external entity, the reverse function characters_to_binary/3 comes in handy. Option unicode is an alias for utf8 , as this is the preferred encoding for Unicode characters in binaries. utf16 is an alias for {utf16,big} and utf32 is an alias for {utf32,big} . The atoms big and little denote big- or little-endian encoding. If the data cannot be converted, either because of illegal Unicode/ISO Latin-1 characters in the list, or because of invalid UTF encoding in any binaries, an error tuple is returned. The error tuple contains the tag error , a list representing the characters that could be converted before the error occurred and a representation of the characters including and after the offending integer/bytes. The last part is mostly for debugging, as it still constitutes a possibly deep or mixed list, or both, not necessarily of the same depth as the original data. The error occurs when traversing the list and whatever is left to decode is returned &quot;as is&quot;. However, if the input Data is a pure binary, the third part of the error tuple is guaranteed to be a binary as well. Errors occur for the following reasons: Integers out of range. If InEncoding is latin1 , an error occurs whenever an integer &gt; 255 is found in the lists. If InEncoding is of a Unicode type, an error occurs whenever either of the following is found: An integer &gt; 16#10FFFF (the maximum Unicode character) An integer in the range 16#D800 to 16#DFFF (invalid range reserved for UTF-16 surrogate pairs) Incorrect UTF encoding. If InEncoding is one of the UTF types, the bytes in any binaries must be valid in that encoding. Errors can occur for various reasons, including the following: &quot;Pure&quot; decoding errors (like the upper bits of the bytes being wrong). The bytes are decoded to a too large number. The bytes are decoded to a code point in the invalid Unicode range. Encoding is &quot;overlong&quot;, meaning that a number should have been encoded in fewer bytes. The case of a truncated UTF is handled specially, see the paragraph about incomplete binaries below. If InEncoding is latin1 , binaries are always valid as long as they contain whole bytes, as each byte falls into the valid ISO Latin-1 range. A special type of error is when no actual invalid integers or bytes are found, but a trailing binary() consists of too few bytes to decode the last character. This error can occur if bytes are read from a file in chunks or if binaries in other ways are split on non-UTF character boundaries. An incomplete tuple is then returned instead of the error tuple. It consists of the same parts as the error tuple, but the tag is incomplete instead of error and the last element is always guaranteed to be a binary consisting of the first part of a (so far) valid UTF character. If one UTF character is split over two consecutive binaries in the Data , the conversion succeeds. This means that a character can be decoded from a range of binaries as long as the whole range is specified as input without errors occurring. Example: decode_data ( Data ) -&gt; case unicode : characters_to_list ( Data , unicode ) of { incomplete , Encoded , Rest } -&gt; More = get_some_more_data ( ) , Encoded ++ decode_data ( [ Rest , More ] ) ; { error , Encoded , Rest } -&gt; handle_error ( Encoded , Rest ) ; List -&gt; List end . However, bit strings that are not whole bytes are not allowed, so a UTF character must be split along 8-bit boundaries to ever be decoded. A badarg exception is thrown for the following cases: Any parameters are of the wrong type. The list structure is invalid (a number as tail). The binaries do not contain whole bytes (bit strings).","ref":"unicode.html#characters_to_list/2","title":"unicode.characters_to_list/2","type":"function"},{"doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of canonical equivalent Composed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is an utf8 encoded binary. 4 &gt; unicode : characters_to_nfc_binary ( [ &lt;&lt; &quot;abc..a&quot; &gt;&gt; , [ 778 ] , $a , [ 776 ] , $o , [ 776 ] ] ) . &lt;&lt; &quot;abc..åäö&quot; / utf8 &gt;&gt;","ref":"unicode.html#characters_to_nfc_binary/1","title":"unicode.characters_to_nfc_binary/1","type":"function"},{"doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of canonical equivalent Composed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is a list of characters. 3 &gt; unicode : characters_to_nfc_list ( [ &lt;&lt; &quot;abc..a&quot; &gt;&gt; , [ 778 ] , $a , [ 776 ] , $o , [ 776 ] ] ) . &quot;abc..åäö&quot;","ref":"unicode.html#characters_to_nfc_list/1","title":"unicode.characters_to_nfc_list/1","type":"function"},{"doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of canonical equivalent Decomposed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is an utf8 encoded binary. 2 &gt; unicode : characters_to_nfd_binary ( &quot;abc..åäö&quot; ) . &lt;&lt; 97 , 98 , 99 , 46 , 46 , 97 , 204 , 138 , 97 , 204 , 136 , 111 , 204 , 136 &gt;&gt;","ref":"unicode.html#characters_to_nfd_binary/1","title":"unicode.characters_to_nfd_binary/1","type":"function"},{"doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of canonical equivalent Decomposed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is a list of characters. 1 &gt; unicode : characters_to_nfd_list ( &quot;abc..åäö&quot; ) . [ 97 , 98 , 99 , 46 , 46 , 97 , 778 , 97 , 776 , 111 , 776 ]","ref":"unicode.html#characters_to_nfd_list/1","title":"unicode.characters_to_nfd_list/1","type":"function"},{"doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of compatibly equivalent Composed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is an utf8 encoded binary. 4 &gt; unicode : characters_to_nfkc_binary ( [ &lt;&lt; &quot;abc..a&quot; &gt;&gt; , [ 778 ] , $a , [ 776 ] , $o , [ 776 ] , [ 65299 , 65298 ] ] ) . &lt;&lt; &quot;abc..åäö32&quot; / utf8 &gt;&gt;","ref":"unicode.html#characters_to_nfkc_binary/1","title":"unicode.characters_to_nfkc_binary/1","type":"function"},{"doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of compatibly equivalent Composed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is a list of characters. 3 &gt; unicode : characters_to_nfkc_list ( [ &lt;&lt; &quot;abc..a&quot; &gt;&gt; , [ 778 ] , $a , [ 776 ] , $o , [ 776 ] , [ 65299 , 65298 ] ] ) . &quot;abc..åäö32&quot;","ref":"unicode.html#characters_to_nfkc_list/1","title":"unicode.characters_to_nfkc_list/1","type":"function"},{"doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of compatibly equivalent Decomposed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is an utf8 encoded binary. 2 &gt; unicode : characters_to_nfkd_binary ( [ &quot;abc..åäö&quot; , [ 65299 , 65298 ] ] ) . &lt;&lt; 97 , 98 , 99 , 46 , 46 , 97 , 204 , 138 , 97 , 204 , 136 , 111 , 204 , 136 , 51 , 50 &gt;&gt;","ref":"unicode.html#characters_to_nfkd_binary/1","title":"unicode.characters_to_nfkd_binary/1","type":"function"},{"doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of compatibly equivalent Decomposed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is a list of characters. 1 &gt; unicode : characters_to_nfkd_list ( [ &quot;abc..åäö&quot; , [ 65299 , 65298 ] ] ) . [ 97 , 98 , 99 , 46 , 46 , 97 , 778 , 97 , 776 , 111 , 776 , 51 , 50 ]","ref":"unicode.html#characters_to_nfkd_list/1","title":"unicode.characters_to_nfkd_list/1","type":"function"},{"doc":"Creates a UTF Byte Order Mark (BOM) as a binary from the supplied InEncoding . The BOM is, if supported at all, expected to be placed first in UTF encoded files or messages. The function returns &lt;&lt;&gt;&gt; for latin1 encoding, as there is no BOM for ISO Latin-1. Notice that the BOM for UTF-8 is seldom used, and it is really not a byte order mark. There are obviously no byte order issues with UTF-8, so the BOM is only there to differentiate UTF-8 encoding from other UTF formats.","ref":"unicode.html#encoding_to_bom/1","title":"unicode.encoding_to_bom/1","type":"function"},{"doc":"","ref":"unicode.html#t:chardata/0","title":"unicode.chardata/0","type":"type"},{"doc":"","ref":"unicode.html#t:charlist/0","title":"unicode.charlist/0","type":"type"},{"doc":"","ref":"unicode.html#t:encoding/0","title":"unicode.encoding/0","type":"type"},{"doc":"","ref":"unicode.html#t:endian/0","title":"unicode.endian/0","type":"type"},{"doc":"","ref":"unicode.html#t:external_chardata/0","title":"unicode.external_chardata/0","type":"type"},{"doc":"","ref":"unicode.html#t:external_charlist/0","title":"unicode.external_charlist/0","type":"type"},{"doc":"A binary() with characters coded in a user-specified Unicode encoding other than UTF-8 (that is, UTF-16 or UTF-32).","ref":"unicode.html#t:external_unicode_binary/0","title":"unicode.external_unicode_binary/0","type":"type"},{"doc":"A binary() with characters coded in ISO Latin-1.","ref":"unicode.html#t:latin1_binary/0","title":"unicode.latin1_binary/0","type":"type"},{"doc":"An integer() representing a valid ISO Latin-1 character (0-255).","ref":"unicode.html#t:latin1_char/0","title":"unicode.latin1_char/0","type":"type"},{"doc":"Same as iodata() .","ref":"unicode.html#t:latin1_chardata/0","title":"unicode.latin1_chardata/0","type":"type"},{"doc":"Same as iolist() .","ref":"unicode.html#t:latin1_charlist/0","title":"unicode.latin1_charlist/0","type":"type"},{"doc":"A binary() with characters encoded in the UTF-8 coding standard.","ref":"unicode.html#t:unicode_binary/0","title":"unicode.unicode_binary/0","type":"type"},{"doc":"This module contains functions for parsing and handling URIs ( RFC 3986 ) and form-urlencoded query strings ( HTML 5.2 ). Parsing and serializing non-UTF-8 form-urlencoded query strings are also supported ( HTML 5.0 ). A URI is an identifier consisting of a sequence of characters matching the syntax rule named URI in RFC 3986 . The generic URI syntax consists of a hierarchical sequence of components referred to as the scheme, authority, path, query, and fragment: URI = scheme &quot;:&quot; hier - part [ &quot;?&quot; query ] [ &quot;#&quot; fragment ] hier - part = &quot;//&quot; authority path - abempty / path - absolute / path - rootless / path - empty scheme = ALPHA * ( ALPHA / DIGIT / &quot;+&quot; / &quot;-&quot; / &quot;.&quot; ) authority = [ userinfo &quot;@&quot; ] host [ &quot;:&quot; port ] userinfo = * ( unreserved / pct - encoded / sub - delims / &quot;:&quot; ) reserved = gen - delims / sub - delims gen - delims = &quot;:&quot; / &quot;/&quot; / &quot;?&quot; / &quot;#&quot; / &quot;[&quot; / &quot;]&quot; / &quot;@&quot; sub - delims = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;&#39;&quot; / &quot;(&quot; / &quot;)&quot; / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot; unreserved = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; The interpretation of a URI depends only on the characters used and not on how those characters are represented in a network protocol. The functions implemented by this module cover the following use cases: Parsing URIs into its components and returing a map parse/1 Recomposing a map of URI components into a URI string recompose/1 Changing inbound binary and percent-encoding of URIs transcode/2 Transforming URIs into a normalized form normalize/1 normalize/2 Composing form-urlencoded query strings from a list of key-value pairs compose_query/1 compose_query/2 Dissecting form-urlencoded query strings into a list of key-value pairs dissect_query/1 Decoding percent-encoded triplets percent_decode/1 There are four different encodings present during the handling of URIs: Inbound binary encoding in binaries Inbound percent-encoding in lists and binaries Outbound binary encoding in binaries Outbound percent-encoding in lists and binaries Functions with uri_string() argument accept lists, binaries and mixed lists (lists with binary elements) as input type. All of the functions but transcode/2 expects input as lists of unicode codepoints, UTF-8 encoded binaries and UTF-8 percent-encoded URI parts (&quot;%C3%B6&quot; corresponds to the unicode character &quot;ö&quot;). Unless otherwise specified the return value type and encoding are the same as the input type and encoding. That is, binary input returns binary output, list input returns a list output but mixed input returns list output. In case of lists there is only percent-encoding. In binaries, however, both binary encoding and percent-encoding shall be considered. transcode/2 provides the means to convert between the supported encodings, it takes a uri_string() and a list of options specifying inbound and outbound encodings. RFC 3986 does not mandate any specific character encoding and it is usually defined by the protocol or surrounding text. This library takes the same assumption, binary and percent-encoding are handled as one configuration unit, they cannot be set to different values.","ref":"uri_string.html","title":"uri_string","type":"module"},{"doc":"This is a utility function meant to be used in the shell for printing the allowed characters in each major URI component, and also in the most important characters sets. Please note that this function does not replace the ABNF rules defined by the standards, these character sets are derived directly from those aformentioned rules. For more information see the Uniform Resource Identifiers chapter in stdlib's Users Guide.","ref":"uri_string.html#allowed_characters/0","title":"uri_string.allowed_characters/0","type":"function"},{"doc":"Composes a form-urlencoded QueryString based on a QueryList , a list of non-percent-encoded key-value pairs. Form-urlencoding is defined in section 4.10.21.6 of the HTML 5.2 specification and in section 4.10.22.6 of the HTML 5.0 specification for non-UTF-8 encodings. See also the opposite operation dissect_query/1 . Example: 1 &gt; uri_string : compose_query ( [ { &quot;foo bar&quot; , &quot;1&quot; } , { &quot;city&quot; , &quot;örebro&quot; } ] ) . &quot;foo+bar=1&amp;city=%C3%B6rebro&quot; 2 &gt; uri_string : compose_query ( [ { &lt;&lt; &quot;foo bar&quot; &gt;&gt; , &lt;&lt; &quot;1&quot; &gt;&gt; } , 2 &gt; { &lt;&lt; &quot;city&quot; &gt;&gt; , &lt;&lt; &quot;örebro&quot; / utf8 &gt;&gt; } ] ) . &lt;&lt; &quot;foo+bar=1&amp;city=%C3%B6rebro&quot; &gt;&gt;","ref":"uri_string.html#compose_query/1","title":"uri_string.compose_query/1","type":"function"},{"doc":"Same as compose_query/1 but with an additional Options parameter, that controls the encoding (&quot;charset&quot;) used by the encoding algorithm. There are two supported encodings: utf8 (or unicode ) and latin1 . Each character in the entry's name and value that cannot be expressed using the selected character encoding, is replaced by a string consisting of a U+0026 AMPERSAND character (&amp;), a &quot;#&quot; (U+0023) character, one or more ASCII digits representing the Unicode code point of the character in base ten, and finally a &quot;;&quot; (U+003B) character. Bytes that are out of the range 0x2A, 0x2D, 0x2E, 0x30 to 0x39, 0x41 to 0x5A, 0x5F, 0x61 to 0x7A, are percent-encoded (U+0025 PERCENT SIGN character (%) followed by uppercase ASCII hex digits representing the hexadecimal value of the byte). See also the opposite operation dissect_query/1 . Example: 1 &gt; uri_string : compose_query ( [ { &quot;foo bar&quot; , &quot;1&quot; } , { &quot;city&quot; , &quot;örebro&quot; } ] , 1 &gt; [ { encoding , latin1 } ] ) . &quot;foo+bar=1&amp;city=%F6rebro&quot; 2 &gt; uri_string : compose_query ( [ { &lt;&lt; &quot;foo bar&quot; &gt;&gt; , &lt;&lt; &quot;1&quot; &gt;&gt; } , 2 &gt; { &lt;&lt; &quot;city&quot; &gt;&gt; , &lt;&lt; &quot;東京&quot; / utf8 &gt;&gt; } ] , [ { encoding , latin1 } ] ) . &lt;&lt; &quot;foo+bar=1&amp;city=%26%2326481%3B%26%2320140%3B&quot; &gt;&gt;","ref":"uri_string.html#compose_query/2","title":"uri_string.compose_query/2","type":"function"},{"doc":"Dissects an urlencoded QueryString and returns a QueryList , a list of non-percent-encoded key-value pairs. Form-urlencoding is defined in section 4.10.21.6 of the HTML 5.2 specification and in section 4.10.22.6 of the HTML 5.0 specification for non-UTF-8 encodings. See also the opposite operation compose_query/1 . Example: 1 &gt; uri_string : dissect_query ( &quot;foo+bar=1&amp;city=%C3%B6rebro&quot; ) . [ { &quot;foo bar&quot; , &quot;1&quot; } , { &quot;city&quot; , &quot;örebro&quot; } ] 2 &gt; uri_string : dissect_query ( &lt;&lt; &quot;foo+bar=1&amp;city=%26%2326481%3B%26%2320140%3B&quot; &gt;&gt; ) . [ { &lt;&lt; &quot;foo bar&quot; &gt;&gt; , &lt;&lt; &quot;1&quot; &gt;&gt; } , { &lt;&lt; &quot;city&quot; &gt;&gt; , &lt;&lt; 230 , 157 , 177 , 228 , 186 , 172 &gt;&gt; } ]","ref":"uri_string.html#dissect_query/1","title":"uri_string.dissect_query/1","type":"function"},{"doc":"Transforms an URI into a normalized form using Syntax-Based Normalization as defined by RFC 3986 . This function implements case normalization, percent-encoding normalization, path segment normalization and scheme based normalization for HTTP(S) with basic support for FTP, SSH, SFTP and TFTP. Example: 1 &gt; uri_string : normalize ( &quot;/a/b/c/./../../g&quot; ) . &quot;/a/g&quot; 2 &gt; uri_string : normalize ( &lt;&lt; &quot;mid/content=5/../6&quot; &gt;&gt; ) . &lt;&lt; &quot;mid/6&quot; &gt;&gt; 3 &gt; uri_string : normalize ( &quot;http://localhost:80&quot; ) . &quot;http://localhost/&quot; 4 &gt; uri_string : normalize ( \#{ scheme =&gt; &quot;http&quot; , port =&gt; 80 , path =&gt; &quot;/a/b/c/./../../g&quot; , 4 &gt; host =&gt; &quot;localhost-örebro&quot; } ) . &quot;http://localhost-%C3%B6rebro/a/g&quot;","ref":"uri_string.html#normalize/1","title":"uri_string.normalize/1","type":"function"},{"doc":"Same as normalize/1 but with an additional Options parameter, that controls whether the normalized URI shall be returned as an uri_map(). There is one supported option: return_map . Example: 1 &gt; uri_string : normalize ( &quot;/a/b/c/./../../g&quot; , [ return_map ] ) . \#{ path =&gt; &quot;/a/g&quot; } 2 &gt; uri_string : normalize ( &lt;&lt; &quot;mid/content=5/../6&quot; &gt;&gt; , [ return_map ] ) . \#{ path =&gt; &lt;&lt; &quot;mid/6&quot; &gt;&gt; } 3 &gt; uri_string : normalize ( &quot;http://localhost:80&quot; , [ return_map ] ) . \#{ scheme =&gt; &quot;http&quot; , path =&gt; &quot;/&quot; , host =&gt; &quot;localhost&quot; } 4 &gt; uri_string : normalize ( \#{ scheme =&gt; &quot;http&quot; , port =&gt; 80 , path =&gt; &quot;/a/b/c/./../../g&quot; , 4 &gt; host =&gt; &quot;localhost-örebro&quot; } , [ return_map ] ) . \#{ scheme =&gt; &quot;http&quot; , path =&gt; &quot;/a/g&quot; , host =&gt; &quot;localhost-örebro&quot; }","ref":"uri_string.html#normalize/2","title":"uri_string.normalize/2","type":"function"},{"doc":"Parses an RFC 3986 compliant uri_string() into a uri_map() , that holds the parsed components of the URI . If parsing fails, an error tuple is returned. See also the opposite operation recompose/1 . Example: 1 &gt; uri_string : parse ( &quot;foo://user@example.com:8042/over/there?name=ferret#nose&quot; ) . \#{ fragment =&gt; &quot;nose&quot; , host =&gt; &quot;example.com&quot; , path =&gt; &quot;/over/there&quot; , port =&gt; 8042 , query =&gt; &quot;name=ferret&quot; , scheme =&gt; foo , userinfo =&gt; &quot;user&quot; } 2 &gt; uri_string : parse ( &lt;&lt; &quot;foo://user@example.com:8042/over/there?name=ferret&quot; &gt;&gt; ) . \#{ host =&gt; &lt;&lt; &quot;example.com&quot; &gt;&gt; , path =&gt; &lt;&lt; &quot;/over/there&quot; &gt;&gt; , port =&gt; 8042 , query =&gt; &lt;&lt; &quot;name=ferret&quot; &gt;&gt; , scheme =&gt; &lt;&lt; &quot;foo&quot; &gt;&gt; , userinfo =&gt; &lt;&lt; &quot;user&quot; &gt;&gt; }","ref":"uri_string.html#parse/1","title":"uri_string.parse/1","type":"function"},{"doc":"Decodes all percent-encoded triplets in the input that can be both a uri_string() and a uri_map() . Note, that this function performs raw decoding and it shall be used on already parsed URI components. Applying this function directly on a standard URI can effectively change it. If the input encoding is not UTF-8, an error tuple is returned. Example: 1 &gt; uri_string : percent_decode ( \#{ host =&gt; &quot;localhost-%C3%B6rebro&quot; , path =&gt; [ ] , 1 &gt; scheme =&gt; &quot;http&quot; } ) . \#{ host =&gt; &quot;localhost-örebro&quot; , path =&gt; [ ] , scheme =&gt; &quot;http&quot; } 2 &gt; uri_string : percent_decode ( &lt;&lt; &quot;%C3%B6rebro&quot; &gt;&gt; ) . &lt;&lt; &quot;örebro&quot; / utf8 &gt;&gt; Using uri_string:percent_decode/1 directly on a URI is not safe. This example shows, that after each consecutive application of the function the resulting URI will be changed. None of these URIs refer to the same resource. 3 &gt; uri_string : percent_decode ( &lt;&lt; &quot;http://local%252Fhost/path&quot; &gt;&gt; ) . &lt;&lt; &quot;http://local%2Fhost/path&quot; &gt;&gt; 4 &gt; uri_string : percent_decode ( &lt;&lt; &quot;http://local%2Fhost/path&quot; &gt;&gt; ) . &lt;&lt; &quot;http://local/host/path&quot; &gt;&gt;","ref":"uri_string.html#percent_decode/1","title":"uri_string.percent_decode/1","type":"function"},{"doc":"Creates an RFC 3986 compliant URIString (percent-encoded), based on the components of URIMap . If the URIMap is invalid, an error tuple is returned. See also the opposite operation parse/1 . Example: 1 &gt; URIMap = \#{ fragment =&gt; &quot;nose&quot; , host =&gt; &quot;example.com&quot; , path =&gt; &quot;/over/there&quot; , 1 &gt; port =&gt; 8042 , query =&gt; &quot;name=ferret&quot; , scheme =&gt; &quot;foo&quot; , userinfo =&gt; &quot;user&quot; } . \#{ fragment =&gt; &quot;nose&quot; , host =&gt; &quot;example.com&quot; , path =&gt; &quot;/over/there&quot; , port =&gt; 8042 , query =&gt; &quot;name=ferret&quot; , scheme =&gt; &quot;foo&quot; , userinfo =&gt; &quot;user&quot; } 2 &gt; uri_string : recompose ( URIMap ) . &quot;foo://example.com:8042/over/there?name=ferret#nose&quot;","ref":"uri_string.html#recompose/1","title":"uri_string.recompose/1","type":"function"},{"doc":"Convert a RefURI reference that might be relative to a given base URI into the parsed components of the reference's target, which can then be recomposed to form the target URI. Example: 1 &gt; uri_string : resolve ( &quot;/abs/ol/ute&quot; , &quot;http://localhost/a/b/c?q&quot; ) . &quot;http://localhost/abs/ol/ute&quot; 2 &gt; uri_string : resolve ( &quot;../relative&quot; , &quot;http://localhost/a/b/c?q&quot; ) . &quot;http://localhost/a/relative&quot; 3 &gt; uri_string : resolve ( &quot;http://localhost/full&quot; , &quot;http://localhost/a/b/c?q&quot; ) . &quot;http://localhost/full&quot; 4 &gt; uri_string : resolve ( \#{ path =&gt; &quot;path&quot; , query =&gt; &quot;xyz&quot; } , &quot;http://localhost/a/b/c?q&quot; ) . &quot;http://localhost/a/b/path?xyz&quot;","ref":"uri_string.html#resolve/2","title":"uri_string.resolve/2","type":"function"},{"doc":"Same as resolve/2 but with an additional Options parameter, that controls whether the target URI shall be returned as an uri_map(). There is one supported option: return_map . Example: 1 &gt; uri_string : resolve ( &quot;/abs/ol/ute&quot; , &quot;http://localhost/a/b/c?q&quot; , [ return_map ] ) . \#{ host =&gt; &quot;localhost&quot; , path =&gt; &quot;/abs/ol/ute&quot; , scheme =&gt; &quot;http&quot; } 2 &gt; uri_string : resolve ( \#{ path =&gt; &quot;/abs/ol/ute&quot; } , \#{ scheme =&gt; &quot;http&quot; , 2 &gt; host =&gt; &quot;localhost&quot; , path =&gt; &quot;/a/b/c?q&quot; } , [ return_map ] ) . \#{ host =&gt; &quot;localhost&quot; , path =&gt; &quot;/abs/ol/ute&quot; , scheme =&gt; &quot;http&quot; }","ref":"uri_string.html#resolve/3","title":"uri_string.resolve/3","type":"function"},{"doc":"Transcodes an RFC 3986 compliant URIString , where Options is a list of tagged tuples, specifying the inbound ( in_encoding ) and outbound ( out_encoding ) encodings. in_encoding and out_encoding specifies both binary encoding and percent-encoding for the input and output data. Mixed encoding, where binary encoding is not the same as percent-encoding, is not supported. If an argument is invalid, an error tuple is returned. Example: 1 &gt; uri_string : transcode ( &lt;&lt; &quot;foo%00%00%00%F6bar&quot; / utf32 &gt;&gt; , 1 &gt; [ { in_encoding , utf32 } , { out_encoding , utf8 } ] ) . &lt;&lt; &quot;foo%C3%B6bar&quot; / utf8 &gt;&gt; 2 &gt; uri_string : transcode ( &quot;foo%F6bar&quot; , [ { in_encoding , latin1 } , 2 &gt; { out_encoding , utf8 } ] ) . &quot;foo%C3%B6bar&quot;","ref":"uri_string.html#transcode/2","title":"uri_string.transcode/2","type":"function"},{"doc":"Error tuple indicating the type of error. Possible values of the second component: invalid_character invalid_encoding invalid_input invalid_map invalid_percent_encoding invalid_scheme invalid_uri invalid_utf8 missing_value The third component is a term providing additional information about the cause of the error.","ref":"uri_string.html#t:error/0","title":"uri_string.error/0","type":"type"},{"doc":"Map holding the main components of a URI.","ref":"uri_string.html#t:uri_map/0","title":"uri_string.uri_map/0","type":"type"},{"doc":"List of unicode codepoints, a UTF-8 encoded binary, or a mix of the two, representing an RFC 3986 compliant URI ( percent-encoded form ). A URI is a sequence of characters from a very limited set: the letters of the basic Latin alphabet, digits, and a few special characters.","ref":"uri_string.html#t:uri_string/0","title":"uri_string.uri_string/0","type":"type"},{"doc":"This module provides read and write access to the registry on Windows. It is essentially a port driver wrapped around the Win32 API calls for accessing the registry. The registry is a hierarchical database, used to store various system and software information in Windows. It contains installation data, and is updated by installers and system programs. The Erlang installer updates the registry by adding data that Erlang needs. The registry contains keys and values. Keys are like the directories in a file system, they form a hierarchy. Values are like files, they have a name and a value, and also a type. Paths to keys are left to right, with subkeys to the right and backslash between keys. (Remember that backslashes must be doubled in Erlang strings.) Case is preserved but not significant. For example, &quot;\\\\hkey_local_machine\\\\software\\\\Ericsson\\\\Erlang\\\\5.0&quot; is the key for the installation data for the latest Erlang release. There are six entry points in the Windows registry, top-level keys. They can be abbreviated in this module as follows: Abbreviation Registry key == == == == == == == == == == == == hkcr HKEY_CLASSES_ROOT current_user HKEY_CURRENT_USER hkcu HKEY_CURRENT_USER local_machine HKEY_LOCAL_MACHINE hklm HKEY_LOCAL_MACHINE users HKEY_USERS hku HKEY_USERS current_config HKEY_CURRENT_CONFIG hkcc HKEY_CURRENT_CONFIG dyn_data HKEY_DYN_DATA hkdd HKEY_DYN_DATA The key above can be written as &quot;\\\\hklm\\\\software\\\\ericsson\\\\erlang\\\\5.0&quot; . This module uses a current key. It works much like the current directory. From the current key, values can be fetched, subkeys can be listed, and so on. Under a key, any number of named values can be stored. They have names, types, and data. win32reg supports storing of the following types: REG_DWORD , which is an integer REG_SZ , which is a string REG_BINARY , which is a binary Other types can be read, and are returned as binaries. There is also a &quot;default&quot; value, which has the empty string as name. It is read and written with the atom default instead of the name. Some registry values are stored as strings with references to environment variables, for example, %SystemRoot%Windows . SystemRoot is an environment variable, and is to be replaced with its value. Function expand/1 is provided so that environment variables surrounded by % can be expanded to their values. For more information on the Windows registry, see consult the Win32 Programmer's Reference. See Also erl_posix_msg , The Windows 95 Registry (book from O'Reilly), Win32 Programmer's Reference (from Microsoft)","ref":"win32reg.html","title":"win32reg","type":"module"},{"doc":"Changes the current key to another key. Works like cd . The key can be specified as a relative path or as an absolute path, starting with \\.","ref":"win32reg.html#change_key/2","title":"win32reg.change_key/2","type":"function"},{"doc":"Creates a key, or just changes to it, if it is already there. Works like a combination of mkdir and cd . Calls the Win32 API function RegCreateKeyEx() . The registry must have been opened in write mode.","ref":"win32reg.html#change_key_create/2","title":"win32reg.change_key_create/2","type":"function"},{"doc":"Closes the registry. After that, the RegHandle cannot be used.","ref":"win32reg.html#close/1","title":"win32reg.close/1","type":"function"},{"doc":"Returns the path to the current key. This is the equivalent of pwd . Notice that the current key is stored in the driver, and can be invalid (for example, if the key has been removed).","ref":"win32reg.html#current_key/1","title":"win32reg.current_key/1","type":"function"},{"doc":"Deletes the current key, if it is valid. Calls the Win32 API function RegDeleteKey() . Notice that this call does not change the current key (unlike change_key_create/2 ). This means that after the call, the current key is invalid.","ref":"win32reg.html#delete_key/1","title":"win32reg.delete_key/1","type":"function"},{"doc":"Deletes a named value on the current key. The atom default is used for the default value. The registry must have been opened in write mode.","ref":"win32reg.html#delete_value/2","title":"win32reg.delete_value/2","type":"function"},{"doc":"Expands a string containing environment variables between percent characters. Anything between two % is taken for an environment variable, and is replaced by the value. Two consecutive % are replaced by one % . A variable name that is not in the environment results in an error.","ref":"win32reg.html#expand/1","title":"win32reg.expand/1","type":"function"},{"doc":"Converts a POSIX error code to a string (by calling erl_posix_msg:message/1 ).","ref":"win32reg.html#format_error/1","title":"win32reg.format_error/1","type":"function"},{"doc":"Opens the registry for reading or writing. The current key is the root ( HKEY_CLASSES_ROOT ). Flag read in the mode list can be omitted. Use change_key/2 with an absolute path after open .","ref":"win32reg.html#open/1","title":"win32reg.open/1","type":"function"},{"doc":"Sets the named (or default) value to value . Calls the Win32 API function RegSetValueEx() . The value can be of three types, and the corresponding registry type is used. The supported types are the following: REG_DWORD for integers REG_SZ for strings REG_BINARY for binaries Other types cannot be added or changed. The registry must have been opened in write mode.","ref":"win32reg.html#set_value/3","title":"win32reg.set_value/3","type":"function"},{"doc":"Returns a list of subkeys to the current key. Calls the Win32 API function EnumRegKeysEx() . Avoid calling this on the root keys, as it can be slow.","ref":"win32reg.html#sub_keys/1","title":"win32reg.sub_keys/1","type":"function"},{"doc":"Retrieves the named value (or default) on the current key. Registry values of type REG_SZ are returned as strings. Type REG_DWORD values are returned as integers. All other types are returned as binaries.","ref":"win32reg.html#value/2","title":"win32reg.value/2","type":"function"},{"doc":"Retrieves a list of all values on the current key. The values have types corresponding to the registry types, see value/2 . Calls the Win32 API function EnumRegValuesEx() .","ref":"win32reg.html#values/1","title":"win32reg.values/1","type":"function"},{"doc":"","ref":"win32reg.html#t:name/0","title":"win32reg.name/0","type":"type"},{"doc":"As returned by open/1 .","ref":"win32reg.html#t:reg_handle/0","title":"win32reg.reg_handle/0","type":"opaque"},{"doc":"","ref":"win32reg.html#t:value/0","title":"win32reg.value/0","type":"type"},{"doc":"This module archives and extracts files to and from a zip archive. The zip format is specified by the &quot;ZIP Appnote.txt&quot; file, available on the PKWARE web site www.pkware.com . The zip module supports zip archive versions up to 6.1. However, password-protection and Zip64 are not supported. By convention, the name of a zip file is to end with .zip . To abide to the convention, add .zip to the filename. To create zip archives, use function zip/2 or zip/3 . They are also available as create/2,3 , to resemble the erl_tar module. To extract files from a zip archive, use function unzip/1 or unzip/2 . They are also available as extract/1,2 , to resemble the erl_tar module. To fold a function over all files in a zip archive, use function foldl/3 . To return a list of the files in a zip archive, use function list_dir/1 or list_dir/2 . They are also available as table/1,2 , to resemble the erl_tar module. To print a list of files to the Erlang shell, use function t/1 or tt/1 . Sometimes it is desirable to open a zip archive, and to unzip files from it file by file, without having to reopen the archive. This can be done by functions zip_open/1,2 , zip_get/1,2 , zip_list_dir/1 , and zip_close/1 . Limitations Zip64 archives are not supported. Password-protected and encrypted archives are not supported. Only the DEFLATE (zlib-compression) and the STORE (uncompressed data) zip methods are supported. The archive size is limited to 2 GB (32 bits). Comments for individual files are not supported when creating zip archives. The zip archive comment for the whole zip archive is supported. Changing a zip archive is not supported. To add or remove a file from an archive, the whole archive must be recreated.","ref":"zip.html","title":"zip","type":"module"},{"doc":"Creates a zip archive containing the files specified in FileList . create/2 and create/3 are provided as synonyms to resemble module erl_tar . FileList is a list of files, with paths relative to the current directory, which are stored with this path in the archive. Files can also be specified with data in binaries to create an archive directly from data. Files are compressed using the DEFLATE compression, as described in the &quot;Appnote.txt&quot; file. However, files are stored without compression if they are already compressed. zip/2 and zip/3 check the file extension to determine if the file is to be stored without compression. Files with the following extensions are not compressed: .Z , .zip , .zoo , .arc , .lzh , .arj . It is possible to override the default behavior and control what types of files that are to be compressed by using options {compress, What} and {uncompress, What} . It is also possible to use many compress and uncompress options. To trigger file compression, its extension must match with the compress condition and must not match the uncompress condition. For example, if compress is set to [&quot;gif&quot;, &quot;jpg&quot;] and uncompress is set to [&quot;jpg&quot;] , only files with extension &quot;gif&quot; are compressed. Options: cooked By default, this function opens the zip file in mode raw , which is faster but does not allow a remote (Erlang) file server to be used. Adding cooked to the mode list overrides the default and opens the zip file without the raw option. The same applies for the files added. verbose Prints an informational message about each added file. memory The output is not to a file, but instead as a tuple {FileName, binary()} . The binary is a full zip archive with header and can be extracted with, for example, unzip/2 . {comment, Comment} Adds a comment to the zip archive. {cwd, CWD} Uses the specified directory as current work directory ( cwd ). This is prepended to filenames when adding them, although not in the zip archive (acting like file:set_cwd/1 in Kernel, but without changing the global cwd property.). {compress, What} Controls what types of files to be compressed. Defaults to all . The following values of What are allowed: all All files are compressed (as long as they pass the uncompress condition). [Extension] Only files with exactly these extensions are compressed. {add,[Extension]} Adds these extensions to the list of compress extensions. {del,[Extension]} Deletes these extensions from the list of compress extensions. {uncompress, What} Controls what types of files to be uncompressed. Defaults to [&quot;.Z&quot;, &quot;.zip&quot;, &quot;.zoo&quot;, &quot;.arc&quot;, &quot;.lzh&quot;, &quot;.arj&quot;] . The following values of What are allowed: all No files are compressed. [Extension] Files with these extensions are uncompressed. {add,[Extension]} Adds these extensions to the list of uncompress extensions. {del,[Extension]} Deletes these extensions from the list of uncompress extensions.","ref":"zip.html#create/2","title":"zip.create/2","type":"function"},{"doc":"","ref":"zip.html#create/3","title":"zip.create/3","type":"function"},{"doc":"unzip/1 extracts all files from a zip archive. unzip/2 provides options to extract some files, and more. extract/1 and extract/2 are provided as synonyms to resemble module erl_tar . If argument Archive is specified as a binary, the contents of the binary is assumed to be a zip archive, otherwise a filename. Options: {file_list, FileList} By default, all files are extracted from the zip archive. With option {file_list, FileList} , function unzip/2 only extracts the files whose names are included in FileList . The full paths, including the names of all subdirectories within the zip archive, must be specified. cooked By default, this function opens the zip file in raw mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding cooked to the mode list overrides the default and opens the zip file without option raw . The same applies for the files extracted. keep_old_files By default, all files with the same name as files in the zip archive are overwritten. With option keep_old_files set, function unzip/2 does not overwrite existing files. Notice that even with option memory specified, which means that no files are overwritten, existing files are excluded from the result. verbose Prints an informational message for each extracted file. memory Instead of extracting to the current directory, the result is given as a list of tuples {Filename, Binary} , where Binary is a binary containing the extracted data of file Filename in the zip archive. {cwd, CWD} Uses the specified directory as current directory. It is prepended to filenames when extracting them from the zip archive. (Acting like file:set_cwd/1 in Kernel, but without changing the global cwd property.)","ref":"zip.html#extract/1","title":"zip.extract/1","type":"function"},{"doc":"","ref":"zip.html#extract/2","title":"zip.extract/2","type":"function"},{"doc":"Calls Fun(FileInArchive, GetInfo , GetBin, AccIn) on successive files in the Archive , starting with AccIn == Acc0 . FileInArchive is the name that the file has in the archive. GetInfo is a fun that returns information about the file. GetBin returns the file contents. Both GetInfo and GetBin must be called within the Fun . Their behavior is undefined if they are called outside the context of Fun . The Fun must return a new accumulator, which is passed to the next call. foldl/3 returns the final accumulator value. Acc0 is returned if the archive is empty. It is not necessary to iterate over all files in the archive. The iteration can be ended prematurely in a controlled manner by throwing an exception. Example: &gt; Name = &quot;dummy.zip&quot; . &quot;dummy.zip&quot; &gt; { ok , { Name , Bin } } = zip : create ( Name , [ { &quot;foo&quot; , &lt;&lt; &quot;FOO&quot; &gt;&gt; } , { &quot;bar&quot; , &lt;&lt; &quot;BAR&quot; &gt;&gt; } ] , [ memory ] ) . { ok , { &quot;dummy.zip&quot; , &lt;&lt; 80 , 75 , 3 , 4 , 20 , 0 , 0 , 0 , 0 , 0 , 74 , 152 , 97 , 60 , 171 , 39 , 212 , 26 , 3 , 0 , 0 , 0 , 3 , 0 , 0 , . . . &gt;&gt; } } &gt; { ok , FileSpec } = zip : foldl ( fun ( N , I , B , Acc ) -&gt; [ { N , B ( ) , I ( ) } | Acc ] end , [ ] , { Name , Bin } ) . { ok , [ { &quot;bar&quot; , &lt;&lt; &quot;BAR&quot; &gt;&gt; , { file_info , 3 , regular , read_write , { { 2010 , 3 , 1 } , { 19 , 2 , 10 } } , { { 2010 , 3 , 1 } , { 19 , 2 , 10 } } , { { 2010 , 3 , 1 } , { 19 , 2 , 10 } } , 54 , 1 , 0 , 0 , 0 , 0 , 0 } } , { &quot;foo&quot; , &lt;&lt; &quot;FOO&quot; &gt;&gt; , { file_info , 3 , regular , read_write , { { 2010 , 3 , 1 } , { 19 , 2 , 10 } } , { { 2010 , 3 , 1 } , { 19 , 2 , 10 } } , { { 2010 , 3 , 1 } , { 19 , 2 , 10 } } , 54 , 1 , 0 , 0 , 0 , 0 , 0 } } ] } &gt; { ok , { Name , Bin } } = zip : create ( Name , lists : reverse ( FileSpec ) , [ memory ] ) . { ok , { &quot;dummy.zip&quot; , &lt;&lt; 80 , 75 , 3 , 4 , 20 , 0 , 0 , 0 , 0 , 0 , 74 , 152 , 97 , 60 , 171 , 39 , 212 , 26 , 3 , 0 , 0 , 0 , 3 , 0 , 0 , . . . &gt;&gt; } } &gt; catch zip : foldl ( fun ( &quot;foo&quot; , _ , B , _ ) -&gt; throw ( B ( ) ) ; ( _ , _ , _ , Acc ) -&gt; Acc end , [ ] , { Name , Bin } ) . &lt;&lt; &quot;FOO&quot; &gt;&gt;","ref":"zip.html#foldl/3","title":"zip.foldl/3","type":"function"},{"doc":"list_dir/1 retrieves all filenames in the zip archive Archive . list_dir/2 provides options. table/1 and table/2 are provided as synonyms to resemble the erl_tar module. The result value is the tuple {ok, List} , where List contains the zip archive comment as the first element. One option is available: cooked By default, this function opens the zip file in raw mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding cooked to the mode list overrides the default and opens the zip file without option raw .","ref":"zip.html#list_dir/1","title":"zip.list_dir/1","type":"function"},{"doc":"","ref":"zip.html#list_dir/2","title":"zip.list_dir/2","type":"function"},{"doc":"Prints all filenames in the zip archive Archive to the Erlang shell. (Similar to tar t .)","ref":"zip.html#t/1","title":"zip.t/1","type":"function"},{"doc":"","ref":"zip.html#table/1","title":"zip.table/1","type":"function"},{"doc":"","ref":"zip.html#table/2","title":"zip.table/2","type":"function"},{"doc":"Prints filenames and information about all files in the zip archive Archive to the Erlang shell. (Similar to tar tv .)","ref":"zip.html#tt/1","title":"zip.tt/1","type":"function"},{"doc":"","ref":"zip.html#unzip/1","title":"zip.unzip/1","type":"function"},{"doc":"","ref":"zip.html#unzip/2","title":"zip.unzip/2","type":"function"},{"doc":"","ref":"zip.html#zip/2","title":"zip.zip/2","type":"function"},{"doc":"","ref":"zip.html#zip/3","title":"zip.zip/3","type":"function"},{"doc":"Closes a zip archive, previously opened with zip_open/1,2 . All resources are closed, and the handle is not to be used after closing.","ref":"zip.html#zip_close/1","title":"zip.zip_close/1","type":"function"},{"doc":"Extracts one or all files from an open archive. The files are unzipped to memory or to file, depending on the options specified to function zip_open/1,2 when opening the archive.","ref":"zip.html#zip_get/1","title":"zip.zip_get/1","type":"function"},{"doc":"","ref":"zip.html#zip_get/2","title":"zip.zip_get/2","type":"function"},{"doc":"Returns the file list of an open zip archive. The first returned element is the zip archive comment.","ref":"zip.html#zip_list_dir/1","title":"zip.zip_list_dir/1","type":"function"},{"doc":"Opens a zip archive, and reads and saves its directory. This means that later reading files from the archive is faster than unzipping files one at a time with unzip/1,2 . The archive must be closed with zip_close/1 . The ZipHandle is closed if the process that originally opened the archive dies.","ref":"zip.html#zip_open/1","title":"zip.zip_open/1","type":"function"},{"doc":"","ref":"zip.html#zip_open/2","title":"zip.zip_open/2","type":"function"},{"doc":"These options are described in create/3 .","ref":"zip.html#t:create_option/0","title":"zip.create_option/0","type":"type"},{"doc":"","ref":"zip.html#t:extension/0","title":"zip.extension/0","type":"type"},{"doc":"","ref":"zip.html#t:extension_spec/0","title":"zip.extension_spec/0","type":"type"},{"doc":"The name of a zip file.","ref":"zip.html#t:filename/0","title":"zip.filename/0","type":"type"},{"doc":"As returned by zip_open/2 .","ref":"zip.html#t:handle/0","title":"zip.handle/0","type":"opaque"},{"doc":"The record zip_comment only contains the archive comment for a zip archive.","ref":"zip.html#t:zip_comment/0","title":"zip.zip_comment/0","type":"type"},{"doc":"The record zip_file contains the following fields: name The filename info File information as in file:read_file_info/1 in Kernel comment The comment for the file in the zip archive offset The file offset in the zip archive (used internally) comp_size The size of the compressed file (the size of the uncompressed file is found in info )","ref":"zip.html#t:zip_file/0","title":"zip.zip_file/0","type":"type"}]