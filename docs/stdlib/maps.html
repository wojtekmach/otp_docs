<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.25.1">
    <meta name="project" content="stdlib v3.15.2">

    <title>maps â€” stdlib v3.15.2</title>
    <link rel="stylesheet" href="dist/erlang-951161c89561e05735a5.css" />

    <script src="dist/sidebar_items-2e60d1dd15.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-f97730d45ef67f3e6188.js"></script>


  </head>
  <body data-type="modules">
    <script>

      try {
        if (localStorage.getItem('night-mode') === 'true') {
          document.body.classList.add('night-mode');
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <span class="icon-search" aria-hidden="true" title="Submit search"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <span class="icon-cross" aria-hidden="true" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="api-reference.html" class="sidebar-projectName">
stdlib
      </a>
      <strong class="sidebar-projectVersion">
        v3.15.2
      </strong>
    </div>

  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list-link" href="#full-list">Pages</a></li>

      <li><a id="modules-list-link" href="#full-list">Modules</a></li>


  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

      <h1>
maps <small class="app-vsn">(stdlib v3.15.2)</small>

      </h1>


        <section id="moduledoc">
<p>This module contains functions for maps processing. The Efficiency Guide contains a chapter that describes how to use maps efficiently.</p>
        </section>


        <section id="summary" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#summary">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
            Summary
          </h1>

  <div class="summary-types summary">
    <h2>
      <a href="#types">Types</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:iterator/0">-type iterator() :: term().</a>

  </div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:iterator/2">-type iterator(Arg1,Arg2) :: term().</a>

  </div>

    <div class="summary-synopsis"><p>An iterator representing the associations in a map with keys of type <code>Key</code> and values of type <code>Value</code>.</p></div>

</div>

  </div>

  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#filter/2">filter/2</a>

  </div>

    <div class="summary-synopsis"><p>Returns a map <code>Map</code> for which predicate <code>Pred</code> holds true in <code>MapOrIter</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#filtermap/2">filtermap/2</a>

  </div>

    <div class="summary-synopsis"><p>Returns a map <code>Map</code> that is the result of calling <code>Fun(Key, Value1)</code> for every <code>Key</code> to value <code>Value1</code> association in <code>MapOrIter</code> in any order.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#find/2">find/2</a>

  </div>

    <div class="summary-synopsis"><p>Returns a tuple <code>{ok, Value}</code>, where <code>Value</code> is the value associated with <code>Key</code>, or <code>error</code> if no value is associated with <code>Key</code> in <code>Map</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#fold/3">fold/3</a>

  </div>

    <div class="summary-synopsis"><p>Calls <code>F(Key, Value, AccIn)</code> for every <code>Key</code> to value <code>Value</code> association in <code>MapOrIter</code> in any order. Function <code>fun F/3</code> must return a new accumulator, which is passed to the next successive call. This function returns the final value of the accumulator. The initial accumulator value <code>Init</code> is returned if the map is empty.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#foreach/2">foreach/2</a>

  </div>

    <div class="summary-synopsis"><p>Calls <code>fun F(Key, Value)</code> for every <code>Key</code> to value <code>Value</code> association in <code>MapOrIter</code> in any order.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#from_keys/2">from_keys/2</a>

  </div>

    <div class="summary-synopsis"><p>Takes a list of keys and a value and builds a map where all keys point to the same value. The key can be in any order, and keys and value can be of any term.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#from_list/1">from_list/1</a>

  </div>

    <div class="summary-synopsis"><p>Takes a list of key-value tuples elements and builds a map. The associations can be in any order, and both keys and values in the association can be of any term. If the same key appears more than once, the latter (right-most) value is used and the previous values are ignored.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#get/2">get/2</a>

  </div>

    <div class="summary-synopsis"><p>Returns value <code>Value</code> associated with <code>Key</code> if <code>Map</code> contains <code>Key</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#get/3">get/3</a>

  </div>

    <div class="summary-synopsis"><p>Returns value <code>Value</code> associated with <code>Key</code> if <code>Map</code> contains <code>Key</code>. If no value is associated with <code>Key</code>, <code>Default</code> is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#intersect/2">intersect/2</a>

  </div>

    <div class="summary-synopsis"><p>Intersects two maps into a single map <code>Map3</code>. If a key exists in both maps, the value in <code>Map1</code> is superseded by the value in <code>Map2</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#intersect_with/3">intersect_with/3</a>

  </div>

    <div class="summary-synopsis"><p>Intersects two maps into a single map <code>Map3</code>. If a key exists in both maps, the value in <code>Map1</code> is combined with the value in <code>Map2</code> by the <code>Combiner</code> fun. When <code>Combiner</code> is applied the key that exists in both maps is the first parameter, the value from <code>Map1</code> is the second parameter, and the value from <code>Map2</code> is the third parameter.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_key/2">is_key/2</a>

  </div>

    <div class="summary-synopsis"><p>Returns <code>true</code> if map <code>Map</code> contains <code>Key</code> and returns <code>false</code> if it does not contain the <code>Key</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#iterator/1">iterator/1</a>

  </div>

    <div class="summary-synopsis"><p>Returns a map iterator <code>Iterator</code> that can be used by <a href="#next/1"><code>maps:next/1</code></a> to traverse the key-value associations in a map. When iterating over a map, the memory usage is guaranteed to be bounded no matter the size of the map.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#keys/1">keys/1</a>

  </div>

    <div class="summary-synopsis"><p>Returns a complete list of keys, in any order, which resides within <code>Map</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map/2">map/2</a>

  </div>

    <div class="summary-synopsis"><p>Produces a new map <code>Map</code> by calling function <code>fun F(Key, Value1)</code> for every <code>Key</code> to value <code>Value1</code> association in <code>MapOrIter</code> in any order. Function <code>fun Fun/2</code> must return value <code>Value2</code> to be associated with key <code>Key</code> for the new map <code>Map</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#merge/2">merge/2</a>

  </div>

    <div class="summary-synopsis"><p>Merges two maps into a single map <code>Map3</code>. If two keys exist in both maps, the value in <code>Map1</code> is superseded by the value in <code>Map2</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#merge_with/3">merge_with/3</a>

  </div>

    <div class="summary-synopsis"><p>Merges two maps into a single map <code>Map3</code>. If a key exists in both maps, the value in <code>Map1</code> is combined with the value in <code>Map2</code> by the <code>Combiner</code> fun. When <code>Combiner</code> is applied the key that exists in both maps is the first parameter, the value from <code>Map1</code> is the second parameter, and the value from <code>Map2</code> is the third parameter.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#new/0">new/0</a>

  </div>

    <div class="summary-synopsis"><p>Returns a new empty map.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#next/1">next/1</a>

  </div>

    <div class="summary-synopsis"><p>Returns the next key-value association in <code>Iterator</code> and a new iterator for the remaining associations in the iterator.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#put/3">put/3</a>

  </div>

    <div class="summary-synopsis"><p>Associates <code>Key</code> with value <code>Value</code> and inserts the association into map <code>Map2</code>. If key <code>Key</code> already exists in map <code>Map1</code>, the old associated value is replaced by value <code>Value</code>. The function returns a new map <code>Map2</code> containing the new association and the old associations in <code>Map1</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#remove/2">remove/2</a>

  </div>

    <div class="summary-synopsis"><p>Removes the <code>Key</code>, if it exists, and its associated value from <code>Map1</code> and returns a new map <code>Map2</code> without key <code>Key</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#size/1">size/1</a>

  </div>

    <div class="summary-synopsis"><p>Returns the number of key-value associations in <code>Map</code>. This operation occurs in constant time.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#take/2">take/2</a>

  </div>

    <div class="summary-synopsis"><p>The function removes the <code>Key</code>, if it exists, and its associated value from <code>Map1</code> and returns a tuple with the removed <code>Value</code> and the new map <code>Map2</code> without key <code>Key</code>. If the key does not exist <code>error</code> is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#to_list/1">to_list/1</a>

  </div>

    <div class="summary-synopsis"><p>Returns a list of pairs representing the key-value associations of <code>Map</code>, where the pairs <code>[{K1,V1}, ..., {Kn,Vn}]</code> are returned in arbitrary order.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#update/3">update/3</a>

  </div>

    <div class="summary-synopsis"><p>If <code>Key</code> exists in <code>Map1</code>, the old associated value is replaced by value <code>Value</code>. The function returns a new map <code>Map2</code> containing the new associated value.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#update_with/3">update_with/3</a>

  </div>

    <div class="summary-synopsis"><p>Update a value in a <code>Map1</code> associated with <code>Key</code> by calling <code>Fun</code> on the old value to get a new value. An exception <code>{badkey,Key}</code> is generated if <code>Key</code> is not present in the map.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#update_with/4">update_with/4</a>

  </div>

    <div class="summary-synopsis"><p>Update a value in a <code>Map1</code> associated with <code>Key</code> by calling <code>Fun</code> on the old value to get a new value. If <code>Key</code> is not present in <code>Map1</code> then <code>Init</code> will be associated with <code>Key</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#values/1">values/1</a>

  </div>

    <div class="summary-synopsis"><p>Returns a complete list of values, in arbitrary order, contained in map <code>Map</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#with/2">with/2</a>

  </div>

    <div class="summary-synopsis"><p>Returns a new map <code>Map2</code> with the keys <code>K1</code> through <code>Kn</code> and their associated values from map <code>Map1</code>. Any key in <code>Ks</code> that does not exist in <code>Map1</code> is ignored.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#without/2">without/2</a>

  </div>

    <div class="summary-synopsis"><p>Returns a new map <code>Map2</code> without keys <code>K1</code> through <code>Kn</code> and their associated values from map <code>Map1</code>. Any key in <code>Ks</code> that does not exist in <code>Map1</code> is ignored</p></div>

</div>

  </div>

        </section>


        <section id="types" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#types">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Types
          </h1>
          <div class="types-list">
<section class="detail" id="t:iterator/0">

  <div class="detail-header">
    <a href="#t:iterator/0" class="detail-link" title="Link to this type">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this type</span>
    </a>
    <h1 class="signature">-type iterator() :: term().</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>iterator() :: <a href="#t:iterator/2">iterator</a>(term(), term()).</pre>

      </div>


  </section>
</section>
<section class="detail" id="t:iterator/2">

  <div class="detail-header">
    <a href="#t:iterator/2" class="detail-link" title="Link to this opaque">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this opaque</span>
    </a>
    <h1 class="signature">-type iterator(Arg1,Arg2) :: term().</h1>


      <span class="note">(opaque)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>iterator(Key, Value)</pre>

      </div>

<p>An iterator representing the associations in a map with keys of type <code>Key</code> and values of type <code>Value</code>.</p><p>Created using <a href="#iterator/1"><code>maps:iterator/1</code></a>.</p><p>Consumed by <a href="#next/1"><code>maps:next/1</code></a>, <a href="#filter/2"><code>maps:filter/2</code></a>, <a href="#fold/3"><code>maps:fold/3</code></a> and <a href="#map/2"><code>maps:map/2</code></a>.</p>
  </section>
</section>

          </div>
        </section>

        <section id="functions" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#functions">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Functions
          </h1>
          <div class="functions-list">
<section class="detail" id="filter/2">

  <div class="detail-header">
    <a href="#filter/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">filter/2</h1>


      <span class="note">(since OTP 18.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>filter(Pred, MapOrIter) -> Map
          when
              Pred :: fun((Key, Value) -> boolean()),
              MapOrIter :: #{Key => Value} | <a href="#t:iterator/2">iterator</a>(Key, Value),
              Map :: #{Key => Value}.</pre>

      </div>

<p>Returns a map <code>Map</code> for which predicate <code>Pred</code> holds true in <code>MapOrIter</code>.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>MapOrIter</code> is not a map or valid iterator, or with <code>badarg</code> if <code>Pred</code> is not a function of arity 2.</p><p><em>Example:</em></p><pre><code type="none">&gt; M = #{a =&gt; 2, b =&gt; 3, c=&gt; 4, &quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 4},
  Pred = fun(K,V) -&gt; is_atom(K) andalso (V rem 2) =:= 0 end,
  maps:filter(Pred,M).
#{a =&gt; 2,c =&gt; 4}</code></pre>
  </section>
</section>
<section class="detail" id="filtermap/2">

  <div class="detail-header">
    <a href="#filtermap/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">filtermap/2</h1>


      <span class="note">(since OTP 24.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>filtermap(Fun, MapOrIter) -> Map
             when
                 Fun :: fun((Key, Value1) -> boolean() | {true, Value2}),
                 MapOrIter :: #{Key => Value1} | <a href="#t:iterator/2">iterator</a>(Key, Value1),
                 Map :: #{Key => Value1 | Value2}.</pre>

      </div>

<p>Returns a map <code>Map</code> that is the result of calling <code>Fun(Key, Value1)</code> for every <code>Key</code> to value <code>Value1</code> association in <code>MapOrIter</code> in any order.</p><p>If <code>Fun(Key, Value1)</code> returns <code>true</code>, the association is copied to the result map. If it returns <code>false</code>, the association is not copied. If it returns <code>{true, NewValue}</code>, the value for <code>Key</code> is replaced with <code>NewValue</code>at this position is replaced in the result map.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>MapOrIter</code> is not a map or valid iterator, or with <code>badarg</code> if <code>Fun</code> is not a function of arity 3.</p><p><em>Example:</em></p><pre><code type="none">&gt; Fun = fun(K,V) when is_atom(K) -&gt; {true, V*2}; (_,V) -&gt; (V rem 2) =:= 0 end,
  Map = #{k1 =&gt; 1, &quot;k2&quot; =&gt; 2, &quot;k3&quot; =&gt; 3},
  maps:filtermap(Fun,Map).
#{k1 =&gt; 2,&quot;k2&quot; =&gt; 2}</code></pre>
  </section>
</section>
<section class="detail" id="find/2">

  <div class="detail-header">
    <a href="#find/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">find/2</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>find(Key, Map) -> {ok, Value} | error when Map :: #{Key => Value, _ => _}.</pre>

      </div>

<p>Returns a tuple <code>{ok, Value}</code>, where <code>Value</code> is the value associated with <code>Key</code>, or <code>error</code> if no value is associated with <code>Key</code> in <code>Map</code>.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>Map</code> is not a map.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map = #{&quot;hi&quot; =&gt; 42},
  Key = &quot;hi&quot;,
  maps:find(Key,Map).
{ok,42}</code></pre>
  </section>
</section>
<section class="detail" id="fold/3">

  <div class="detail-header">
    <a href="#fold/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">fold/3</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>fold(Fun, Init, MapOrIter) -> Acc
        when
            Fun :: fun((Key, Value, AccIn) -> AccOut),
            Init :: term(),
            Acc :: AccOut,
            AccIn :: Init | AccOut,
            MapOrIter :: #{Key => Value} | <a href="#t:iterator/2">iterator</a>(Key, Value).</pre>

      </div>

<p>Calls <code>F(Key, Value, AccIn)</code> for every <code>Key</code> to value <code>Value</code> association in <code>MapOrIter</code> in any order. Function <code>fun F/3</code> must return a new accumulator, which is passed to the next successive call. This function returns the final value of the accumulator. The initial accumulator value <code>Init</code> is returned if the map is empty.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>MapOrIter</code> is not a map or valid iterator, or with <code>badarg</code> if <code>Fun</code> is not a function of arity 3.</p><p><em>Example:</em></p><pre><code type="none">&gt; Fun = fun(K,V,AccIn) when is_list(K) -&gt; AccIn + V end,
  Map = #{&quot;k1&quot; =&gt; 1, &quot;k2&quot; =&gt; 2, &quot;k3&quot; =&gt; 3},
  maps:fold(Fun,0,Map).
6</code></pre>
  </section>
</section>
<section class="detail" id="foreach/2">

  <div class="detail-header">
    <a href="#foreach/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">foreach/2</h1>


      <span class="note">(since OTP 24.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>foreach(Fun, MapOrIter) -> ok
           when
               Fun :: fun((Key, Value) -> term()),
               MapOrIter :: #{Key => Value} | <a href="#t:iterator/2">iterator</a>(Key, Value).</pre>

      </div>

<p>Calls <code>fun F(Key, Value)</code> for every <code>Key</code> to value <code>Value</code> association in <code>MapOrIter</code> in any order.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>MapOrIter</code> is not a map or valid iterator, or with <code>badarg</code> if <code>Fun</code> is not a function of arity 2.</p>
  </section>
</section>
<section class="detail" id="from_keys/2">

  <div class="detail-header">
    <a href="#from_keys/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">from_keys/2</h1>


      <span class="note">(since OTP 24.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>from_keys(Keys, Value) -> Map when Keys :: list(), Value :: term(), Map :: map().</pre>

      </div>

<p>Takes a list of keys and a value and builds a map where all keys point to the same value. The key can be in any order, and keys and value can be of any term.</p><p><em>Example:</em></p><pre><code type="none">&gt; Keys = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], maps:from_keys(Keys, ok).
#{&quot;a&quot; =&gt; ok,&quot;b&quot; =&gt; ok,&quot;c&quot; =&gt; ok}</code></pre>
  </section>
</section>
<section class="detail" id="from_list/1">

  <div class="detail-header">
    <a href="#from_list/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">from_list/1</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>from_list(List) -> Map when List :: [{Key, Value}], Key :: term(), Value :: term(), Map :: map().</pre>

      </div>

<p>Takes a list of key-value tuples elements and builds a map. The associations can be in any order, and both keys and values in the association can be of any term. If the same key appears more than once, the latter (right-most) value is used and the previous values are ignored.</p><p><em>Example:</em></p><pre><code type="none">&gt; List = [{&quot;a&quot;,ignored},{1337,&quot;value two&quot;},{42,value_three},{&quot;a&quot;,1}],
  maps:from_list(List).
#{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1}</code></pre>
  </section>
</section>
<section class="detail" id="get/2">

  <div class="detail-header">
    <a href="#get/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">get/2</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>get(Key, Map) -> Value when Key :: term(), Map :: map(), Value :: term().</pre>

      </div>

<p>Returns value <code>Value</code> associated with <code>Key</code> if <code>Map</code> contains <code>Key</code>.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>Map</code> is not a map, or with a <code>{badkey,Key}</code> exception if no value is associated with <code>Key</code>.</p><p><em>Example:</em></p><pre><code type="none">&gt; Key = 1337,
  Map = #{42 =&gt; value_two,1337 =&gt; &quot;value one&quot;,&quot;a&quot; =&gt; 1},
  maps:get(Key,Map).
&quot;value one&quot;</code></pre>
  </section>
</section>
<section class="detail" id="get/3">

  <div class="detail-header">
    <a href="#get/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">get/3</h1>


      <span class="note">(since OTP 17.1)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>get(Key, Map, Default) -> Value | Default when Map :: #{Key => Value, _ => _}.</pre>

      </div>

<p>Returns value <code>Value</code> associated with <code>Key</code> if <code>Map</code> contains <code>Key</code>. If no value is associated with <code>Key</code>, <code>Default</code> is returned.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>Map</code> is not a map.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map = #{ key1 =&gt; val1, key2 =&gt; val2 }.
#{key1 =&gt; val1,key2 =&gt; val2}
&gt; maps:get(key1, Map, &quot;Default value&quot;).
val1
&gt; maps:get(key3, Map, &quot;Default value&quot;).
&quot;Default value&quot;</code></pre>
  </section>
</section>
<section class="detail" id="intersect/2">

  <div class="detail-header">
    <a href="#intersect/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">intersect/2</h1>


      <span class="note">(since OTP 24.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>intersect(Map1, Map2) -> Map3
             when Map1 :: #{Key => term()}, Map2 :: #{term() => Value2}, Map3 :: #{Key => Value2}.</pre>

      </div>

<p>Intersects two maps into a single map <code>Map3</code>. If a key exists in both maps, the value in <code>Map1</code> is superseded by the value in <code>Map2</code>.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>Map1</code> or <code>Map2</code> is not a map.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map1 = #{a =&gt; &quot;value_one&quot;, b =&gt; &quot;value_two&quot;},
  Map2 = #{a =&gt; 1, c =&gt; 2},
  maps:intersect(Map1,Map2).
#{a =&gt; 1}</code></pre>
  </section>
</section>
<section class="detail" id="intersect_with/3">

  <div class="detail-header">
    <a href="#intersect_with/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">intersect_with/3</h1>


      <span class="note">(since OTP 24.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>intersect_with(Combiner, Map1, Map2) -> Map3
                  when
                      Map1 :: #{Key => Value1},
                      Map2 :: #{term() => Value2},
                      Combiner :: fun((Key, Value1, Value2) -> CombineResult),
                      Map3 :: #{Key => CombineResult}.</pre>

      </div>

<p>Intersects two maps into a single map <code>Map3</code>. If a key exists in both maps, the value in <code>Map1</code> is combined with the value in <code>Map2</code> by the <code>Combiner</code> fun. When <code>Combiner</code> is applied the key that exists in both maps is the first parameter, the value from <code>Map1</code> is the second parameter, and the value from <code>Map2</code> is the third parameter.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>Map1</code> or <code>Map2</code> is not a map. The call fails with a <code>badarg</code> exception if <code>Combiner</code> is not a fun that takes three arguments.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map1 = #{a =&gt; &quot;value_one&quot;, b =&gt; &quot;value_two&quot;},
  Map2 = #{a =&gt; 1, c =&gt; 2},
  maps:intersect_with(fun(_Key, Value1, Value2) -&gt; {Value1, Value2} end, Map1, Map2).
#{a =&gt; {&quot;value_one&quot;,1}}</code></pre>
  </section>
</section>
<section class="detail" id="is_key/2">

  <div class="detail-header">
    <a href="#is_key/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">is_key/2</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>is_key(Key, Map) -> boolean() when Key :: term(), Map :: map().</pre>

      </div>

<p>Returns <code>true</code> if map <code>Map</code> contains <code>Key</code> and returns <code>false</code> if it does not contain the <code>Key</code>.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>Map</code> is not a map.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map = #{&quot;42&quot; =&gt; value}.
#{&quot;42&quot; =&gt; value}
&gt; maps:is_key(&quot;42&quot;,Map).
true
&gt; maps:is_key(value,Map).
false</code></pre>
  </section>
</section>
<section class="detail" id="iterator/1">

  <div class="detail-header">
    <a href="#iterator/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">iterator/1</h1>


      <span class="note">(since OTP 21.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>iterator(Map) -> Iterator when Map :: #{Key => Value}, Iterator :: <a href="#t:iterator/2">iterator</a>(Key, Value).</pre>

      </div>

<p>Returns a map iterator <code>Iterator</code> that can be used by <a href="#next/1"><code>maps:next/1</code></a> to traverse the key-value associations in a map. When iterating over a map, the memory usage is guaranteed to be bounded no matter the size of the map.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>Map</code> is not a map.</p><p><em>Example:</em></p><pre><code type="none">&gt; M = #{ a =&gt; 1, b =&gt; 2 }.
#{a =&gt; 1,b =&gt; 2}
&gt; I = maps:iterator(M), ok.
ok
&gt; {K1, V1, I2} = maps:next(I), {K1, V1}.
{a,1}
&gt; {K2, V2, I3} = maps:next(I2),{K2, V2}.
{b,2}
&gt; maps:next(I3).
none</code></pre>
  </section>
</section>
<section class="detail" id="keys/1">

  <div class="detail-header">
    <a href="#keys/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">keys/1</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>keys(Map) -> Keys when Map :: #{Key => _}, Keys :: [Key].</pre>

      </div>

<p>Returns a complete list of keys, in any order, which resides within <code>Map</code>.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>Map</code> is not a map.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map = #{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1},
  maps:keys(Map).
[42,1337,&quot;a&quot;]</code></pre>
  </section>
</section>
<section class="detail" id="map/2">

  <div class="detail-header">
    <a href="#map/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">map/2</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>map(Fun, MapOrIter) -> Map
       when
           Fun :: fun((Key, Value1) -> Value2),
           MapOrIter :: #{Key => Value1} | <a href="#t:iterator/2">iterator</a>(Key, Value1),
           Map :: #{Key => Value2}.</pre>

      </div>

<p>Produces a new map <code>Map</code> by calling function <code>fun F(Key, Value1)</code> for every <code>Key</code> to value <code>Value1</code> association in <code>MapOrIter</code> in any order. Function <code>fun Fun/2</code> must return value <code>Value2</code> to be associated with key <code>Key</code> for the new map <code>Map</code>.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>MapOrIter</code> is not a map or valid iterator, or with <code>badarg</code> if <code>Fun</code> is not a function of arity 2.</p><p><em>Example:</em></p><pre><code type="none">&gt; Fun = fun(K,V1) when is_list(K) -&gt; V1*2 end,
  Map = #{&quot;k1&quot; =&gt; 1, &quot;k2&quot; =&gt; 2, &quot;k3&quot; =&gt; 3},
  maps:map(Fun,Map).
#{&quot;k1&quot; =&gt; 2,&quot;k2&quot; =&gt; 4,&quot;k3&quot; =&gt; 6}</code></pre>
  </section>
</section>
<section class="detail" id="merge/2">

  <div class="detail-header">
    <a href="#merge/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">merge/2</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>merge(Map1, Map2) -> Map3 when Map1 :: map(), Map2 :: map(), Map3 :: map().</pre>

      </div>

<p>Merges two maps into a single map <code>Map3</code>. If two keys exist in both maps, the value in <code>Map1</code> is superseded by the value in <code>Map2</code>.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>Map1</code> or <code>Map2</code> is not a map.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map1 = #{a =&gt; &quot;value_one&quot;, b =&gt; &quot;value_two&quot;},
  Map2 = #{a =&gt; 1, c =&gt; 2},
  maps:merge(Map1,Map2).
#{a =&gt; 1,b =&gt; &quot;value_two&quot;,c =&gt; 2}</code></pre>
  </section>
</section>
<section class="detail" id="merge_with/3">

  <div class="detail-header">
    <a href="#merge_with/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">merge_with/3</h1>


      <span class="note">(since OTP 24.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>merge_with(Combiner, Map1, Map2) -> Map3
              when
                  Map1 :: #{Key1 => Value1},
                  Map2 :: #{Key2 => Value2},
                  Combiner :: fun((Key1, Value1, Value2) -> CombineResult),
                  Map3 :: #{Key1 => CombineResult, Key1 => Value1, Key2 => Value2}.</pre>

      </div>

<p>Merges two maps into a single map <code>Map3</code>. If a key exists in both maps, the value in <code>Map1</code> is combined with the value in <code>Map2</code> by the <code>Combiner</code> fun. When <code>Combiner</code> is applied the key that exists in both maps is the first parameter, the value from <code>Map1</code> is the second parameter, and the value from <code>Map2</code> is the third parameter.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>Map1</code> or <code>Map2</code> is not a map. The call fails with a <code>badarg</code> exception if <code>Combiner</code> is not a fun that takes three arguments.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map1 = #{a =&gt; &quot;value_one&quot;, b =&gt; &quot;value_two&quot;},
  Map2 = #{a =&gt; 1, c =&gt; 2},
  maps:merge_with(fun(_Key, Value1, Value2) -&gt; {Value1, Value2} end, Map1, Map2).
#{a =&gt; {&quot;value_one&quot;,1},b =&gt; &quot;value_two&quot;,c =&gt; 2}</code></pre>
  </section>
</section>
<section class="detail" id="new/0">

  <div class="detail-header">
    <a href="#new/0" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">new/0</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>new() -> Map when Map :: #{}.</pre>

      </div>

<p>Returns a new empty map.</p><p><em>Example:</em></p><pre><code type="none">&gt; maps:new().
#{}</code></pre>
  </section>
</section>
<section class="detail" id="next/1">

  <div class="detail-header">
    <a href="#next/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">next/1</h1>


      <span class="note">(since OTP 21.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>next(Iterator) -> {Key, Value, NextIterator} | none
        when Iterator :: <a href="#t:iterator/2">iterator</a>(Key, Value), NextIterator :: <a href="#t:iterator/2">iterator</a>(Key, Value).</pre>

      </div>

<p>Returns the next key-value association in <code>Iterator</code> and a new iterator for the remaining associations in the iterator.</p><p>If there are no more associations in the iterator, <code>none</code> is returned.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map = #{a =&gt; 1, b =&gt; 2, c =&gt; 3}.
#{a =&gt; 1,b =&gt; 2,c =&gt; 3}
&gt; I = maps:iterator(Map), ok.
ok
&gt; {K1, V1, I1} = maps:next(I), {K1, V1}.
{a,1}
&gt; {K2, V2, I2} = maps:next(I1), {K2, V2}.
{b,2}
&gt; {K3, V3, I3} = maps:next(I2), {K3, V3}.
{c,3}
&gt; maps:next(I3).
none</code></pre>
  </section>
</section>
<section class="detail" id="put/3">

  <div class="detail-header">
    <a href="#put/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">put/3</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>put(Key, Value, Map1) -> Map2 when Key :: term(), Value :: term(), Map1 :: map(), Map2 :: map().</pre>

      </div>

<p>Associates <code>Key</code> with value <code>Value</code> and inserts the association into map <code>Map2</code>. If key <code>Key</code> already exists in map <code>Map1</code>, the old associated value is replaced by value <code>Value</code>. The function returns a new map <code>Map2</code> containing the new association and the old associations in <code>Map1</code>.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>Map1</code> is not a map.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map = #{&quot;a&quot; =&gt; 1}.
#{&quot;a&quot; =&gt; 1}
&gt; maps:put(&quot;a&quot;, 42, Map).
#{&quot;a&quot; =&gt; 42}
&gt; maps:put(&quot;b&quot;, 1337, Map).
#{&quot;a&quot; =&gt; 1,&quot;b&quot; =&gt; 1337}</code></pre>
  </section>
</section>
<section class="detail" id="remove/2">

  <div class="detail-header">
    <a href="#remove/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">remove/2</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>remove(Key, Map1) -> Map2 when Key :: term(), Map1 :: map(), Map2 :: map().</pre>

      </div>

<p>Removes the <code>Key</code>, if it exists, and its associated value from <code>Map1</code> and returns a new map <code>Map2</code> without key <code>Key</code>.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>Map1</code> is not a map.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map = #{&quot;a&quot; =&gt; 1}.
#{&quot;a&quot; =&gt; 1}
&gt; maps:remove(&quot;a&quot;,Map).
#{}
&gt; maps:remove(&quot;b&quot;,Map).
#{&quot;a&quot; =&gt; 1}</code></pre>
  </section>
</section>
<section class="detail" id="size/1">

  <div class="detail-header">
    <a href="#size/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">size/1</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>size(Map) -> non_neg_integer() when Map :: map().</pre>

      </div>

<p>Returns the number of key-value associations in <code>Map</code>. This operation occurs in constant time.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map = #{42 =&gt; value_two,1337 =&gt; &quot;value one&quot;,&quot;a&quot; =&gt; 1},
  maps:size(Map).
3</code></pre>
  </section>
</section>
<section class="detail" id="take/2">

  <div class="detail-header">
    <a href="#take/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">take/2</h1>


      <span class="note">(since OTP 19.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>take(Key, Map1) -> {Value, Map2} | error when Map1 :: #{Key => Value, _ => _}, Map2 :: #{_ => _}.</pre>

      </div>

<p>The function removes the <code>Key</code>, if it exists, and its associated value from <code>Map1</code> and returns a tuple with the removed <code>Value</code> and the new map <code>Map2</code> without key <code>Key</code>. If the key does not exist <code>error</code> is returned.</p><p>The call will fail with a <code>{badmap,Map}</code> exception if <code>Map1</code> is not a map.</p><p>Example:</p><pre><code type="none">&gt; Map = #{&quot;a&quot; =&gt; &quot;hello&quot;, &quot;b&quot; =&gt; &quot;world&quot;}.
#{&quot;a&quot; =&gt; &quot;hello&quot;, &quot;b&quot; =&gt; &quot;world&quot;}
&gt; maps:take(&quot;a&quot;,Map).
{&quot;hello&quot;,#{&quot;b&quot; =&gt; &quot;world&quot;}}
&gt; maps:take(&quot;does not exist&quot;,Map).
error</code></pre>
  </section>
</section>
<section class="detail" id="to_list/1">

  <div class="detail-header">
    <a href="#to_list/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">to_list/1</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>to_list(Map) -> [{Key, Value}] when Map :: #{Key => Value}.</pre>

      </div>

<p>Returns a list of pairs representing the key-value associations of <code>Map</code>, where the pairs <code>[{K1,V1}, ..., {Kn,Vn}]</code> are returned in arbitrary order.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>Map</code> is not a map.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map = #{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1},
  maps:to_list(Map).
[{42,value_three},{1337,&quot;value two&quot;},{&quot;a&quot;,1}]</code></pre>
  </section>
</section>
<section class="detail" id="update/3">

  <div class="detail-header">
    <a href="#update/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">update/3</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>update(Key, Value, Map1) -> Map2 when Map1 :: #{Key := _, _ => _}, Map2 :: #{Key := Value, _ => _}.</pre>

      </div>

<p>If <code>Key</code> exists in <code>Map1</code>, the old associated value is replaced by value <code>Value</code>. The function returns a new map <code>Map2</code> containing the new associated value.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>Map1</code> is not a map, or with a <code>{badkey,Key}</code> exception if no value is associated with <code>Key</code>.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map = #{&quot;a&quot; =&gt; 1}.
#{&quot;a&quot; =&gt; 1}
&gt; maps:update(&quot;a&quot;, 42, Map).
#{&quot;a&quot; =&gt; 42}</code></pre>
  </section>
</section>
<section class="detail" id="update_with/3">

  <div class="detail-header">
    <a href="#update_with/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">update_with/3</h1>


      <span class="note">(since OTP 19.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>update_with(Key, Fun, Map1) -> Map2
               when
                   Map1 :: #{Key := Value1, _ => _},
                   Map2 :: #{Key := Value2, _ => _},
                   Fun :: fun((Value1) -> Value2).</pre>

      </div>

<p>Update a value in a <code>Map1</code> associated with <code>Key</code> by calling <code>Fun</code> on the old value to get a new value. An exception <code>{badkey,Key}</code> is generated if <code>Key</code> is not present in the map.</p><p>Example:</p><pre><code type="none">&gt; Map = #{&quot;counter&quot; =&gt; 1},
  Fun = fun(V) -&gt; V + 1 end,
  maps:update_with(&quot;counter&quot;,Fun,Map).
#{&quot;counter&quot; =&gt; 2}</code></pre>
  </section>
</section>
<section class="detail" id="update_with/4">

  <div class="detail-header">
    <a href="#update_with/4" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">update_with/4</h1>


      <span class="note">(since OTP 19.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>update_with(Key, Fun, Init, Map1) -> Map2
               when
                   Map1 :: #{Key => Value1, _ => _},
                   Map2 :: #{Key := Value2 | Init, _ => _},
                   Fun :: fun((Value1) -> Value2).</pre>

      </div>

<p>Update a value in a <code>Map1</code> associated with <code>Key</code> by calling <code>Fun</code> on the old value to get a new value. If <code>Key</code> is not present in <code>Map1</code> then <code>Init</code> will be associated with <code>Key</code>.</p><p>Example:</p><pre><code type="none">&gt; Map = #{&quot;counter&quot; =&gt; 1},
  Fun = fun(V) -&gt; V + 1 end,
  maps:update_with(&quot;new counter&quot;,Fun,42,Map).
#{&quot;counter&quot; =&gt; 1,&quot;new counter&quot; =&gt; 42}</code></pre>
  </section>
</section>
<section class="detail" id="values/1">

  <div class="detail-header">
    <a href="#values/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">values/1</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>values(Map) -> Values when Map :: #{_ => Value}, Values :: [Value].</pre>

      </div>

<p>Returns a complete list of values, in arbitrary order, contained in map <code>Map</code>.</p><p>The call fails with a <code>{badmap,Map}</code> exception if <code>Map</code> is not a map.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map = #{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1},
  maps:values(Map).
[value_three,&quot;value two&quot;,1]</code></pre>
  </section>
</section>
<section class="detail" id="with/2">

  <div class="detail-header">
    <a href="#with/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">with/2</h1>


      <span class="note">(since OTP 17.3)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>with(Ks, Map1) -> Map2 when Ks :: [K], Map1 :: #{K => V, _ => _}, Map2 :: #{K => V}.</pre>

      </div>

<p>Returns a new map <code>Map2</code> with the keys <code>K1</code> through <code>Kn</code> and their associated values from map <code>Map1</code>. Any key in <code>Ks</code> that does not exist in <code>Map1</code> is ignored.</p><p><em>Example:</em></p><pre><code type="none">&gt; Map = #{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1},
  Ks = [&quot;a&quot;,42,&quot;other key&quot;],
  maps:with(Ks,Map).
#{42 =&gt; value_three,&quot;a&quot; =&gt; 1}</code></pre>
  </section>
</section>
<section class="detail" id="without/2">

  <div class="detail-header">
    <a href="#without/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">without/2</h1>


      <span class="note">(since OTP 17.0)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>without(Ks, Map1) -> Map2 when Ks :: [K], Map1 :: map(), Map2 :: map(), K :: term().</pre>

      </div>

<p>Returns a new map <code>Map2</code> without keys <code>K1</code> through <code>Kn</code> and their associated values from map <code>Map1</code>. Any key in <code>Ks</code> that does not exist in <code>Map1</code> is ignored</p><p><em>Example:</em></p><pre><code type="none">&gt; Map = #{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1},
  Ks = [&quot;a&quot;,42,&quot;other key&quot;],
  maps:without(Ks,Map).
#{1337 =&gt; &quot;value two&quot;}</code></pre>
  </section>
</section>

          </div>
        </section>

      <footer class="footer">

        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.25.1) for the
            <a href="https://elixir-lang.org" title="Elixir" target="_blank">Elixir programming language</a>.
          </span>
          <span class="line">
            Designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>

            <a href="api-reference.html" title="API reference" class="line footer-button">API Reference</a>

          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button display-quick-switch">
            Go to a HexDocs package
          </button>
          <button class="line footer-button tooltips-toggle">
            <span class="tooltips-option-disable">Disable tooltips</span>
            <span class="tooltips-option-enable">Enable tooltips</span>
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
