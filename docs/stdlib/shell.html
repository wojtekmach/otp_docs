<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.25.1">
    <meta name="project" content="stdlib v3.15.2">

    <title>shell â€” stdlib v3.15.2</title>
    <link rel="stylesheet" href="dist/erlang-951161c89561e05735a5.css" />

    <script src="dist/sidebar_items-2e60d1dd15.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-f97730d45ef67f3e6188.js"></script>


  </head>
  <body data-type="modules">
    <script>

      try {
        if (localStorage.getItem('night-mode') === 'true') {
          document.body.classList.add('night-mode');
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <span class="icon-search" aria-hidden="true" title="Submit search"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <span class="icon-cross" aria-hidden="true" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="api-reference.html" class="sidebar-projectName">
stdlib
      </a>
      <strong class="sidebar-projectVersion">
        v3.15.2
      </strong>
    </div>

  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list-link" href="#full-list">Pages</a></li>

      <li><a id="modules-list-link" href="#full-list">Modules</a></li>


  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

      <h1>
shell <small class="app-vsn">(stdlib v3.15.2)</small>

      </h1>


        <section id="moduledoc">
<p>This module provides an Erlang shell.</p><p>The shell is a user interface program for entering expression sequences. The expressions are evaluated and a value is returned. A history mechanism saves previous commands and their values, which can then be incorporated in later commands. How many commands and results to save can be determined by the user, either interactively, by calling <a href="#history/1"><code>history/1</code></a> and <a href="#results/1"><code>results/1</code></a>, or by setting the application configuration parameters <code>shell_history_length</code> and <code>shell_saved_results</code> for the STDLIB application.</p><p>The shell uses a helper process for evaluating commands to protect the history mechanism from exceptions. By default the evaluator process is killed when an exception occurs, but by calling <a href="#catch_exception/1"><code>catch_exception/1</code></a> or by setting the application configuration parameter <code>shell_catch_exception</code> for the STDLIB application this behavior can be changed. See also the example below.</p><p>Variable bindings, and local process dictionary changes that are generated in user expressions are preserved, and the variables can be used in later commands to access their values. The bindings can also be forgotten so the variables can be reused.</p><p>The special shell commands all have the syntax of (local) function calls. They are evaluated as normal function calls and many commands can be used in one expression sequence.</p><p>If a command (local function call) is not recognized by the shell, an attempt is first made to find the function in module <code>user_default</code>, where customized local commands can be placed. If found, the function is evaluated, otherwise an attempt is made to evaluate the function in module <code>shell_default</code>. Module <code>user_default</code> must be explicitly loaded.</p><p>The shell also permits the user to start multiple concurrent jobs. A job can be regarded as a set of processes that can communicate with the shell.</p><p>There is some support for reading and printing records in the shell. During compilation record expressions are translated to tuple expressions. In runtime it is not known whether a tuple represents a record, and the record definitions used by the compiler are unavailable at runtime. So, to read the record syntax and print tuples as records when possible, record definitions must be maintained by the shell itself.</p><p>The shell commands for reading, defining, forgetting, listing, and printing records are described below. Notice that each job has its own set of record definitions. To facilitate matters, record definitions in modules <code>shell_default</code> and <code>user_default</code> (if loaded) are read each time a new job is started. For example, adding the following line to <code>user_default</code> makes the definition of <code>file_info</code> readily available in the shell:</p><pre><code type="none">-include_lib(&quot;kernel/include/file.hrl&quot;).</code></pre><p>The shell runs in two modes:</p><ul><li><p><code>Normal (possibly restricted)</code> mode, in which commands can be edited and expressions evaluated</p></li><li><p>Job Control Mode, <code>JCL</code>, in which jobs can be started, killed, detached, and connected</p></li></ul><p>Only the currently connected job can 'talk' to the shell.</p><h2 id="module-shell-commands" class="section-heading">
  <a href="#module-shell-commands" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Shell Commands
</h2>
<p>The commands below are the built-in shell commands that are always available. In most system the commands listed in the <a href="c.html">c(3)</a> module are also available in the shell.</p><dl><dt><code>b()</code></dt><dd><p>Prints the current variable bindings.</p></dd><dt><code>f()</code></dt><dd><p>Removes all variable bindings.</p></dd><dt><code>f(X)</code></dt><dd><p>Removes the binding of variable <code>X</code>.</p></dd><dt><code>h()</code></dt><dd><p>Prints the history list.</p></dd><dt><code>history(N)</code></dt><dd><p>Sets the number of previous commands to keep in the history list to <code>N</code>. The previous number is returned. Defaults to 20.</p></dd><dt><code>results(N)</code></dt><dd><p>Sets the number of results from previous commands to keep in the history list to <code>N</code>. The previous number is returned. Defaults to 20.</p></dd><dt><code>e(N)</code></dt><dd><p>Repeats command <code>N</code>, if <code>N</code> is positive. If it is negative, the <code>N</code>th previous command is repeated (that is, <code>e(-1)</code> repeats the previous command).</p></dd><dt><code>v(N)</code></dt><dd><p>Uses the return value of command <code>N</code> in the current command, if <code>N</code> is positive. If it is negative, the return value of the <code>N</code>th previous command is used (that is, <code>v(-1)</code> uses the value of the previous command).</p></dd><dt><code>help()</code></dt><dd><p>Evaluates <code>shell_default:help()</code>.</p></dd><dt><code>c(Mod)</code></dt><dd><p>Evaluates <code>shell_default:c(Mod)</code>. This compiles and loads the module <code>Mod</code> and purges old versions of the code, if necessary. <code>Mod</code> can be either a module name or a a source file path, with or without <code>.erl</code> extension.</p></dd><dt><code>catch_exception(Bool)</code></dt><dd><p>Sets the exception handling of the evaluator process. The previous exception handling is returned. The default (<code>false</code>) is to kill the evaluator process when an exception occurs, which causes the shell to create a new evaluator process. When the exception handling is set to <code>true</code>, the evaluator process lives on. This means, for example, that ports and ETS tables as well as processes linked to the evaluator process survive the exception.</p></dd><dt><code>rd(RecordName, RecordDefinition)</code></dt><dd><p>Defines a record in the shell. <code>RecordName</code> is an atom and <code>RecordDefinition</code> lists the field names and the default values. Usually record definitions are made known to the shell by use of the <code>rr/1,2,3</code> commands described below, but sometimes it is handy to define records on the fly.</p></dd><dt><code>rf()</code></dt><dd><p>Removes all record definitions, then reads record definitions from the modules <code>shell_default</code> and <code>user_default</code> (if loaded). Returns the names of the records defined.</p></dd><dt><code>rf(RecordNames)</code></dt><dd><p>Removes selected record definitions. <code>RecordNames</code> is a record name or a list of record names. To remove all record definitions, use <code>'_'</code>.</p></dd><dt><code>rl()</code></dt><dd><p>Prints all record definitions.</p></dd><dt><code>rl(RecordNames)</code></dt><dd><p>Prints selected record definitions. <code>RecordNames</code> is a record name or a list of record names.</p></dd><dt><code>rp(Term)</code></dt><dd><p>Prints a term using the record definitions known to the shell. All of <code>Term</code> is printed; the depth is not limited as is the case when a return value is printed.</p></dd><dt><code>rr(Module)</code></dt><dd><p>Reads record definitions from a module's BEAM file. If there are no record definitions in the BEAM file, the source file is located and read instead. Returns the names of the record definitions read. <code>Module</code> is an atom.</p></dd><dt><code>rr(Wildcard)</code></dt><dd><p>Reads record definitions from files. Existing definitions of any of the record names read are replaced. <code>Wildcard</code> is a wildcard string as defined in <a href="filelib.html"><code>filelib(3)</code></a>, but not an atom.</p></dd><dt><code>rr(WildcardOrModule, RecordNames)</code></dt><dd><p>Reads record definitions from files but discards record names not mentioned in <code>RecordNames</code> (a record name or a list of record names).</p></dd><dt><code>rr(WildcardOrModule, RecordNames, Options)</code></dt><dd><p>Reads record definitions from files. The compiler options <code>{i,Â Dir}</code>, <code>{d,Â Macro}</code>, and <code>{d,Â Macro,Â Value}</code> are recognized and used for setting up the include path and macro definitions. To read all record definitions, use <code>'_'</code> as value of <code>RecordNames</code>.</p></dd></dl><h2 id="module-example" class="section-heading">
  <a href="#module-example" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Example
</h2>
<p>The following example is a long dialog with the shell. Commands starting with <code>&gt;</code> are inputs to the shell. All other lines are output from the shell.</p><pre><code class="makeup erlang"><span class="ss">strider</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="ss">erl</span><span class="w">
</span><span class="n">Erlang</span><span class="w"> </span><span class="p" data-group-id="4476212088-1">(</span><span class="n">BEAM</span><span class="p" data-group-id="4476212088-1">)</span><span class="w"> </span><span class="ss">emulator</span><span class="w"> </span><span class="ss">version</span><span class="w"> </span><span class="mf">5.3</span><span class="w"> </span><span class="p" data-group-id="4476212088-2">[</span><span class="ss">hipe</span><span class="p" data-group-id="4476212088-2">]</span><span class="w"> </span><span class="p" data-group-id="4476212088-3">[</span><span class="nc">threads</span><span class="p">:</span><span class="mi">0</span><span class="p" data-group-id="4476212088-3">]</span><span class="w">

</span><span class="n">Eshell</span><span class="w"> </span><span class="n">V5</span><span class="p">.</span><span class="mi">3</span><span class="w">  </span><span class="p" data-group-id="4476212088-4">(</span><span class="ss">abort</span><span class="w"> </span><span class="ss">with</span><span class="w"> </span><span class="err">^</span><span class="n">G</span><span class="p" data-group-id="4476212088-4">)</span><span class="w">
</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;abcd&quot;</span><span class="p">.</span><span class="w">
</span><span class="s">&quot;abcd&quot;</span></code></pre><p>Command 1 sets variable <code>Str</code> to string <code>&quot;abcd&quot;</code>.</p><pre><code class="makeup erlang"><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">length</span><span class="p" data-group-id="2391505638-1">(</span><span class="n">Str</span><span class="p" data-group-id="2391505638-1">)</span><span class="p">.</span><span class="w">
</span><span class="mi">4</span></code></pre><p>Command 2 sets <code>L</code> to the length of string <code>Str</code>.</p><pre><code class="makeup erlang"><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Descriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="5320276577-1">{</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="nf">list_to_atom</span><span class="p" data-group-id="5320276577-2">(</span><span class="n">Str</span><span class="p" data-group-id="5320276577-2">)</span><span class="p" data-group-id="5320276577-1">}</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="5320276577-3">{</span><span class="mi">4</span><span class="p">,</span><span class="ss">abcd</span><span class="p" data-group-id="5320276577-3">}</span></code></pre><p>Command 3 builds the tuple <code>Descriptor</code>, evaluating the BIF <a href="https://wojtekmach.pl/otp_docs/erts/erlang.html#list_to_atom/1"><code>list_to_atom/1</code> </a>.</p><pre><code class="makeup erlang"><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L</span><span class="p">.</span><span class="w"> 
</span><span class="mi">4</span></code></pre><p>Command 4 prints the value of variable <code>L</code>.</p><pre><code class="makeup erlang"><span class="mi">5</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">b</span><span class="p" data-group-id="1983092620-1">(</span><span class="p" data-group-id="1983092620-1">)</span><span class="p">.</span><span class="w">
</span><span class="n">Descriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1983092620-2">{</span><span class="mi">4</span><span class="p">,</span><span class="ss">abcd</span><span class="p" data-group-id="1983092620-2">}</span><span class="w">
</span><span class="n">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w">
</span><span class="n">Str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;abcd&quot;</span><span class="w">
</span><span class="ss">ok</span></code></pre><p>Command 5 evaluates the internal shell command <code>b()</code>, which is an abbreviation of &quot;bindings&quot;. This prints the current shell variables and their bindings. <code>ok</code> at the end is the return value of function <code>b()</code>.</p><pre><code class="makeup erlang"><span class="mi">6</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">f</span><span class="p" data-group-id="6279645537-1">(</span><span class="n">L</span><span class="p" data-group-id="6279645537-1">)</span><span class="p">.</span><span class="w"> 
</span><span class="ss">ok</span></code></pre><p>Command 6 evaluates the internal shell command <code>f(L)</code> (abbreviation of &quot;forget&quot;). The value of variable <code>L</code> is removed.</p><pre><code class="makeup erlang"><span class="mi">7</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">b</span><span class="p" data-group-id="5614911846-1">(</span><span class="p" data-group-id="5614911846-1">)</span><span class="p">.</span><span class="w">
</span><span class="n">Descriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="5614911846-2">{</span><span class="mi">4</span><span class="p">,</span><span class="ss">abcd</span><span class="p" data-group-id="5614911846-2">}</span><span class="w">
</span><span class="n">Str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;abcd&quot;</span><span class="w">
</span><span class="ss">ok</span></code></pre><p>Command 7 prints the new bindings.</p><pre><code class="makeup erlang"><span class="mi">8</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">f</span><span class="p" data-group-id="8012623437-1">(</span><span class="n">L</span><span class="p" data-group-id="8012623437-1">)</span><span class="p">.</span><span class="w">
</span><span class="ss">ok</span></code></pre><p>Command 8 has no effect, as <code>L</code> has no value.</p><pre><code class="makeup erlang"><span class="mi">9</span><span class="o">&gt;</span><span class="w"> </span><span class="p" data-group-id="5746244483-1">{</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="p">_</span><span class="p" data-group-id="5746244483-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Descriptor</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="5746244483-2">{</span><span class="mi">4</span><span class="p">,</span><span class="ss">abcd</span><span class="p" data-group-id="5746244483-2">}</span></code></pre><p>Command 9 performs a pattern matching operation on <code>Descriptor</code>, binding a new value to <code>L</code>.</p><pre><code class="makeup erlang"><span class="mi">10</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L</span><span class="p">.</span><span class="w">
</span><span class="mi">4</span></code></pre><p>Command 10 prints the current value of <code>L</code>.</p><pre><code class="makeup erlang"><span class="mi">11</span><span class="o">&gt;</span><span class="w"> </span><span class="p" data-group-id="3618397900-1">{</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="p" data-group-id="3618397900-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Descriptor</span><span class="p">.</span><span class="w">
</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="ss">exception</span><span class="w"> </span><span class="nc">error</span><span class="p">:</span><span class="w"> </span><span class="ss">no</span><span class="w"> </span><span class="ss">match</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="ss">right</span><span class="w"> </span><span class="ss">hand</span><span class="w"> </span><span class="ss">side</span><span class="w"> </span><span class="ss">value</span><span class="w"> </span><span class="p" data-group-id="3618397900-2">{</span><span class="mi">4</span><span class="p">,</span><span class="ss">abcd</span><span class="p" data-group-id="3618397900-2">}</span></code></pre><p>Command 11 tries to match <code>{P, Q, R}</code> against <code>Descriptor</code>, which is <code>{4, abc}</code>. The match fails and none of the new variables become bound. The printout starting with &quot;<code>** exception error:</code>&quot; is not the value of the expression (the expression had no value because its evaluation failed), but a warning printed by the system to inform the user that an error has occurred. The values of the other variables (<code>L</code>, <code>Str</code>, and so on) are unchanged.</p><pre><code class="makeup erlang"><span class="mi">12</span><span class="o">&gt;</span><span class="w"> </span><span class="n">P</span><span class="p">.</span><span class="w">
</span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="w"> </span><span class="ss">variable</span><span class="w"> </span><span class="ss">&#39;P&#39;</span><span class="w"> </span><span class="ss">is</span><span class="w"> </span><span class="ss">unbound</span><span class="w">
</span><span class="mi">13</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Descriptor</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="3723497528-1">{</span><span class="mi">4</span><span class="p">,</span><span class="ss">abcd</span><span class="p" data-group-id="3723497528-1">}</span></code></pre><p>Commands 12 and 13 show that <code>P</code> is unbound because the previous command failed, and that <code>Descriptor</code> has not changed.</p><pre><code class="makeup erlang"><span class="mi">14</span><span class="o">&gt;</span><span class="p" data-group-id="1788783799-1">{</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p" data-group-id="1788783799-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Descriptor</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1788783799-2">{</span><span class="mi">4</span><span class="p">,</span><span class="ss">abcd</span><span class="p" data-group-id="1788783799-2">}</span><span class="w">
</span><span class="mi">15</span><span class="o">&gt;</span><span class="w"> </span><span class="n">P</span><span class="p">.</span><span class="w">
</span><span class="mi">4</span></code></pre><p>Commands 14 and 15 show a correct match where <code>P</code> and <code>Q</code> are bound.</p><pre><code class="makeup erlang"><span class="mi">16</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">f</span><span class="p" data-group-id="7435753637-1">(</span><span class="p" data-group-id="7435753637-1">)</span><span class="p">.</span><span class="w">
</span><span class="ss">ok</span></code></pre><p>Command 16 clears all bindings.</p><p>The next few commands assume that <code>test1:demo(X)</code> is defined as follows:</p><p><code>demo(X) -&gt;</code><br/>Â Â Â Â <code>put(aa, worked),</code><br/>Â Â Â Â <code>X = 1,</code><br/>Â Â Â Â <code>X + 10.</code></p><pre><code class="makeup erlang"><span class="mi">17</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">put</span><span class="p" data-group-id="4404803047-1">(</span><span class="ss">aa</span><span class="p">,</span><span class="w"> </span><span class="ss">hello</span><span class="p" data-group-id="4404803047-1">)</span><span class="p">.</span><span class="w">
</span><span class="ss">undefined</span><span class="w">
</span><span class="mi">18</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">get</span><span class="p" data-group-id="4404803047-2">(</span><span class="ss">aa</span><span class="p" data-group-id="4404803047-2">)</span><span class="p">.</span><span class="w">
</span><span class="ss">hello</span></code></pre><p>Commands 17 and 18 set and inspect the value of item <code>aa</code> in the process dictionary.</p><pre><code class="makeup erlang"><span class="mi">19</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">test1</span><span class="p">:</span><span class="nf">demo</span><span class="p" data-group-id="5758909097-1">(</span><span class="mi">1</span><span class="p" data-group-id="5758909097-1">)</span><span class="p">.</span><span class="w">
</span><span class="mi">11</span></code></pre><p>Command 19 evaluates <code>test1:demo(1)</code>. The evaluation succeeds and the changes made in the process dictionary become visible to the shell. The new value of dictionary item <code>aa</code> can be seen in command 20.</p><pre><code class="makeup erlang"><span class="mi">20</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">get</span><span class="p" data-group-id="1251352880-1">(</span><span class="p" data-group-id="1251352880-1">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1251352880-2">[</span><span class="p" data-group-id="1251352880-3">{</span><span class="ss">aa</span><span class="p">,</span><span class="ss">worked</span><span class="p" data-group-id="1251352880-3">}</span><span class="p" data-group-id="1251352880-2">]</span><span class="w">
</span><span class="mi">21</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">put</span><span class="p" data-group-id="1251352880-4">(</span><span class="ss">aa</span><span class="p">,</span><span class="w"> </span><span class="ss">hello</span><span class="p" data-group-id="1251352880-4">)</span><span class="p">.</span><span class="w">
</span><span class="ss">worked</span><span class="w">
</span><span class="mi">22</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">test1</span><span class="p">:</span><span class="nf">demo</span><span class="p" data-group-id="1251352880-5">(</span><span class="mi">2</span><span class="p" data-group-id="1251352880-5">)</span><span class="p">.</span><span class="w">
</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="ss">exception</span><span class="w"> </span><span class="nc">error</span><span class="p">:</span><span class="w"> </span><span class="ss">no</span><span class="w"> </span><span class="ss">match</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="ss">right</span><span class="w"> </span><span class="ss">hand</span><span class="w"> </span><span class="ss">side</span><span class="w"> </span><span class="ss">value</span><span class="w"> </span><span class="mi">1</span><span class="w">
     </span><span class="ss">in</span><span class="w"> </span><span class="ss">function</span><span class="w">  </span><span class="nc">test1</span><span class="p">:</span><span class="ss">demo</span><span class="o">/</span><span class="mi">1</span></code></pre><p>Commands 21 and 22 change the value of dictionary item <code>aa</code> to <code>hello</code> and call <code>test1:demo(2)</code>. Evaluation fails and the changes made to the dictionary in <code>test1:demo(2)</code>, before the error occurred, are discarded.</p><pre><code class="makeup erlang"><span class="mi">23</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Z</span><span class="p">.</span><span class="w">
</span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="w"> </span><span class="ss">variable</span><span class="w"> </span><span class="ss">&#39;Z&#39;</span><span class="w"> </span><span class="ss">is</span><span class="w"> </span><span class="ss">unbound</span><span class="w">
</span><span class="mi">24</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">get</span><span class="p" data-group-id="1010137336-1">(</span><span class="ss">aa</span><span class="p" data-group-id="1010137336-1">)</span><span class="p">.</span><span class="w">
</span><span class="ss">hello</span></code></pre><p>Commands 23 and 24 show that <code>Z</code> was not bound and that dictionary item <code>aa</code> has retained its original value.</p><pre><code class="makeup erlang"><span class="mi">25</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">erase</span><span class="p" data-group-id="5736169296-1">(</span><span class="p" data-group-id="5736169296-1">)</span><span class="p">,</span><span class="w"> </span><span class="nf">put</span><span class="p" data-group-id="5736169296-2">(</span><span class="ss">aa</span><span class="p">,</span><span class="w"> </span><span class="ss">hello</span><span class="p" data-group-id="5736169296-2">)</span><span class="p">.</span><span class="w">
</span><span class="ss">undefined</span><span class="w">
</span><span class="mi">26</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">spawn</span><span class="p" data-group-id="5736169296-3">(</span><span class="ss">test1</span><span class="p">,</span><span class="w"> </span><span class="ss">demo</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5736169296-4">[</span><span class="mi">1</span><span class="p" data-group-id="5736169296-4">]</span><span class="p" data-group-id="5736169296-3">)</span><span class="p">.</span><span class="w">
</span><span class="o">&lt;</span><span class="mf">0.57</span><span class="p">.</span><span class="mi">0</span><span class="o">&gt;</span><span class="w">
</span><span class="mi">27</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">get</span><span class="p" data-group-id="5736169296-5">(</span><span class="ss">aa</span><span class="p" data-group-id="5736169296-5">)</span><span class="p">.</span><span class="w">
</span><span class="ss">hello</span></code></pre><p>Commands 25, 26, and 27 show the effect of evaluating <code>test1:demo(1)</code> in the background. In this case, the expression is evaluated in a newly spawned process. Any changes made in the process dictionary are local to the newly spawned process and therefore not visible to the shell.</p><pre><code class="makeup erlang"><span class="mi">28</span><span class="o">&gt;</span><span class="w"> </span><span class="nc">io</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="8623216140-1">(</span><span class="s">&quot;hello hello\n&quot;</span><span class="p" data-group-id="8623216140-1">)</span><span class="p">.</span><span class="w">
</span><span class="ss">hello</span><span class="w"> </span><span class="ss">hello</span><span class="w">
</span><span class="ss">ok</span><span class="w">
</span><span class="mi">29</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">e</span><span class="p" data-group-id="8623216140-2">(</span><span class="mi">28</span><span class="p" data-group-id="8623216140-2">)</span><span class="p">.</span><span class="w">
</span><span class="ss">hello</span><span class="w"> </span><span class="ss">hello</span><span class="w">
</span><span class="ss">ok</span><span class="w">
</span><span class="mi">30</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">v</span><span class="p" data-group-id="8623216140-3">(</span><span class="mi">28</span><span class="p" data-group-id="8623216140-3">)</span><span class="p">.</span><span class="w">
</span><span class="ss">ok</span></code></pre><p>Commands 28, 29 and 30 use the history facilities of the shell. Command 29 re-evaluates command 28. Command 30 uses the value (result) of command 28. In the cases of a pure function (a function with no side effects), the result is the same. For a function with side effects, the result can be different.</p><p>The next few commands show some record manipulation. It is assumed that <code>ex.erl</code> defines a record as follows:</p><p><code>-record(rec, {a, b = val()}).</code></p><p><code>val() -&gt;</code><br/>Â Â Â Â <code>3.</code></p><pre><code class="makeup erlang"><span class="mi">31</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">c</span><span class="p" data-group-id="8814332620-1">(</span><span class="ss">ex</span><span class="p" data-group-id="8814332620-1">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8814332620-2">{</span><span class="ss">ok</span><span class="p">,</span><span class="ss">ex</span><span class="p" data-group-id="8814332620-2">}</span><span class="w">
</span><span class="mi">32</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">rr</span><span class="p" data-group-id="8814332620-3">(</span><span class="ss">ex</span><span class="p" data-group-id="8814332620-3">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8814332620-4">[</span><span class="ss">rec</span><span class="p" data-group-id="8814332620-4">]</span></code></pre><p>Commands 31 and 32 compile file <code>ex.erl</code> and read the record definitions in <code>ex.beam</code>. If the compiler did not output any record definitions on the BEAM file, <code>rr(ex)</code> tries to read record definitions from the source file instead.</p><pre><code class="makeup erlang"><span class="mi">33</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">rl</span><span class="p" data-group-id="3702950934-1">(</span><span class="ss">rec</span><span class="p" data-group-id="3702950934-1">)</span><span class="p">.</span><span class="w">
</span><span class="p">-</span><span class="na">record</span><span class="p" data-group-id="3702950934-2">(</span><span class="ss">rec</span><span class="p">,</span><span class="p" data-group-id="3702950934-3">{</span><span class="ss">a</span><span class="p">,</span><span class="ss">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">val</span><span class="p" data-group-id="3702950934-4">(</span><span class="p" data-group-id="3702950934-4">)</span><span class="p" data-group-id="3702950934-3">}</span><span class="p" data-group-id="3702950934-2">)</span><span class="p">.</span><span class="w">
</span><span class="ss">ok</span></code></pre><p>Command 33 prints the definition of the record named <code>rec</code>.</p><pre><code class="makeup erlang"><span class="mi">34</span><span class="o">&gt;</span><span class="w"> </span><span class="o">#</span><span class="ss">rec</span><span class="p" data-group-id="2244134134-1">{</span><span class="p" data-group-id="2244134134-1">}</span><span class="p">.</span><span class="w">
</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="ss">exception</span><span class="w"> </span><span class="nc">error</span><span class="p">:</span><span class="w"> </span><span class="ss">undefined</span><span class="w"> </span><span class="ss">shell</span><span class="w"> </span><span class="ss">command</span><span class="w"> </span><span class="ss">val</span><span class="o">/</span><span class="mi">0</span></code></pre><p>Command 34 tries to create a <code>rec</code> record, but fails as function <code>val/0</code> is undefined.</p><pre><code class="makeup erlang"><span class="mi">35</span><span class="o">&gt;</span><span class="w"> </span><span class="o">#</span><span class="ss">rec</span><span class="p" data-group-id="1960758596-1">{</span><span class="ss">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="1960758596-1">}</span><span class="p">.</span><span class="w">
</span><span class="o">#</span><span class="ss">rec</span><span class="p" data-group-id="1960758596-2">{</span><span class="ss">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">undefined</span><span class="p">,</span><span class="ss">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="1960758596-2">}</span></code></pre><p>Command 35 shows the workaround: explicitly assign values to record fields that cannot otherwise be initialized.</p><pre><code class="makeup erlang"><span class="mi">36</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">rp</span><span class="p" data-group-id="0237182862-1">(</span><span class="nf">v</span><span class="p" data-group-id="0237182862-2">(</span><span class="o">-</span><span class="mi">1</span><span class="p" data-group-id="0237182862-2">)</span><span class="p" data-group-id="0237182862-1">)</span><span class="p">.</span><span class="w">
</span><span class="o">#</span><span class="ss">rec</span><span class="p" data-group-id="0237182862-3">{</span><span class="ss">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">undefined</span><span class="p">,</span><span class="ss">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="0237182862-3">}</span><span class="w">
</span><span class="ss">ok</span></code></pre><p>Command 36 prints the newly created record using record definitions maintained by the shell.</p><pre><code class="makeup erlang"><span class="mi">37</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">rd</span><span class="p" data-group-id="2978361352-1">(</span><span class="ss">rec</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2978361352-2">{</span><span class="ss">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">orddict</span><span class="p">:</span><span class="nf">new</span><span class="p" data-group-id="2978361352-3">(</span><span class="p" data-group-id="2978361352-3">)</span><span class="p" data-group-id="2978361352-2">}</span><span class="p" data-group-id="2978361352-1">)</span><span class="p">.</span><span class="w">
</span><span class="ss">rec</span></code></pre><p>Command 37 defines a record directly in the shell. The definition replaces the one read from file <code>ex.beam</code>.</p><pre><code class="makeup erlang"><span class="mi">38</span><span class="o">&gt;</span><span class="w"> </span><span class="o">#</span><span class="ss">rec</span><span class="p" data-group-id="7783946548-1">{</span><span class="p" data-group-id="7783946548-1">}</span><span class="p">.</span><span class="w">
</span><span class="o">#</span><span class="ss">rec</span><span class="p" data-group-id="7783946548-2">{</span><span class="ss">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="7783946548-3">[</span><span class="p" data-group-id="7783946548-3">]</span><span class="p" data-group-id="7783946548-2">}</span><span class="w">
</span><span class="ss">ok</span></code></pre><p>Command 38 creates a record using the new definition, and prints the result.</p><pre><code class="makeup erlang"><span class="mi">39</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">rd</span><span class="p" data-group-id="8497124207-1">(</span><span class="ss">rec</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8497124207-2">{</span><span class="ss">c</span><span class="p" data-group-id="8497124207-2">}</span><span class="p" data-group-id="8497124207-1">)</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="w">
</span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="mi">15</span><span class="p">:</span><span class="w"> </span><span class="ss">variable</span><span class="w"> </span><span class="ss">&#39;A&#39;</span><span class="w"> </span><span class="ss">is</span><span class="w"> </span><span class="ss">unbound</span><span class="w">
</span><span class="mi">40</span><span class="o">&gt;</span><span class="w"> </span><span class="o">#</span><span class="ss">rec</span><span class="p" data-group-id="8497124207-3">{</span><span class="p" data-group-id="8497124207-3">}</span><span class="p">.</span><span class="w">
</span><span class="o">#</span><span class="ss">rec</span><span class="p" data-group-id="8497124207-4">{</span><span class="ss">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">undefined</span><span class="p" data-group-id="8497124207-4">}</span><span class="w">
</span><span class="ss">ok</span></code></pre><p>Command 39 and 40 show that record definitions are updated as side effects. The evaluation of the command fails, but the definition of <code>rec</code> has been carried out.</p><p>For the next command, it is assumed that <code>test1:loop(N)</code> is defined as follows:</p><p><code>loop(N) -&gt;</code><br/>Â Â Â Â <code>io:format(&quot;Hello Number: ~w~n&quot;, [N]),</code><br/>Â Â Â Â <code>loop(N+1).</code></p><pre><code class="makeup erlang"><span class="mi">41</span><span class="o">&gt;</span><span class="w"> </span><span class="nc">test1</span><span class="p">:</span><span class="nf">loop</span><span class="p" data-group-id="6090731581-1">(</span><span class="mi">0</span><span class="p" data-group-id="6090731581-1">)</span><span class="p">.</span><span class="w">
</span><span class="n">Hello</span><span class="w"> </span><span class="n">Number</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="n">Hello</span><span class="w"> </span><span class="n">Number</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="n">Hello</span><span class="w"> </span><span class="n">Number</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="n">Hello</span><span class="w"> </span><span class="n">Number</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="w">

</span><span class="n">User</span><span class="w"> </span><span class="ss">switch</span><span class="w"> </span><span class="ss">command</span><span class="w">
 </span><span class="o">--</span><span class="o">&gt;</span><span class="w"> </span><span class="ss">i</span><span class="w">
 </span><span class="o">--</span><span class="o">&gt;</span><span class="w"> </span><span class="ss">c</span><span class="w">
</span><span class="p">.</span><span class="w">
</span><span class="p">.</span><span class="w">
</span><span class="p">.</span><span class="w">
</span><span class="n">Hello</span><span class="w"> </span><span class="n">Number</span><span class="p">:</span><span class="w"> </span><span class="mi">3374</span><span class="w">
</span><span class="n">Hello</span><span class="w"> </span><span class="n">Number</span><span class="p">:</span><span class="w"> </span><span class="mi">3375</span><span class="w">
</span><span class="n">Hello</span><span class="w"> </span><span class="n">Number</span><span class="p">:</span><span class="w"> </span><span class="mi">3376</span><span class="w">
</span><span class="n">Hello</span><span class="w"> </span><span class="n">Number</span><span class="p">:</span><span class="w"> </span><span class="mi">3377</span><span class="w">
</span><span class="n">Hello</span><span class="w"> </span><span class="n">Number</span><span class="p">:</span><span class="w"> </span><span class="mi">3378</span><span class="w">
</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="ss">exception</span><span class="w"> </span><span class="nc">exit</span><span class="p">:</span><span class="w"> </span><span class="ss">killed</span></code></pre><p>Command 41 evaluates <code>test1:loop(0)</code>, which puts the system into an infinite loop. At this point the user types <code>^G</code> (Control G), which suspends output from the current process, which is stuck in a loop, and activates <code>JCL</code> mode. In <code>JCL</code> mode the user can start and stop jobs.</p><p>In this particular case, command <code>i</code> (&quot;interrupt&quot;) terminates the looping program, and command <code>c</code> connects to the shell again. As the process was running in the background before we killed it, more printouts occur before message &quot;<code>** exception exit: killed</code>&quot; is shown.</p><pre><code class="makeup erlang"><span class="mi">42</span><span class="o">&gt;</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ets</span><span class="p">:</span><span class="nf">new</span><span class="p" data-group-id="6373039112-1">(</span><span class="ss">t</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6373039112-2">[</span><span class="p" data-group-id="6373039112-2">]</span><span class="p" data-group-id="6373039112-1">)</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Ref</span><span class="o">&lt;</span><span class="mf">0.1662103692</span><span class="p">.</span><span class="mf">2407923716.214192</span><span class="o">&gt;</span></code></pre><p>Command 42 creates an ETS table.</p><pre><code class="makeup erlang"><span class="mi">43</span><span class="o">&gt;</span><span class="w"> </span><span class="nc">ets</span><span class="p">:</span><span class="nf">insert</span><span class="p" data-group-id="4031977888-1">(</span><span class="p" data-group-id="4031977888-2">{</span><span class="ss">d</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="4031977888-2">}</span><span class="p" data-group-id="4031977888-1">)</span><span class="p">.</span><span class="w">
</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="ss">exception</span><span class="w"> </span><span class="nc">error</span><span class="p">:</span><span class="w"> </span><span class="ss">undefined</span><span class="w"> </span><span class="ss">function</span><span class="w"> </span><span class="nc">ets</span><span class="p">:</span><span class="ss">insert</span><span class="o">/</span><span class="mi">1</span></code></pre><p>Command 43 tries to insert a tuple into the ETS table, but the first argument (the table) is missing. The exception kills the evaluator process.</p><pre><code class="makeup erlang"><span class="mi">44</span><span class="o">&gt;</span><span class="w"> </span><span class="nc">ets</span><span class="p">:</span><span class="nf">insert</span><span class="p" data-group-id="7282306030-1">(</span><span class="n">E</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7282306030-2">{</span><span class="ss">d</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="7282306030-2">}</span><span class="p" data-group-id="7282306030-1">)</span><span class="p">.</span><span class="w">
</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="ss">exception</span><span class="w"> </span><span class="nc">error</span><span class="p">:</span><span class="w"> </span><span class="ss">argument</span><span class="w"> </span><span class="ss">is</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="ss">wrong</span><span class="w"> </span><span class="ss">type</span><span class="w">
     </span><span class="ss">in</span><span class="w"> </span><span class="ss">function</span><span class="w">  </span><span class="nc">ets</span><span class="p">:</span><span class="ss">insert</span><span class="o">/</span><span class="mi">2</span><span class="w">
        </span><span class="ss">called</span><span class="w"> </span><span class="ss">as</span><span class="w"> </span><span class="nc">ets</span><span class="p">:</span><span class="nf">insert</span><span class="p" data-group-id="7282306030-3">(</span><span class="mi">16</span><span class="p">,</span><span class="p" data-group-id="7282306030-4">{</span><span class="ss">d</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="7282306030-4">}</span><span class="p" data-group-id="7282306030-3">)</span></code></pre><p>Command 44 corrects the mistake, but the ETS table has been destroyed as it was owned by the killed evaluator process.</p><pre><code class="makeup erlang"><span class="mi">45</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">f</span><span class="p" data-group-id="3883417002-1">(</span><span class="n">E</span><span class="p" data-group-id="3883417002-1">)</span><span class="p">.</span><span class="w">
</span><span class="ss">ok</span><span class="w">
</span><span class="mi">46</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">catch_exception</span><span class="p" data-group-id="3883417002-2">(</span><span class="ss">true</span><span class="p" data-group-id="3883417002-2">)</span><span class="p">.</span><span class="w">
</span><span class="ss">false</span></code></pre><p>Command 46 sets the exception handling of the evaluator process to <code>true</code>. The exception handling can also be set when starting Erlang by <code>erl -stdlib shell_catch_exception true</code>.</p><pre><code class="makeup erlang"><span class="mi">47</span><span class="o">&gt;</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ets</span><span class="p">:</span><span class="nf">new</span><span class="p" data-group-id="1116447559-1">(</span><span class="ss">t</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1116447559-2">[</span><span class="p" data-group-id="1116447559-2">]</span><span class="p" data-group-id="1116447559-1">)</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Ref</span><span class="o">&lt;</span><span class="mf">0.1662103692</span><span class="p">.</span><span class="mf">2407923716.214197</span><span class="o">&gt;</span><span class="w">
</span><span class="mi">48</span><span class="o">&gt;</span><span class="w"> </span><span class="nc">ets</span><span class="p">:</span><span class="nf">insert</span><span class="p" data-group-id="1116447559-3">(</span><span class="p" data-group-id="1116447559-4">{</span><span class="ss">d</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="1116447559-4">}</span><span class="p" data-group-id="1116447559-3">)</span><span class="p">.</span><span class="w">
</span><span class="o">*</span><span class="w"> </span><span class="ss">exception</span><span class="w"> </span><span class="nc">error</span><span class="p">:</span><span class="w"> </span><span class="ss">undefined</span><span class="w"> </span><span class="ss">function</span><span class="w"> </span><span class="nc">ets</span><span class="p">:</span><span class="ss">insert</span><span class="o">/</span><span class="mi">1</span></code></pre><p>Command 48 makes the same mistake as in command 43, but this time the evaluator process lives on. The single star at the beginning of the printout signals that the exception has been caught.</p><pre><code class="makeup erlang"><span class="mi">49</span><span class="o">&gt;</span><span class="w"> </span><span class="nc">ets</span><span class="p">:</span><span class="nf">insert</span><span class="p" data-group-id="0663109538-1">(</span><span class="n">E</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0663109538-2">{</span><span class="ss">d</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="0663109538-2">}</span><span class="p" data-group-id="0663109538-1">)</span><span class="p">.</span><span class="w">
</span><span class="ss">true</span></code></pre><p>Command 49 successfully inserts the tuple into the ETS table.</p><pre><code class="makeup erlang"><span class="mi">50</span><span class="o">&gt;</span><span class="w"> </span><span class="nc">ets</span><span class="p">:</span><span class="nf">insert</span><span class="p" data-group-id="3425260161-1">(</span><span class="p">#</span><span class="n">Ref</span><span class="o">&lt;</span><span class="mf">0.1662103692</span><span class="p">.</span><span class="mf">2407923716.214197</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3425260161-2">{</span><span class="ss">e</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="3425260161-2">}</span><span class="p" data-group-id="3425260161-1">)</span><span class="p">.</span><span class="w">
</span><span class="ss">true</span></code></pre><p>Command 50 inserts another tuple into the ETS table. This time the first argument is the table identifier itself. The shell can parse commands with pids (<code>&lt;0.60.0&gt;</code>), ports (<code>#Port&lt;0.536&gt;</code>), references (<code>#Ref&lt;0.1662103692.2407792644.214210&gt;</code>), and external functions (<code>#Fun&lt;a.b.1&gt;</code>), but the command fails unless the corresponding pid, port, reference, or function can be created in the running system.</p><pre><code class="makeup erlang"><span class="mi">51</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">halt</span><span class="p" data-group-id="2265068580-1">(</span><span class="p" data-group-id="2265068580-1">)</span><span class="p">.</span><span class="w">
</span><span class="ss">strider</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span></code></pre><p>Command 51 exits the Erlang runtime system.</p><h2 id="module-jcl-mode" class="section-heading">
  <a href="#module-jcl-mode" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  JCL Mode
</h2>
<p>When the shell starts, it starts a single evaluator process. This process, together with any local processes that it spawns, is referred to as a <code>job</code>. Only the current job, which is said to be <code>connected</code>, can perform operations with standard I/O. All other jobs, which are said to be <code>detached</code>, are <code>blocked</code> if they attempt to use standard I/O.</p><p>All jobs that do not use standard I/O run in the normal way.</p><p>The shell escape key <code>^G</code> (Control G) detaches the current job and activates <code>JCL</code> mode. The <code>JCL</code> mode prompt is <code>&quot;--&gt;&quot;</code>. If <code>&quot;?&quot;</code> is entered at the prompt, the following help message is displayed:</p><pre><code class="makeup erlang"><span class="o">--</span><span class="o">&gt;</span><span class="w"> </span><span class="o">?</span><span class="w">
</span><span class="ss">c</span><span class="w"> </span><span class="p" data-group-id="7216233112-1">[</span><span class="ss">nn</span><span class="p" data-group-id="7216233112-1">]</span><span class="w">            </span><span class="o">-</span><span class="w"> </span><span class="ss">connect</span><span class="w"> </span><span class="ss">to</span><span class="w"> </span><span class="ss">job</span><span class="w">
</span><span class="ss">i</span><span class="w"> </span><span class="p" data-group-id="7216233112-2">[</span><span class="ss">nn</span><span class="p" data-group-id="7216233112-2">]</span><span class="w">            </span><span class="o">-</span><span class="w"> </span><span class="ss">interrupt</span><span class="w"> </span><span class="ss">job</span><span class="w">
</span><span class="ss">k</span><span class="w"> </span><span class="p" data-group-id="7216233112-3">[</span><span class="ss">nn</span><span class="p" data-group-id="7216233112-3">]</span><span class="w">            </span><span class="o">-</span><span class="w"> </span><span class="ss">kill</span><span class="w"> </span><span class="ss">job</span><span class="w">
</span><span class="ss">j</span><span class="w">                 </span><span class="o">-</span><span class="w"> </span><span class="ss">list</span><span class="w"> </span><span class="ss">all</span><span class="w"> </span><span class="ss">jobs</span><span class="w">
</span><span class="ss">s</span><span class="w"> </span><span class="p" data-group-id="7216233112-4">[</span><span class="ss">shell</span><span class="p" data-group-id="7216233112-4">]</span><span class="w">         </span><span class="o">-</span><span class="w"> </span><span class="ss">start</span><span class="w"> </span><span class="ss">local</span><span class="w"> </span><span class="ss">shell</span><span class="w">
</span><span class="ss">r</span><span class="w"> </span><span class="p" data-group-id="7216233112-5">[</span><span class="nb">node</span><span class="w"> </span><span class="p" data-group-id="7216233112-6">[</span><span class="ss">shell</span><span class="p" data-group-id="7216233112-6">]</span><span class="p" data-group-id="7216233112-5">]</span><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="ss">start</span><span class="w"> </span><span class="ss">remote</span><span class="w"> </span><span class="ss">shell</span><span class="w">
</span><span class="ss">q</span><span class="w">                 </span><span class="o">-</span><span class="w"> </span><span class="ss">quit</span><span class="w"> </span><span class="ss">erlang</span><span class="w">
</span><span class="o">?</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="ss">h</span><span class="w">             </span><span class="o">-</span><span class="w"> </span><span class="ss">this</span><span class="w"> </span><span class="ss">message</span></code></pre><p>The <code>JCL</code> commands have the following meaning:</p><dl><dt><code>c [nn]</code></dt><dd><p>Connects to job number <code>&lt;nn&gt;</code> or the current job. The standard shell is resumed. Operations that use standard I/O by the current job are interleaved with user inputs to the shell.</p></dd><dt><code>i [nn]</code></dt><dd><p>Stops the current evaluator process for job number <code>nn</code> or the current job, but does not kill the shell process. So, any variable bindings and the process dictionary are preserved and the job can be connected again. This command can be used to interrupt an endless loop.</p></dd><dt><code>k [nn]</code></dt><dd><p>Kills job number <code>nn</code> or the current job. All spawned processes in the job are killed, provided they have not evaluated the <code>group_leader/1</code> BIF and are located on the local machine. Processes spawned on remote nodes are not killed.</p></dd><dt><code>j</code></dt><dd><p>Lists all jobs. A list of all known jobs is printed. The current job name is prefixed with '*'.</p></dd><dt><code>s</code></dt><dd><p>Starts a new job. This is assigned the new index <code>[nn]</code>, which can be used in references.</p></dd><dt><code>s [shell]</code></dt><dd><p>Starts a new job. This is assigned the new index <code>[nn]</code>, which can be used in references. If optional argument <code>shell</code> is specified, it is assumed to be a module that implements an alternative shell.</p></dd><dt><code>r [node]</code></dt><dd><p>Starts a remote job on <code>node</code>. This is used in distributed Erlang to allow a shell running on one node to control a number of applications running on a network of nodes. If optional argument <code>shell</code> is specified, it is assumed to be a module that implements an alternative shell.</p></dd><dt><code>q</code></dt><dd><p>Quits Erlang. Notice that this option is disabled if Erlang is started with the ignore break, <code>+Bi</code>, system flag (which can be useful, for example when running a restricted shell, see the next section).</p></dd><dt><code>?</code></dt><dd><p>Displays the help message above.</p></dd></dl><p>The behavior of shell escape can be changed by the STDLIB application variable <code>shell_esc</code>. The value of the variable can be either <code>jcl</code> (<code>erl -stdlib shell_esc jcl</code>) or <code>abort</code> (<code>erl -stdlib shell_esc abort</code>). The first option sets <code>^G</code> to activate <code>JCL</code> mode (which is also default behavior). The latter sets <code>^G</code> to terminate the current shell and start a new one. <code>JCL</code> mode cannot be invoked when <code>shell_esc</code> is set to <code>abort</code>.</p><p>If you want an Erlang node to have a remote job active from the start (rather than the default local job), start Erlang with flag <code>-remsh</code>, for example, <code>erl -remsh other_node@other_host</code></p><h2 id="module-restricted-shell" class="section-heading">
  <a href="#module-restricted-shell" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Restricted Shell
</h2>
<p>The shell can be started in a restricted mode. In this mode, the shell evaluates a function call only if allowed. This feature makes it possible to, for example, prevent a user from accidentally calling a function from the prompt that could harm a running system (useful in combination with system flag <code>+Bi</code>).</p><p>When the restricted shell evaluates an expression and encounters a function call or an operator application, it calls a callback function (with information about the function call in question). This callback function returns <code>true</code> to let the shell go ahead with the evaluation, or <code>false</code> to abort it. There are two possible callback functions for the user to implement:</p><ul><li><p><code>local_allowed(Func, ArgList, State) -&gt; {boolean(),NewState}</code></p><p>This is used to determine if the call to the local function <code>Func</code> with arguments <code>ArgList</code> is to be allowed.</p></li><li><p><code>non_local_allowed(FuncSpec, ArgList, State) -&gt; {boolean(),NewState} | {{redirect,NewFuncSpec,NewArgList},NewState}</code></p><p>This is used to determine if the call to non-local function <code>FuncSpec</code> (<code>{Module,Func}</code> or a fun) with arguments <code>ArgList</code> is to be allowed. The return value <code>{redirect,NewFuncSpec,NewArgList}</code> can be used to let the shell evaluate some other function than the one specified by <code>FuncSpec</code> and <code>ArgList</code>.</p></li></ul><p>These callback functions are called from local and non-local evaluation function handlers, described in the <a href="erl_eval.html"><code>erl_eval</code></a> manual page. (Arguments in <code>ArgList</code> are evaluated before the callback functions are called.)</p><p>Argument <code>State</code> is a tuple <code>{ShellState,ExprState}</code>. The return value <code>NewState</code> has the same form. This can be used to carry a state between calls to the callback functions. Data saved in <code>ShellState</code> lives through an entire shell session. Data saved in <code>ExprState</code> lives only through the evaluation of the current expression.</p><p>There are two ways to start a restricted shell session:</p><ul><li><p>Use STDLIB application variable <code>restricted_shell</code> and specify, as its value, the name of the callback module. Example (with callback functions implemented in <code>callback_mod.erl</code>): <code>$ erl -stdlib restricted_shell callback_mod</code>.</p></li><li><p>From a normal shell session, call function <a href="#start_restricted/1"><code>start_restricted/1</code></a>. This exits the current evaluator and starts a new one in restricted mode.</p></li></ul><p><em>Notes:</em></p><ul><li><p>When restricted shell mode is activated or deactivated, new jobs started on the node run in restricted or normal mode, respectively.</p></li><li><p>If restricted mode has been enabled on a particular node, remote shells connecting to this node also run in restricted mode.</p></li><li><p>The callback functions cannot be used to allow or disallow execution of functions called from compiled code (only functions called from expressions entered at the shell prompt).</p></li></ul><p>Errors when loading the callback module is handled in different ways depending on how the restricted shell is activated:</p><ul><li><p>If the restricted shell is activated by setting the STDLIB variable during emulator startup, and the callback module cannot be loaded, a default restricted shell allowing only the commands <code>q()</code> and <code>init:stop()</code> is used as fallback.</p></li><li><p>If the restricted shell is activated using <a href="#start_restricted/1"><code>start_restricted/1</code></a> and the callback module cannot be loaded, an error report is sent to the error logger and the call returns <code>{error,Reason}</code>.</p></li></ul><h2 id="module-prompting" class="section-heading">
  <a href="#module-prompting" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Prompting
</h2>
<p>The default shell prompt function displays the name of the node (if the node can be part of a distributed system) and the current command number. The user can customize the prompt function by calling <a href="#prompt_func/1"><code>prompt_func/1</code></a> or by setting application configuration parameter <code>shell_prompt_func</code> for the STDLIB application.</p><p>A customized prompt function is stated as a tuple <code>{Mod,Â Func}</code>. The function is called as <code>Mod:Func(L)</code>, where <code>L</code> is a list of key-value pairs created by the shell. Currently there is only one pair: <code>{history, N}</code>, where <code>N</code> is the current command number. The function is to return a list of characters or an atom. This constraint is because of the Erlang I/O protocol. Unicode characters beyond code point 255 are allowed in the list and the atom. Notice that in restricted mode the call <code>Mod:Func(L)</code> must be allowed or the default shell prompt function is called.</p>
        </section>


        <section id="summary" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#summary">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
            Summary
          </h1>

  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#catch_exception/1">catch_exception(Bool) -&gt; boolean()</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">Bool = boolean()</li></ul><p>Sets the exception handling of the evaluator process. The previous exception handling is returned. The default (<code>false</code>) is to kill the evaluator process when an exception occurs, which causes the shell to create a new evaluator process. When the exception handling is set to <code>true</code>, the evaluator process lives on, which means that, for example, ports and ETS tables as well as processes linked to the evaluator process survive the exception.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#history/1">history/1</a>

  </div>

    <div class="summary-synopsis"><p>Sets the number of previous commands to keep in the history list to <code>N</code>. The previous number is returned. Defaults to 20.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#prompt_func/1">prompt_func/1</a>

  </div>

    <div class="summary-synopsis"><p>Sets the shell prompt function to <code>PromptFunc</code>. The previous prompt function is returned.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#results/1">results/1</a>

  </div>

    <div class="summary-synopsis"><p>Sets the number of results from previous commands to keep in the history list to <code>N</code>. The previous number is returned. Defaults to 20.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#start_restricted/1">start_restricted/1</a>

  </div>

    <div class="summary-synopsis"><p>Exits a normal shell and starts a restricted shell. <code>Module</code> specifies the callback module for the functions <code>local_allowed/3</code> and <code>non_local_allowed/3</code>. The function is meant to be called from the shell.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#stop_restricted/0">stop_restricted/0</a>

  </div>

    <div class="summary-synopsis"><p>Exits a restricted shell and starts a normal shell. The function is meant to be called from the shell.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#strings/1">strings/1</a>

  </div>

    <div class="summary-synopsis"><p>Sets pretty printing of lists to <code>Strings</code>. The previous value of the flag is returned.</p></div>

</div>

  </div>

        </section>


        <section id="functions" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#functions">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Functions
          </h1>
          <div class="functions-list">
<section class="detail" id="catch_exception/1">

  <div class="detail-header">
    <a href="#catch_exception/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">catch_exception(Bool) -&gt; boolean()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>catch_exception(Bool) -> boolean() when Bool :: boolean().</pre>

      </div>

<ul class="types"><li class="type">Bool = boolean()</li></ul><p>Sets the exception handling of the evaluator process. The previous exception handling is returned. The default (<code>false</code>) is to kill the evaluator process when an exception occurs, which causes the shell to create a new evaluator process. When the exception handling is set to <code>true</code>, the evaluator process lives on, which means that, for example, ports and ETS tables as well as processes linked to the evaluator process survive the exception.</p>
  </section>
</section>
<section class="detail" id="history/1">

  <div class="detail-header">
    <a href="#history/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">history/1</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>history(N) -> non_neg_integer() when N :: non_neg_integer().</pre>

      </div>

<p>Sets the number of previous commands to keep in the history list to <code>N</code>. The previous number is returned. Defaults to 20.</p>
  </section>
</section>
<section class="detail" id="prompt_func/1">

  <div class="detail-header">
    <a href="#prompt_func/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">prompt_func/1</h1>


      <span class="note">(since OTP R13B04)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>prompt_func(PromptFunc) -> PromptFunc2
               when
                   PromptFunc :: default | {module(), atom()},
                   PromptFunc2 :: default | {module(), atom()}.</pre>

      </div>

<p>Sets the shell prompt function to <code>PromptFunc</code>. The previous prompt function is returned.</p>
  </section>
</section>
<section class="detail" id="results/1">

  <div class="detail-header">
    <a href="#results/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">results/1</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>results(N) -> non_neg_integer() when N :: non_neg_integer().</pre>

      </div>

<p>Sets the number of results from previous commands to keep in the history list to <code>N</code>. The previous number is returned. Defaults to 20.</p>
  </section>
</section>
<section class="detail" id="start_restricted/1">

  <div class="detail-header">
    <a href="#start_restricted/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">start_restricted/1</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>start_restricted(Module) -> {error, Reason}
                    when Module :: module(), Reason :: <a href="https://wojtekmach.pl/otp_docs/kernel/code.html#t:load_error_rsn/0">code:load_error_rsn</a>().</pre>

      </div>

<p>Exits a normal shell and starts a restricted shell. <code>Module</code> specifies the callback module for the functions <code>local_allowed/3</code> and <code>non_local_allowed/3</code>. The function is meant to be called from the shell.</p><p>If the callback module cannot be loaded, an error tuple is returned. The <code>Reason</code> in the error tuple is the one returned by the code loader when trying to load the code of the callback module.</p>
  </section>
</section>
<section class="detail" id="stop_restricted/0">

  <div class="detail-header">
    <a href="#stop_restricted/0" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">stop_restricted/0</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>stop_restricted() -> no_return().</pre>

      </div>

<p>Exits a restricted shell and starts a normal shell. The function is meant to be called from the shell.</p>
  </section>
</section>
<section class="detail" id="strings/1">

  <div class="detail-header">
    <a href="#strings/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">strings/1</h1>


      <span class="note">(since OTP R16B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>strings(Strings) -> Strings2 when Strings :: boolean(), Strings2 :: boolean().</pre>

      </div>

<p>Sets pretty printing of lists to <code>Strings</code>. The previous value of the flag is returned.</p><p>The flag can also be set by the STDLIB application variable <code>shell_strings</code>. Defaults to <code>true</code>, which means that lists of integers are printed using the string syntax, when possible. Value <code>false</code> means that no lists are printed using the string syntax.</p>
  </section>
</section>

          </div>
        </section>

      <footer class="footer">

        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.25.1) for the
            <a href="https://elixir-lang.org" title="Elixir" target="_blank">Elixir programming language</a>.
          </span>
          <span class="line">
            Designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>

            <a href="api-reference.html" title="API reference" class="line footer-button">API Reference</a>

          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button display-quick-switch">
            Go to a HexDocs package
          </button>
          <button class="line footer-button tooltips-toggle">
            <span class="tooltips-option-disable">Disable tooltips</span>
            <span class="tooltips-option-enable">Enable tooltips</span>
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
