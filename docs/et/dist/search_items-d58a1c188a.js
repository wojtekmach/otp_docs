searchNodes=[{"doc":"Interface module for the Event Trace (ET) application","ref":"et.html","title":"et","type":"module"},{"doc":"These functions sends a signal to the outer space and the caller hopes that someone is listening. In other words, they invoke et:trace_me/4 and et:trace_me/5 respectively.","ref":"et.html#phone_home/4","title":"et.phone_home/4","type":"function"},{"doc":"","ref":"et.html#phone_home/5","title":"et.phone_home/5","type":"function"},{"doc":"Deprecated functions which for the time being are kept for backwards compatibility. Invokes et:trace_me/4 and et:trace_me/5 respectively.","ref":"et.html#report_event/4","title":"et.report_event/4","type":"function"},{"doc":"","ref":"et.html#report_event/5","title":"et.report_event/5","type":"function"},{"doc":"Invokes et:trace_me/5 with both From and To set to FromTo .","ref":"et.html#trace_me/4","title":"et.trace_me/4","type":"function"},{"doc":"DetailLevel = integer(X) when X =&lt; 0, X &gt;= 100 From = actor() To = actor() Label = atom() | string() | term() Contents = [{Key, Value}] | term() actor() = term() A function that is intended to be traced. This function is intended to be invoked at strategic places in user applications in order to enable simplified tracing. The functions are extremely light weight as they do nothing besides returning an atom. The functions are designed for being traced. The global tracing mechanism in et_collector defaults to set its trace pattern to these functions. The label is intended to provide a brief summary of the event. It is preferred to use an atom but a string would also do. The contents can be any term but in order to simplify post processing of the traced events, a plain list of {Key, Value} tuples is preferred. Some events, such as messages, are directed from some actor to another. Other events (termed actions) may be undirected and only have one actor.","ref":"et.html#trace_me/5","title":"et.trace_me/5","type":"function"},{"doc":"Interface module for the Event Trace (ET) application","ref":"et_collector.html","title":"et_collector","type":"module"},{"doc":"CollectorPid = pid() RawPattern = {report_module(), extended_dbg_match_spec()} report_module() = atom() | undefined extended_dbg_match_spec() = detail_level() | dbg_match_spec() RawPattern = detail_level() detail_level() = min | max | integer(X) when X =&lt; 0, X &gt;= 100 TracePattern = {report_module(), dbg_match_spec_match_spec()} Change active trace pattern globally on all trace nodes.","ref":"et_collector.html#change_pattern/2","title":"et_collector.change_pattern/2","type":"function"},{"doc":"Handle = collector_pid() | table_handle() collector_pid() = pid() table_handle() = record(table_handle) Clear the event table.","ref":"et_collector.html#clear_table/1","title":"et_collector.clear_table/1","type":"function"},{"doc":"CollectorPid = pid() SubscriberPid = pid() Key = {subscriber, SubscriberPid} | term() Delete a dictionary entry and send a {et, {dict_delete, Key}} tuple to all registered subscribers. If the deleted entry is a registered subscriber, it will imply that the subscriber process gets is unregistered as subscriber as well as it gets it final message.","ref":"et_collector.html#dict_delete/2","title":"et_collector.dict_delete/2","type":"function"},{"doc":"CollectorPid = pid() FilterFun = filter_fun() SubscriberPid = pid() Void = term() Key = term() Val = term() Insert a dictionary entry and send a {et, {dict_insert, Key, Val}} tuple to all registered subscribers. If the entry is a new subscriber, it will imply that the new subscriber process first will get one message for each already stored dictionary entry, before it and all old subscribers will get this particular entry. The collector process links to and then supervises the subscriber process. If the subscriber process dies it will imply that it gets unregistered as with a normal dict_delete/2.","ref":"et_collector.html#dict_insert/3","title":"et_collector.dict_insert/3","type":"function"},{"doc":"CollectorPid = pid() FilterFun = filter_fun() CollectorPid = pid() Key = term() Val = term() Lookup a dictionary entry and return zero or one value.","ref":"et_collector.html#dict_lookup/2","title":"et_collector.dict_lookup/2","type":"function"},{"doc":"CollectorPid = pid() Pattern = '_' | {key_pattern(), val_pattern()} key_pattern() = ets_match_object_pattern() val_pattern() = ets_match_object_pattern() Match = {key(), val()} key() = term() val() = term() Match some dictionary entries","ref":"et_collector.html#dict_match/2","title":"et_collector.dict_match/2","type":"function"},{"doc":"CollectorPid = pid() Reason = term() Return a the identity of the globally registered collector if there is any.","ref":"et_collector.html#get_global_pid/0","title":"et_collector.get_global_pid/0","type":"function"},{"doc":"Short for iterate(Handle, Prev, Limit, undefined, Prev) -&gt; NewAcc","ref":"et_collector.html#iterate/3","title":"et_collector.iterate/3","type":"function"},{"doc":"Handle = collector_pid() | table_handle() Prev = first | last | event_key() Limit = done() | forward() | backward() collector_pid() = pid() table_handle() = record(table_handle) event_key() = record(event) | record(event_ts) | record(trace_ts) done() = 0 forward() = infinity | integer(X) where X &gt; 0 backward() = '-infinity' | integer(X) where X &lt; 0 Fun = fun(Event, Acc) -&gt; NewAcc Acc = NewAcc = term() Iterate over the currently stored events. Iterates over the currently stored events and applies a function for each event. The iteration may be performed forwards or backwards and may be limited to a maximum number of events (abs(Limit)).","ref":"et_collector.html#iterate/5","title":"et_collector.iterate/5","type":"function"},{"doc":"Type = record(table_handle) | trace_ts | event_ts Stuff = record(event) | Key Key = record(event_ts) | record(trace_ts) Make a key out of an event record or an old key.","ref":"et_collector.html#make_key/2","title":"et_collector.make_key/2","type":"function"},{"doc":"CollectorPid = pid() CollectorPid = pid() Msg = term() Sends a message to all registered subscribers.","ref":"et_collector.html#multicast/2","title":"et_collector.multicast/2","type":"function"},{"doc":"Handle = Initial | Continuation Initial = collector_pid() collector_pid() = pid() Continuation = record(table_handle) TraceOrEvent = record(event) | dbg_trace_tuple() | end_of_trace Reason = term() DetailLevel = integer(X) when X =&lt; 0, X &gt;= 100 From = actor() To = actor() FromTo = actor() Label = atom() | string() | term() Contents = [{Key, Value}] | term() actor() = term() Report an event to the collector. All events are filtered thru the collector filter, which optionally may transform or discard the event. The first call should use the pid of the collector process as report handle, while subsequent calls should use the table handle.","ref":"et_collector.html#report/2","title":"et_collector.report/2","type":"function"},{"doc":"","ref":"et_collector.html#report_event/5","title":"et_collector.report_event/5","type":"function"},{"doc":"","ref":"et_collector.html#report_event/6","title":"et_collector.report_event/6","type":"function"},{"doc":"CollectorPid = pid() FileName = string() Options = [option()] Reason = term() option() = event_option() | file_option() | table_option() event_option() = existing file_option() = write | append table_option() = keep | clear Save the events to a file. By default the currently stored events (existing) are written to a brand new file (write) and the events are kept (keep) after they have been written to the file. Instead of keeping the events after writing them to file, it is possible to remove all stored events after they have successfully written to file (clear). The options defaults to existing, write and keep.","ref":"et_collector.html#save_event_file/3","title":"et_collector.save_event_file/3","type":"function"},{"doc":"Options = [option()] option() = {parent_pid, pid()} | {event_order, event_order()} | {dict_insert, {filter, collector}, collector_fun()} | {dict_insert, {filter, event_filter_name()}, event_filter_fun()} | {dict_insert, {subscriber, pid()}, dict_val()} | {dict_insert, dict_key(), dict_val()} | {dict_delete, dict_key()} | {trace_client, trace_client()} | {trace_global, boolean()} | {trace_pattern, trace_pattern()} | {trace_port, integer()} | {trace_max_queue, integer()} event_order() = trace_ts | event_ts trace_pattern() = {report_module(), extended_dbg_match_spec()} | undefined report_module() = atom() | undefined extended_dbg_match_spec() = detail_level() | dbg_match_spec() detail_level() = min | max | integer(X) when X =&lt; 0, X &gt;= 100 trace_client() = {event_file, file_name()} | {dbg_trace_type(), dbg_trace_parameters()} file_name() = string() collector_fun() = trace_filter_fun() | event_filter_fun() trace_filter_fun() = fun(TraceData) -&gt; false | true | {true, NewEvent} event_filter_fun() = fun(Event) -&gt; false | true | {true, NewEvent} event_filter_name() = atom() TraceData = erlang_trace_data() Event = NewEvent = record(event) dict_key() = term() dict_val() = term() CollectorPid = pid() Reason = term() Start a collector process. The collector collects trace events and keeps them ordered by their timestamp. The timestamp may either reflect the time when the actual trace data was generated (trace_ts) or when the trace data was transformed into an event record (event_ts). If the time stamp is missing in the trace data (missing timestamp option to erlang:trace/4) the trace_ts will be set to the event_ts. Events are reported to the collector directly with the report function or indirectly via one or more trace clients. All reported events are first filtered thru the collector filter before they are stored by the collector. By replacing the default collector filter with a customized dito it is possible to allow any trace data as input. The collector filter is a dictionary entry with the predefined key {filter, collector} and the value is a fun of arity 1. See et_selector:make_event/1 for interface details, such as which erlang:trace/1 tuples that are accepted. The collector has a built-in dictionary service. Any term may be stored as value in the dictionary and bound to a unique key. When new values are inserted with an existing key, the new values will overwrite the existing ones. Processes may subscribe on dictionary updates by using {subscriber, pid()} as dictionary key. All dictionary updates will be propagated to the subscriber processes matching the pattern {{subscriber, '_'}, '_'} where the first '_' is interpreted as a pid(). In global trace mode, the collector will automatically start tracing on all connected Erlang nodes. When a node connects, a port tracer will be started on that node and a corresponding trace client on the collector node. Default values: parent_pid - self(). event_order - trace_ts. trace_global - false. trace_pattern - undefined. trace_port - 4711. trace_max_queue - 50.","ref":"et_collector.html#start_link/1","title":"et_collector.start_link/1","type":"function"},{"doc":"Type = dbg_trace_client_type() Parameters = dbg_trace_client_parameters() Pid = dbg_trace_client_pid() Load raw Erlang trace from a file, port or process.","ref":"et_collector.html#start_trace_client/3","title":"et_collector.start_trace_client/3","type":"function"},{"doc":"CollectorPid = pid() Stop a collector process.","ref":"et_collector.html#stop/1","title":"et_collector.stop/1","type":"function"},{"doc":"","ref":"et_selector.html","title":"et_selector","type":"module"},{"doc":"Pattern = detail_level() | empty_match_spec() | erlang_trace_pattern_match_spec() detail_level() = min | max | integer(X) when X &gt;= 0, X =&lt; 100 empty_match_spec() = [] Activates/deactivates tracing by changing the current trace pattern. min detail level deactivates tracing of calls to et:trace_me/4,5 max detail level activates tracing of all calls to et:trace_me/4,5 integer(X) detail level activates tracing of all calls to et:trace_me/4,5 whose detail level argument is lesser than X . An empty match spec deactivates tracing of calls to et:trace_me/4,5 Other match specs activates tracing of calls to et:trace_me/4,5 accordingly with erlang:trace_pattern/2 .","ref":"et_selector.html#change_pattern/1","title":"et_selector.change_pattern/1","type":"function"},{"doc":"RawPattern = detail_level() TracePattern = erlang_trace_pattern_match_spec() detail_level() = min | max | integer(X) when X &gt;= 0, X =&lt; 100 Makes a trace pattern suitable to feed change_pattern/1 Min detail level deactivates tracing of calls to et:trace_me/4,5 Max detail level activates tracing of all calls to et:trace_me/4,5 integer(X) detail level activates tracing of all calls to et:trace_me/4,5 whose detail level argument is lesser than X. See also erlang:trace_pattern/2 for more info about its match_spec()","ref":"et_selector.html#make_pattern/1","title":"et_selector.make_pattern/1","type":"function"},{"doc":"Mod = module_name() | undefined module_name() = atom() ValidTraceData = erlang_trace_data() | record(event) erlang_trace_data() = {trace, Pid, Label, Info} | {trace, Pid, Label, Info, Extra} | {trace_ts, Pid, Label, Info, ReportedTS} | {trace_ts, Pid, Label, Info, Extra, ReportedTS} | {seq_trace, Label, Info} | {seq_trace, Label, Info, ReportedTS} | {drop, NumberOfDroppedItems} Transforms trace data and makes an event record out of it. See erlang:trace/3 for more info about the semantics of the trace data. An event record consists of the following fields: detail_level Noise has a high level as opposed to essentials. trace_ts Time when the trace was generated. Same as event_ts if omitted in trace data. event_ts Time when the event record was created. from From actor, such as sender of a message. to To actor, such as receiver of message. label Label intended to provide a brief event summary. contents All nitty gritty details of the event. See et:trace_me/4 and et:trace_me/5 for details. Returns: {true, Event} where Event is an #event{} record representing the trace data true means that the trace data already is an event record and that it is valid as it is. No transformation is needed. false means that the trace data is uninteresting and should be dropped","ref":"et_selector.html#parse_event/2","title":"et_selector.parse_event/2","type":"function"},{"doc":"","ref":"et_viewer.html","title":"et_viewer","type":"module"},{"doc":"FileName() = string() ViewerPid = pid() Reason = term() Start a new event viewer and a corresponding collector and load them with trace events from a trace file.","ref":"et_viewer.html#file/1","title":"et_viewer.file/1","type":"function"},{"doc":"ViewerPid = pid() CollectorPid = pid() Returns the identifier of the collector process.","ref":"et_viewer.html#get_collector_pid/1","title":"et_viewer.get_collector_pid/1","type":"function"},{"doc":"Simplified start of a sequence chart viewer with global tracing activated. Convenient to be used from the command line (erl -s et_viewer).","ref":"et_viewer.html#start/0","title":"et_viewer.start/0","type":"function"},{"doc":"Start of a sequence chart viewer without linking to the parent process.","ref":"et_viewer.html#start/1","title":"et_viewer.start/1","type":"function"},{"doc":"Options = [option() | collector_option()] option() = {parent_pid, extended_pid()} | {title, term()} | {detail_level, detail_level()} | {is_suspended, boolean()} | {scale, integer()} | {width, integer()} | {height, integer()} | {collector_pid, extended_pid()} | {event_order, event_order()} | {active_filter, atom()} | {max_actors, extended_integer()} | {trace_pattern, et_collector_trace_pattern()} | {trace_port, et_collector_trace_port()} | {trace_global, et_collector_trace_global()} | {trace_client, et_collector_trace_client()} | {dict_insert, {filter, filter_name()}, event_filter_fun()} | {dict_insert, et_collector_dict_key(), et_collector_dict_val()} | {dict_delete, {filter, filter_name()}} | {dict_delete, et_collector_dict_key()} | {actors, actors()} | {first_event, first_key()} | {hide_unknown, boolean()} | {hide_actions, boolean()} | {display_mode, display_mode()} extended_pid() = pid() | undefined detail_level() = min | max | integer(X) when X &gt;=0, X =&lt; 100 event_order() = trace_ts | event_ts extended_integer() = integer() | infinity display_mode() = all | {search_actors, direction(), first_key(), actors()} direction() = forward | reverse first_key() = event_key() actors() = [term()] filter_name() = atom() filter_fun() = fun(Event) -&gt; false | true | {true, NewEvent} Event = NewEvent = record(event) ViewerPid = pid() Reason = term() Start a sequence chart viewer for trace events (messages/actions) A filter_fun() takes an event record as sole argument and returns false | true | {true, NewEvent}. If the collector_pid is undefined a new et_collector will be started with the following parameter settings: parent_pid , event_order , trace_global , trace_pattern , trace_port , trace_max_queue , trace_client , dict_insert and dict_delete . The new et_viewer will register itself as an et_collector subscriber. Default values: parent_pid - self(). title - &quot;et_viewer&quot;. detail_level - max. is_suspended - false. scale - 2. width - 800. height - 600. collector_pid - undefined. event_order - trace_ts. active_filter - collector. max_actors - 5. actors - [&quot;UNKNOWN&quot;]. first_event - first. hide_unknown - false. hide_actions - false. display_mode - all.","ref":"et_viewer.html#start_link/1","title":"et_viewer.start_link/1","type":"function"},{"doc":"ViewerPid = pid() Stops a viewer process.","ref":"et_viewer.html#stop/1","title":"et_viewer.stop/1","type":"function"}]