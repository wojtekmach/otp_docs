<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.25.1">
    <meta name="project" content="tftp v1.0.3">

    <title>tftp — tftp v1.0.3</title>
    <link rel="stylesheet" href="dist/erlang-951161c89561e05735a5.css" />

    <script src="dist/sidebar_items-fbdbbcaf2d.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-f97730d45ef67f3e6188.js"></script>


  </head>
  <body data-type="modules">
    <script>

      try {
        if (localStorage.getItem('night-mode') === 'true') {
          document.body.classList.add('night-mode');
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <span class="icon-search" aria-hidden="true" title="Submit search"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <span class="icon-cross" aria-hidden="true" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="api-reference.html" class="sidebar-projectName">
tftp
      </a>
      <strong class="sidebar-projectVersion">
        v1.0.3
      </strong>
    </div>

  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list-link" href="#full-list">Pages</a></li>

      <li><a id="modules-list-link" href="#full-list">Modules</a></li>


  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

      <h1>
tftp <small>behaviour</small> <small class="app-vsn">(tftp v1.0.3)</small>

      </h1>


        <section id="moduledoc">
<p>Interface module for the <code>tftp</code> application.</p><a id="options"></a><h2 id="module-data-types" class="section-heading">
  <a href="#module-data-types" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  DATA TYPES
</h2>
<p><code>ServiceConfig = Options</code></p><p><code>Options = [option()]</code></p><p>Most of the options are common for both the client and the server side, but some of them differs a little. The available <code>option()</code>s are as follows:</p><dl><dt><code>{debug, Level}</code></dt><dd><p><code>Level = none | error | warning | brief | normal | verbose | all</code></p><p>Controls the level of debug printouts. Default is <code>none</code>.</p></dd><dt><code>{host, Host}</code></dt><dd><p><code>Host = hostname()</code>, see <a href="https://wojtekmach.pl/otp_docs/kernel/inet.html">inet(3)</a>.</p><p>The name or IP address of the host where the TFTP daemon resides. This option is only used by the client.</p></dd><dt><code>{port, Port}</code></dt><dd><p><code>Port = int()</code></p><p>The TFTP port where the daemon listens. Defaults is the standardized number 69. On the server side, it can sometimes make sense to set it to 0, meaning that the daemon just picks a free port (which one is returned by function <code>info/1</code>).</p><p>If a socket is connected already, option <code>{udp, [{fd, integer()}]}</code> can be used to pass the open file descriptor to <code>gen_udp</code>. This can be automated by using a command-line argument stating the prebound file descriptor number. For example, if the port is 69 and file descriptor 22 is opened by <code>setuid_socket_wrap</code>, the command-line argument &quot;-tftpd_69 22&quot; triggers the prebound file descriptor 22 to be used instead of opening port 69. The UDP option <code>{udp, [{fd, 22}]}</code> is automatically added. See <code>init:get_argument/</code> about command-line arguments and <code>gen_udp:open/2</code> about UDP options.</p></dd><dt><code>{port_policy, Policy}</code></dt><dd><p><code>Policy = random | Port | {range, MinPort, MaxPort}</code></p><p><code>Port = MinPort = MaxPort = int()</code></p><p>Policy for the selection of the temporary port that is used by the server/client during the file transfer. Default is <code>random</code>, which is the standardized policy. With this policy a randomized free port is used. A single port or a range of ports can be useful if the protocol passes through a firewall.</p></dd><dt><code>{udp, Options}</code></dt><dd><p><code>Options = [Opt]</code>, see <a href="https://wojtekmach.pl/otp_docs/kernel/gen_udp.html#open/1">gen_udp:open/2</a>.</p></dd><dt><code>{use_tsize, Bool}</code></dt><dd><p><code>Bool = bool()</code></p><p>Flag for automated use of option <code>tsize</code>. With this set to <code>true</code>, the <code>write_file/3</code> client determines the filesize and sends it to the server as the standardized <code>tsize</code> option. A <code>read_file/3</code> client acquires only a filesize from the server by sending a zero <code>tsize</code>.</p></dd><dt><code>{max_tsize, MaxTsize}</code></dt><dd><p><code>MaxTsize = int() | infinity</code></p><p>Threshold for the maximal filesize in bytes. The transfer is aborted if the limit is exceeded. Default is <code>infinity</code>.</p></dd><dt><code>{max_conn, MaxConn}</code></dt><dd><p><code>MaxConn = int() | infinity</code></p><p>Threshold for the maximal number of active connections. The daemon rejects the setup of new connections if the limit is exceeded. Default is <code>infinity</code>.</p></dd><dt><code>{TftpKey, TftpVal}</code></dt><dd><p><code>TftpKey = string()</code><br/><code>TftpVal = string()</code></p><p>Name and value of a TFTP option.</p></dd><dt><code>{reject, Feature}</code></dt><dd><p><code>Feature = Mode | TftpKey</code><br/><code> Mode = read | write</code><br/><code> TftpKey = string()</code></p><p>Controls which features to reject. This is mostly useful for the server as it can restrict the use of certain TFTP options or read/write access.</p></dd><dt><code>{callback, {RegExp, Module, State}}</code></dt><dd><p><code>RegExp = string()</code><br/><code>Module = atom()</code><br/><code>State = term()</code></p><p>Registration of a callback module. When a file is to be transferred, its local filename is matched to the regular expressions of the registered callbacks. The first matching callback is used during the transfer. See <a href="tftp.html#read_file/3">read_file/3</a> and <a href="tftp.html#write_file/3">write_file/3</a>.</p><p>The callback module must implement the <code>tftp</code> behavior, see <a href="tftp.html#content#tftp_callback">CALLBACK FUNCTIONS</a>.</p></dd><dt><code>{logger, Module}</code></dt><dd><p><code>Module = module()</code></p><p>Callback module for customized logging of errors, warnings, and info messages. The callback module must implement the <code>tftp_logger</code> behavior, see <a href="tftp.html#content#tftp_logger">LOGGER FUNCTIONS</a>. The default module is <code>tftp_logger</code>.</p></dd><dt><code>{max_retries, MaxRetries}</code></dt><dd><p><code>MaxRetries = int()</code></p><p>Threshold for the maximal number of retries. By default the server/client tries to resend a message up to five times when the time-out expires.</p></dd></dl><a id="tftp_callback"></a><h2 id="module-callback-functions" class="section-heading">
  <a href="#module-callback-functions" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  CALLBACK FUNCTIONS
</h2>
<p>A <code>tftp</code> callback module is to be implemented as a <code>tftp</code> behavior and export the functions listed in the following.</p><p>On the server side, the callback interaction starts with a call to <code>open/5</code> with the registered initial callback state. <code>open/5</code> is expected to open the (virtual) file. Then either function <code>read/1</code> or <code>write/2</code> is invoked repeatedly, once per transferred block. At each function call, the state returned from the previous call is obtained. When the last block is encountered, function <code>read/1</code> or <code>write/2</code> is expected to close the (virtual) file and return its last state. Function <code>abort/3</code> is only used in error situations. Function <code>prepare/5</code> is not used on the server side.</p><p>On the client side, the callback interaction is the same, but it starts and ends a bit differently. It starts with a call to <code>prepare/5</code> with the same arguments as <code>open/5</code> takes. <code>prepare/5</code> is expected to validate the TFTP options suggested by the user and to return the subset of them that it accepts. Then the options are sent to the server, which performs the same TFTP option negotiation procedure. The options that are accepted by the server are forwarded to function <code>open/5</code> on the client side. On the client side, function <code>open/5</code> must accept all option as-is or reject the transfer. Then the callback interaction follows the same pattern as described for the server side. When the last block is encountered in <code>read/1</code> or <code>write/2</code>, the returned state is forwarded to the user and returned from <code>read_file</code>/3 or <code>write_file/3</code>.</p><p>If a callback (performing the file access in the TFTP server) takes too long time (more than the double TFTP time-out), the server aborts the connection and sends an error reply to the client. This implies that the server releases resources attached to the connection faster than before. The server simply assumes that the client has given up.</p><p>If the TFTP server receives yet another request from the same client (same host and port) while it already has an active connection to the client, it ignores the new request if the request is equal to the first one (same filename and options). This implies that the (new) client will be served by the already ongoing connection on the server side. By not setting up yet another connection, in parallel with the ongoing one, the server consumes less resources.</p><a id="prepare"></a>
        </section>


        <section id="summary" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#summary">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
            Summary
          </h1>

  <div class="summary-callbacks summary">
    <h2>
      <a href="#callbacks">Callbacks</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#c:abort/3">Module:abort(Code, Text, State) -&gt; ok</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">Code = undef | enoent | eacces | enospc</li><li class="type">  | badop | eexist | baduser | badopt</li><li class="type">  | int()</li><li class="type">Text = string()</li><li class="type">State = term()</li></ul><p>Invoked when the file transfer is aborted.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#c:error_msg/2">Logger:error_msg(Format, Data) -&gt; ok | exit(Reason)</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">Format = string()</li><li class="type">Data = [term()]</li><li class="type">Reason = term()</li></ul><p>Logs an error message. See <code>error_logger:error_msg/2</code> for details.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#c:info_msg/2">Logger:info_msg(Format, Data) -&gt; ok | exit(Reason)</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">Format = string()</li><li class="type">Data = [term()]</li><li class="type">Reason = term()</li></ul><p>Logs an info message. See <code>error_logger:info_msg/2</code> for details.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#c:open/6">Module:open(Peer, Access, Filename, Mode, SuggestedOptions, State) -&gt; {ok, AcceptedOptions, NewState} | {error, {Code, Text}}</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">Peer = {PeerType, PeerHost, PeerPort}</li><li class="type">PeerType = inet | inet6</li><li class="type">PeerHost = ip_address()</li><li class="type">PeerPort = integer()</li><li class="type">Access = read | write</li><li class="type">Filename = string()</li><li class="type">Mode = string()</li><li class="type">SuggestedOptions = AcceptedOptions = [{Key, Value}]</li><li class="type"> Key = Value = string()</li><li class="type">State = InitialState | term()</li><li class="type"> InitialState = [] | [{root_dir, string()}]</li><li class="type">NewState = term()</li><li class="type">Code = undef | enoent | eacces | enospc</li><li class="type">  | badop | eexist | baduser | badopt</li><li class="type">  | int()</li><li class="type">Text = string()</li></ul><p>Opens a file for read or write access.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#c:prepare/6">Module:prepare(Peer, Access, Filename, Mode, SuggestedOptions, InitialState) -&gt; {ok, AcceptedOptions, NewState} | {error, {Code, Text}}</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">Peer = {PeerType, PeerHost, PeerPort}</li><li class="type">PeerType = inet | inet6</li><li class="type">PeerHost = ip_address()</li><li class="type">PeerPort = integer()</li><li class="type">Access = read | write</li><li class="type">Filename = string()</li><li class="type">Mode = string()</li><li class="type">SuggestedOptions = AcceptedOptions = [{Key, Value}]</li><li class="type"> Key = Value = string()</li><li class="type">InitialState = [] | [{root_dir, string()}]</li><li class="type">NewState = term()</li><li class="type">Code = undef | enoent | eacces | enospc</li><li class="type">  | badop | eexist | baduser | badopt</li><li class="type">  | int()</li><li class="type">Text = string()</li></ul><p>Prepares to open a file on the client side.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#c:read/1">Module:read(State) -&gt; {more, Bin, NewState} | {last, Bin, FileSize} | {error, {Code, Text}}</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">State = NewState = term()</li><li class="type">Bin = binary()</li><li class="type">FileSize = int()</li><li class="type">Code = undef | enoent | eacces | enospc</li><li class="type">  | badop | eexist | baduser | badopt</li><li class="type">  | int()</li><li class="type">Text = string()</li></ul><p>Reads a chunk from the file.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#c:warning_msg/2">Logger:warning_msg(Format, Data) -&gt; ok | exit(Reason)</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">Format = string()</li><li class="type">Data = [term()]</li><li class="type">Reason = term()</li></ul><p>Logs a warning message. See <code>error_logger:warning_msg/2</code> for details.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#c:write/2">Module:write(Bin, State) -&gt; {more, NewState} | {last, FileSize} | {error, {Code, Text}}</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">Bin = binary()</li><li class="type">State = NewState = term()</li><li class="type">FileSize = int()</li><li class="type">Code = undef | enoent | eacces | enospc</li><li class="type">  | badop | eexist | baduser | badopt</li><li class="type">  | int()</li><li class="type">Text = string()</li></ul><p>Writes a chunk to the file.</p></div>

</div>

  </div>

  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#change_config/2">change_config(daemons, Options) -&gt; [{Pid, Result}]</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">Options = [option()]</li><li class="type">Pid = pid()</li><li class="type">Result = ok | {error, Reason}</li><li class="type">Reason = term()</li></ul><p>Changes configuration for all TFTP daemon processes.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#change_config/2">change_config(servers, Options) -&gt; [{Pid, Result}]</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">Options = [option()]</li><li class="type">Pid = pid()</li><li class="type">Result = ok | {error, Reason}</li><li class="type">Reason = term()</li></ul><p>Changes configuration for all TFTP server processes.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#change_config/2">change_config(Pid, Options) -&gt; Result</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">Pid = pid()</li><li class="type">Options = [option()]</li><li class="type">Result = ok | {error, Reason}</li><li class="type">Reason = term()</li></ul><p>Changes configuration for a TFTP daemon, server, or client process.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#info/1">info(daemons) -&gt; [{Pid, Options}]</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">Pid = [pid()]</li><li class="type">Options = [option()]</li><li class="type">Reason = term()</li></ul><p>Returns information about all TFTP daemon processes.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#info/1">info(servers) -&gt; [{Pid, Options}]</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">Pid = [pid()]</li><li class="type">Options = [option()]</li><li class="type">Reason = term()</li></ul><p>Returns information about all TFTP server processes.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#info/1">info(Pid) -&gt; {ok, Options} | {error, Reason}</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">Options = [option()]</li><li class="type">Reason = term()</li></ul><p>Returns information about a TFTP daemon, server, or client process.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#read_file/3">read_file(RemoteFilename, LocalFilename, Options) -&gt; {ok, LastCallbackState} | {error, Reason}</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">RemoteFilename = string()</li><li class="type">LocalFilename = binary | string()</li><li class="type">Options = [option()]</li><li class="type">LastCallbackState = term()</li><li class="type">Reason = term()</li></ul><p>Reads a (virtual) file <code>RemoteFilename</code> from a TFTP server.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#start/1">start(Options) -&gt; {ok, Pid} | {error, Reason}</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">Options = [option()]</li><li class="type">Pid = pid()</li><li class="type">Reason = term()</li></ul><p>Starts a daemon process listening for UDP packets on a port. When it receives a request for read or write, it spawns a temporary server process handling the actual transfer of the (virtual) file.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#write_file/3">write_file(RemoteFilename, LocalFilename, Options) -&gt; {ok, LastCallbackState} | {error, Reason}</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li class="type">RemoteFilename = string()</li><li class="type">LocalFilename = binary() | string()</li><li class="type">Options = [option()]</li><li class="type">LastCallbackState = term()</li><li class="type">Reason = term()</li></ul><p>Writes a (virtual) file <code>RemoteFilename</code> to a TFTP server.</p></div>

</div>

  </div>

        </section>


        <section id="callbacks" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#callbacks">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Callbacks
          </h1>
          <div class="callbacks-list">
<section class="detail" id="c:abort/3">

  <div class="detail-header">
    <a href="#c:abort/3" class="detail-link" title="Link to this callback">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this callback</span>
    </a>
    <h1 class="signature">Module:abort(Code, Text, State) -&gt; ok</h1>


      <span class="note">(since OTP 18.1)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>abort(Code :: <a href="#t:error_code/0">error_code</a>(), string(), State :: term()) -> ok.</pre>

      </div>

<ul class="types"><li class="type">Code = undef | enoent | eacces | enospc</li><li class="type">  | badop | eexist | baduser | badopt</li><li class="type">  | int()</li><li class="type">Text = string()</li><li class="type">State = term()</li></ul><p>Invoked when the file transfer is aborted.</p><p>The callback function is expected to clean up its used resources after the aborted file transfer, such as closing open file descriptors and so on. The function is not invoked if any of the other callback functions returns an error, as it is expected that they already have cleaned up the necessary resources. However, it is invoked if the functions fail (crash).</p>
  </section>
</section>
<section class="detail" id="c:error_msg/2">

  <div class="detail-header">
    <a href="#c:error_msg/2" class="detail-link" title="Link to this callback">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this callback</span>
    </a>
    <h1 class="signature">Logger:error_msg(Format, Data) -&gt; ok | exit(Reason)</h1>


      <span class="note">(since OTP 18.1)</span>

  </div>

  <section class="docstring">

<ul class="types"><li class="type">Format = string()</li><li class="type">Data = [term()]</li><li class="type">Reason = term()</li></ul><p>Logs an error message. See <code>error_logger:error_msg/2</code> for details.</p><a id="warning_msg"></a>
  </section>
</section>
<section class="detail" id="c:info_msg/2">

  <div class="detail-header">
    <a href="#c:info_msg/2" class="detail-link" title="Link to this callback">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this callback</span>
    </a>
    <h1 class="signature">Logger:info_msg(Format, Data) -&gt; ok | exit(Reason)</h1>


      <span class="note">(since OTP 18.1)</span>

  </div>

  <section class="docstring">

<ul class="types"><li class="type">Format = string()</li><li class="type">Data = [term()]</li><li class="type">Reason = term()</li></ul><p>Logs an info message. See <code>error_logger:info_msg/2</code> for details.</p>
  </section>
</section>
<section class="detail" id="c:open/6">

  <div class="detail-header">
    <a href="#c:open/6" class="detail-link" title="Link to this callback">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this callback</span>
    </a>
    <h1 class="signature">Module:open(Peer, Access, Filename, Mode, SuggestedOptions, State) -&gt; {ok, AcceptedOptions, NewState} | {error, {Code, Text}}</h1>


      <span class="note">(since OTP 18.1)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>open(Peer :: <a href="#t:peer/0">peer</a>(),
     Access :: <a href="#t:access/0">access</a>(),
     Filename :: <a href="https://wojtekmach.pl/otp_docs/kernel/file.html#t:name/0">file:name</a>(),
     Mode :: string(),
     SuggestedOptions :: <a href="#t:options/0">options</a>(),
     State :: [] | [{root_dir, string()}] | term()) ->
        {ok, AcceptedOptions :: <a href="#t:options/0">options</a>(), NewState :: term()} |
        {error, {Code :: <a href="#t:error_code/0">error_code</a>(), string()}}.</pre>

      </div>

<ul class="types"><li class="type">Peer = {PeerType, PeerHost, PeerPort}</li><li class="type">PeerType = inet | inet6</li><li class="type">PeerHost = ip_address()</li><li class="type">PeerPort = integer()</li><li class="type">Access = read | write</li><li class="type">Filename = string()</li><li class="type">Mode = string()</li><li class="type">SuggestedOptions = AcceptedOptions = [{Key, Value}]</li><li class="type"> Key = Value = string()</li><li class="type">State = InitialState | term()</li><li class="type"> InitialState = [] | [{root_dir, string()}]</li><li class="type">NewState = term()</li><li class="type">Code = undef | enoent | eacces | enospc</li><li class="type">  | badop | eexist | baduser | badopt</li><li class="type">  | int()</li><li class="type">Text = string()</li></ul><p>Opens a file for read or write access.</p><p>On the client side, where the <code>open/5</code> call has been preceded by a call to <code>prepare/5</code>, all options must be accepted or rejected.</p><p>On the server side, where there is no preceding <code>prepare/5</code> call, no new options can be added, but those present in <code>SuggestedOptions</code> can be omitted or replaced with new values in <code>AcceptedOptions</code>.</p><a id="read"></a>
  </section>
</section>
<section class="detail" id="c:prepare/6">

  <div class="detail-header">
    <a href="#c:prepare/6" class="detail-link" title="Link to this callback">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this callback</span>
    </a>
    <h1 class="signature">Module:prepare(Peer, Access, Filename, Mode, SuggestedOptions, InitialState) -&gt; {ok, AcceptedOptions, NewState} | {error, {Code, Text}}</h1>


      <span class="note">(since OTP 18.1)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>prepare(Peer :: <a href="#t:peer/0">peer</a>(),
        Access :: <a href="#t:access/0">access</a>(),
        Filename :: <a href="https://wojtekmach.pl/otp_docs/kernel/file.html#t:name/0">file:name</a>(),
        Mode :: string(),
        SuggestedOptions :: <a href="#t:options/0">options</a>(),
        InitialState :: [] | [{root_dir, string()}]) ->
           {ok, AcceptedOptions :: <a href="#t:options/0">options</a>(), NewState :: term()} |
           {error, {Code :: <a href="#t:error_code/0">error_code</a>(), string()}}.</pre>

      </div>

<ul class="types"><li class="type">Peer = {PeerType, PeerHost, PeerPort}</li><li class="type">PeerType = inet | inet6</li><li class="type">PeerHost = ip_address()</li><li class="type">PeerPort = integer()</li><li class="type">Access = read | write</li><li class="type">Filename = string()</li><li class="type">Mode = string()</li><li class="type">SuggestedOptions = AcceptedOptions = [{Key, Value}]</li><li class="type"> Key = Value = string()</li><li class="type">InitialState = [] | [{root_dir, string()}]</li><li class="type">NewState = term()</li><li class="type">Code = undef | enoent | eacces | enospc</li><li class="type">  | badop | eexist | baduser | badopt</li><li class="type">  | int()</li><li class="type">Text = string()</li></ul><p>Prepares to open a file on the client side.</p><p>No new options can be added, but those present in <code>SuggestedOptions</code> can be omitted or replaced with new values in <code>AcceptedOptions</code>.</p><p>This is followed by a call to <code>open/4</code> before any read/write access is performed. <code>AcceptedOptions</code> is sent to the server, which replies with the options that it accepts. These are then forwarded to <code>open/4</code> as <code>SuggestedOptions</code>.</p><a id="open"></a>
  </section>
</section>
<section class="detail" id="c:read/1">

  <div class="detail-header">
    <a href="#c:read/1" class="detail-link" title="Link to this callback">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this callback</span>
    </a>
    <h1 class="signature">Module:read(State) -&gt; {more, Bin, NewState} | {last, Bin, FileSize} | {error, {Code, Text}}</h1>


      <span class="note">(since OTP 18.1)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>read(State :: term()) ->
        {more, binary(), NewState :: term()} |
        {last, binary(), integer()} |
        {error, {Code :: <a href="#t:error_code/0">error_code</a>(), string()}}.</pre>

      </div>

<ul class="types"><li class="type">State = NewState = term()</li><li class="type">Bin = binary()</li><li class="type">FileSize = int()</li><li class="type">Code = undef | enoent | eacces | enospc</li><li class="type">  | badop | eexist | baduser | badopt</li><li class="type">  | int()</li><li class="type">Text = string()</li></ul><p>Reads a chunk from the file.</p><p>The callback function is expected to close the file when the last file chunk is encountered. When an error is encountered, the callback function is expected to clean up after the aborted file transfer, such as closing open file descriptors, and so on. In both cases there will be no more calls to any of the callback functions.</p><a id="write"></a>
  </section>
</section>
<section class="detail" id="c:warning_msg/2">

  <div class="detail-header">
    <a href="#c:warning_msg/2" class="detail-link" title="Link to this callback">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this callback</span>
    </a>
    <h1 class="signature">Logger:warning_msg(Format, Data) -&gt; ok | exit(Reason)</h1>


      <span class="note">(since OTP 18.1)</span>

  </div>

  <section class="docstring">

<ul class="types"><li class="type">Format = string()</li><li class="type">Data = [term()]</li><li class="type">Reason = term()</li></ul><p>Logs a warning message. See <code>error_logger:warning_msg/2</code> for details.</p><a id="info_msg"></a>
  </section>
</section>
<section class="detail" id="c:write/2">

  <div class="detail-header">
    <a href="#c:write/2" class="detail-link" title="Link to this callback">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this callback</span>
    </a>
    <h1 class="signature">Module:write(Bin, State) -&gt; {more, NewState} | {last, FileSize} | {error, {Code, Text}}</h1>


      <span class="note">(since OTP 18.1)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>write(binary(), State :: term()) ->
         {more, NewState :: term()} |
         {last, FileSize :: integer()} |
         {error, {Code :: <a href="#t:error_code/0">error_code</a>(), string()}}.</pre>

      </div>

<ul class="types"><li class="type">Bin = binary()</li><li class="type">State = NewState = term()</li><li class="type">FileSize = int()</li><li class="type">Code = undef | enoent | eacces | enospc</li><li class="type">  | badop | eexist | baduser | badopt</li><li class="type">  | int()</li><li class="type">Text = string()</li></ul><p>Writes a chunk to the file.</p><p>The callback function is expected to close the file when the last file chunk is encountered. When an error is encountered, the callback function is expected to clean up after the aborted file transfer, such as closing open file descriptors, and so on. In both cases there will be no more calls to any of the callback functions.</p><a id="abort"></a>
  </section>
</section>

          </div>
        </section>

        <section id="functions" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#functions">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Functions
          </h1>
          <div class="functions-list">
<section class="detail" id="change_config/2">

  <div class="detail-header">
    <a href="#change_config/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">change_config(daemons, Options) -&gt; [{Pid, Result}]</h1>


  </div>

  <section class="docstring">

<ul class="types"><li class="type">Options = [option()]</li><li class="type">Pid = pid()</li><li class="type">Result = ok | {error, Reason}</li><li class="type">Reason = term()</li></ul><p>Changes configuration for all TFTP daemon processes.</p>
  </section>
</section>
<section class="detail" id="change_config/2">

  <div class="detail-header">
    <a href="#change_config/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">change_config(servers, Options) -&gt; [{Pid, Result}]</h1>


  </div>

  <section class="docstring">

<ul class="types"><li class="type">Options = [option()]</li><li class="type">Pid = pid()</li><li class="type">Result = ok | {error, Reason}</li><li class="type">Reason = term()</li></ul><p>Changes configuration for all TFTP server processes.</p>
  </section>
</section>
<section class="detail" id="change_config/2">

  <div class="detail-header">
    <a href="#change_config/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">change_config(Pid, Options) -&gt; Result</h1>


  </div>

  <section class="docstring">

<ul class="types"><li class="type">Pid = pid()</li><li class="type">Options = [option()]</li><li class="type">Result = ok | {error, Reason}</li><li class="type">Reason = term()</li></ul><p>Changes configuration for a TFTP daemon, server, or client process.</p>
  </section>
</section>
<section class="detail" id="info/1">

  <div class="detail-header">
    <a href="#info/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">info(daemons) -&gt; [{Pid, Options}]</h1>


  </div>

  <section class="docstring">

<ul class="types"><li class="type">Pid = [pid()]</li><li class="type">Options = [option()]</li><li class="type">Reason = term()</li></ul><p>Returns information about all TFTP daemon processes.</p>
  </section>
</section>
<section class="detail" id="info/1">

  <div class="detail-header">
    <a href="#info/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">info(servers) -&gt; [{Pid, Options}]</h1>


  </div>

  <section class="docstring">

<ul class="types"><li class="type">Pid = [pid()]</li><li class="type">Options = [option()]</li><li class="type">Reason = term()</li></ul><p>Returns information about all TFTP server processes.</p>
  </section>
</section>
<section class="detail" id="info/1">

  <div class="detail-header">
    <a href="#info/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">info(Pid) -&gt; {ok, Options} | {error, Reason}</h1>


  </div>

  <section class="docstring">

<ul class="types"><li class="type">Options = [option()]</li><li class="type">Reason = term()</li></ul><p>Returns information about a TFTP daemon, server, or client process.</p>
  </section>
</section>
<section class="detail" id="read_file/3">

  <div class="detail-header">
    <a href="#read_file/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">read_file(RemoteFilename, LocalFilename, Options) -&gt; {ok, LastCallbackState} | {error, Reason}</h1>


  </div>

  <section class="docstring">

<ul class="types"><li class="type">RemoteFilename = string()</li><li class="type">LocalFilename = binary | string()</li><li class="type">Options = [option()]</li><li class="type">LastCallbackState = term()</li><li class="type">Reason = term()</li></ul><p>Reads a (virtual) file <code>RemoteFilename</code> from a TFTP server.</p><p>If <code>LocalFilename</code> is the atom <code>binary</code>, <code>tftp_binary</code> is used as callback module. It concatenates all transferred blocks and returns them as one single binary in <code>LastCallbackState</code>.</p><p>If <code>LocalFilename</code> is a string and there are no registered callback modules, <code>tftp_file</code> is used as callback module. It writes each transferred block to the file named <code>LocalFilename</code> and returns the number of transferred bytes in <code>LastCallbackState</code>.</p><p>If <code>LocalFilename</code> is a string and there are registered callback modules, <code>LocalFilename</code> is tested against the regexps of these and the callback module corresponding to the first match is used, or an error tuple is returned if no matching regexp is found.</p>
  </section>
</section>
<section class="detail" id="start/1">

  <div class="detail-header">
    <a href="#start/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">start(Options) -&gt; {ok, Pid} | {error, Reason}</h1>


  </div>

  <section class="docstring">

<ul class="types"><li class="type">Options = [option()]</li><li class="type">Pid = pid()</li><li class="type">Reason = term()</li></ul><p>Starts a daemon process listening for UDP packets on a port. When it receives a request for read or write, it spawns a temporary server process handling the actual transfer of the (virtual) file.</p>
  </section>
</section>
<section class="detail" id="write_file/3">

  <div class="detail-header">
    <a href="#write_file/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">write_file(RemoteFilename, LocalFilename, Options) -&gt; {ok, LastCallbackState} | {error, Reason}</h1>


  </div>

  <section class="docstring">

<ul class="types"><li class="type">RemoteFilename = string()</li><li class="type">LocalFilename = binary() | string()</li><li class="type">Options = [option()]</li><li class="type">LastCallbackState = term()</li><li class="type">Reason = term()</li></ul><p>Writes a (virtual) file <code>RemoteFilename</code> to a TFTP server.</p><p>If <code>LocalFilename</code> is a binary, <code>tftp_binary</code> is used as callback module. The binary is transferred block by block and the number of transferred bytes is returned in <code>LastCallbackState</code>.</p><p>If <code>LocalFilename</code> is a string and there are no registered callback modules, <code>tftp_file</code> is used as callback module. It reads the file named <code>LocalFilename</code> block by block and returns the number of transferred bytes in <code>LastCallbackState</code>.</p><p>If <code>LocalFilename</code> is a string and there are registered callback modules, <code>LocalFilename</code> is tested against the regexps of these and the callback module corresponding to the first match is used, or an error tuple is returned if no matching regexp is found.</p>
  </section>
</section>

          </div>
        </section>

      <footer class="footer">

        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.25.1) for the
            <a href="https://elixir-lang.org" title="Elixir" target="_blank">Elixir programming language</a>.
          </span>
          <span class="line">
            Designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>

            <a href="api-reference.html" title="API reference" class="line footer-button">API Reference</a>

          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button display-quick-switch">
            Go to a HexDocs package
          </button>
          <button class="line footer-button tooltips-toggle">
            <span class="tooltips-option-disable">Disable tooltips</span>
            <span class="tooltips-option-enable">Enable tooltips</span>
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
