searchNodes=[{"doc":"Provides functions to handle public-key infrastructure, for details see public_key(6). Common Records and ASN.1 Types All records used in this Reference Manual are generated from ASN.1 specifications and are documented in the User's Guide. See Public-key Records. Use the following include directive to get access to the records and constant macros described here and in the User's Guide: - include_lib ( &quot;public_key/include/public_key.hrl&quot; ) .","ref":"public_key.html","title":"public_key","type":"module"},{"doc":"Computes shared secret.","ref":"public_key.html#compute_key/2","title":"public_key.compute_key/2","type":"function"},{"doc":"Computes shared secret.","ref":"public_key.html#compute_key/3","title":"public_key.compute_key/3","type":"function"},{"doc":"Public-key decryption using the private key. See also crypto:private_decrypt/4","ref":"public_key.html#decrypt_private/2","title":"public_key.decrypt_private/2","type":"function"},{"doc":"","ref":"public_key.html#decrypt_private/3","title":"public_key.decrypt_private/3","type":"function"},{"doc":"Public-key decryption using the public key. See also crypto:public_decrypt/4","ref":"public_key.html#decrypt_public/2","title":"public_key.decrypt_public/2","type":"function"},{"doc":"","ref":"public_key.html#decrypt_public/3","title":"public_key.decrypt_public/3","type":"function"},{"doc":"Decodes a public-key ASN.1 DER encoded entity.","ref":"public_key.html#der_decode/2","title":"public_key.der_decode/2","type":"function"},{"doc":"Encodes a public-key entity with ASN.1 DER encoding.","ref":"public_key.html#der_encode/2","title":"public_key.der_encode/2","type":"function"},{"doc":"Selects a group for Diffie-Hellman key exchange with the key size in the range MinSize...MaxSize and as close to SuggestedSize as possible. If Groups == undefined a default set will be used, otherwise the group is selected from Groups . First a size, as close as possible to SuggestedSize, is selected. Then one group with that key size is randomly selected from the specified set of groups. If no size within the limits of MinSize and MaxSize is available, {error,no_group_found} is returned. The default set of groups is listed in lib/public_key/priv/moduli . This file may be regenerated like this: $&gt; cd $E RL_TOP / lib / public_key / priv / $&gt; generate -- -- wait until all background jobs has finished . It may take several days ! $&gt; cat moduli - * &gt; moduli $&gt; cd . . ; make","ref":"public_key.html#dh_gex_group/4","title":"public_key.dh_gex_group/4","type":"function"},{"doc":"Public-key encryption using the private key. See also crypto:private_encrypt/4 .","ref":"public_key.html#encrypt_private/2","title":"public_key.encrypt_private/2","type":"function"},{"doc":"","ref":"public_key.html#encrypt_private/3","title":"public_key.encrypt_private/3","type":"function"},{"doc":"Public-key encryption using the public key. See also crypto:public_encrypt/4 .","ref":"public_key.html#encrypt_public/2","title":"public_key.encrypt_public/2","type":"function"},{"doc":"","ref":"public_key.html#encrypt_public/3","title":"public_key.encrypt_public/3","type":"function"},{"doc":"Generates a new keypair. Note that except for Diffie-Hellman the public key is included in the private key structure. See also crypto:generate_key/2","ref":"public_key.html#generate_key/1","title":"public_key.generate_key/1","type":"function"},{"doc":"Decodes PEM binary data and returns entries as ASN.1 DER encoded entities. Example {ok, PemBin} = file:read_file(&quot;cert.pem&quot;). PemEntries = public_key:pem_decode(PemBin).","ref":"public_key.html#pem_decode/1","title":"public_key.pem_decode/1","type":"function"},{"doc":"Creates a PEM binary.","ref":"public_key.html#pem_encode/1","title":"public_key.pem_encode/1","type":"function"},{"doc":"Decodes a PEM entry. pem_decode/1 returns a list of PEM entries. Notice that if the PEM entry is of type 'SubjectPublickeyInfo', it is further decoded to an rsa_public_key() or dsa_public_key() .","ref":"public_key.html#pem_entry_decode/1","title":"public_key.pem_entry_decode/1","type":"function"},{"doc":"","ref":"public_key.html#pem_entry_decode/2","title":"public_key.pem_entry_decode/2","type":"function"},{"doc":"Creates a PEM entry that can be feed to pem_encode/1 . If Asn1Type is 'SubjectPublicKeyInfo' , Entity must be either an rsa_public_key() , dsa_public_key() or an ec_public_key() and this function creates the appropriate 'SubjectPublicKeyInfo' entry.","ref":"public_key.html#pem_entry_encode/2","title":"public_key.pem_entry_encode/2","type":"function"},{"doc":"","ref":"public_key.html#pem_entry_encode/3","title":"public_key.pem_entry_encode/3","type":"function"},{"doc":"Returns the issuer of the CRL .","ref":"public_key.html#pkix_crl_issuer/1","title":"public_key.pkix_crl_issuer/1","type":"function"},{"doc":"Verify that Cert is the CRL signer.","ref":"public_key.html#pkix_crl_verify/2","title":"public_key.pkix_crl_verify/2","type":"function"},{"doc":"Performs CRL validation. It is intended to be called from the verify fun of pkix_path_validation/3 . Available options: {update_crl, fun()} The fun has the following type specification: fun ( # &#39;DistributionPoint&#39; { } , # &#39;CertificateList&#39; { } ) -&gt; # &#39;CertificateList&#39; { } The fun uses the information in the distribution point to access the latest possible version of the CRL. If this fun is not specified, Public Key uses the default implementation: fun ( _ DP , CRL ) -&gt; CRL end {issuer_fun, fun()} The fun has the following type specification: fun ( # &#39;DistributionPoint&#39; { } , # &#39;CertificateList&#39; { } , { rdnSequence , [ # &#39;AttributeTypeAndValue&#39; { } ] } , term ( ) ) -&gt; { ok , # &#39;OTPCertificate&#39; { } , [ der_encoded ] } The fun returns the root certificate and certificate chain that has signed the CRL. fun ( DP , CRL , Issuer , UserState ) -&gt; { ok , RootCert , CertChain } {undetermined_details, boolean()} Defaults to false. When revocation status cannot be determined, and this option is set to true, details of why no CRLs where accepted are included in the return value.","ref":"public_key.html#pkix_crls_validate/3","title":"public_key.pkix_crls_validate/3","type":"function"},{"doc":"Decodes an ASN.1 DER-encoded PKIX certificate. Option otp uses the customized ASN.1 specification OTP-PKIX.asn1 for decoding and also recursively decode most of the standard parts.","ref":"public_key.html#pkix_decode_cert/2","title":"public_key.pkix_decode_cert/2","type":"function"},{"doc":"Creates a distribution point for CRLs issued by the same issuer as Cert . Can be used as input to pkix_crls_validate/3","ref":"public_key.html#pkix_dist_point/1","title":"public_key.pkix_dist_point/1","type":"function"},{"doc":"Extracts distribution points from the certificates extensions.","ref":"public_key.html#pkix_dist_points/1","title":"public_key.pkix_dist_points/1","type":"function"},{"doc":"DER encodes a PKIX x509 certificate or part of such a certificate. This function must be used for encoding certificates or parts of certificates that are decoded/created in the otp format, whereas for the plain format this function directly calls der_encode/2 .","ref":"public_key.html#pkix_encode/3","title":"public_key.pkix_encode/3","type":"function"},{"doc":"Translates OID to Erlang digest type","ref":"public_key.html#pkix_hash_type/1","title":"public_key.pkix_hash_type/1","type":"function"},{"doc":"Checks if a certificate is a fixed Diffie-Hellman certificate.","ref":"public_key.html#pkix_is_fixed_dh_cert/1","title":"public_key.pkix_is_fixed_dh_cert/1","type":"function"},{"doc":"Checks if IssuerCert issued Cert .","ref":"public_key.html#pkix_is_issuer/2","title":"public_key.pkix_is_issuer/2","type":"function"},{"doc":"Checks if a certificate is self-signed.","ref":"public_key.html#pkix_is_self_signed/1","title":"public_key.pkix_is_self_signed/1","type":"function"},{"doc":"Returns the x509 certificater issuer id, if it can be determined.","ref":"public_key.html#pkix_issuer_id/2","title":"public_key.pkix_issuer_id/2","type":"function"},{"doc":"Checks whether the given distribution point matches the Issuing Distribution Point of the CRL, as described in RFC 5280. If the CRL doesn't have an Issuing Distribution Point extension, the distribution point always matches.","ref":"public_key.html#pkix_match_dist_point/2","title":"public_key.pkix_match_dist_point/2","type":"function"},{"doc":"Normalizes an issuer name so that it can be easily compared to another issuer name.","ref":"public_key.html#pkix_normalize_name/1","title":"public_key.pkix_normalize_name/1","type":"function"},{"doc":"TrustedCert = #'OTPCertificate'{} | der_encoded() | atom() Normally a trusted certificate, but it can also be a path-validation error that can be discovered while constructing the input to this function and that is to be run through the verify_fun . Examples are unknown_ca and selfsigned_peer. CertChain = [der_encoded()] A list of DER-encoded certificates in trust order ending with the peer certificate. Options = proplists:proplist() PublicKeyInfo = {?'rsaEncryption' | ?'id-RSASSA-PSS'| ?'id-dsa', rsa_public_key() | integer(), 'NULL' | 'RSASSA-PSS-params'{} | 'Dss-Parms'{}} PolicyTree = term() At the moment this is always an empty list as policies are not currently supported. Reason = cert_expired | invalid_issuer | invalid_signature | name_not_permitted | missing_basic_constraint | invalid_key_usage | {revoked, crl_reason()} | atom() Performs a basic path validation according to RFC 5280. However, CRL validation is done separately by pkix_crls_validate/3 and is to be called from the supplied verify_fun . Available options: {verify_fun, {fun(), InitialUserState::term()} The fun must be defined as: fun ( OtpCert : : # &#39;OTPCertificate&#39; { } , Event : : { bad_cert , Reason : : atom ( ) | { revoked , atom ( ) } } | { extension , # &#39;Extension&#39; { } } , InitialUserState : : term ( ) ) -&gt; { valid , UserState : : term ( ) } | { valid_peer , UserState : : term ( ) } | { fail , Reason : : term ( ) } | { unknown , UserState : : term ( ) } . If the verify callback fun returns {fail, Reason} , the verification process is immediately stopped. If the verify callback fun returns {valid, UserState} , the verification process is continued. This can be used to accept specific path validation errors, such as selfsigned_peer , as well as verifying application-specific extensions. If called with an extension unknown to the user application, the return value {unknown, UserState} is to be used. Note that user defined custom verify_fun may alter original path validation error (e.g selfsigned_peer ). Use with caution. {max_path_length, integer()} The max_path_length is the maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if max_path_length is 0, the PEER must be signed by the trusted ROOT-CA directly, if it is 1, the path can be PEER, CA, ROOT-CA, if it is 2, the path can be PEER, CA, CA, ROOT-CA, and so on. Possible reasons for a bad certificate: cert_expired Certificate is no longer valid as its expiration date has passed. invalid_issuer Certificate issuer name does not match the name of the issuer certificate in the chain. invalid_signature Certificate was not signed by its issuer certificate in the chain. name_not_permitted Invalid Subject Alternative Name extension. missing_basic_constraint Certificate, required to have the basic constraints extension, does not have a basic constraints extension. invalid_key_usage Certificate key is used in an invalid way according to the key-usage extension. {revoked, crl_reason()} Certificate has been revoked. atom() Application-specific error reason that is to be checked by the verify_fun .","ref":"public_key.html#pkix_path_validation/3","title":"public_key.pkix_path_validation/3","type":"function"},{"doc":"Signs an 'OTPTBSCertificate'. Returns the corresponding DER-encoded certificate.","ref":"public_key.html#pkix_sign/2","title":"public_key.pkix_sign/2","type":"function"},{"doc":"Translates signature algorithm OID to Erlang digest and signature types. The AlgorithmId is the signature OID from a certificate or a certificate revocation list.","ref":"public_key.html#pkix_sign_types/1","title":"public_key.pkix_sign_types/1","type":"function"},{"doc":"Returns the X509 certificate subject id.","ref":"public_key.html#pkix_subject_id/1","title":"public_key.pkix_subject_id/1","type":"function"},{"doc":"Options = \#{chain_type() := chain_opts()} Options for ROOT, Intermediate and Peer certs chain_type() = server_chain | client_chain chain_opts() = \#{root := [cert_opt()] | root_cert(), peer := [cert_opt()], intermediates =&gt; [[cert_opt()]]} A valid chain must have at least a ROOT and a peer cert. The root cert can be given either as a cert pre-generated by pkix_test_root_cert/2 , or as root cert generation options. root_cert() = \#{cert := der_encoded(), key := Key} A root certificate generated by pkix_test_root_cert/2 . cert_opt() = {Key, Value} For available options see cert_opt() below. Config = \#{server_config := [conf_opt()], client_config := [conf_opt()]} conf_opt() = {cert, der_encoded()} | {key, PrivateKey} |{cacerts, [der_encoded()]} This is a subset of the type ssl:tls_option() . PrivateKey is what generate_key/1 returns. Creates certificate configuration(s) consisting of certificate and its private key plus CA certificate bundle, for a client and a server, intended to facilitate automated testing of applications using X509-certificates, often through SSL/TLS. The test data can be used when you have control over both the client and the server in a test scenario. When this function is called with a map containing client and server chain specifications; it generates both a client and a server certificate chain where the cacerts returned for the server contains the root cert the server should trust and the intermediate certificates the server should present to connecting clients. The root cert the server should trust is the one used as root of the client certificate chain. Vice versa applies to the cacerts returned for the client. The root cert(s) can either be pre-generated with pkix_test_root_cert/2 , or if options are specified; it is (they are) generated. When this function is called with a list of certificate options; it generates a configuration with just one node certificate where cacerts contains the root cert and the intermediate certs that should be presented to a peer. In this case the same root cert must be used for all peers. This is useful in for example an Erlang distributed cluster where any node, towards another node, acts either as a server or as a client depending on who connects to whom. The generated certificate contains a subject altname, which is not needed in a client certificate, but makes the certificate useful for both roles. The cert_opt() type consists of the following options: {digest, digest_type()} Hash algorithm to be used for signing the certificate together with the key option. Defaults to sha that is sha1. {key, key_params() | private_key()} Parameters to be used to call public_key:generate_key/1, to generate a key, or an existing key. Defaults to generating an ECDSA key. Note this could fail if Erlang/OTP is compiled with a very old cryptolib. {validity, {From::erlang:timestamp(), To::erlang:timestamp()}} The validity period of the certificate. {extensions, [#'Extension'{}]} Extensions to include in the certificate. Default extensions included in CA certificates if not otherwise specified are: [ # &#39;Extension&#39; { extnID = ? &#39;id-ce-keyUsage&#39; , extnValue = [ keyCertSign , cRLSign ] , critical = false } , # &#39;Extension&#39; { extnID = ? &#39;id-ce-basicConstraints&#39; , extnValue = # &#39;BasicConstraints&#39; { cA = true } , critical = true } ] Default extensions included in the server peer cert if not otherwise specified are: [ # &#39;Extension&#39; { extnID = ? &#39;id-ce-keyUsage&#39; , extnValue = [ digitalSignature , keyAgreement ] , critical = false } , # &#39;Extension&#39; { extnID = ? &#39;id-ce-subjectAltName&#39; , extnValue = [ { dNSName , Hostname } ] , critical = false } ] Hostname is the result of calling net_adm:localhost() in the Erlang node where this funcion is called. Note that the generated certificates and keys does not provide a formally correct PKIX-trust-chain and they cannot be used to achieve real security. This function is provided for testing purposes only.","ref":"public_key.html#pkix_test_data/1","title":"public_key.pkix_test_data/1","type":"function"},{"doc":"Name = string() The root certificate name. Options = [cert_opt()] For available options see cert_opt() under pkix_test_data/1 . RootCert = \#{cert := der_encoded(), key := Key} A root certificate and key. The Key is generated by generate_key/1 . Generates a root certificate that can be used in multiple calls to pkix_test_data/1 when you want the same root certificate for several generated certificates.","ref":"public_key.html#pkix_test_root_cert/2","title":"public_key.pkix_test_root_cert/2","type":"function"},{"doc":"Verifies PKIX x.509 certificate signature.","ref":"public_key.html#pkix_verify/2","title":"public_key.pkix_verify/2","type":"function"},{"doc":"Cert = der_encoded() | #'OTPCertificate'{} ReferenceIDs = [ RefID ] RefID = {dns_id,string()} | {srv_id,string()} | {uri_id,string()} | {ip,inet:ip_address()|string()} | {OtherRefID,term()}} OtherRefID = atom() Opts = [ PvhOpt() ] PvhOpt = [MatchOpt | FailCallBackOpt | FqdnExtractOpt] MatchOpt = {match_fun, fun(RefId | FQDN::string(), PresentedID) -&gt; boolean() | default} PresentedID = {dNSName,string()} | {uniformResourceIdentifier,string() | {iPAddress,list(byte())} | {OtherPresId,term()}} OtherPresID = atom() FailCallBackOpt = {fail_callback, fun(#'OTPCertificate'{}) -&gt; boolean()} FqdnExtractOpt = {fqdn_fun, fun(RefID) -&gt; FQDN::string() | default | undefined} This function checks that the Presented Identifier (e.g hostname) in a peer certificate is in agreement with at least one of the Reference Identifier that the client expects to be connected to. The function is intended to be added as an extra client check of the peer certificate when performing public_key:pkix_path_validation/3 See RFC 6125 for detailed information about hostname verification. The User's Guide and code examples describes this function more detailed. The {OtherRefId,term()} is defined by the user and is passed to the match_fun , if defined. If the term in OtherRefId is a binary, it will be converted to a string. The ip Reference ID takes an inet:ip_address() or an ip address in string format (E.g &quot;10.0.1.1&quot; or &quot;1234::5678:9012&quot;) as second element. The options are: match_fun The fun/2 in this option replaces the default host name matching rules. The fun should return a boolean to tell if the Reference ID and Presented ID matches or not. The fun can also return a third value, the atom default , if the default matching rules shall apply. This makes it possible to augment the tests with a special case: fun ( . . . . ) -&gt; true ; % My special case ( _ , _ ) -&gt; default % all others falls back to the inherit tests end See pkix_verify_hostname_match_fun/1 for a function that takes a protocol name as argument and returns a fun/2 suitable for this option and Re-defining the match operation in the User's Guide for an example. fail_callback If a matching fails, there could be circumstances when the certificate should be accepted anyway. Think for example of a web browser where you choose to accept an outdated certificate. This option enables implementation of such a function. This fun/1 is called when no ReferenceID matches. The return value of the fun (a boolean() ) decides the outcome. If true the the certificate is accepted otherwise it is rejected. See &quot;Pinning&quot; a Certificate in the User's Guide. fqdn_fun This option augments the host name extraction from URIs and other Reference IDs. It could for example be a very special URI that is not standardised. The fun takes a Reference ID as argument and returns one of: the hostname the atom default : the default host name extract function will be used the atom undefined : a host name could not be extracted. The pkix_verify_hostname/3 will return false . For an example, see Hostname extraction in the User's Guide.","ref":"public_key.html#pkix_verify_hostname/2","title":"public_key.pkix_verify_hostname/2","type":"function"},{"doc":"","ref":"public_key.html#pkix_verify_hostname/3","title":"public_key.pkix_verify_hostname/3","type":"function"},{"doc":"Protocol = https The algorithm for wich the fun should implement the special matching rules RefId See pkix_verify_hostname/3 . FQDN See pkix_verify_hostname/3 . PresentedID See pkix_verify_hostname/3 . The return value of calling this function is intended to be used in the match_fun option in pkix_verify_hostname/3 . The returned fun augments the verify hostname matching according to the specific rules for the protocol in the argument.","ref":"public_key.html#pkix_verify_hostname_match_fun/1","title":"public_key.pkix_verify_hostname_match_fun/1","type":"function"},{"doc":"Generates a short hash of an issuer name. The hash is returned as a string containing eight hexadecimal digits. The return value of this function is the same as the result of the commands openssl crl -hash and openssl x509 -issuer_hash , when passed the issuer name of a CRL or a certificate, respectively. This hash is used by the c_rehash tool to maintain a directory of symlinks to CRL files, in order to facilitate looking up a CRL by its issuer name.","ref":"public_key.html#short_name_hash/1","title":"public_key.short_name_hash/1","type":"function"},{"doc":"Creates a digital signature. The Msg is either the binary &quot;plain text&quot; data to be signed or it is the hashed value of &quot;plain text&quot;, that is, the digest.","ref":"public_key.html#sign/3","title":"public_key.sign/3","type":"function"},{"doc":"","ref":"public_key.html#sign/4","title":"public_key.sign/4","type":"function"},{"doc":"This function is deprecated and should not be used in new programs. Use ssh_file:decode/2 instead. Decodes an SSH file-binary. In the case of known_hosts or auth_keys , the binary can include one or more lines of the file. Returns a list of public keys and their attributes, possible attribute values depends on the file type represented by the binary. If the Type is ssh2_pubkey , the result will be Decoded_ssh2_pubkey . Otherwise it will be Decoded_OtherType . RFC4716 attributes - see RFC 4716. {headers, [{string(), utf8_string()}]} auth_key attributes - see manual page for sshd. {comment, string()} {options, [string()]} {bits, integer()} - In SSH version 1 files. known_host attributes - see manual page for sshd. {hostnames, [string()]} {comment, string()} {bits, integer()} - In SSH version 1 files. Example: {ok, SshBin} = file:read_file(&quot;known_hosts&quot;) . If Type is public_key the binary can be either an RFC4716 public key or an OpenSSH public key.","ref":"public_key.html#ssh_decode/2","title":"public_key.ssh_decode/2","type":"function"},{"doc":"This function is deprecated and should not be used in new programs. Use ssh_file:encode/2 instead. Encodes a list of SSH file entries (public keys and attributes) to a binary. Possible attributes depend on the file type, see ssh_decode/2 . If the Type is ssh2_pubkey , the InData shall be InData_ssh2_pubkey . Otherwise it shall be OtherInData .","ref":"public_key.html#ssh_encode/2","title":"public_key.ssh_encode/2","type":"function"},{"doc":"HostKey = public_key() DigestType = digest_type() Calculates a ssh fingerprint from a public host key as openssh does. This function is deprecated and should not be used in new programs. Use ssh:hostkey_fingerprint/1 or ssh:hostkey_fingerprint/2 instead. The algorithm in ssh_hostkey_fingerprint/1 is md5 to be compatible with older ssh-keygen commands. The string from the second variant is prepended by the algorithm name in uppercase as in newer ssh-keygen commands. Examples: 2 &gt; public_key : ssh_hostkey_fingerprint ( Key ) . &quot;f5:64:a6:c1:5a:cb:9f:0a:10:46:a2:5c:3e:2f:57:84&quot; 3 &gt; public_key : ssh_hostkey_fingerprint ( md5 , Key ) . &quot;MD5:f5:64:a6:c1:5a:cb:9f:0a:10:46:a2:5c:3e:2f:57:84&quot; 4 &gt; public_key : ssh_hostkey_fingerprint ( sha , Key ) . &quot;SHA1:bSLY/C4QXLDL/Iwmhyg0PGW9UbY&quot; 5 &gt; public_key : ssh_hostkey_fingerprint ( sha256 , Key ) . &quot;SHA256:aZGXhabfbf4oxglxltItWeHU7ub3Dc31NcNw2cMJePQ&quot; 6 &gt; public_key : ssh_hostkey_fingerprint ( [ sha , sha256 ] , Key ) . [ &quot;SHA1:bSLY/C4QXLDL/Iwmhyg0PGW9UbY&quot; , &quot;SHA256:aZGXhabfbf4oxglxltItWeHU7ub3Dc31NcNw2cMJePQ&quot; ]","ref":"public_key.html#ssh_hostkey_fingerprint/1","title":"public_key.ssh_hostkey_fingerprint/1","type":"function"},{"doc":"","ref":"public_key.html#ssh_hostkey_fingerprint/2","title":"public_key.ssh_hostkey_fingerprint/2","type":"function"},{"doc":"Verifies a digital signature. The Msg is either the binary &quot;plain text&quot; data or it is the hashed value of &quot;plain text&quot;, that is, the digest.","ref":"public_key.html#verify/4","title":"public_key.verify/4","type":"function"},{"doc":"","ref":"public_key.html#verify/5","title":"public_key.verify/5","type":"function"},{"doc":"ASN.1 type present in the Public Key applications ASN.1 specifications.","ref":"public_key.html#t:asn1_type/0","title":"public_key.asn1_type/0","type":"type"},{"doc":"","ref":"public_key.html#t:cert_id/0","title":"public_key.cert_id/0","type":"type"},{"doc":"Cipher = &quot;RC2-CBC&quot; | &quot;DES-CBC&quot; | &quot;DES-EDE3-CBC&quot; Salt could be generated with crypto:strong_rand_bytes(8) .","ref":"public_key.html#t:cipher/0","title":"public_key.cipher/0","type":"type"},{"doc":"Cipher = &quot;RC2-CBC&quot; | &quot;DES-CBC&quot; | &quot;DES-EDE3-CBC&quot; Salt could be generated with crypto:strong_rand_bytes(8) .","ref":"public_key.html#t:cipher_info/0","title":"public_key.cipher_info/0","type":"type"},{"doc":"Cipher = &quot;RC2-CBC&quot; | &quot;DES-CBC&quot; | &quot;DES-EDE3-CBC&quot; Salt could be generated with crypto:strong_rand_bytes(8) .","ref":"public_key.html#t:cipher_info_params/0","title":"public_key.cipher_info_params/0","type":"type"},{"doc":"","ref":"public_key.html#t:crl_reason/0","title":"public_key.crl_reason/0","type":"type"},{"doc":"","ref":"public_key.html#t:der_encoded/0","title":"public_key.der_encoded/0","type":"type"},{"doc":"Cipher = &quot;RC2-CBC&quot; | &quot;DES-CBC&quot; | &quot;DES-EDE3-CBC&quot; Salt could be generated with crypto:strong_rand_bytes(8) .","ref":"public_key.html#t:der_or_encrypted_der/0","title":"public_key.der_or_encrypted_der/0","type":"type"},{"doc":"","ref":"public_key.html#t:digest_type/0","title":"public_key.digest_type/0","type":"type"},{"doc":"","ref":"public_key.html#t:dsa_private_key/0","title":"public_key.dsa_private_key/0","type":"type"},{"doc":"","ref":"public_key.html#t:dsa_public_key/0","title":"public_key.dsa_public_key/0","type":"type"},{"doc":"","ref":"public_key.html#t:ec_private_key/0","title":"public_key.ec_private_key/0","type":"type"},{"doc":"","ref":"public_key.html#t:ec_public_key/0","title":"public_key.ec_public_key/0","type":"type"},{"doc":"","ref":"public_key.html#t:ecpk_parameters/0","title":"public_key.ecpk_parameters/0","type":"type"},{"doc":"","ref":"public_key.html#t:ecpk_parameters_api/0","title":"public_key.ecpk_parameters_api/0","type":"type"},{"doc":"","ref":"public_key.html#t:ed_params/0","title":"public_key.ed_params/0","type":"type"},{"doc":"The tagged ed_pri format will not be returned from any public_key functions but can be used as input, should be considered deprecated.","ref":"public_key.html#t:ed_private_key/0","title":"public_key.ed_private_key/0","type":"type"},{"doc":"The tagged ed_pub format will not be returned from any public_key functions but can be used as input, should be considered deprecated.","ref":"public_key.html#t:ed_public_key/0","title":"public_key.ed_public_key/0","type":"type"},{"doc":"","ref":"public_key.html#t:issuer_name/0","title":"public_key.issuer_name/0","type":"type"},{"doc":"","ref":"public_key.html#t:key_params/0","title":"public_key.key_params/0","type":"type"},{"doc":"Object identifier, a tuple of integers as generated by the ASN.1 compiler.","ref":"public_key.html#t:oid/0","title":"public_key.oid/0","type":"type"},{"doc":"Cipher = &quot;RC2-CBC&quot; | &quot;DES-CBC&quot; | &quot;DES-EDE3-CBC&quot; Salt could be generated with crypto:strong_rand_bytes(8) .","ref":"public_key.html#t:pem_entry/0","title":"public_key.pem_entry/0","type":"type"},{"doc":"","ref":"public_key.html#t:pki_asn1_type/0","title":"public_key.pki_asn1_type/0","type":"type"},{"doc":"","ref":"public_key.html#t:private_key/0","title":"public_key.private_key/0","type":"type"},{"doc":"","ref":"public_key.html#t:public_key/0","title":"public_key.public_key/0","type":"type"},{"doc":"","ref":"public_key.html#t:rsa_private_key/0","title":"public_key.rsa_private_key/0","type":"type"},{"doc":"","ref":"public_key.html#t:rsa_pss_private_key/0","title":"public_key.rsa_pss_private_key/0","type":"type"},{"doc":"","ref":"public_key.html#t:rsa_pss_public_key/0","title":"public_key.rsa_pss_public_key/0","type":"type"},{"doc":"","ref":"public_key.html#t:rsa_public_key/0","title":"public_key.rsa_public_key/0","type":"type"},{"doc":"Cipher = &quot;RC2-CBC&quot; | &quot;DES-CBC&quot; | &quot;DES-EDE3-CBC&quot; Salt could be generated with crypto:strong_rand_bytes(8) .","ref":"public_key.html#t:salt/0","title":"public_key.salt/0","type":"type"},{"doc":"","ref":"public_key.html#t:ssh_file/0","title":"public_key.ssh_file/0","type":"type"}]