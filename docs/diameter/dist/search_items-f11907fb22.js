searchNodes=[{"doc":"This module provides the interface with which a user can implement a Diameter node that sends and receives messages using the Diameter protocol as defined in RFC 6733. Basic usage consists of creating a representation of a locally implemented Diameter node and its capabilities with start_service/2 , adding transport capability using add_transport/2 and sending Diameter requests and receiving Diameter answers with call/4 . Incoming Diameter requests are communicated as callbacks to a diameter_app(3) callback modules as specified in the service configuration. Beware the difference between diameter (not capitalized) and Diameter (capitalized). The former refers to the Erlang application named diameter whose main api is defined here, the latter to Diameter protocol in the sense of RFC 6733. The diameter application must be started before calling most functions in this module. DATA TYPES Address() DiameterIdentity() Grouped() OctetString() Time() Unsigned32() UTF8String() Types corresponding to RFC 6733 AVP Data Formats. Defined in diameter_dict(4). application_alias() = term() Name identifying a Diameter application in service configuration. Passed to call/4 when sending requests defined by the application. application_module() = Mod | [Mod | ExtraArgs] | #diameter_callback{} Mod = atom ( ) ExtraArgs = list ( ) Module implementing the callback interface defined in diameter_app(3) , along with any extra arguments to be appended to those documented. Note that extra arguments specific to an outgoing request can be specified to call/4 , in which case those are appended to any module-specific extra arguments. Specifying a #diameter_callback{} record allows individual functions to be configured in place of the usual diameter_app(3) callbacks. See diameter_callback.erl for details. application_opt() Options defining a Diameter application. Has one of the following types. {alias, application_alias()} Unique identifier for the application in the scope of the service. Defaults to the value of the dictionary option. {dictionary, atom()} Name of an encode/decode module for the Diameter messages defined by the application. These modules are generated from files whose format is documented in diameter_dict(4). {module, application_module()} Callback module in which messages of the Diameter application are handled. See diameter_app(3) for the required interface and semantics. {state, term()} Initial callback state. The prevailing state is passed to some diameter_app(3) callbacks, which can then return a new state. Defaults to the value of the alias option. {call_mutates_state, true|false} Whether or not the pick_peer/4 application callback can modify the application state. Defaults to false . pick_peer/4 callbacks are serialized when this option is true , which is a potential performance bottleneck. A simple Diameter client may suffer no ill effects from using mutable state but a server or agent that responds to incoming request should probably avoid it. {answer_errors, callback|report|discard} Manner in which incoming answer messages containing decode errors are handled. If callback then errors result in a handle_answer/4 callback in the same fashion as for handle_request/3, with errors communicated in the errors field of the #diameter_packet{} passed to the callback. If report then an answer containing errors is discarded without a callback and a warning report is written to the log. If discard then an answer containing errors is silently discarded without a callback. In both the report and discard cases the return value for the call/4 invocation in question is as if a callback had taken place and returned {error, failure} . Defaults to discard . {request_errors, answer_3xxx|answer|callback} Manner in which incoming requests are handled when an error other than 3007 (DIAMETER_APPLICATION_UNSUPPORTED, which cannot be associated with an application callback module), is detected. If answer_3xxx then requests are answered without a handle_request/3 callback taking place. If answer then even 5xxx errors are answered without a callback unless the connection in question has configured the RFC 3588 common dictionary as noted below. If callback then a handle_request/3 callback always takes place and its return value determines the answer sent to the peer, if any. Defaults to answer_3xxx . Answers sent by diameter set the E-bit in the Diameter Header. Since RFC 3588 allows only 3xxx result codes in an answer-message , answer has the same semantics as answer_3xxx when the transport in question has been configured with diameter_gen_base_rfc3588 as its common dictionary. Since RFC 6733 allows both 3xxx and 5xxx result codes in an answer-message , a transport with diameter_gen_base_rfc6733 as its common dictionary does distinguish between answer_3xxx and answer . call_opt() Options available to call/4 when sending an outgoing Diameter request. Has one of the following types. {extra, list()} Extra arguments to append to callbacks to the callback module in question. These are appended to any extra arguments configured on the callback itself. Multiple options append to the argument list. {filter, peer_filter()} Filter to apply to the list of available peers before passing it to the pick_peer/4 callback for the application in question. Multiple options are equivalent a single all filter on the corresponding list of filters. Defaults to none . {peer, diameter_app:peer_ref() } Peer to which the request in question can be sent, preempting the selection of peers having advertised support for the Diameter application in question. Multiple options can be specified, and their order is respected in the candidate lists passed to a subsequent pick_peer/4 callback. {timeout, Unsigned32()} Number of milliseconds after which the request should timeout. Defaults to 5000. detach Cause call/4 to return ok as soon as the request in question has been encoded, instead of waiting for and returning the result from a subsequent handle_answer/4 or handle_error/4 callback. An invalid option will cause call/4 to fail. capability() AVP values sent in outgoing CER or CEA messages during capabilities exchange. Can be configured both on a service and a transport, values on the latter taking precedence. Has one of the following types. {'Origin-Host', DiameterIdentity()} {'Origin-Realm', DiameterIdentity()} {'Host-IP-Address', [Address()]} An address list is available to the start function of a transport module , which can return a new list for use in the subsequent CER or CEA. Host-IP-Address need not be specified if the transport module in question communicates an address list as described in diameter_transport(3) {'Vendor-Id', Unsigned32()} {'Product-Name', UTF8String()} {'Origin-State-Id', Unsigned32()} Origin-State-Id is optional but, if configured, will be included in outgoing CER/CEA and DWR/DWA messages. Setting a value of 0 (zero) is equivalent to not setting a value, as documented in RFC 6733. The function origin_state_id/0 can be used as to retrieve a value that is computed when the diameter application is started. {'Supported-Vendor-Id', [Unsigned32()]} {'Auth-Application-Id', [Unsigned32()]} {'Inband-Security-Id', [Unsigned32()]} Inband-Security-Id defaults to the empty list, which is equivalent to a list containing only 0 (NO_INBAND_SECURITY). If 1 (TLS) is specified then TLS is selected if the CER/CEA received from the peer offers it. {'Acct-Application-Id', [Unsigned32()]} {'Vendor-Specific-Application-Id', [Grouped()]} {'Firmware-Revision', Unsigned32()} Note that each tuple communicates one or more AVP values. It is an error to specify duplicate tuples. eval() = {M,F,A} | fun() | [eval() | A] An expression that can be evaluated as a function in the following sense. eval ( [ { M , F , A } | T ] ) -&gt; apply ( M , F , T ++ A ) ; eval ( [ [ F | A ] | T ] ) -&gt; eval ( [ F | T ++ A ] ) ; eval ( [ F | A ] ) -&gt; apply ( F , A ) ; eval ( F ) -&gt; eval ( [ F ] ) . Applying an eval() E to an argument list A is meant in the sense of eval([E|A]) . Beware of using fun expressions of the form fun Name/Arity in situations in which the fun is not short-lived and code is to be upgraded at runtime since any processes retaining such a fun will have a reference to old code. In particular, such a value is typically inappropriate in configuration passed to start_service/2 or add_transport/2 . peer_filter() = term() Filter passed to call/4 in order to select candidate peers for a pick_peer/4 callback. Has one of the following types. none Matches any peer. This is a convenience that provides a filter equivalent to no filter. host Matches only those peers whose Origin-Host has the same value as Destination-Host in the outgoing request in question, or any peer if the request does not contain a Destination-Host AVP. realm Matches only those peers whose Origin-Realm has the same value as Destination-Realm in the outgoing request in question, or any peer if the request does not contain a Destination-Realm AVP. {host, any|DiameterIdentity()} Matches only those peers whose Origin-Host has the specified value, or all peers if the atom any . {realm, any|DiameterIdentity()} Matches only those peers whose Origin-Realm has the specified value, or all peers if the atom any . {eval, eval()} Matches only those peers for which the specified eval() returns true when applied to the connection's diameter_caps record. Any other return value or exception is equivalent to false . {neg, peer_filter()} Matches only those peers not matched by the specified filter. {all, [peer_filter()]} Matches only those peers matched by each filter in the specified list. {any, [peer_filter()]} Matches only those peers matched by at least one filter in the specified list. The resulting list will be in match order, peers matching the first filter of the list sorting before those matched by the second, and so on. {first, [peer_filter()]} Like any , but stops at the first filter for which there are matches, which can be much more efficient when there are many peers. For example, the following filter causes only peers best matching both the host and realm filters to be presented. { first , [ { all , [ host , realm ] } , realm ] } An invalid filter is equivalent to {any,[]} , a filter that matches no peer. The host and realm filters cause the Destination-Host and Destination-Realm AVPs to be extracted from the outgoing request, assuming it to be a record- or list-valued diameter_codec:message() , and assuming at most one of each AVP. If this is not the case then the {host|realm, DiameterIdentity()} filters must be used to achieve the desired result. An empty DiameterIdentity() (which should not be typical) matches all hosts/realms for the purposes of filtering. A host filter is not typically desirable when setting Destination-Host since it will remove peer agents from the candidates list. service_event() = #diameter_event{service = service_name(), info = service_event_info()} An event message sent to processes that have subscribed to these using subscribe/1 . service_event_info() = term() The info field of a service_event() record. Can have one of the following types. start stop The service is being started or stopped. No event precedes a start event. No event follows a stop event, and this event implies the termination of all transport processes. {up, Ref, Peer, Config, Pkt} {up, Ref, Peer, Config} {down, Ref, Peer, Config} Ref = transport_ref() Peer = diameter_app:peer() Config = {connect|listen, [transport_opt()]} Pkt = #diameter_packet{} The RFC 3539 watchdog state machine has transitioned into ( up ) or out of ( down ) the OKAY state. If a #diameter_packet{} is present in an up event then there has been a capabilities exchange on a newly established transport connection and the record contains the received CER or CEA. Note that a single up or down event for a given peer corresponds to multiple peer_up/3 or peer_down/3 callbacks, one for each of the Diameter applications negotiated during capabilities exchange. That is, the event communicates connectivity with the peer as a whole while the callbacks communicate connectivity with respect to individual Diameter applications. {reconnect, Ref, Opts} Ref = transport_ref ( ) Opts = [ transport_opt ( ) ] A connecting transport is attempting to establish/reestablish a transport connection with a peer following connect_timer or watchdog_timer expiry. {closed, Ref, Reason, Config} Ref = transport_ref ( ) Config = { connect | listen , [ transport_opt ( ) ] } Capabilities exchange has failed. Reason can have one of the following types. {'CER', Result, Caps, Pkt} Result = ResultCode | { capabilities_cb , CB , ResultCode | discard } Caps = # diameter_caps { } Pkt = # diameter_packet { } ResultCode = integer ( ) CB = eval ( ) An incoming CER has been answered with the indicated result code, or discarded. Caps contains pairs of values, for the local node and remote peer respectively. Pkt contains the CER in question. In the case of rejection by a capabilities callback, the tuple contains the rejecting callback. {'CER', Caps, {ResultCode, Pkt}} ResultCode = integer ( ) Caps = # diameter_caps { } Pkt = # diameter_packet { } An incoming CER contained errors and has been answered with the indicated result code. Caps contains values for the local node only. Pkt contains the CER in question. {'CER', timeout} An expected CER was not received within capx_timeout of connection establishment. {'CEA', Result, Caps, Pkt} Result = ResultCode | atom ( ) | { capabilities_cb , CB , ResultCode | discard } Caps = # diameter_caps { } Pkt = # diameter_packet { } ResultCode = integer ( ) An incoming CEA has been rejected for the indicated reason. An integer-valued Result indicates the result code sent by the peer. Caps contains pairs of values for the local node and remote peer. Pkt contains the CEA in question. In the case of rejection by a capabilities callback, the tuple contains the rejecting callback. {'CEA', Caps, Pkt} Caps = # diameter_caps { } Pkt = # diameter_packet { } An incoming CEA contained errors and has been rejected. Caps contains only values for the local node. Pkt contains the CEA in question. {'CEA', timeout} An expected CEA was not received within capx_timeout of connection establishment. {watchdog, Ref, PeerRef, {From, To}, Config} Ref = transport_ref() PeerRef = diameter_app:peer_ref() From, To = initial | okay | suspect | down | reopen Config = {connect|listen, [transport_opt()]} An RFC 3539 watchdog state machine has changed state. any() For forward compatibility, a subscriber should be prepared to receive info fields of forms other than the above. service_name() = term() Name of a service as passed to start_service/2 and with which the service is identified. There can be at most one service with a given name on a given node. Note that erlang:make_ref/0 can be used to generate a service name that is somewhat unique. service_opt() Option passed to start_service/2 . Can be any capability() as well as the following. {application, [application_opt()]} A Diameter application supported by the service. A service must configure one tuple for each Diameter application it intends to support. For an outgoing request, the relevant application_alias() is passed to call/4 , while for an incoming request the application identifier in the message header determines the application, the identifier being specified in the application's dictionary file. The capabilities advertised by a node must match its configured applications. In particular, application configuration must be matched by corresponding capability() configuration, of *-Application-Id AVPs in particular. {decode_format, record | list | map | none} The format of decoded messages and grouped AVPs in the msg field of diameter_packet records and value field of diameter_avp records respectively. If record then a record whose definition is generated from the dictionary file in question. If list or map then a [Name | Avps] pair where Avps is a list of AVP name/values pairs or a map keyed on AVP names respectively. If none then the atom-value message name, or undefined for a Grouped AVP. See also diameter_codec:message() . Defaults to record . AVPs are decoded into a list of diameter_avp records in avps field of diameter_packet records independently of decode_format . {restrict_connections, false | node | nodes | [node()] | eval()} The degree to which the service allows multiple transport connections to the same peer, as identified by its Origin-Host at capabilities exchange. If [node()] then a connection is rejected if another already exists on any of the specified nodes. Types false , node , nodes and eval() are equivalent to [] , [node()] , [node()|nodes()] and the evaluated value respectively, evaluation of each expression taking place whenever a new connection is to be established. Note that false allows an unlimited number of connections to be established with the same peer. Multiple connections are independent and governed by their own peer and watchdog state machines. Defaults to nodes . {sequence, {H,N} | eval()} A constant value H for the topmost 32-N bits of of 32-bit End-to-End and Hop-by-Hop Identifiers generated by the service, either explicitly or as a return value of a function to be evaluated at start_service/2 . In particular, an identifier Id is mapped to a new identifier as follows. ( H bsl N ) bor ( Id band ( ( 1 bsl N ) - 1 ) ) Note that RFC 6733 requires that End-to-End Identifiers remain unique for a period of at least 4 minutes and that this and the call rate places a lower bound on appropriate values of N : at a rate of R requests per second, an N -bit counter traverses all of its values in (1 bsl N) div (R*60) minutes, so the bound is 4*R*60 =&lt; 1 bsl N . N must lie in the range 0..32 and H must be a non-negative integer less than 1 bsl (32-N) . Defaults to {0,32} . Multiple Erlang nodes implementing the same Diameter node should be configured with different sequence masks to ensure that each node uses a unique range of End-to-End and Hop-by-Hop Identifiers for outgoing requests. {share_peers, boolean() | [node()] | eval()} Nodes to which peer connections established on the local Erlang node are communicated. Shared peers become available in the remote candidates list passed to pick_peer/4 callbacks on remote nodes whose services are configured to use them: see use_shared_peers below. If false then peers are not shared. If [node()] then peers are shared with the specified list of nodes. If eval() then peers are shared with the nodes returned by the specified function, evaluated whenever a peer connection becomes available or a remote service requests information about local connections. The value true is equivalent to fun erlang:nodes/0 . The value node() in a list is ignored, so a collection of services can all be configured to share with the same list of nodes. Defaults to false . Peers are only shared with services of the same name for the purpose of sending outgoing requests. Since the value of the application_opt() alias , passed to call/4 , is the handle for identifying a peer as a suitable candidate, services that share peers must use the same aliases to identify their supported applications. They should typically also configure identical capabilities() , since by sharing peer connections they are distributing the implementation of a single Diameter node across multiple Erlang nodes. {strict_arities, boolean() | encode | decode} Whether or not to require that the number of AVPs in a message or grouped AVP agree with those specified in the dictionary in question when passing messages to diameter_app(3) callbacks. If true then mismatches in an outgoing messages cause message encoding to fail, while mismatches in an incoming message are reported as 5005/5009 errors in the errors field of the diameter_packet record passed to handle_request/3 or handle_answer/4 callbacks. If false then neither error is enforced/detected. If encode or decode then errors are only enforced/detected on outgoing or incoming messages respectively. Defaults to true . Disabling arity checks affects the form of messages at encode/decode. In particular, decoded AVPs are represented as lists of values, regardless of the AVP's arity (ie. expected number in the message/AVP grammar in question), and values are expected to be supplied as lists at encode. This differs from the historic decode behaviour of representing AVPs of arity 1 as bare values, not wrapped in a list. {string_decode, boolean()} Whether or not to decode AVPs of type OctetString() and its derived types DiameterIdentity(), DiameterURI(), IPFilterRule(), QoSFilterRule(), and UTF8String(). If true then AVPs of these types are decoded to string(). If false then values are retained as binary(). Defaults to true . This option should be set to false since a sufficiently malicious peer can otherwise cause large amounts of memory to be consumed when decoded Diameter messages are passed between processes. The default value is for backwards compatibility. {traffic_counters, boolean()} Whether or not to count application-specific messages; those for which diameter_app(3) callbacks take place. If false then only messages handled by diameter itself are counted: CER/CEA, DWR/DWA, DPR/DPA. Defaults to true . Disabling counters is a performance improvement, but means that the omitted counters are not returned by service_info/2 . {use_shared_peers, boolean() | [node()] | eval()} Nodes from which communicated peers are made available in the remote candidates list of pick_peer/4 callbacks. If false then remote peers are not used. If [node()] then only peers from the specified list of nodes are used. If eval() then only peers returned by the specified function are used, evaluated whenever a remote service communicates information about an available peer connection. The value true is equivalent to fun erlang:nodes/0 . The value node() in a list is ignored. Defaults to false . A service that does not use shared peers will always pass the empty list as the second argument of pick_peer/4 callbacks. Sending a request over a peer connection on a remote node is less efficient than sending it over a local connection. It may be preferable to make use of the service_opt() restrict_connections and maintain a dedicated connection on each node from which requests are sent. transport_opt() Any transport option except applications , capabilities , transport_config , and transport_module . Used as defaults for transport configuration, values passed to add_transport/2 overriding values configured on the service. transport_opt() Option passed to add_transport/2 . Has one of the following types. {applications, [application_alias()]} Diameter applications to which the transport should be restricted. Defaults to all applications configured on the service in question. Applications not configured on the service in question are ignored. The capabilities advertised by a node must match its configured applications. In particular, setting applications on a transport typically implies having to set matching *-Application-Id AVPs in a capabilities() tuple. {avp_dictionaries, [module()]} A list of alternate dictionary modules with which to encode/decode AVPs that are not defined by the dictionary of the application in question. At decode, such AVPs are represented as diameter_avp records in the 'AVP' field of a decoded message or Grouped AVP, the first alternate that succeeds in decoding the AVP setting the record's value field. At encode, values in an 'AVP' list can be passed as AVP name/value 2-tuples, and it is an encode error for no alternate to define the AVP of such a tuple. Defaults to the empty list. The motivation for alternate dictionaries is RFC 7683, Diameter Overload Indication Conveyance (DOIC), which defines AVPs to be piggybacked onto existing application messages rather than defining an application of its own. The DOIC dictionary is provided by the diameter application, as module diameter_gen_doic_rfc7683 , but alternate dictionaries can be used to encode/decode any set of AVPs not known to an application dictionary. {capabilities, [capability()]} AVPs used to construct outgoing CER/CEA messages. Values take precedence over any specified on the service in question. Specifying a capability as a transport option may be particularly appropriate for Inband-Security-Id, in case TLS is desired over TCP as implemented by diameter_tcp(3) . {capabilities_cb, eval()} Callback invoked upon reception of CER/CEA during capabilities exchange in order to ask whether or not the connection should be accepted. Applied to the transport_ref() and #diameter_caps{} record of the connection. The return value can have one of the following types. ok Accept the connection. integer() Causes an incoming CER to be answered with the specified Result-Code. discard Causes an incoming CER to be discarded without CEA being sent. unknown Equivalent to returning 3010 , DIAMETER_UNKNOWN_PEER. Returning anything but ok or a 2xxx series result code causes the transport connection to be broken. Multiple capabilities_cb options can be specified, in which case the corresponding callbacks are applied until either all return ok or one does not. {capx_timeout, Unsigned32()} Number of milliseconds after which a transport process having an established transport connection will be terminated if the expected capabilities exchange message (CER or CEA) is not received from the peer. For a connecting transport, the timing of connection attempts is governed by connect_timer or watchdog_timer expiry. For a listening transport, the peer determines the timing. Defaults to 10000. {connect_timer, Tc} Tc = Unsigned32 ( ) For a connecting transport, the RFC 6733 Tc timer, in milliseconds. This timer determines the frequency with which a transport attempts to establish an initial connection with its peer following transport configuration. Once an initial connection has been established, watchdog_timer determines the frequency of reconnection attempts, as required by RFC 3539. For a listening transport, the timer specifies the time after which a previously connected peer will be forgotten: a connection after this time is regarded as an initial connection rather than reestablishment, causing the RFC 3539 state machine to pass to state OKAY rather than REOPEN. Note that these semantics are not governed by the RFC and that a listening transport's connect_timer should be greater than its peer's Tw plus jitter. Defaults to 30000 for a connecting transport and 60000 for a listening transport. {disconnect_cb, eval()} Callback invoked prior to terminating the transport process of a transport connection having watchdog state OKAY . Applied to application|service|transport and the transport_ref() and diameter_app:peer() in question: application indicates that the diameter application is being stopped, service that the service in question is being stopped by stop_service/1 , and transport that the transport in question is being removed by remove_transport/2 . The return value can have one of the following types. {dpr, [option()]} Send Disconnect-Peer-Request to the peer, the transport process being terminated following reception of Disconnect-Peer-Answer or timeout. An option() can be one of the following. {cause, 0|rebooting|1|busy|2|goaway} Disconnect-Cause to send, REBOOTING , BUSY and DO_NOT_WANT_TO_TALK_TO_YOU respectively. Defaults to rebooting for Reason=service|application and goaway for Reason=transport . {timeout, Unsigned32()} Number of milliseconds after which the transport process is terminated if DPA has not been received. Defaults to the value of dpa_timeout . dpr Equivalent to {dpr, []} . close Terminate the transport process without Disconnect-Peer-Request being sent to the peer. ignore Equivalent to not having configured the callback. Multiple disconnect_cb options can be specified, in which case the corresponding callbacks are applied until one of them returns a value other than ignore . All callbacks returning ignore is equivalent to not having configured them. Defaults to a single callback returning dpr . {dpa_timeout, Unsigned32()} Number of milliseconds after which a transport connection is terminated following an outgoing DPR if DPA is not received. Defaults to 1000. {dpr_timeout, Unsigned32()} Number of milliseconds after which a transport connection is terminated following an incoming DPR if the peer does not close the connection. Defaults to 5000. {incoming_maxlen, 0..16777215} Bound on the expected size of incoming Diameter messages. Messages larger than the specified number of bytes are discarded. Defaults to 16777215 , the maximum value of the 24-bit Message Length field in a Diameter Header. {length_errors, exit|handle|discard} How to deal with errors in the Message Length field of the Diameter Header in an incoming message. An error in this context is that the length is not at least 20 bytes (the length of a Header), is not a multiple of 4 (a valid length) or is not the length of the message in question, as received over the transport interface documented in diameter_transport(3) . If exit then the transport process in question exits. If handle then the message is processed as usual, a resulting handle_request/3 or handle_answer/4 callback (if one takes place) indicating the 5015 error (DIAMETER_INVALID_MESSAGE_LENGTH). If discard then the message in question is silently discarded. Defaults to exit . The default value reflects the fact that a transport module for a stream-oriented transport like TCP may not be able to recover from a message length error since such a transport must use the Message Length header to divide the incoming byte stream into individual Diameter messages. An invalid length leaves it with no reliable way to rediscover message boundaries, which may result in the failure of subsequent messages. See diameter_tcp(3) for the behaviour of that module. {pool_size, pos_integer()} Number of transport processes to start. For a listening transport, determines the size of the pool of accepting transport processes, a larger number being desirable for processing multiple concurrent peer connection attempts. For a connecting transport, determines the number of connections to the peer in question that will be attempted to be establshed: the service_opt(): restrict_connections should also be configured on the service in question to allow multiple connections to the same peer. {spawn_opt, [term()] | {M,F,A}} An options list passed to erlang:spawn_opt/2 to spawn a handler process for an incoming Diameter request on the local node, or an MFA that returns the pid of a handler process. Options monitor and link are ignored in the list-valued case. An MFA is applied with an additional term prepended to its argument list, and should return either the pid of the handler process that invokes diameter_traffic:request/1 on the argument in order to process the request, or the atom discard . The handler process need not be local, and diameter need not be started on the remote node, but diameter and relevant application callbacks must be on the code path. Defaults to the empty list. {strict_capx, boolean()]} Whether or not to enforce the RFC 6733 requirement that any message before capabilities exchange should close the peer connection. If false then unexpected messages are discarded. Defaults to true. Changing this results in non-standard behaviour, but can be useful in case peers are known to be behave badly. {strict_mbit, boolean()} Whether or not to regard an AVP setting the M-bit as erroneous when the command grammar in question does not explicitly allow the AVP. If true then such AVPs are regarded as 5001 errors, DIAMETER_AVP_UNSUPPORTED. If false then the M-bit is ignored and policing it becomes the receiver's responsibility. Defaults to true . RFC 6733 is unclear about the semantics of the M-bit. One the one hand, the CCF specification in section 3.2 documents AVP in a command grammar as meaning any arbitrary AVP; on the other hand, 1.3.4 states that AVPs setting the M-bit cannot be added to an existing command: the modified command must instead be placed in a new Diameter application. The reason for the latter is presumably interoperability: allowing arbitrary AVPs setting the M-bit in a command makes its interpretation implementation-dependent, since there's no guarantee that all implementations will understand the same set of arbitrary AVPs in the context of a given command. However, interpreting AVP in a command grammar as any AVP, regardless of M-bit, renders 1.3.4 meaningless, since the receiver can simply ignore any AVP it thinks isn't relevant, regardless of the sender's intent. Beware of confusing mandatory in the sense of the M-bit with mandatory in the sense of the command grammar. The former is a semantic requirement: that the receiver understand the semantics of the AVP in the context in question. The latter is a syntactic requirement: whether or not the AVP must occur in the message in question. {transport_config, term()} {transport_config, term(), Unsigned32() | infinity} Term passed as the third argument to the start/3 function of the relevant transport module in order to start a transport process. Defaults to the empty list. The 3-tuple form additionally specifies an interval, in milliseconds, after which a started transport process should be terminated if it has not yet established a connection. For example, the following options on a connecting transport request a connection with one peer over SCTP or another (typically the same) over TCP. { transport_module , diameter_sctp } { transport_config , SctpOpts , 5000 } { transport_module , diameter_tcp } { transport_config , TcpOpts } To listen on both SCTP and TCP, define one transport for each. {transport_module, atom()} Module implementing a transport process as defined in diameter_transport(3) . Defaults to diameter_tcp . Multiple transport_module and transport_config options are allowed. The order of these is significant in this case (and only in this case), a transport_module being paired with the first transport_config following it in the options list, or the default value for trailing modules. Transport starts will be attempted with each of the modules in order until one establishes a connection within the corresponding timeout (see below) or all fail. {watchdog_config, [{okay|suspect, non_neg_integer()}]} Configuration that alters the behaviour of the watchdog state machine. On key okay , the non-negative number of answered DWR messages before transitioning from REOPEN to OKAY. On key suspect , the number of watchdog timeouts before transitioning from OKAY to SUSPECT when DWR is unanswered, or 0 to not make the transition. Defaults to [{okay, 3}, {suspect, 1}] . Not specifying a key is equivalent to specifying the default value for that key. The default value is as required by RFC 3539: changing it results in non-standard behaviour that should only be used to simulate misbehaving nodes during test. {watchdog_timer, TwInit} TwInit = Unsigned32 ( ) | { M , F , A } The RFC 3539 watchdog timer. An integer value is interpreted as the RFC's TwInit in milliseconds, a jitter of ± 2 seconds being added at each rearming of the timer to compute the RFC's Tw. An MFA is expected to return the RFC's Tw directly, with jitter applied, allowing the jitter calculation to be performed by the callback. An integer value must be at least 6000 as required by RFC 3539. Defaults to 30000. Unrecognized options are silently ignored but are returned unmodified by service_info/2 and can be referred to in predicate functions passed to remove_transport/2 . transport_ref() = reference() Reference returned by add_transport/2 that identifies the configuration. SEE ALSO diameter_app(3) , diameter_transport(3) , diameter_dict(4)","ref":"diameter.html","title":"diameter","type":"module"},{"doc":"SvcName = service_name() Opt = transport_opt() Ref = transport_ref() Reason = term() Add transport capability to a service. The service will start transport processes as required in order to establish a connection with the peer, either by connecting to the peer ( connect ) or by accepting incoming connection requests ( listen ). A connecting transport establishes transport connections with at most one peer, an listening transport potentially with many. The diameter application takes responsibility for exchanging CER/CEA with the peer. Upon successful completion of capabilities exchange the service calls each relevant application module's peer_up/3 callback after which the caller can exchange Diameter messages with the peer over the transport. In addition to CER/CEA, the service takes responsibility for the handling of DWR/DWA and required by RFC 3539, as well as for DPR/DPA. The returned reference uniquely identifies the transport within the scope of the service. Note that the function returns before a transport connection has been established. It is not an error to add a transport to a service that has not yet been configured: a service can be started after configuring its transports.","ref":"diameter.html#add_transport/2","title":"diameter.add_transport/2","type":"function"},{"doc":"SvcName = service_name() App = application_alias() Request = diameter_codec:message() Answer = term() Opt = call_opt() Send a Diameter request message. App specifies the Diameter application in which the request is defined and callbacks to the corresponding callback module will follow as described below and in diameter_app(3) . Unless the detach option is specified, the call returns either when an answer message is received from the peer or an error occurs. In the answer case, the return value is as returned by a handle_answer/4 callback. In the error case, whether or not the error is returned directly by diameter or from a handle_error/4 callback depends on whether or not the outgoing request is successfully encoded for transmission to the peer, the cases being documented below. If there are no suitable peers, or if pick_peer/4 rejects them by returning false , then {error,no_connection} is returned. Otherwise pick_peer/4 is followed by a prepare_request/3 callback, the message is encoded and then sent. There are several error cases which may prevent an answer from being received and passed to a handle_answer/4 callback: If the initial encode of the outgoing request fails, then the request process fails and {error,encode} is returned. If the request is successfully encoded and sent but the answer times out then a handle_error/4 callback takes place with Reason = timeout . If the request is successfully encoded and sent but the service in question is stopped before an answer is received then a handle_error/4 callback takes place with Reason = cancel . If the transport connection with the peer goes down after the request has been sent but before an answer has been received then an attempt is made to resend the request to an alternate peer. If no such peer is available, or if the subsequent pick_peer/4 callback rejects the candidates, then a handle_error/4 callback takes place with Reason = failover . If a peer is selected then a prepare_retransmit/3 callback takes place, after which the semantics are the same as following an initial prepare_request/3 callback. If an encode error takes place during retransmission then the request process fails and {error,failure} is returned. If an application callback made in processing the request fails (pick_peer, prepare_request, prepare_retransmit, handle_answer or handle_error) then either {error,encode} or {error,failure} is returned depending on whether or not there has been an attempt to send the request over the transport. Note that {error,encode} is the only return value which guarantees that the request has not been sent over the transport connection.","ref":"diameter.html#call/4","title":"diameter.call/4","type":"function"},{"doc":"Return a reasonable value for use as Origin-State-Id in outgoing messages. The value returned is the number of seconds since 19680120T031408Z, the first value that can be encoded as a Diameter Time() , at the time the diameter application was started.","ref":"diameter.html#origin_state_id/0","title":"diameter.origin_state_id/0","type":"function"},{"doc":"SvcName = service_name() Pred = Fun | MFA | transport_ref() | list() | true | false Fun = fun((transport_ref(), connect|listen, list()) -&gt; boolean())     | fun((transport_ref(), list()) -&gt; boolean())     | fun((list()) -&gt; boolean()) MFA = {atom(), atom(), list()} Reason = term() Remove previously added transports. Pred determines which transports to remove. An arity-3-valued Pred removes all transports for which Pred(Ref, Type, Opts) returns true , where Type and Opts are as passed to add_transport/2 and Ref is as returned by it. The remaining forms are equivalent to an arity-3 fun as follows. Pred = fun ( transport_ref ( ) , list ( ) ) : fun ( Ref , _ , Opts ) -&gt; Pred ( Ref , Opts ) end Pred = fun ( list ( ) ) : fun ( _ , _ , Opts ) -&gt; Pred ( Opts ) end Pred = transport_ref ( ) : fun ( Ref , _ , _ ) -&gt; Pred == Ref end Pred = list ( ) : fun ( _ , _ , Opts ) -&gt; [ ] == Pred -- Opts end Pred = true : fun ( _ , _ , _ ) -&gt; true end Pred = false : fun ( _ , _ , _ ) -&gt; false end Pred = { M , F , A } : fun ( Ref , Type , Opts ) -&gt; apply ( M , F , [ Ref , Type , Opts | A ] ) end Removing a transport causes the corresponding transport processes to be terminated. Whether or not a DPR message is sent to a peer is controlled by value of disconnect_cb configured on the transport.","ref":"diameter.html#remove_transport/2","title":"diameter.remove_transport/2","type":"function"},{"doc":"SvcName = service_name() Info = Item | [Info] Item = atom() Return information about a started service. Requesting info for an unknown service causes undefined to be returned. Requesting a list of items causes a tagged list to be returned. Item can be one of the following. 'Origin-Host' 'Origin-Realm' 'Vendor-Id' 'Product-Name' 'Origin-State-Id' 'Host-IP-Address' 'Supported-Vendor' 'Auth-Application-Id' 'Inband-Security-Id' 'Acct-Application-Id' 'Vendor-Specific-Application-Id' 'Firmware-Revision' Return a capability value as configured with start_service/2 . applications Return the list of applications as configured with start_service/2 . capabilities Return a tagged list of all capabilities values as configured with start_service/2 . transport Return a list containing one entry for each of the service's transport as configured with add_transport/2 . Each entry is a tagged list containing both configuration and information about established peer connections. An example return value with for a client service with Origin-Host &quot;client.example.com&quot; configured with a single transport connected to &quot;server.example.com&quot; might look as follows. [ [ { ref , # Ref &lt; 0.0 . 0.93 &gt; } , { type , connect } , { options , [ { transport_module , diameter_tcp } , { transport_config , [ { ip , { 127 , 0 , 0 , 1 } } , { raddr , { 127 , 0 , 0 , 1 } } , { rport , 3868 } , { reuseaddr , true } ] } ] } , { watchdog , { &lt; 0.66 . 0 &gt; , - 576460736368485571 , okay } } , { peer , { &lt; 0.67 . 0 &gt; , - 576460736357885808 } } , { apps , [ { 0 , common } ] } , { caps , [ { origin_host , { &quot;client.example.com&quot; , &quot;server.example.com&quot; } } , { origin_realm , { &quot;example.com&quot; , &quot;example.com&quot; } } , { host_ip_address , { [ { 127 , 0 , 0 , 1 } ] , [ { 127 , 0 , 0 , 1 } ] } } , { vendor_id , { 0 , 193 } } , { product_name , { &quot;Client&quot; , &quot;Server&quot; } } , { origin_state_id , { [ ] , [ ] } } , { supported_vendor_id , { [ ] , [ ] } } , { auth_application_id , { [ 0 ] , [ 0 ] } } , { inband_security_id , { [ ] , [ 0 ] } } , { acct_application_id , { [ ] , [ ] } } , { vendor_specific_application_id , { [ ] , [ ] } } , { firmware_revision , { [ ] , [ ] } } , { avp , { [ ] , [ ] } } ] } , { port , [ { owner , &lt; 0.69 . 0 &gt; } , { module , diameter_tcp } , { socket , { { 127 , 0 , 0 , 1 } , 48758 } } , { peer , { { 127 , 0 , 0 , 1 } , 3868 } } , { statistics , [ { recv_oct , 656 } , { recv_cnt , 6 } , { recv_max , 148 } , { recv_avg , 109 } , { recv_dvi , 19 } , { send_oct , 836 } , { send_cnt , 6 } , { send_max , 184 } , { send_avg , 139 } , { send_pend , 0 } ] } ] } , { statistics , [ { { { 0 , 258 , 0 } , recv } , 3 } , { { { 0 , 258 , 1 } , send } , 3 } , { { { 0 , 258 , 0 } , recv , { &#39;Result-Code&#39; , 2001 } } , 3 } , { { { 0 , 257 , 0 } , recv } , 1 } , { { { 0 , 257 , 1 } , send } , 1 } , { { { 0 , 257 , 0 } , recv , { &#39;Result-Code&#39; , 2001 } } , 1 } , { { { 0 , 280 , 1 } , recv } , 2 } , { { { 0 , 280 , 0 } , send } , 2 } , { { { 0 , 280 , 0 } , send , { &#39;Result-Code&#39; , 2001 } } , 2 } ] } ] ] Here ref is a transport_ref() and options the corresponding transport_opt() list passed to add_transport/2 . The watchdog entry shows the state of a connection's RFC 3539 watchdog state machine. The peer entry identifies the diameter_app:peer_ref() for which there will have been peer_up/3 callbacks for the Diameter applications identified by the apps entry, common being the application_alias() . The caps entry identifies the capabilities sent by the local node and received from the peer during capabilities exchange. The port entry displays socket-level information about the transport connection. The statistics entry presents Diameter-level counters, an entry like {{{0,280,1},recv},2} saying that the client has received 2 DWR messages: {0,280,1} = {Application_Id, Command_Code, R_Flag} . Note that watchdog , peer , apps , caps and port entries depend on connectivity with the peer and may not be present. Note also that the statistics entry presents values accumulated during the lifetime of the transport configuration. A listening transport presents its information slightly differently since there may be multiple accepted connections for the same transport_ref() . The transport info returned by a server with a single client connection might look as follows. [ [ { ref , # Ref &lt; 0.0 . 0.61 &gt; } , { type , listen } , { options , [ { transport_module , diameter_tcp } , { transport_config , [ { reuseaddr , true } , { ip , { 127 , 0 , 0 , 1 } } , { port , 3868 } ] } ] } , { accept , [ [ { watchdog , { &lt; 0.56 . 0 &gt; , - 576460739249514012 , okay } } , { peer , { &lt; 0.58 . 0 &gt; , - 576460638229179167 } } , { apps , [ { 0 , common } ] } , { caps , [ { origin_host , { &quot;server.example.com&quot; , &quot;client.example.com&quot; } } , { origin_realm , { &quot;example.com&quot; , &quot;example.com&quot; } } , { host_ip_address , { [ { 127 , 0 , 0 , 1 } ] , [ { 127 , 0 , 0 , 1 } ] } } , { vendor_id , { 193 , 0 } } , { product_name , { &quot;Server&quot; , &quot;Client&quot; } } , { origin_state_id , { [ ] , [ ] } } , { supported_vendor_id , { [ ] , [ ] } } , { auth_application_id , { [ 0 ] , [ 0 ] } } , { inband_security_id , { [ ] , [ ] } } , { acct_application_id , { [ ] , [ ] } } , { vendor_specific_application_id , { [ ] , [ ] } } , { firmware_revision , { [ ] , [ ] } } , { avp , { [ ] , [ ] } } ] } , { port , [ { owner , &lt; 0.62 . 0 &gt; } , { module , diameter_tcp } , { socket , { { 127 , 0 , 0 , 1 } , 3868 } } , { peer , { { 127 , 0 , 0 , 1 } , 48758 } } , { statistics , [ { recv_oct , 1576 } , { recv_cnt , 16 } , { recv_max , 184 } , { recv_avg , 98 } , { recv_dvi , 26 } , { send_oct , 1396 } , { send_cnt , 16 } , { send_max , 148 } , { send_avg , 87 } , { send_pend , 0 } ] } ] } ] , [ { watchdog , { &lt; 0.72 . 0 &gt; , - 576460638229717546 , initial } } ] ] } , { statistics , [ { { { 0 , 280 , 0 } , recv } , 7 } , { { { 0 , 280 , 1 } , send } , 7 } , { { { 0 , 280 , 0 } , recv , { &#39;Result-Code&#39; , 2001 } } , 7 } , { { { 0 , 258 , 1 } , recv } , 3 } , { { { 0 , 258 , 0 } , send } , 3 } , { { { 0 , 258 , 0 } , send , { &#39;Result-Code&#39; , 2001 } } , 3 } , { { { 0 , 280 , 1 } , recv } , 5 } , { { { 0 , 280 , 0 } , send } , 5 } , { { { 0 , 280 , 0 } , send , { &#39;Result-Code&#39; , 2001 } } , 5 } , { { { 0 , 257 , 1 } , recv } , 1 } , { { { 0 , 257 , 0 } , send } , 1 } , { { { 0 , 257 , 0 } , send , { &#39;Result-Code&#39; , 2001 } } , 1 } ] } ] ] The information presented here is as in the connect case except that the client connections are grouped under an accept tuple. Whether or not the transport_opt() pool_size has been configured affects the format of the listing in the case of a connecting transport, since a value greater than 1 implies multiple transport processes for the same transport_ref() , as in the listening case. The format in this case is similar to the listening case, with a pool tuple in place of an accept tuple. connections Return a list containing one entry for every established transport connection whose watchdog state machine is not in the down state. This is a flat view of transport info which lists only active connections and for which Diameter-level statistics are accumulated only for the lifetime of the transport connection. A return value for the server above might look as follows. [ [ { ref , # Ref &lt; 0.0 . 0.61 &gt; } , { type , accept } , { options , [ { transport_module , diameter_tcp } , { transport_config , [ { reuseaddr , true } , { ip , { 127 , 0 , 0 , 1 } } , { port , 3868 } ] } ] } , { watchdog , { &lt; 0.56 . 0 &gt; , - 576460739249514012 , okay } } , { peer , { &lt; 0.58 . 0 &gt; , - 576460638229179167 } } , { apps , [ { 0 , common } ] } , { caps , [ { origin_host , { &quot;server.example.com&quot; , &quot;client.example.com&quot; } } , { origin_realm , { &quot;example.com&quot; , &quot;example.com&quot; } } , { host_ip_address , { [ { 127 , 0 , 0 , 1 } ] , [ { 127 , 0 , 0 , 1 } ] } } , { vendor_id , { 193 , 0 } } , { product_name , { &quot;Server&quot; , &quot;Client&quot; } } , { origin_state_id , { [ ] , [ ] } } , { supported_vendor_id , { [ ] , [ ] } } , { auth_application_id , { [ 0 ] , [ 0 ] } } , { inband_security_id , { [ ] , [ ] } } , { acct_application_id , { [ ] , [ ] } } , { vendor_specific_application_id , { [ ] , [ ] } } , { firmware_revision , { [ ] , [ ] } } , { avp , { [ ] , [ ] } } ] } , { port , [ { owner , &lt; 0.62 . 0 &gt; } , { module , diameter_tcp } , { socket , { { 127 , 0 , 0 , 1 } , 3868 } } , { peer , { { 127 , 0 , 0 , 1 } , 48758 } } , { statistics , [ { recv_oct , 10124 } , { recv_cnt , 132 } , { recv_max , 184 } , { recv_avg , 76 } , { recv_dvi , 9 } , { send_oct , 10016 } , { send_cnt , 132 } , { send_max , 148 } , { send_avg , 75 } , { send_pend , 0 } ] } ] } , { statistics , [ { { { 0 , 280 , 0 } , recv } , 62 } , { { { 0 , 280 , 1 } , send } , 62 } , { { { 0 , 280 , 0 } , recv , { &#39;Result-Code&#39; , 2001 } } , 62 } , { { { 0 , 258 , 1 } , recv } , 3 } , { { { 0 , 258 , 0 } , send } , 3 } , { { { 0 , 258 , 0 } , send , { &#39;Result-Code&#39; , 2001 } } , 3 } , { { { 0 , 280 , 1 } , recv } , 66 } , { { { 0 , 280 , 0 } , send } , 66 } , { { { 0 , 280 , 0 } , send , { &#39;Result-Code&#39; , 2001 } } , 66 } , { { { 0 , 257 , 1 } , recv } , 1 } , { { { 0 , 257 , 0 } , send } , 1 } , { { { 0 , 257 , 0 } , send , { &#39;Result-Code&#39; , 2001 } } , 1 } ] } ] ] Note that there may be multiple entries with the same ref , in contrast to transport info. statistics Return a {{Counter, Ref}, non_neg_integer()} list of counter values. Ref can be either a transport_ref() or a diameter_app:peer_ref() . Entries for the latter are folded into corresponding entries for the former as peer connections go down. Entries for both are removed at remove_transport/2 . The Diameter-level statistics returned by transport and connections info are based upon these entries. diameter_app:peer_ref() Return transport configuration associated with a single peer, as passed to add_transport/2 . The returned list is empty if the peer is unknown. Otherwise it contains the ref , type and options tuples as in transport and connections info above. For example: [ { ref , # Ref &lt; 0.0 . 0.61 &gt; } , { type , accept } , { options , [ { transport_module , diameter_tcp } , { transport_config , [ { reuseaddr , true } , { ip , { 127 , 0 , 0 , 1 } } , { port , 3868 } ] } ] } ]","ref":"diameter.html#service_info/2","title":"diameter.service_info/2","type":"function"},{"doc":"SvcName = service_name() Return the list of started services.","ref":"diameter.html#services/0","title":"diameter.services/0","type":"function"},{"doc":"Ident = DiameterIdentity() Return a value for a Session-Id AVP. The value has the form required by section 8.8 of RFC 6733. Ident should be the Origin-Host of the peer from which the message containing the returned value will be sent.","ref":"diameter.html#session_id/1","title":"diameter.session_id/1","type":"function"},{"doc":"Start the diameter application. The diameter application must be started before starting a service. In a production system this is typically accomplished by a boot file, not by calling start/0 explicitly.","ref":"diameter.html#start/0","title":"diameter.start/0","type":"function"},{"doc":"SvcName = service_name() Options = [service_opt()] Reason = term() Start a diameter service. A service defines a locally-implemented Diameter node, specifying the capabilities to be advertised during capabilities exchange. Transports are added to a service using add_transport/2 . A transport can both override its service's capabilities and restrict its supported Diameter applications so &quot;service = Diameter node as identified by Origin-Host&quot; is not necessarily the case.","ref":"diameter.html#start_service/2","title":"diameter.start_service/2","type":"function"},{"doc":"Stop the diameter application.","ref":"diameter.html#stop/0","title":"diameter.stop/0","type":"function"},{"doc":"SvcName = service_name() Reason = term() Stop a diameter service. Stopping a service causes all associated transport connections to be broken. A DPR message will be sent as in the case of remove_transport/2 . Stopping a service does not remove any associated transports: remove_transport/2 must be called to remove transport configuration.","ref":"diameter.html#stop_service/1","title":"diameter.stop_service/1","type":"function"},{"doc":"SvcName = service_name() Subscribe to service_event() messages from a service. It is not an error to subscribe to events from a service that does not yet exist. Doing so before adding transports is required to guarantee the reception of all transport-related events.","ref":"diameter.html#subscribe/1","title":"diameter.subscribe/1","type":"function"},{"doc":"SvcName = service_name() Unsubscribe to event messages from a service.","ref":"diameter.html#unsubscribe/1","title":"diameter.unsubscribe/1","type":"function"},{"doc":"Incoming Diameter messages are decoded from binary() before being communicated to diameter_app(3) callbacks. Similarly, outgoing Diameter messages are encoded into binary() before being passed to the appropriate diameter_transport(3) module for transmission. The functions documented here implement the default encode/decode. The diameter user does not need to call functions here explicitly when sending and receiving messages using diameter:call/4 and the callback interface documented in diameter_app(3) : diameter itself provides encode/decode as a consequence of configuration passed to diameter:start_service/2 , and the results may differ from those returned by the functions documented here, depending on configuration. The header() and packet() records below are defined in diameter.hrl, which can be included as follows. - include_lib ( &quot;diameter/include/diameter.hrl&quot; ) . Application-specific records are defined in the hrl files resulting from dictionary file compilation. DATA TYPES uint8()  = 0..255 uint24() = 0..16777215 uint32() = 0..4294967295 8-bit, 24-bit and 32-bit integers occurring in Diameter and AVP headers. avp() = #diameter_avp{} The application-neutral representation of an AVP. Primarily intended for use by relay applications that need to handle arbitrary Diameter applications. A service implementing a specific Diameter application (for which it configures a dictionary) can manipulate values of type message() instead. Fields have the following types. code = uint32() is_mandatory = boolean() need_encryption = boolean() vendor_id = uint32() | undefined Values in the AVP header, corresponding to AVP Code, the M flag, P flags and Vendor-ID respectively. A Vendor-ID other than undefined implies a set V flag. data = iolist() The data bytes of the AVP. name = atom() The name of the AVP as defined in the dictionary file in question, or undefined if the AVP is unknown to the dictionary file in question. value = term() The decoded value of an AVP. Will be undefined on decode if the data bytes could not be decoded, the AVP is unknown, or if the decode format is none . The type of a decoded value is as document in diameter_dict(4). type = atom() The type of the AVP as specified in the dictionary file in question (or one it inherits). Possible types are undefined and the Diameter types: OctetString , Integer32 , Integer64 , Unsigned32 , Unsigned64 , Float32 , Float64 , Grouped , Enumerated , Address , Time , UTF8String , DiameterIdentity , DiameterURI , IPFilterRule and QoSFilterRule . dictionary() = module() The name of a generated dictionary module as generated by diameterc(1) or diameter_make:codec/2 . The interface provided by a dictionary module is an implementation detail that may change. header() = #diameter_header{} The record representation of the Diameter header. Values in a packet() returned by decode/2 are as extracted from the incoming message. Values set in an packet() passed to encode/2 are preserved in the encoded binary(), with the exception of length , cmd_code and application_id , all of which are determined by the dictionary() in question. It is not necessary to set header fields explicitly in outgoing messages as diameter itself will set appropriate values. Setting inappropriate values can be useful for test purposes. Fields have the following types. version = uint8() length = uint24() cmd_code = uint24() application_id = uint32() hop_by_hop_id = uint32() end_to_end_id = uint32() Values of the Version, Message Length, Command-Code, Application-ID, Hop-by-Hop Identifier and End-to-End Identifier fields of the Diameter header. is_request = boolean() is_proxiable = boolean() is_error = boolean() is_retransmitted = boolean() Values corresponding to the R(equest), P(roxiable), E(rror) and T(Potentially re-transmitted message) flags of the Diameter header. message() = record() | maybe_improper_list() The representation of a Diameter message as passed to diameter:call/4 or returned from a handle_request/3 callback. The record representation is as outlined in diameter_dict(4): a message as defined in a dictionary file is encoded as a record with one field for each component AVP. Equivalently, a message can also be encoded as a list whose head is the atom-valued message name (as specified in the relevant dictionary file) and whose tail is either a list of AVP name/values pairs or a map with values keyed on AVP names. The format at decode is determined by diameter:service_opt() decode_format . Any of the formats is accepted at encode. Another list-valued representation allows a message to be specified as a list whose head is a header() and whose tail is an avp() list. This representation is used by diameter itself when relaying requests as directed by the return value of a handle_request/3 callback. It differs from the other two in that it bypasses the checks for messages that do not agree with their definitions in the dictionary in question: messages are sent exactly as specified. packet() = #diameter_packet{} A container for incoming and outgoing Diameter messages. Fields have the following types. header = header() | undefined The Diameter header of the message. Can be (and typically should be) undefined for an outgoing message in a non-relay application, in which case diameter provides appropriate values. avps = [ avp() ] | undefined The AVPs of the message. Ignored for an outgoing message if the msg field is set to a value other than undefined . msg = message() | undefined The incoming/outgoing message. For an incoming message, a term corresponding to the configured decode format if the message can be decoded in a non-relay application, undefined otherwise. For an outgoing message, setting a [ header() | avp() ] list is equivalent to setting the header and avps fields to the corresponding values. A value in the msg field does not imply an absence of decode errors. The errors field should also be examined. bin = binary() The incoming message prior to encode or the outgoing message after encode. errors = [5000..5999 | {5000..5999, avp()}] Errors detected at decode of an incoming message, as identified by a corresponding 5xxx series Result-Code (Permanent Failures). For an incoming request, these should be used to formulate an appropriate answer as documented for the handle_request/3 callback in diameter_app(3) . For an incoming answer, the diameter:application_opt() answer_errors determines the behaviour. transport_data = term() An arbitrary term of meaning only to the transport process in question, as documented in diameter_transport(3) . SEE ALSO diameterc(1), diameter_app(3) , diameter_dict(4), diameter_make(3)","ref":"diameter_codec.html","title":"diameter_codec","type":"module"},{"doc":"Mod = dictionary() Bin = binary() Pkt = packet() Decode a Diameter message.","ref":"diameter_codec.html#decode/2","title":"diameter_codec.decode/2","type":"function"},{"doc":"Mod = dictionary() Msg = message() | packet() Pkt = packet() Encode a Diameter message.","ref":"diameter_codec.html#encode/2","title":"diameter_codec.encode/2","type":"function"},{"doc":"The function codec/2 is used to compile a diameter dictionary file into Erlang source. The resulting source implements the interface diameter requires to encode and decode the dictionary's messages and AVPs. The utility diameterc(1) provides an alternate compilation interface. BUGS Unrecognized options are silently ignored. SEE ALSO diameterc(1), diameter_dict(4)","ref":"diameter_make.html","title":"diameter_make","type":"module"},{"doc":"Compile a single dictionary file. The input File can be either a path or a literal dictionary, the occurrence of newline (ascii NL) or carriage return (ascii CR) identifying the latter. Opt determines the format of the results and whether they are written to file or returned, and can have the following types. parse | forms | erl | hrl Specifies an output format. Whether the output is returned or written to file depends on whether or not option return is specified. When written to file, the resulting file(s) will have extensions .D , .F , .erl , and .hrl respectively, basenames defaulting to dictionary if the input dictionary is literal and does not specify @name . When returned, results are in the order of the corresponding format options. Format options default to erl and hrl (in this order) if unspecified. The parse format is an internal representation that can be passed to flatten/1 and format/1 , while the forms format can be passed to compile:forms/2 . The erl and hrl formats are returned as iolists. {include, string()} Prepend the specified directory to the code path. Use to point at beam files compiled from inherited dictionaries, @inherits in a dictionary file creating a beam dependency, not an erl/hrl dependency. Multiple include options can be specified. {outdir, string()} Write generated source to the specified directory. Defaults to the current working directory. Has no effect if option return is specified. return Return results in a {ok, [Out]} tuple instead of writing to file and returning ok . {name|prefix, string()} Transform the input dictionary before compilation, setting @name or @prefix to the specified string. {inherits, string()} Transform the input dictionary before compilation, appending @inherits of the specified string. Two forms have special meaning: { inherits , &quot;-&quot; } { inherits , &quot;Prev/Mod&quot; } The first has the effect of clearing any previous inherits, the second of replacing a previous inherits of Prev to one of Mod . This allows the semantics of the input dictionary to be changed without modifying the file itself. Multiple inherits options can be specified. Note that a dictionary's @name , together with the outdir option, determine the output paths when the return option is not specified. The @name of a literal input dictionary defaults to dictionary . A returned error reason can be converted into a readable string using format_error/1 .","ref":"diameter_make.html#codec/2","title":"diameter_make.codec/2","type":"function"},{"doc":"Reconstitute a parsed dictionary, as returned by codec/2 , without using @inherits . That is, construct an equivalent dictionary in which all AVP's are definined in the dictionary itself. The return value is also a parsed dictionary.","ref":"diameter_make.html#flatten/1","title":"diameter_make.flatten/1","type":"function"},{"doc":"Turns a parsed dictionary, as returned by codec/2 , back into the dictionary format.","ref":"diameter_make.html#format/1","title":"diameter_make.format/1","type":"function"},{"doc":"Turn an error reason returned by codec/2 into a readable string.","ref":"diameter_make.html#format_error/1","title":"diameter_make.format_error/1","type":"function"},{"doc":"This module implements diameter transport over SCTP using gen_sctp(3) . It can be specified as the value of a transport_module option to diameter:add_transport/2 and implements the behaviour documented in diameter_transport(3) . SEE ALSO diameter(3) , diameter_transport(3) , gen_sctp(3) , inet(3)","ref":"diameter_sctp.html","title":"diameter_sctp","type":"module"},{"doc":"Type = connect | accept Ref = diameter:transport_ref() Svc = #diameter_service{} Opt = OwnOpt | SctpOpt Pid = pid() LAddr = inet:ip_address() Reason = term() OwnOpt = {raddr, inet:ip_address() } | {rport, integer()} | {accept, Match} | {unordered, boolean() | pos_integer()} | {packet, boolean() | raw} | {message_cb, diameter:eval()} | {sender, boolean()} SctpOpt = term() Match = inet:ip_address() | string() | [Match] The start function required by diameter_transport(3) . Options raddr and rport specify the remote address and port for a connecting transport and not valid for a listening transport: the former is required while latter defaults to 3868 if unspecified. Multiple raddr options can be specified, in which case the connecting transport in question attempts each in sequence until an association is established. Option accept specifies remote addresses for a listening transport and is not valid for a connecting transport. If specified, a remote address that does not match one of the specified addresses causes the association to be aborted. Multiple accept options can be specified. A string-valued Match that does not parse as an address is interpreted as a regular expression. Option unordered specifies whether or not to use unordered delivery, integer N being equivalent to N =&lt; OS , where OS is the number of outbound streams negotiated on the association in question. Regardless of configuration, sending is ordered on stream 0 until reception of a second incoming message, to ensure that a peer receives capabilities exchange messages before any other. Defaults to false . Option packet determines how/if an incoming message is packaged into a diameter_packet record. If false then messages are received as binary(). If true then as a record with the binary() message in the bin field and a {stream, Id} tuple in the transport_data field, where Id is the identifier of the inbound stream the message was received on. If raw then as a record with the received ancillary sctp_sndrcvinfo record in the transport_data field. Defaults to true . Options message_cb and sender have semantics identical to those documented in diameter_tcp(3) , but with the message argument to a recv callback being as directed by the packet option. An {outstream, Id} tuple in the transport_data field of a outgoing diameter_packet record sets the outbound stream on which the message is sent, modulo the negotiated number of outbound streams. Any other value causes successive such sends to cycle though all outbound streams. Remaining options are any accepted by gen_sctp:open/1 , with the exception of options mode , binary , list , active and sctp_events . Note that options ip and port specify the local address and port respectively. Multiple ip options can be specified for a multihomed peer. If none are specified then the values of Host-IP-Address in the diameter_service record are used. Option port defaults to 3868 for a listening transport and 0 for a connecting transport. An small receive buffer may result in a peer having to resend incoming messages: set the inet(3) option recbuf to increase the buffer size. An small send buffer may result in outgoing messages being discarded: set the inet(3) option sndbuf to increase the buffer size.","ref":"diameter_sctp.html#start/3","title":"diameter_sctp.start/3","type":"function"},{"doc":"This module implements diameter transport over TCP using gen_tcp(3) . It can be specified as the value of a transport_module option to diameter:add_transport/2 and implements the behaviour documented in diameter_transport(3) . TLS security is supported, either as an upgrade following capabilities exchange or at connection establishment. Note that the ssl application is required for TLS and must be started before configuring TLS capability on diameter transports. SEE ALSO diameter(3) , diameter_transport(3) , gen_tcp(3) , inet(3) , ssl(3)","ref":"diameter_tcp.html","title":"diameter_tcp","type":"module"},{"doc":"Type = connect | accept Ref = diameter:transport_ref() Svc = #diameter_service{} Opt = OwnOpt | SslOpt | TcpOpt Pid = pid() LAddr = inet:ip_address() Reason = term() OwnOpt = {raddr, inet:ip_address() } | {rport, integer()} | {accept, Match} | {port, integer()} | {fragment_timer, infinity | 0..16#FFFFFFFF} | {message_cb, diameter:eval()} | {sender, boolean()} SslOpt = {ssl_options, true | list()} TcpOpt = term() Match = inet:ip_address() | string() | [Match] The start function required by diameter_transport(3) . Options raddr and rport specify the remote address and port for a connecting transport and are not valid for a listening transport. Option accept specifies remote addresses for a listening transport and is not valid for a connecting transport. If specified, a remote address that does not match one of the specified addresses causes the connection to be aborted. Multiple accept options can be specified. A string-valued Match that does not parse as an address is interpreted as a regular expression. Option ssl_options must be specified for a transport that should support TLS: a value of true results in a TLS handshake immediately upon connection establishment while list() specifies options to be passed to ssl:connect/2 or ssl:handshake/2 after capabilities exchange if TLS is negotiated. Option fragment_timer specifies the timeout, in milliseconds, of a timer used to flush messages from the incoming byte stream even if the number of bytes indicated in the Message Length field of its Diameter Header have not yet been accumulated: such a message is received over the transport interface after two successive timeouts without the reception of additional bytes. Defaults to 1000. Option sender specifies whether or not to use a dedicated process for sending outgoing messages, which avoids the possibility of send blocking reception. Defaults to false . If set to true then a message_cb that avoids the possibility of messages being queued in the sender process without bound should be configured. Option message_cb specifies a callback that is invoked on incoming and outgoing messages, that can be used to implement flow control. It is applied to two arguments: an atom indicating the reason for the callback ( send , recv , or ack after a completed send), and the message in question (binary() on recv , binary() or diameter_packet record on send or ack , or false on ack when an incoming request has been discarded). It should return a list of actions and a new callback as tail; eg. [fun cb/3, State] . Valid actions are the atoms send or recv , to cause a following message-valued action to be sent/received, a message to send/receive (binary() or diameter_packet record), or a boolean() to enable/disable reading on the socket. More than one send / recv /message sequence can be returned from the same callback, and an initial send / recv can be omitted if the same as the value passed as the callback's first argument. Reading is initially enabled, and returning false does not imply there cannot be subsequent recv callbacks since messages may already have been read. An empty tail is equivalent to the prevailing callback. Defaults to a callback equivalent to fun(ack, _) -&gt; []; (_, Msg) -&gt; [Msg] end . Remaining options are any accepted by ssl:connect/3 or gen_tcp:connect/3 for a connecting transport, or ssl:listen/2 or gen_tcp:listen/2 for a listening transport, depending on whether or not {ssl_options, true} has been specified. Options binary , packet and active cannot be specified. Also, option port can be specified for a listening transport to specify the local listening port, the default being the standardized 3868. Note that the option ip specifies the local address. An ssl_options list must be specified if and only if the transport in question has set Inband-Security-Id to 1 ( TLS ), as specified to either diameter:start_service/2 or diameter:add_transport/2 , so that the transport process will receive notification of whether or not to commence with a TLS handshake following capabilities exchange. Failing to specify an options list on a TLS-capable transport for which TLS is negotiated will cause TLS handshake to fail. Failing to specify TLS capability when ssl_options has been specified will cause the transport process to wait for a notification that will not be forthcoming, which will eventually cause the RFC 3539 watchdog to take down the connection. The first element of a non-empty Host-IP-Address list in Svc provides the local IP address if an ip option is not specified. The local address is either returned from start/3 or passed in a connected message over the transport interface.","ref":"diameter_tcp.html#start/3","title":"diameter_tcp.start/3","type":"function"}]