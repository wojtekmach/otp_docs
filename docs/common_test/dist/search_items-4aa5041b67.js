searchNodes=[{"doc":"Main user interface for the Common Test framework. This module implements the command-line interface for running tests and basic functions for Common Test case issues, such as configuration and logging. Test Suite Support Macros The config macro is defined in ct.hrl . This macro is to be used to retrieve information from the Config variable sent to all test cases. It is used with two arguments; the first is the name of the configuration variable to retrieve, the second is the Config variable supplied to the test case. Possible configuration variables include: data_dir - Data file directory priv_dir - Scratch file directory Whatever added by init_per_suite/1 or init_per_testcase/2 in the test suite.","ref":"ct.html","title":"ct","type":"module"},{"doc":"Reason = term() ErrorReason = no_testcase_running | parallel_group Aborts the currently executing test case. The user must know with certainty which test case is currently executing. The function is therefore only safe to call from a function that has been called (or synchronously invoked) by the test case. Reason , the reason for aborting the test case, is printed in the test case log.","ref":"ct.html#abort_current_testcase/1","title":"ct.abort_current_testcase/1","type":"function"},{"doc":"Callback = atom() Config = string() Reason = term() Loads configuration variables using the specified callback module and configuration string. The callback module is to be either loaded or present in the code path. Loaded configuration variables can later be removed using function ct:remove_config/2 .","ref":"ct.html#add_config/2","title":"ct.add_config/2","type":"function"},{"doc":"Comment = string() Reason = {multiple_cases_running, TestCases} | 'enable break with release_shell option' TestCases = [atom()] Cancels any active timetrap and pauses the execution of the current test case until the user calls function continue/0 . The user can then interact with the Erlang node running the tests, for example, for debugging purposes or for manually executing a part of the test case. If a parallel group is executing, ct:break/2 is to be called instead. A cancelled timetrap is not automatically reactivated after the break, but must be started explicitly with ct:timetrap/1 . In order for the break/continue functionality to work, Common Test must release the shell process controlling stdin . This is done by setting start option release_shell to true . For details, see section Running Tests from the Erlang Shell or from an Erlang Program in the User's Guide.","ref":"ct.html#break/1","title":"ct.break/1","type":"function"},{"doc":"TestCase = atom() Comment = string() Reason = 'test case not running' | 'enable break with release_shell option' Works the same way as ct:break/1 , only argument TestCase makes it possible to pause a test case executing in a parallel group. Function ct:continue/1 is to be used to resume execution of TestCase . For details, see ct:break/1 .","ref":"ct.html#break/2","title":"ct.break/2","type":"function"},{"doc":"ListOfStrings = [string()] Equivalent to ct:capture_get([default]) .","ref":"ct.html#capture_get/0","title":"ct.capture_get/0","type":"function"},{"doc":"ExclCategories = [atom()] ListOfStrings = [string()] Returns and purges the list of text strings buffered during the latest session of capturing printouts to stdout . Log categories that are to be ignored in ListOfStrings can be specified with ExclCategories . If ExclCategories = [] , no filtering takes place. See also ct:capture_start/0 , ct:capture_stop/0 , ct:log/3 .","ref":"ct.html#capture_get/1","title":"ct.capture_get/1","type":"function"},{"doc":"Starts capturing all text strings printed to stdout during execution of the test case. See also ct:capture_get/1 , ct:capture_stop/0 .","ref":"ct.html#capture_start/0","title":"ct.capture_start/0","type":"function"},{"doc":"Stops capturing text strings (a session started with capture_start/0 ). See also ct:capture_get/1 , ct:capture_start/0 .","ref":"ct.html#capture_stop/0","title":"ct.capture_stop/0","type":"function"},{"doc":"Comment = term() Prints the specified Comment in the comment field in the table on the test suite result page. If called several times, only the last comment is printed. The test case return value {comment,Comment} overwrites the string set by this function.","ref":"ct.html#comment/1","title":"ct.comment/1","type":"function"},{"doc":"Format = string() Args = list() Prints the formatted string in the comment field in the table on the test suite result page. Arguments Format and Args are used in a call to io_lib:format/2 to create the comment string. The behavior of comment/2 is otherwise the same as function ct:comment/1 .","ref":"ct.html#comment/2","title":"ct.comment/2","type":"function"},{"doc":"This function must be called to continue after a test case (not executing in a parallel group) has called function ct:break/1 .","ref":"ct.html#continue/0","title":"ct.continue/0","type":"function"},{"doc":"TestCase = atom() This function must be called to continue after a test case has called ct:break/2 . If the paused test case, TestCase , executes in a parallel group, this function, rather than continue/0 , must be used to let the test case proceed.","ref":"ct.html#continue/1","title":"ct.continue/1","type":"function"},{"doc":"EncryptFileName = string() TargetFileName = string() Reason = term() Decrypts EncryptFileName , previously generated with ct:encrypt_config_file/2,3 . The original file contents is saved in the target file. The encryption key, a string, must be available in a text file named .ct_config.crypt , either in the current directory, or the home directory of the user (it is searched for in that order).","ref":"ct.html#decrypt_config_file/2","title":"ct.decrypt_config_file/2","type":"function"},{"doc":"EncryptFileName = string() TargetFileName = string() KeyOrFile = {key, string()} | {file, string()} Reason = term() Decrypts EncryptFileName , previously generated with ct:encrypt_config_file/2,3 . The original file contents is saved in the target file. The key must have the same value as that used for encryption.","ref":"ct.html#decrypt_config_file/3","title":"ct.decrypt_config_file/3","type":"function"},{"doc":"SrcFileName = string() EncryptFileName = string() Reason = term() Encrypts the source configuration file with DES3 and saves the result in file EncryptFileName . The key, a string, must be available in a text file named .ct_config.crypt , either in the current directory, or the home directory of the user (it is searched for in that order). For information about using encrypted configuration files when running tests, see section Encrypted Configuration Files in the User's Guide. For details on DES3 encryption/decryption, see application Crypto .","ref":"ct.html#encrypt_config_file/2","title":"ct.encrypt_config_file/2","type":"function"},{"doc":"SrcFileName = string() EncryptFileName = string() KeyOrFile = {key, string()} | {file, string()} Reason = term() Encrypts the source configuration file with DES3 and saves the result in the target file EncryptFileName . The encryption key to use is either the value in {key,Key} or the value stored in the file specified by {file,File} . For information about using encrypted configuration files when running tests, see section Encrypted Configuration Files in the User's Guide. For details on DES3 encryption/decryption, see application Crypto .","ref":"ct.html#encrypt_config_file/3","title":"ct.encrypt_config_file/3","type":"function"},{"doc":"Reason = term() Terminates a test case with the specified error Reason .","ref":"ct.html#fail/1","title":"ct.fail/1","type":"function"},{"doc":"Format = string() Args = list() Terminates a test case with an error message specified by a format string and a list of values (used as arguments to io_lib:format/2 ).","ref":"ct.html#fail/2","title":"ct.fail/2","type":"function"},{"doc":"Equivalent to ct:get_config(Required, undefined, []) .","ref":"ct.html#get_config/1","title":"ct.get_config/1","type":"function"},{"doc":"Equivalent to ct:get_config(Required, Default, []) .","ref":"ct.html#get_config/2","title":"ct.get_config/2","type":"function"},{"doc":"Required = KeyOrName | {KeyOrName, SubKey} | {KeyOrName, SubKey, SubKey} KeyOrName = atom() SubKey = atom() Default = term() Opts = [Opt] | [] Opt = element | all ValueOrElement = term() | Default Reads configuration data values. Returns the matching values or configuration elements, given a configuration variable key or its associated name (if one has been specified with ct:require/2 or a require statement). Example: Given the following configuration file: { unix , [ { telnet , IpAddr } , { user , [ { username , Username } , { password , Password } ] } ] } . Then: ct : get_config ( unix , Default ) -&gt; [ { telnet , IpAddr } , { user , [ { username , Username } , { password , Password } ] } ] ct : get_config ( { unix , telnet } , Default ) -&gt; IpAddr ct : get_config ( { unix , user , username } , Default ) -&gt; Username ct : get_config ( { unix , ftp } , Default ) -&gt; Default ct : get_config ( unknownkey , Default ) -&gt; Default If a configuration variable key has been associated with a name (by ct:require/2 or a require statement), the name can be used instead of the key to read the value: ct : require ( myuser , { unix , user } ) -&gt; ok . ct : get_config ( myuser , Default ) -&gt; [ { username , Username } , { password , Password } ] If a configuration variable is defined in multiple files, use option all to access all possible values. The values are returned in a list. The order of the elements corresponds to the order that the configuration files were specified at startup. If configuration elements (key-value tuples) are to be returned as result instead of values, use option element . The returned elements are then on the form {Required,Value} . See also ct:get_config/1 , ct:get_config/2 , ct:require/1 , ct:require/2 .","ref":"ct.html#get_config/3","title":"ct.get_config/3","type":"function"},{"doc":"EvMgrRef = atom() Gets a reference to the Common Test event manager. The reference can be used to, for example, add a user-specific event handler while tests are running. Example: gen_event : add_handler ( ct : get_event_mgr_ref ( ) , my_ev_h , [ ] )","ref":"ct.html#get_event_mgr_ref/0","title":"ct.get_event_mgr_ref/0","type":"function"},{"doc":"Returns the command used to start this Erlang instance. If this information could not be found, the string &quot;no_prog_name&quot; is returned.","ref":"ct.html#get_progname/0","title":"ct.get_progname/0","type":"function"},{"doc":"TestStatus = [StatusElem] StatusElem = {current, TestCaseInfo} | {successful, Successful} | {failed, Failed} | {skipped, Skipped} | {total, Total} TestCaseInfo = {Suite, TestCase} | [{Suite, TestCase}] Suite = atom() TestCase = atom() Successful = integer() Failed = integer() Skipped = {UserSkipped, AutoSkipped} UserSkipped = integer() AutoSkipped = integer() Total = integer() Reason = term() Returns status of ongoing test. The returned list contains information about which test case is executing (a list of cases when a parallel test case group is executing), as well as counters for successful, failed, skipped, and total test cases so far.","ref":"ct.html#get_status/0","title":"ct.get_status/0","type":"function"},{"doc":"Handle = handle() TargetName = target_name() Returns the name of the target that the specified connection belongs to.","ref":"ct.html#get_target_name/1","title":"ct.get_target_name/1","type":"function"},{"doc":"TestSpecTerms = [{Tag, Value}] Value = [term()] Gets a list of all test specification terms used to configure and run this test.","ref":"ct.html#get_testspec_terms/0","title":"ct.get_testspec_terms/0","type":"function"},{"doc":"Tags = [Tag] | Tag Tag = atom() TestSpecTerms = [{Tag, Value}] | {Tag, Value} Value = [{Node, term()}] | [term()] Node = atom() Reads one or more terms from the test specification used to configure and run this test. Tag is any valid test specification tag, for example, label , config , or logdir . User-specific terms are also available to read if option allow_user_terms is set. All value tuples returned, except user terms, have the node name as first element. To read test terms, use Tag = tests (rather than suites , groups , or cases ). Value is then the list of all tests on the form [{Node,Dir,[{TestSpec,GroupsAndCases1},...]},...] , where GroupsAndCases = [{Group,[Case]}] | [Case] .","ref":"ct.html#get_testspec_terms/1","title":"ct.get_testspec_terms/1","type":"function"},{"doc":"Time = integer() | infinity Scaling = true | false ScaleVal = integer() Reads information about the timetrap set for the current test case. Scaling indicates if Common Test will attempt to compensate timetraps automatically for runtime delays introduced by, for example, tools like cover. ScaleVal is the value of the current scaling multipler (always 1 if scaling is disabled). Note the Time is not the scaled result.","ref":"ct.html#get_timetrap_info/0","title":"ct.get_timetrap_info/0","type":"function"},{"doc":"Category = default | atom() Level = integer() This function returns the verbosity level for the specified logging category. See the User's Guide for details. Use the value default to read the general verbosity level.","ref":"ct.html#get_verbosity/1","title":"ct.get_verbosity/1","type":"function"},{"doc":"Opts = [Opt] Opt = {config, ConfigFiles} | {event_handler, Modules} | {decrypt, KeyOrFile} ConfigFiles = [ConfigFile] ConfigFile = string() Modules = [atom()] KeyOrFile = {key, Key} | {file, KeyFile} Key = string() KeyFile = string() Installs configuration files and event handlers. Run this function once before the first test. Example: install ( [ { config , [ &quot;config_node.ctc&quot; , &quot;config_user.ctc&quot; ] } ] ) This function is automatically run by program ct_run .","ref":"ct.html#install/1","title":"ct.install/1","type":"function"},{"doc":"Telnet = term() Env = {Key, Value} Key = string() Value = string() Performs command listenv on the specified Telnet connection and returns the result as a list of key-value pairs.","ref":"ct.html#listenv/1","title":"ct.listenv/1","type":"function"},{"doc":"Equivalent to ct:log(default, 50, Format, [], []) .","ref":"ct.html#log/1","title":"ct.log/1","type":"function"},{"doc":"X1 = Category | Importance | Format X2 = Format | FormatArgs Equivalent to ct:log(Category, Importance, Format, FormatArgs, []) .","ref":"ct.html#log/2","title":"ct.log/2","type":"function"},{"doc":"X1 = Category | Importance X2 = Importance | Format X3 = Format | FormatArgs | Opts Equivalent to ct:log(Category, Importance, Format, FormatArgs, Opts) .","ref":"ct.html#log/3","title":"ct.log/3","type":"function"},{"doc":"X1 = Category | Importance X2 = Importance | Format X3 = Format | FormatArgs X4 = FormatArgs | Opts Equivalent to ct:log(Category, Importance, Format, FormatArgs, Opts) .","ref":"ct.html#log/4","title":"ct.log/4","type":"function"},{"doc":"Category = atom() Importance = integer() Format = string() FormatArgs = list() Opts = [Opt] Opt = {heading,string()} | no_css | esc_chars Prints from a test case to the log file. This function is meant for printing a string directly from a test case to the test case log file. Default Category is default , default Importance is ?STD_IMPORTANCE , and default value for FormatArgs is [] . For details on Category , Importance and the no_css option, see section Logging - Categories and Verbosity Levels in the User's Guide. Common Test will not escape special HTML characters (&lt;, &gt; and &amp;) in the text printed with this function, unless the esc_chars option is used.","ref":"ct.html#log/5","title":"ct.log/5","type":"function"},{"doc":"Reason = term() If the test is started with option create_priv_dir set to manual_per_tc , in order for the test case to use the private directory, it must first create it by calling this function.","ref":"ct.html#make_priv_dir/0","title":"ct.make_priv_dir/0","type":"function"},{"doc":"Name = atom() Data = term() Sends an asynchronous notification of type Name with Data to the Common Test event manager. This can later be caught by any installed event manager. See also gen_event(3) .","ref":"ct.html#notify/2","title":"ct.notify/2","type":"function"},{"doc":"Equivalent to ct:pal(default, 50, Format, [], []) .","ref":"ct.html#pal/1","title":"ct.pal/1","type":"function"},{"doc":"X1 = Category | Importance | Format X2 = Format | FormatArgs Equivalent to ct:pal(Category, Importance, Format, FormatArgs, []) .","ref":"ct.html#pal/2","title":"ct.pal/2","type":"function"},{"doc":"X1 = Category | Importance X2 = Importance | Format X3 = Format | FormatArgs | Opts Equivalent to ct:pal(Category, Importance, Format, FormatArgs, Opts) .","ref":"ct.html#pal/3","title":"ct.pal/3","type":"function"},{"doc":"X1 = Category | Importance X2 = Importance | Format X3 = Format | FormatArgs X4 = FormatArgs | Opts Equivalent to ct:pal(Category, Importance, Format, FormatArgs, Opts) .","ref":"ct.html#pal/4","title":"ct.pal/4","type":"function"},{"doc":"Category = atom() Importance = integer() Format = string() FormatArgs = list() Opts = [Opt] Opt = {heading,string()} | no_css Prints and logs from a test case. This function is meant for printing a string from a test case, both to the test case log file and to the console. Default Category is default , default Importance is ?STD_IMPORTANCE , and default value for FormatArgs is [] . For details on Category and Importance , see section Logging - Categories and Verbosity Levels in the User's Guide. Note that special characters in the text (&lt;, &gt; and &amp;) will be escaped by Common Test before the text is printed to the log file.","ref":"ct.html#pal/5","title":"ct.pal/5","type":"function"},{"doc":"Data = [string()] Heading = tuple() Table = [tuple()] Parses the printout from an SQL table and returns a list of tuples. The printout to parse is typically the result of a select command in SQL. The returned Table is a list of tuples, where each tuple is a row in the table. Heading is a tuple of strings representing the headings of each column in the table.","ref":"ct.html#parse_table/1","title":"ct.parse_table/1","type":"function"},{"doc":"Equivalent to ct:print(default, 50, Format, [], []) .","ref":"ct.html#print/1","title":"ct.print/1","type":"function"},{"doc":"X1 = Category | Importance | Format X2 = Format | FormatArgs Equivalent to ct:print(Category, Importance, Format, FormatArgs, []) .","ref":"ct.html#print/2","title":"ct.print/2","type":"function"},{"doc":"X1 = Category | Importance X2 = Importance | Format X3 = Format | FormatArgs | Opts Equivalent to ct:print(Category, Importance, Format, FormatArgs, Opts) .","ref":"ct.html#print/3","title":"ct.print/3","type":"function"},{"doc":"X1 = Category | Importance X2 = Importance | Format X3 = Format | FormatArgs X4 = FormatArgs | Opts Equivalent to ct:print(Category, Importance, Format, FormatArgs, Opts) .","ref":"ct.html#print/4","title":"ct.print/4","type":"function"},{"doc":"Category = atom() Importance = integer() Format = string() FormatArgs = list() Opts = [Opt] Opt = {heading,string()} Prints from a test case to the console. This function is meant for printing a string from a test case to the console. Default Category is default , default Importance is ?STD_IMPORTANCE , and default value for FormatArgs is [] . For details on Category and Importance , see section Logging - Categories and Verbosity Levels in the User's Guide.","ref":"ct.html#print/5","title":"ct.print/5","type":"function"},{"doc":"Required = KeyOrName | {KeyOrName, SubKey} | {KeyOrName, SubKey, SubKey} KeyOrName = atom() SubKey = atom() ValueOrElement = term() Reloads configuration file containing specified configuration key. This function updates the configuration data from which the specified configuration variable was read, and returns the (possibly) new value of this variable. If some variables were present in the configuration, but are not loaded using this function, they are removed from the configuration table together with their aliases.","ref":"ct.html#reload_config/1","title":"ct.reload_config/1","type":"function"},{"doc":"TestProcs = [{pid(),GL}] GL = pid() SharedGL = pid() OtherGLs = [pid()] This function will return the identity of test- and group leader processes that are still running at the time of this call. TestProcs are processes in the system that have a Common Test IO process as group leader. SharedGL is the central Common Test IO process, responsible for printing to log files for configuration functions and sequentially executing test cases. OtherGLs are Common Test IO processes that print to log files for test cases in parallel test case groups. The process information returned by this function may be used to locate and terminate remaining processes after tests have finished executing. The function would typically by called from Common Test Hook functions. Note that processes that execute configuration functions or test cases are never included in TestProcs . It is therefore safe to use post configuration hook functions (such as post_end_per_suite, post_end_per_group, post_end_per_testcase) to terminate all processes in TestProcs that have the current group leader process as its group leader. Note also that the shared group leader ( SharedGL ) must never be terminated by the user, only by Common Test. Group leader processes for parallel test case groups ( OtherGLs ) may however be terminated in post_end_per_group hook functions.","ref":"ct.html#remaining_test_procs/0","title":"ct.remaining_test_procs/0","type":"function"},{"doc":"Callback = atom() Config = string() Reason = term() Removes configuration variables (together with their aliases) that were loaded with specified callback module and configuration string.","ref":"ct.html#remove_config/2","title":"ct.remove_config/2","type":"function"},{"doc":"Required = Key | {Key, SubKeys} | {Key, SubKey, SubKeys} Key = atom() SubKeys = SubKey | [SubKey] SubKey = atom() Checks if the required configuration is available. Arbitrarily deep tuples can be specified as Required . Only the last element of the tuple can be a list of SubKey s. Example 1. Require the variable myvar : ok = ct : require ( myvar ) . In this case the configuration file must at least contain: { myvar , Value } . Example 2. Require key myvar with subkeys sub1 and sub2 : ok = ct : require ( { myvar , [ sub1 , sub2 ] } ) . In this case the configuration file must at least contain: { myvar , [ { sub1 , Value } , { sub2 , Value } ] } . Example 3. Require key myvar with subkey sub1 with subsub1 : ok = ct : require ( { myvar , sub1 , sub2 } ) . In this case the configuration file must at least contain: { myvar , [ { sub1 , [ { sub2 , Value } ] } ] } . See also ct:get_config/1 , ct:get_config/2 , ct:get_config/3 , ct:require/2 .","ref":"ct.html#require/1","title":"ct.require/1","type":"function"},{"doc":"Name = atom() Required = Key | {Key, SubKey} | {Key, SubKey, SubKey} SubKey = Key Key = atom() Checks if the required configuration is available and gives it a name. The semantics for Required is the same as in ct:require/1 except that a list of SubKey s cannot be specified. If the requested data is available, the subentry is associated with Name so that the value of the element can be read with ct:get_config/1,2 provided Name is used instead of the whole Required term. Example: Require one node with a Telnet connection and an FTP connection. Name the node a : ok = ct : require ( a , { machine , node } ) . All references to this node can then use the node name. For example, a file over FTP is fetched like follows: ok = ct : ftp_get ( a , RemoteFile , LocalFile ) . For this to work, the configuration file must at least contain: { machine , [ { node , [ { telnet , IpAddr } , { ftp , IpAddr } ] } ] } . The behavior of this function changed radically in Common Test 1.6.2. To keep some backwards compatability, it is still possible to do: ct:require(a,{node,[telnet,ftp]}). This associates the name a with the top-level node entry. For this to work, the configuration file must at least contain: {node,[{telnet,IpAddr},{ftp,IpAddr}]}. See also ct:get_config/1 , ct:get_config/2 , ct:get_config/3 , ct:require/1 .","ref":"ct.html#require/2","title":"ct.require/2","type":"function"},{"doc":"TestDirs = TestDir | [TestDir] Runs all test cases in all suites in the specified directories. See also ct:run/3 .","ref":"ct.html#run/1","title":"ct.run/1","type":"function"},{"doc":"Runs all test cases in the specified suite. See also ct:run/3 .","ref":"ct.html#run/2","title":"ct.run/2","type":"function"},{"doc":"TestDir = string() Suite = atom() Cases = atom() | [atom()] Result = [TestResult] | {error, Reason} Runs the specified test cases. Requires that ct:install/1 has been run first. Suites ( *_SUITE.erl ) files must be stored in TestDir or TestDir/test . All suites are compiled when the test is run.","ref":"ct.html#run/3","title":"ct.run/3","type":"function"},{"doc":"Opts = [OptTuples] OptTuples = {dir, TestDirs} | {suite, Suites} | {group, Groups} | {testcase, Cases} | {spec, TestSpecs} | {join_specs, Bool} | {label, Label} | {config, CfgFiles} | {userconfig, UserConfig} | {allow_user_terms, Bool} | {logdir, LogDir} | {silent_connections, Conns} | {stylesheet, CSSFile} | {cover, CoverSpecFile} | {cover_stop, Bool} | {step, StepOpts} | {event_handler, EventHandlers} | {include, InclDirs} | {auto_compile, Bool} | {abort_if_missing_suites, Bool} | {create_priv_dir, CreatePrivDir} | {multiply_timetraps, M} | {scale_timetraps, Bool} | {repeat, N} | {duration, DurTime} | {until, StopTime} | {force_stop, ForceStop} | {decrypt, DecryptKeyOrFile} | {refresh_logs, LogDir} | {logopts, LogOpts} | {verbosity, VLevels} | {basic_html, Bool} | {esc_chars, Bool} | {keep_logs,KeepSpec} | {ct_hooks, CTHs} | {enable_builtin_hooks, Bool} | {release_shell, Bool} TestDirs = [string()] | string() Suites = [string()] | [atom()] | string() | atom() Cases = [atom()] | atom() Groups = GroupNameOrPath | [GroupNameOrPath] GroupNameOrPath = [atom()] | atom() | all TestSpecs = [string()] | string() Label = string() | atom() CfgFiles = [string()] | string() UserConfig = [{CallbackMod, CfgStrings}] | {CallbackMod, CfgStrings} CallbackMod = atom() CfgStrings = [string()] | string() LogDir = string() Conns = all | [atom()] CSSFile = string() CoverSpecFile = string() StepOpts = [StepOpt] | [] StepOpt = config | keep_inactive EventHandlers = EH | [EH] EH = atom() | {atom(), InitArgs} | {[atom()], InitArgs} InitArgs = [term()] InclDirs = [string()] | string() CreatePrivDir = auto_per_run | auto_per_tc | manual_per_tc M = integer() N = integer() DurTime = string(HHMMSS) StopTime = string(YYMoMoDDHHMMSS) | string(HHMMSS) ForceStop = skip_rest | Bool DecryptKeyOrFile = {key, DecryptKey} | {file, DecryptFile} DecryptKey = string() DecryptFile = string() LogOpts = [LogOpt] LogOpt = no_nl | no_src VLevels = VLevel | [{Category, VLevel}] VLevel = integer() Category = atom() KeepSpec = all | pos_integer() CTHs = [CTHModule | {CTHModule, CTHInitArgs}] CTHModule = atom() CTHInitArgs = term() Result = {Ok, Failed, {UserSkipped, AutoSkipped}} | TestRunnerPid | {error, Reason} Ok = integer() Failed = integer() UserSkipped = integer() AutoSkipped = integer() TestRunnerPid = pid() Reason = term() Runs tests as specified by the combination of options in Opts . The options are the same as those used with program ct_run , see Run Tests from Command Line in the ct_run manual page. Here a TestDir can be used to point out the path to a Suite . Option testcase corresponds to option -case in program ct_run . Configuration files specified in Opts are installed automatically at startup. TestRunnerPid is returned if release_shell == true . For details, see ct:break/1 . Reason indicates the type of error encountered.","ref":"ct.html#run_test/1","title":"ct.run_test/1","type":"function"},{"doc":"TestSpec = [term()] Result = {Ok, Failed, {UserSkipped, AutoSkipped}} | {error, Reason} Ok = integer() Failed = integer() UserSkipped = integer() AutoSkipped = integer() Reason = term() Runs a test specified by TestSpec . The same terms are used as in test specification files. Reason indicates the type of error encountered.","ref":"ct.html#run_testspec/1","title":"ct.run_testspec/1","type":"function"},{"doc":"Category = default | atom() Level = integer() Use this function to set, or modify, the verbosity level for a logging category. See the User's Guide for details. Use the value default to set the general verbosity level.","ref":"ct.html#set_verbosity/2","title":"ct.set_verbosity/2","type":"function"},{"doc":"Time = {hours, Hours} | {minutes, Mins} | {seconds, Secs} | Millisecs | infinity Hours = integer() Mins = integer() Secs = integer() Millisecs = integer() | float() This function, similar to timer:sleep/1 in STDLIB, suspends the test case for a specified time. However, this function also multiplies Time with the multiply_timetraps value (if set) and under certain circumstances also scales up the time automatically if scale_timetraps is set to true (default is false ).","ref":"ct.html#sleep/1","title":"ct.sleep/1","type":"function"},{"doc":"Starts Common Test in interactive mode. From this mode, all test case support functions can be executed directly from the Erlang shell. The interactive mode can also be started from the OS command line with ct_run -shell [-config File...] . If any functions (for example, Telnet or FTP) using &quot;required configuration data&quot; are to be called from the Erlang shell, configuration data must first be required with ct:require/2 . Example: &gt; ct : require ( unix_telnet , unix ) . ok &gt; ct_telnet : open ( unix_telnet ) . { ok , &lt; 0.105 . 0 &gt; } &gt; ct_telnet : cmd ( unix_telnet , &quot;ls .&quot; ) . { ok , [ &quot;ls&quot; , &quot;file1 ...&quot; , . . . ] }","ref":"ct.html#start_interactive/0","title":"ct.start_interactive/0","type":"function"},{"doc":"Case = atom() Steps through a test case with the debugger. See also ct:run/3 .","ref":"ct.html#step/3","title":"ct.step/3","type":"function"},{"doc":"Case = atom() Opts = [Opt] | [] Opt = config | keep_inactive Steps through a test case with the debugger. If option config has been specified, breakpoints are also set on the configuration functions in Suite . See also ct:run/3 .","ref":"ct.html#step/4","title":"ct.step/4","type":"function"},{"doc":"Exits the interactive mode. See also ct:start_interactive/0 .","ref":"ct.html#stop_interactive/0","title":"ct.stop_interactive/0","type":"function"},{"doc":"Name = atom() Data = term() Sends a synchronous notification of type Name with Data to the Common Test event manager. This can later be caught by any installed event manager. See also gen_event(3) .","ref":"ct.html#sync_notify/2","title":"ct.sync_notify/2","type":"function"},{"doc":"TestDir = string() Suite = atom() Testcases = list() Reason = term() Returns all test cases in the specified suite.","ref":"ct.html#testcases/2","title":"ct.testcases/2","type":"function"},{"doc":"Time = {hours, Hours} | {minutes, Mins} | {seconds, Secs} | Millisecs | infinity | Func Hours = integer() Mins = integer() Secs = integer() Millisecs = integer() Func = {M, F, A} | function() M = atom() F = atom() A = list() Sets a new timetrap for the running test case. If the argument is Func , the timetrap is triggered when this function returns. Func can also return a new Time value, which in that case is the value for the new timetrap.","ref":"ct.html#timetrap/1","title":"ct.timetrap/1","type":"function"},{"doc":"TestDir = string() Suite = atom() SuiteUserData = [term()] Reason = term() Returns any data specified with tag userdata in the list of tuples returned from suite/0 .","ref":"ct.html#userdata/2","title":"ct.userdata/2","type":"function"},{"doc":"TestDir = string() Suite = atom() GroupOrCase = {group, GroupName} | atom() GroupName = atom() TCUserData = [term()] Reason = term() Returns any data specified with tag userdata in the list of tuples returned from Suite:group(GroupName) or Suite:Case() .","ref":"ct.html#userdata/3","title":"ct.userdata/3","type":"function"},{"doc":"A configuration key which exists in a configuration file","ref":"ct.html#t:config_key/0","title":"ct.config_key/0","type":"type"},{"doc":"","ref":"ct.html#t:conn_log_mod/0","title":"ct.conn_log_mod/0","type":"type"},{"doc":"","ref":"ct.html#t:conn_log_option/0","title":"ct.conn_log_option/0","type":"type"},{"doc":"Options that can be given to the cth_conn_log hook, which is used for logging of NETCONF and Telnet connections. See ct_netconfc or ct_telnet for description and examples of how to use this hook.","ref":"ct.html#t:conn_log_options/0","title":"ct.conn_log_options/0","type":"type"},{"doc":"","ref":"ct.html#t:conn_log_type/0","title":"ct.conn_log_type/0","type":"type"},{"doc":"The identity (handle) of a connection.","ref":"ct.html#t:handle/0","title":"ct.handle/0","type":"type"},{"doc":"Options that can be given to the cth_conn_log hook, which is used for logging of NETCONF and Telnet connections. See ct_netconfc or ct_telnet for description and examples of how to use this hook.","ref":"ct.html#t:key_or_name/0","title":"ct.key_or_name/0","type":"type"},{"doc":"A name and association to configuration data introduced through a require statement, or a call to ct:require/2 , for example, ct:require(mynodename,{node,[telnet]}) .","ref":"ct.html#t:target_name/0","title":"ct.target_name/0","type":"type"},{"doc":"Common Test framework code coverage support module. This module exports help functions for performing code coverage analysis.","ref":"ct_cover.html","title":"ct_cover","type":"module"},{"doc":"Nodes = [atom()] StartedNodes = [atom()] Reason = cover_not_running | not_main_node Adds nodes to current cover test. Notice that this only works if cover support is active. To have effect, this function is to be called from init_per_suite/1 (see common_test ) before any tests are performed.","ref":"ct_cover.html#add_nodes/1","title":"ct_cover.add_nodes/1","type":"function"},{"doc":"Level = overview | details Tests = [{Tag, Dir}] Tag = atom() Dir = string() Accumulates cover results over multiple tests. See section Cross Cover Analysis in the Users's Guide.","ref":"ct_cover.html#cross_cover_analyse/2","title":"ct_cover.cross_cover_analyse/2","type":"function"},{"doc":"Nodes = [atom()] Reason = cover_not_running | not_main_node Removes nodes from the current cover test. Call this function to stop cover test on nodes previously added with ct_cover:add_nodes/1 . Results on the remote node are transferred to the Common Test node.","ref":"ct_cover.html#remove_nodes/1","title":"ct_cover.remove_nodes/1","type":"function"},{"doc":"FTP client module (based on the ftp application).","ref":"ct_ftp.html","title":"ct_ftp","type":"module"},{"doc":"Connection = connection() Dir = string() Changes directory on remote host.","ref":"ct_ftp.html#cd/2","title":"ct_ftp.cd/2","type":"function"},{"doc":"Connection = connection() Closes the FTP connection.","ref":"ct_ftp.html#close/1","title":"ct_ftp.close/1","type":"function"},{"doc":"Connection = connection() File = string() Deletes a file on remote host.","ref":"ct_ftp.html#delete/2","title":"ct_ftp.delete/2","type":"function"},{"doc":"KeyOrName = Key | Name Key = atom() Name = target_name() RemoteFile = string() LocalFile = string() Opens an FTP connection and fetches a file from the remote host. RemoteFile and LocalFile must be absolute paths. The configuration file must be as for ct_ftp:put/3 . For target_name , see module ct . See also ct:require/2 .","ref":"ct_ftp.html#get/3","title":"ct_ftp.get/3","type":"function"},{"doc":"Connection = connection() Dir = string() Listing = string() Lists directory Dir .","ref":"ct_ftp.html#ls/2","title":"ct_ftp.ls/2","type":"function"},{"doc":"KeyOrName = Key | Name Key = atom() Name = target_name() Handle = handle() Opens an FTP connection to the specified node. You can open a connection for a particular Name and use the same name as reference for all following subsequent operations. If you want the connection to be associated with Handle instead (if you, for example, need to open multiple connections to a host), use Key , the configuration variable name, to specify the target. A connection without an associated target name can only be closed with the handle value. For information on how to create a new Name , see ct:require/2 . For target_name , see module ct .","ref":"ct_ftp.html#open/1","title":"ct_ftp.open/1","type":"function"},{"doc":"KeyOrName = Key | Name Key = atom() Name = target_name() LocalFile = string() RemoteFile = string() Opens an FTP connection and sends a file to the remote host. LocalFile and RemoteFile must be absolute paths. For target_name , see module ct . If the target host is a &quot;special&quot; node, the FTP address must be specified in the configuration file as follows: { node , [ { ftp , IpAddr } ] } . If the target host is something else, for example, a UNIX host, the configuration file must also include the username and password (both strings): { unix , [ { ftp , IpAddr } , { username , Username } , { password , Password } ] } . See also ct:require/2 .","ref":"ct_ftp.html#put/3","title":"ct_ftp.put/3","type":"function"},{"doc":"Fetches a file over FTP. The file gets the same name on the local host. See also ct_ftp:recv/3 .","ref":"ct_ftp.html#recv/2","title":"ct_ftp.recv/2","type":"function"},{"doc":"Connection = connection() RemoteFile = string() LocalFile = string() Fetches a file over FTP. The file is named LocalFile on the local host.","ref":"ct_ftp.html#recv/3","title":"ct_ftp.recv/3","type":"function"},{"doc":"Sends a file over FTP. The file gets the same name on the remote host. See also ct_ftp:send/3 .","ref":"ct_ftp.html#send/2","title":"ct_ftp.send/2","type":"function"},{"doc":"Connection = connection() LocalFile = string() RemoteFile = string() Sends a file over FTP. The file is named RemoteFile on the remote host.","ref":"ct_ftp.html#send/3","title":"ct_ftp.send/3","type":"function"},{"doc":"Connection = connection() Type = ascii | binary Changes the file transfer type.","ref":"ct_ftp.html#type/2","title":"ct_ftp.type/2","type":"function"},{"doc":"For target_name , see module ct .","ref":"ct_ftp.html#t:connection/0","title":"ct_ftp.connection/0","type":"type"},{"doc":"Handle for a specific FTP connection, see module ct .","ref":"ct_ftp.html#t:handle/0","title":"ct_ftp.handle/0","type":"type"},{"doc":"Distributed test execution control for Common Test . This module exports functions for running Common Test nodes on multiple hosts in parallel.","ref":"ct_master.html","title":"ct_master","type":"module"},{"doc":"Stops all running tests.","ref":"ct_master.html#abort/0","title":"ct_master.abort/0","type":"function"},{"doc":"Nodes = atom() | [atom()] Stops tests on specified nodes.","ref":"ct_master.html#abort/1","title":"ct_master.abort/1","type":"function"},{"doc":"Bool = true | false If set to true , the ct_master logs are written on a primitive HTML format, not using the Common Test CSS style sheet.","ref":"ct_master.html#basic_html/1","title":"ct_master.basic_html/1","type":"function"},{"doc":"MasterEvMgrRef = atom() Gets a reference to the Common Test master event manager. The reference can be used to, for example, add a user-specific event handler while tests are running. Example: gen_event : add_handler ( ct_master : get_event_mgr_ref ( ) , my_ev_h , [ ] )","ref":"ct_master.html#get_event_mgr_ref/0","title":"ct_master.get_event_mgr_ref/0","type":"function"},{"doc":"Node = atom() Status = finished_ok | ongoing | aborted | {error, Reason} Reason = term() Returns test progress. If Status is ongoing , tests are running on the node and are not yet finished.","ref":"ct_master.html#progress/0","title":"ct_master.progress/0","type":"function"},{"doc":"TestSpecs = string() | [SeparateOrMerged] Equivalent to ct_master:run(TestSpecs, false, [], []) .","ref":"ct_master.html#run/1","title":"ct_master.run/1","type":"function"},{"doc":"TestSpecs = string() | [SeparateOrMerged] SeparateOrMerged = string() | [string()] InclNodes = [atom()] ExclNodes = [atom()] Equivalent to ct_master:run(TestSpecs, false, InclNodes, ExclNodes) .","ref":"ct_master.html#run/3","title":"ct_master.run/3","type":"function"},{"doc":"TestSpecs = string() | [SeparateOrMerged] SeparateOrMerged = string() | [string()] AllowUserTerms = bool() InclNodes = [atom()] ExclNodes = [atom()] Tests are spawned on the nodes as specified in TestSpecs . Each specification in TestSpec is handled separately. However, it is also possible to specify a list of specifications to be merged into one specification before the tests are executed. Any test without a particular node specification is also executed on the nodes in InclNodes . Nodes in the ExclNodes list are excluded from the test.","ref":"ct_master.html#run/4","title":"ct_master.run/4","type":"function"},{"doc":"TestSpecs = string() | [SeparateOrMerged] SeparateOrMerged = string() | [string()] Node = atom() Equivalent to ct_master:run_on_node(TestSpecs, false, Node) .","ref":"ct_master.html#run_on_node/2","title":"ct_master.run_on_node/2","type":"function"},{"doc":"TestSpecs = string() | [SeparateOrMerged] SeparateOrMerged = string() | [string()] AllowUserTerms = bool() Node = atom() Tests are spawned on Node according to TestSpecs .","ref":"ct_master.html#run_on_node/3","title":"ct_master.run_on_node/3","type":"function"},{"doc":"Node = atom() Opts = [OptTuples] OptTuples = {config, CfgFiles} | {dir, TestDirs} | {suite, Suites} | {testcase, Cases} | {spec, TestSpecs} | {allow_user_terms, Bool} | {logdir, LogDir} | {event_handler, EventHandlers} | {silent_connections, Conns} | {cover, CoverSpecFile} | {cover_stop, Bool} | {userconfig, UserCfgFiles} CfgFiles = string() | [string()] TestDirs = string() | [string()] Suites = atom() | [atom()] Cases = atom() | [atom()] TestSpecs = string() | [string()] LogDir = string() EventHandlers = EH | [EH] EH = atom() | {atom(), InitArgs} | {[atom()], InitArgs} InitArgs = [term()] Conns = all | [atom()] Tests are spawned on Node using ct:run_test/1","ref":"ct_master.html#run_test/2","title":"ct_master.run_test/2","type":"function"},{"doc":"NETCONF client module compliant with RFC 6241, NETCONF Configuration Protocol, and RFC 6242, Using the NETCONF Configuration Protocol over Secure SHell (SSH), and with support for RFC 5277, NETCONF Event Notifications. Connecting to a NETCONF server Call connect/1,2 to establish a connection to a server, then pass the returned handle to session/1-3 to establish a NETCONF session on a new SSH channel. Each call to session/1-3 establishes a new session on the same connection, and results in a hello message to the server. Alternately, open/1,2 can be used to establish a single session on a dedicated connection. (Or, equivalently, only_open/1,2 followed by hello/1-3 .) Connect/session options can be specified in a configuration file with entries like the following. { server_id ( ) , [ option ( ) ] } . The server_id() or an associated ct:target_name() can then be passed to the aforementioned functions to use the referenced configuration. Signaling Protocol operations in the NETCONF protocol are realized as remote procedure calls (RPCs) from client to server and a corresponding reply from server to client. RPCs are sent using like-named functions (eg. edit_config/3-5 to send an edit-config RPC), with the server reply as return value. There are functions for each RPC defined in RFC 6241 and the create-subscription RPC from RFC 5277, all of which are wrappers on send_rpc/2,3 , that can be used to send an arbitrary RPC not defined in RFC 6241 or RFC 5277. All of the signaling functions have one variant with a Timeout argument and one without, corresponding to an infinite timeout. The latter is inappropriate in most cases since a non-response by the server or a missing message-id causes the call to hang indefinitely. Logging The NETCONF server uses error_logger for logging of NETCONF traffic. A special purpose error handler is implemented in ct_conn_log_h . To use this error handler, add the cth_conn_log hook in the test suite, for example: suite() -&gt; [{ct_hooks, [{cth_conn_log, [{ ct:conn_log_mod() , ct:conn_log_options() }]}]}]. conn_log_mod() is the name of the Common Test module implementing the connection protocol, for example, ct_netconfc . Hook option log_type specifies the type of logging: raw The sent and received NETCONF data is logged to a separate text file &quot;as is&quot; without any formatting. A link to the file is added to the test case HTML log. pretty The sent and received NETCONF data is logged to a separate text file with XML data nicely indented. A link to the file is added to the test case HTML log. html (default) The sent and received NETCONF traffic is pretty printed directly in the test case HTML log. silent NETCONF traffic is not logged. By default, all NETCONF traffic is logged in one single log file. However, different connections can be logged in separate files. To do this, use hook option hosts and list the names of the servers/connections to be used in the suite. The connections must be named for this to work, that is, they must be opened with open/2 . Option hosts has no effect if log_type is set to html or silent . The hook options can also be specified in a configuration file with configuration variable ct_conn_log : {ct_conn_log,[{ ct:conn_log_mod() , ct:conn_log_options() }]}. For example: {ct_conn_log,[{ct_netconfc,[{log_type,pretty}, {hosts,[ ct:key_or_name() ]}]}]} Hook options specified in a configuration file overwrite the hard-coded hook options in the test suite. Logging Example 1: The following ct_hooks statement causes pretty printing of NETCONF traffic to separate logs for the connections named nc_server1 and nc_server2 . Any other connections are logged to default NETCONF log. suite ( ) -&gt; [ { ct_hooks , [ { cth_conn_log , [ { ct_netconfc , [ { log_type , pretty } } , { hosts , [ nc_server1 , nc_server2 ] } ] } ] } ] } ] . Connections must be opened as follows: open ( nc_server1 , [ . . . ] ) , open ( nc_server2 , [ . . . ] ) . Logging Example 2: The following configuration file causes raw logging of all NETCONF traffic in to one single text file: { ct_conn_log , [ { ct_netconfc , [ { log_type , raw } ] } ] } . The ct_hooks statement must look as follows: suite ( ) -&gt; [ { ct_hooks , [ { cth_conn_log , [ ] } ] } ] . The same ct_hooks statement without the configuration file would cause HTML logging of all NETCONF connections in to the test case HTML log.","ref":"ct_netconfc.html","title":"ct_netconfc","type":"module"},{"doc":"Executes an action. If the return type is void, ok is returned instead of {ok,[simple_xml()]} .","ref":"ct_netconfc.html#action/2","title":"ct_netconfc.action/2","type":"function"},{"doc":"","ref":"ct_netconfc.html#action/3","title":"ct_netconfc.action/3","type":"function"},{"doc":"Requests graceful termination of the session associated with the client. When a NETCONF server receives a close-session request, it gracefully closes the session. The server releases any locks and resources associated with the session and gracefully closes any associated connections. Any NETCONF requests received after a close-session request are ignored.","ref":"ct_netconfc.html#close_session/1","title":"ct_netconfc.close_session/1","type":"function"},{"doc":"","ref":"ct_netconfc.html#close_session/2","title":"ct_netconfc.close_session/2","type":"function"},{"doc":"Opens an SSH connection to a NETCONF server. If the server options are specified in a configuration file, use connect/2 instead. The opaque handle() reference returned from this function is required as connection identifier when opening sessions over this connection, see session/1-3 .","ref":"ct_netconfc.html#connect/1","title":"ct_netconfc.connect/1","type":"function"},{"doc":"Open an SSH connection to a named NETCONF server. If KeyOrName is a configured server_id() or a target_name() associated with such an Id, then the options for this server are fetched from the configuration file. The options list is added to those of the configuration file. If an option is specified in both lists, the configuration file takes precedence. If the server is not specified in a configuration file, use connect/1 instead. The opaque handle() reference returned from this function can be used as connection identifier when opening sessions over this connection, see session/1-3 . However, if KeyOrName is a target_name() , that is, if the server is named through a call to ct:require/2 or a require statement in the test suite, then this name can be used instead of handle() .","ref":"ct_netconfc.html#connect/2","title":"ct_netconfc.connect/2","type":"function"},{"doc":"Copies configuration data. Which source and target options that can be issued depends on the capabilities supported by the server. That is, :candidate and/or :startup are required.","ref":"ct_netconfc.html#copy_config/3","title":"ct_netconfc.copy_config/3","type":"function"},{"doc":"","ref":"ct_netconfc.html#copy_config/4","title":"ct_netconfc.copy_config/4","type":"function"},{"doc":"Creates a subscription for event notifications by sending an RFC 5277 create-subscription RPC to the server. The calling process receives events as messages of type notification() . From RFC 5722, 2.1 Subscribing to Receive Event Notifications: Stream Indicates which stream of event is of interest. If not present, events in the default NETCONF stream are sent. Filter Indicates which subset of all possible events is of interest. The parameter format is the same as that of the filter parameter in the NETCONF protocol operations. If not present, all events not precluded by other parameters are sent. StartTime Used to trigger the replay feature and indicate that the replay is to start at the time specified. If StartTime is not present, this is not a replay subscription. It is not valid to specify start times that are later than the current time. If StartTime is specified earlier than the log can support, the replay begins with the earliest available notification. This parameter is of type dateTime and compliant to RFC 3339. Implementations must support time zones. StopTime Used with the optional replay feature to indicate the newest notifications of interest. If StopTime is not present, the notifications continues until the subscription is terminated. Must be used with and be later than StartTime . Values of StopTime in the future are valid. This parameter is of type dateTime and compliant to RFC 3339. Implementations must support time zones. See RFC 5277 for more details. The requirement that StopTime must only be used with StartTime is not enforced, to allow an invalid request to be sent to the server. Prior to OTP 22.1, this function was documented as having 15 variants in 6 arities. These are still exported for backwards compatibility, but no longer documented. The map-based variants documented above provide the same functionality with simpler arguments. create-subscription is no longer the only RPC with which NETCONF notifications can be ordered: RFC 8639 adds establish-subscription and future RFCs may add other methods. Specify a receiver option at session creation to provide a destination for incoming notifications independently of a call to create_subscription/2,3 , and use send_rpc/2,3 to send establish-subscription and other arbirary RPCs.","ref":"ct_netconfc.html#create_subscription/2","title":"ct_netconfc.create_subscription/2","type":"function"},{"doc":"","ref":"ct_netconfc.html#create_subscription/3","title":"ct_netconfc.create_subscription/3","type":"function"},{"doc":"Deletes configuration data. The running configuration cannot be deleted and :candidate or :startup must be advertised by the server.","ref":"ct_netconfc.html#delete_config/2","title":"ct_netconfc.delete_config/2","type":"function"},{"doc":"","ref":"ct_netconfc.html#delete_config/3","title":"ct_netconfc.delete_config/3","type":"function"},{"doc":"Closes the given SSH connection. If there are open NETCONF sessions on the connection, these will be brutally aborted. To avoid this, close each session with close_session/1,2","ref":"ct_netconfc.html#disconnect/1","title":"ct_netconfc.disconnect/1","type":"function"},{"doc":"Edits configuration data. By default only the running target is available, unless the server includes :candidate or :startup in its list of capabilities. OptParams can be used for specifying optional parameters ( default-operation , test-option , or error-option ) to be added to the edit-config request. The value must be a list containing valid simple XML, for example: [ { &#39;default-operation&#39; , [ &quot;none&quot; ] } , { &#39;error-option&#39; , [ &quot;rollback-on-error&quot; ] } ] If OptParams is not given, the default value [] is used.","ref":"ct_netconfc.html#edit_config/3","title":"ct_netconfc.edit_config/3","type":"function"},{"doc":"","ref":"ct_netconfc.html#edit_config/4","title":"ct_netconfc.edit_config/4","type":"function"},{"doc":"","ref":"ct_netconfc.html#edit_config/5","title":"ct_netconfc.edit_config/5","type":"function"},{"doc":"Gets data. This operation returns both configuration and state data from the server. Filter type xpath can be used only if the server supports :xpath .","ref":"ct_netconfc.html#get/2","title":"ct_netconfc.get/2","type":"function"},{"doc":"","ref":"ct_netconfc.html#get/3","title":"ct_netconfc.get/3","type":"function"},{"doc":"Returns the server capabilities as received in its hello message.","ref":"ct_netconfc.html#get_capabilities/1","title":"ct_netconfc.get_capabilities/1","type":"function"},{"doc":"","ref":"ct_netconfc.html#get_capabilities/2","title":"ct_netconfc.get_capabilities/2","type":"function"},{"doc":"Gets configuration data. To be able to access another source than running , the server must advertise :candidate and/or :startup . Filter type xpath can be used only if the server supports :xpath .","ref":"ct_netconfc.html#get_config/3","title":"ct_netconfc.get_config/3","type":"function"},{"doc":"","ref":"ct_netconfc.html#get_config/4","title":"ct_netconfc.get_config/4","type":"function"},{"doc":"Sends a request to get the specified event streams. Streams is a list of stream names. The following filter is sent to the NETCONF server in a get request: &lt; netconf xmlns = &quot;urn:ietf:params:xml:ns:netmod:notification&quot; &gt; &lt; streams &gt; &lt; stream &gt; &lt; name &gt; StreamName1 &lt; / name &gt; &lt; / stream &gt; &lt; stream &gt; &lt; name &gt; StreamName2 &lt; / name &gt; &lt; / stream &gt; . . . &lt; / streams &gt; &lt; / netconf &gt; If Streams is an empty list, all streams are requested by sending the following filter: &lt; netconf xmlns = &quot;urn:ietf:params:xml:ns:netmod:notification&quot; &gt; &lt; streams / &gt; &lt; / netconf &gt; If more complex filtering is needed, use ct_netconfc:get/2,3 and specify the exact filter according to &quot;XML Schema for Event Notifications&quot; in RFC 5277.","ref":"ct_netconfc.html#get_event_streams/1","title":"ct_netconfc.get_event_streams/1","type":"function"},{"doc":"","ref":"ct_netconfc.html#get_event_streams/2","title":"ct_netconfc.get_event_streams/2","type":"function"},{"doc":"","ref":"ct_netconfc.html#get_event_streams/3","title":"ct_netconfc.get_event_streams/3","type":"function"},{"doc":"Returns the session Id associated with the specified client.","ref":"ct_netconfc.html#get_session_id/1","title":"ct_netconfc.get_session_id/1","type":"function"},{"doc":"","ref":"ct_netconfc.html#get_session_id/2","title":"ct_netconfc.get_session_id/2","type":"function"},{"doc":"Exchanges hello messages with the server. Returns when the server hello has been received or after the specified timeout. Note that capabilities for an outgoing hello can be passed directly to open/2 .","ref":"ct_netconfc.html#hello/1","title":"ct_netconfc.hello/1","type":"function"},{"doc":"","ref":"ct_netconfc.html#hello/2","title":"ct_netconfc.hello/2","type":"function"},{"doc":"","ref":"ct_netconfc.html#hello/3","title":"ct_netconfc.hello/3","type":"function"},{"doc":"Forces termination of the session associated with the supplied session Id. The server side must abort any ongoing operations, release any locks and resources associated with the session, and close any associated connections. Only if the server is in the confirmed commit phase, the configuration is restored to its state before entering the confirmed commit phase. Otherwise, no configuration rollback is performed. If the specified SessionId is equal to the current session Id, an error is returned.","ref":"ct_netconfc.html#kill_session/2","title":"ct_netconfc.kill_session/2","type":"function"},{"doc":"","ref":"ct_netconfc.html#kill_session/3","title":"ct_netconfc.kill_session/3","type":"function"},{"doc":"Locks the configuration target. Which target parameters that can be used depends on if :candidate and/or :startup are supported by the server. If successfull, the configuration system of the device is unavailable to other clients (NETCONF, CORBA, SNMP, and so on). Locks are intended to be short-lived. Operation kill_session/2,3 can be used to force the release of a lock owned by another NETCONF session. How this is achieved by the server side is implementation-specific.","ref":"ct_netconfc.html#lock/2","title":"ct_netconfc.lock/2","type":"function"},{"doc":"","ref":"ct_netconfc.html#lock/3","title":"ct_netconfc.lock/3","type":"function"},{"doc":"Opens a NETCONF session, but does not send hello . As open/1 , but does not send a hello message.","ref":"ct_netconfc.html#only_open/1","title":"ct_netconfc.only_open/1","type":"function"},{"doc":"Opens a named NETCONF session, but does not send hello . As open/2 , but does not send a hello message.","ref":"ct_netconfc.html#only_open/2","title":"ct_netconfc.only_open/2","type":"function"},{"doc":"Opens a NETCONF session and exchanges hello messages. If the server options are specified in a configuration file, or if a named client is needed for logging purposes (see section Logging in this module), use open/2 instead. The opaque handle() reference returned from this function is required as client identifier when calling any other function in this module.","ref":"ct_netconfc.html#open/1","title":"ct_netconfc.open/1","type":"function"},{"doc":"Opens a named NETCONF session and exchanges hello messages. If KeyOrName is a configured server_id() or a target_name() associated with such an Id, then the options for this server are fetched from the configuration file. The options list is added to those of the configuration file. If an option is specified in both lists, the configuration file take precedence. If the server is not specified in a configuration file, use open/1 instead. The opaque handle() reference returned from this function can be used as client identifier when calling any other function in this module. However, if KeyOrName is a target_name() , that is, if the server is named through a call to ct:require/2 or a require statement in the test suite, then this name can be used instead of handle() . See also ct:require/2 .","ref":"ct_netconfc.html#open/2","title":"ct_netconfc.open/2","type":"function"},{"doc":"Sends an XML document to the server. The specified XML document is sent &quot;as is&quot; to the server. This function can be used for sending XML documents that cannot be expressed by other interface functions in this module.","ref":"ct_netconfc.html#send/2","title":"ct_netconfc.send/2","type":"function"},{"doc":"","ref":"ct_netconfc.html#send/3","title":"ct_netconfc.send/3","type":"function"},{"doc":"Sends a NETCONF rpc request to the server. The specified XML document is wrapped in a valid NETCONF rpc request and sent to the server. The message-id and namespace attributes are added to element rpc . This function can be used for sending rpc requests that cannot be expressed by other interface functions in this module.","ref":"ct_netconfc.html#send_rpc/2","title":"ct_netconfc.send_rpc/2","type":"function"},{"doc":"","ref":"ct_netconfc.html#send_rpc/3","title":"ct_netconfc.send_rpc/3","type":"function"},{"doc":"Opens a NETCONF session as a channel on the given SSH connection, and exchanges hello messages with the server. The opaque handle() reference returned from this function can be used as client identifier when calling any other function in this module. However, if KeyOrName is used and it is a target_name() , that is, if the server is named through a call to ct:require/2 or a require statement in the test suite, then this name can be used instead of handle() .","ref":"ct_netconfc.html#session/1","title":"ct_netconfc.session/1","type":"function"},{"doc":"","ref":"ct_netconfc.html#session/2","title":"ct_netconfc.session/2","type":"function"},{"doc":"","ref":"ct_netconfc.html#session/3","title":"ct_netconfc.session/3","type":"function"},{"doc":"Unlocks the configuration target. If the client earlier has acquired a lock through lock/2,3 , this operation releases the associated lock. To access another target than running , the server must support :candidate and/or :startup .","ref":"ct_netconfc.html#unlock/2","title":"ct_netconfc.unlock/2","type":"function"},{"doc":"","ref":"ct_netconfc.html#unlock/3","title":"ct_netconfc.unlock/3","type":"function"},{"doc":"Handle to a NETCONF session, as required by signaling functions.","ref":"ct_netconfc.html#t:client/0","title":"ct_netconfc.client/0","type":"type"},{"doc":"","ref":"ct_netconfc.html#t:error_reason/0","title":"ct_netconfc.error_reason/0","type":"type"},{"doc":"Handle to a connection to a NETCONF server as returned by connect/1,2 , or to a session as returned by session/1-3 , open/1,2 , or only_open/1,2 .","ref":"ct_netconfc.html#t:handle/0","title":"ct_netconfc.handle/0","type":"opaque"},{"doc":"","ref":"ct_netconfc.html#t:host/0","title":"ct_netconfc.host/0","type":"type"},{"doc":"","ref":"ct_netconfc.html#t:netconf_db/0","title":"ct_netconfc.netconf_db/0","type":"type"},{"doc":"Event notification messages sent as a result of calls to create_subscription/2,3 .","ref":"ct_netconfc.html#t:notification/0","title":"ct_netconfc.notification/0","type":"type"},{"doc":"Options host and port specify the server endpoint to which to connect, and are passed directly to ssh:connect/4 , as are arbitrary ssh options. Common options are user , password and user_dir . Option timeout specifies the number of milliseconds to allow for connection establishment and, if the function in question results in an outgoing hello message, reception of the server hello. The timeout applies to connection and hello independently; one timeout for connection establishment, another for hello reception. Option receiver specifies a destination for incoming notification messages; a left operand of the send operator ( ! ). If not specified then a process calling create_subscription/2,3 becomes the receiver, but explicitly setting a receiver makes it possible to receive notifications that are not ordered by calling this function. Multiple receiver options can be specified. Receiver options are ignored by connect/1-3. Option capability specifies the content of a corresponding element in an outgoing hello message, each option specifying the content of a single element. If no base NETCONF capability is configured then the RFC 4741 1.0 capability, &quot;urn:ietf:params:netconf:base:1.0&quot;, is added, otherwise not. In particular, the RFC 6241 1.1 capability must be explicitly configured. NETCONF capabilities can be specified using the shorthand notation defined in RFC 6241, any capability string starting with a colon being prefixed by either &quot;urn:ietf:params:netconf&quot; or &quot;urn:ietf:params:netconf:capability&quot;, as appropriate. Capability options are ignored by connect/1-3 and only_open/1-2, which don't result in an outgoing hello message.","ref":"ct_netconfc.html#t:option/0","title":"ct_netconfc.option/0","type":"type"},{"doc":"Identity of connection or session configuration in a configuration file.","ref":"ct_netconfc.html#t:server_id/0","title":"ct_netconfc.server_id/0","type":"type"},{"doc":"Representation of XML, as described in application xmerl .","ref":"ct_netconfc.html#t:simple_xml/0","title":"ct_netconfc.simple_xml/0","type":"type"},{"doc":"","ref":"ct_netconfc.html#t:stream_data/0","title":"ct_netconfc.stream_data/0","type":"type"},{"doc":"","ref":"ct_netconfc.html#t:stream_name/0","title":"ct_netconfc.stream_name/0","type":"type"},{"doc":"Stream information as returned by get_event_streams/1-3 . See RFC 5277, &quot;XML Schema for Event Notifications&quot;, for detail on the format of the string values.","ref":"ct_netconfc.html#t:streams/0","title":"ct_netconfc.streams/0","type":"type"},{"doc":"","ref":"ct_netconfc.html#t:xml_attribute_tag/0","title":"ct_netconfc.xml_attribute_tag/0","type":"type"},{"doc":"","ref":"ct_netconfc.html#t:xml_attribute_value/0","title":"ct_netconfc.xml_attribute_value/0","type":"type"},{"doc":"","ref":"ct_netconfc.html#t:xml_attributes/0","title":"ct_netconfc.xml_attributes/0","type":"type"},{"doc":"","ref":"ct_netconfc.html#t:xml_content/0","title":"ct_netconfc.xml_content/0","type":"type"},{"doc":"","ref":"ct_netconfc.html#t:xml_tag/0","title":"ct_netconfc.xml_tag/0","type":"type"},{"doc":"","ref":"ct_netconfc.html#t:xpath/0","title":"ct_netconfc.xpath/0","type":"type"},{"doc":"Date and time of a startTime/stopTime element in an RFC 5277 create-subscription request. Of XML primitive type dateTime , which has the (informal) form [ - ] YYYY - MM - DDThh : mm : ss [ . s ] [ Z | ( + | - ) hh : mm ] where T and Z are literal and .s is one or more fractional seconds.","ref":"ct_netconfc.html#t:xs_datetime/0","title":"ct_netconfc.xs_datetime/0","type":"type"},{"doc":"This module helps running property-based tests in the Common Test framework. One (or more) of the property testing tools QuickCheck , PropEr or Triq is assumed to be installed. The idea with this module is to have a Common Test test suite calling a property testing tool with special property test suites as defined by that tool. The tests are collected in the test directory of the application. The test directory has a subdirectory property_test , where everything needed for the property tests are collected. The usual Erlang application directory structure is assumed. A typical Common Test test suite using ct_property_test is organized as follows: - module ( my_prop_test_SUITE ) . - compile ( export_all ) . - include_lib ( &quot;common_test/include/ct.hrl&quot; ) . all ( ) -&gt; [ prop_ftp_case ] . init_per_suite ( Config ) -&gt; ct_property_test : init_per_suite ( Config ) . %%%---- test case prop_ftp_case ( Config ) -&gt; ct_property_test : quickcheck ( ftp_simple_client_server : prop_ftp ( ) , Config ) . and the the property test module (in this example ftp_simple_client_server.erl ) as almost a usual property testing module (More examples are in the User's Guide): - module ( ftp_simple_client_server ) . - export ( [ prop_ftp / 0 . . . ] ) . - include_lib ( &quot;common_test/include/ct_property_test.hrl&quot; ) . prop_ftp ( ) -&gt; ? FORALL ( . . . .","ref":"ct_property_test.html","title":"ct_property_test","type":"module"},{"doc":"Initializes and extends Config for property based testing. This function investigates if support is available for either QuickCheck , PropEr or Triq and compiles the properties with the first tool found. It is supposed to be called in the init_per_suite/1 function in a CommonTest test suite. Which tools to check for, and in which order could be set with the option {prop_tools, list(eqc|proper|triq)} in the CommonTest configuration Config . The default value is [eqc, proper, triq] with eqc being the first one searched for. If no support is found for any tool, this function returns {skip, Explanation} . If support is found, the option {property_test_tool,ToolModule} with the selected tool main module name ( eqc , proper or triq ) is added to the list Config which then is returned. The property tests are assumed to be in a subdirectory named property_test . All found Erlang files in that directory are compiled with one of the macros 'EQC' , 'PROPER' or 'TRIQ' set, depending on which tool that is first found. This could make parts of the Erlang property tests code to be included or excluded with the macro directives -ifdef(Macro). or -ifndef(Macro). . The file(s) in the property_test subdirectory could, or should, include the ct_property_test include file: - include_lib ( &quot;common_test/include/ct_property_test.hrl&quot; ) . This included file will: Include the correct tool's include file Set the macro 'MOD_eqc' to the correct module name for the selected tool. That is, the macro 'MOD_eqc' is set to either eqc , proper or triq .","ref":"ct_property_test.html#init_per_suite/1","title":"ct_property_test.init_per_suite/1","type":"function"},{"doc":"Same as present_result(Module, Cmds, Triple, Config, [])","ref":"ct_property_test.html#present_result/4","title":"ct_property_test.present_result/4","type":"function"},{"doc":"Module = module() Cmds = the list of commands generated by the property testing tool, for example by proper:commands/1 or by proper:parallel_commands/1 Triple = the output from for example proper:run_commands/2 or proper:run_parallel_commands/2 Config = the Common Test Config in test cases. Options = [present_option()] present_option() = {print_fun, fun(Format,Args)}                  | {spec, StatisticsSpec} The print_fun defines which function to do the actual printout. The default is ct:log/2 . The spec defines what statistics are to be printed Result = boolean() Is false if the test failed and is true if the test passed Presents the result of stateful (statem) property testing using the aggregate function in PropEr, QuickCheck or other similar property testing tool. It is assumed to be called inside the property called by quickcheck/2 : . . . RunResult = run_parallel_commands ( ? MODULE , Cmds ) , ct_property_test : present_result ( ? MODULE , Cmds , RunResult , Config ) . . . See the User's Guide for an example of the usage and of the default printout. The StatisticsSpec is a list of the tuples: {Title::string(), CollectFun::fun/1} {Title::string(), FrequencyFun::/0, CollectFun::fun/1} Each tuple will produce one table in the order of their places in the list. Title will be the title of one result table CollectFun is called with one argument: the Cmds . It should return a list of the values to be counted. The following pre-defined functions exist: ct_property_test:cmnd_names/1 returns a list of commands (function calls) generated in the Cmnd sequence, without Module, Arguments and other details. ct_property_test:num_calls/1 returns a list of the length of commands lists ct_property_test:sequential_parallel/1 returns a list with information about sequential and parallel parts from Tool:parallel_commands/1,2 FrequencyFun/0 returns a fun/1 which is supposed to take a list of items as input, and return an iolist wich will be printed as the table. Per default, the number of each item is counted and the percentage is printed for each. The list [a,b,a,a,c] could for example return [ &quot;a 60%\\n&quot; , &quot;b 20%\\n&quot; , &quot;c 20%\\n&quot; ] which will be printed by the print_fun . The default print_fun will print it as: a 60 % b 20 % c 20 % The default StatisticsSpec is: For sequential commands: [ { &quot;Function calls&quot; , fun cmnd_names / 1 } , { &quot;Length of command sequences&quot; , fun print_frequency_ranges / 0 , fun num_calls / 1 } ] For parallel commands: [ { &quot;Distribution sequential/parallel&quot; , fun sequential_parallel / 1 } , { &quot;Function calls&quot; , fun cmnd_names / 1 } , { &quot;Length of command sequences&quot; , fun print_frequency_ranges / 0 , fun num_calls / 1 } ]","ref":"ct_property_test.html#present_result/5","title":"ct_property_test.present_result/5","type":"function"},{"doc":"Calls the selected tool's function for running the Property . It is usually and by historical reasons called quickcheck, and that is why that name is used in this module ( ct_property_test ). The result is returned in a form suitable for Common Test test suites. This function is intended to be called in test cases in test suites.","ref":"ct_property_test.html#quickcheck/2","title":"ct_property_test.quickcheck/2","type":"function"},{"doc":"Common Test specific layer on Erlang/OTP rpc .","ref":"ct_rpc.html","title":"ct_rpc","type":"module"},{"doc":"App = atom() Candidates = [NodeName] NodeName = atom() From a set of candidate nodes determines which of them is running the application App . If none of the candidate nodes is running App , the function makes the test case calling this function to fail. This function is the same as calling app_node(App, Candidates, true) .","ref":"ct_rpc.html#app_node/2","title":"ct_rpc.app_node/2","type":"function"},{"doc":"App = atom() Candidates = [NodeName] NodeName = atom() FailOnBadRPC = true | false Same as ct_rpc:app_node/2 , except that argument FailOnBadRPC determines if the search for a candidate node is to stop if badrpc is received at some point.","ref":"ct_rpc.html#app_node/3","title":"ct_rpc.app_node/3","type":"function"},{"doc":"App = atom() Candidates = [NodeName] NodeName = atom() FailOnBadRPC = true | false Cookie = atom() Same as ct_rpc:app_node/2 , except that argument FailOnBadRPC determines if the search for a candidate node is to stop if badrpc is received at some point. The cookie on the client node is set to Cookie for this rpc operation (used to match the server node cookie).","ref":"ct_rpc.html#app_node/4","title":"ct_rpc.app_node/4","type":"function"},{"doc":"Same as call(Node, Module, Function, Args, infinity) .","ref":"ct_rpc.html#call/4","title":"ct_rpc.call/4","type":"function"},{"doc":"Node = NodeName | {Fun, FunArgs} Fun = function() FunArgs = term() NodeName = atom() Module = atom() Function = atom() Args = [term()] Reason = timeout | term() Evaluates apply(Module, Function, Args) on the node Node . Returns either whatever Function returns, or {badrpc, Reason} if the remote procedure call fails. If Node is {Fun, FunArgs} , applying Fun to FunArgs is to return a node name.","ref":"ct_rpc.html#call/5","title":"ct_rpc.call/5","type":"function"},{"doc":"Node = NodeName | {Fun, FunArgs} Fun = function() FunArgs = term() NodeName = atom() Module = atom() Function = atom() Args = [term()] Reason = timeout | term() Cookie = atom() Evaluates apply(Module, Function, Args) on the node Node . Returns either whatever Function returns, or {badrpc, Reason} if the remote procedure call fails. If Node is {Fun, FunArgs} , applying Fun to FunArgs is to return a node name. The cookie on the client node is set to Cookie for this rpc operation (used to match the server node cookie).","ref":"ct_rpc.html#call/6","title":"ct_rpc.call/6","type":"function"},{"doc":"Node = NodeName | {Fun, FunArgs} Fun = function() FunArgs = term() NodeName = atom() Module = atom() Function = atom() Args = [term()] Reason = timeout | term() Evaluates apply(Module, Function, Args) on the node Node . No response is delivered and the process that makes the call is not suspended until the evaluation is completed as in the case of call/3,4 . If Node is {Fun, FunArgs} , applying Fun to FunArgs is to return a node name.","ref":"ct_rpc.html#cast/4","title":"ct_rpc.cast/4","type":"function"},{"doc":"Node = NodeName | {Fun, FunArgs} Fun = function() FunArgs = term() NodeName = atom() Module = atom() Function = atom() Args = [term()] Reason = timeout | term() Cookie = atom() Evaluates apply(Module, Function, Args) on the node Node . No response is delivered and the process that makes the call is not suspended until the evaluation is completed as in the case of call/3,4 . If Node is {Fun, FunArgs} , applying Fun to FunArgs is to return a node name. The cookie on the client node is set to Cookie for this rpc operation (used to match the server node cookie).","ref":"ct_rpc.html#cast/5","title":"ct_rpc.cast/5","type":"function"},{"doc":"Common Test framework functions for starting and stopping nodes for Large-Scale Testing. This module exports functions used by the Common Test Master to start and stop &quot;slave&quot; nodes. It is the default callback module for the {init, node_start} term in the Test Specification.","ref":"ct_slave.html","title":"ct_slave","type":"module"},{"doc":"Node = atom() Result = {ok, NodeName} | {error, Reason, NodeName} Reason = already_started | started_not_connected | boot_timeout | init_timeout | startup_timeout | not_alive NodeName = atom() Starts an Erlang node with name Node on the local host. See also ct_slave:start/3 .","ref":"ct_slave.html#start/1","title":"ct_slave.start/1","type":"function"},{"doc":"HostOrNode = atom() NodeOrOpts = atom() | list() Result = {ok, NodeName} | {error, Reason, NodeName} Reason = already_started | started_not_connected | boot_timeout | init_timeout | startup_timeout | not_alive NodeName = atom() Starts an Erlang node with default options on a specified host, or on the local host with specified options. That is, the call is interpreted as start(Host, Node) when the second argument is atom-valued and start(Node, Opts) when it is list-valued. See also ct_slave:start/3 .","ref":"ct_slave.html#start/2","title":"ct_slave.start/2","type":"function"},{"doc":"Node = atom() Host = atom() Opts = [OptTuples] OptTuples = {username, Username} | {password, Password} | {boot_timeout, BootTimeout} | {init_timeout, InitTimeout} | {startup_timeout, StartupTimeout} | {startup_functions, StartupFunctions} | {monitor_master, Monitor} | {kill_if_fail, KillIfFail} | {erl_flags, ErlangFlags} | {env, [{EnvVar, Value}]} Username = string() Password = string() BootTimeout = integer() InitTimeout = integer() StartupTimeout = integer() StartupFunctions = [StartupFunctionSpec] StartupFunctionSpec = {Module, Function, Arguments} Module = atom() Function = atom() Arguments = [term] Monitor = bool() KillIfFail = bool() ErlangFlags = string() EnvVar = string() Value = string() Result = {ok, NodeName} | {error, Reason, NodeName} Reason = already_started | started_not_connected | boot_timeout | init_timeout | startup_timeout | not_alive NodeName = atom() Starts an Erlang node with name Node on host Host as specified by the combination of options in Opts . Options Username and Password are used to log on to the remote host Host . Username , if omitted, defaults to the current username. Password is empty by default. A list of functions specified in option Startup are executed after startup of the node. Notice that all used modules are to be present in the code path on Host . The time-outs are applied as follows: BootTimeout The time to start the Erlang node, in seconds. Defaults to 3 seconds. If the node is not pingable within this time, the result {error, boot_timeout, NodeName} is returned. InitTimeout The time to wait for the node until it calls the internal callback function informing master about a successful startup. Defaults to 1 second. In case of a timed out message, the result {error, init_timeout, NodeName} is returned. StartupTimeout The time to wait until the node stops to run StartupFunctions . Defaults to 1 second. If this time-out occurs, the result {error, startup_timeout, NodeName} is returned. Options: monitor_master Specifies if the slave node is to be stopped if the master node stops. Defaults to false . kill_if_fail Specifies if the slave node is to be killed if a time-out occurs during initialization or startup. Defaults to true . Notice that the node can also be still alive it the boot time-out occurred, but it is not killed in this case. erl_flags Specifies which flags are added to the parameters of the executable erl . env Specifies a list of environment variables that will extend the environment. Special return values: {error, already_started, NodeName} if the node with the specified name is already started on a specified host. {error, started_not_connected, NodeName} if the node is started, but not connected to the master node. {error, not_alive, NodeName} if the node on which ct_slave:start/3 is called, is not alive. Notice that NodeName is the name of the current node in this case.","ref":"ct_slave.html#start/3","title":"ct_slave.start/3","type":"function"},{"doc":"Node = atom() Result = {ok, NodeName} | {error, Reason, NodeName} Reason = not_started | not_connected | stop_timeout Stops the running Erlang node with name Node on the local host.","ref":"ct_slave.html#stop/1","title":"ct_slave.stop/1","type":"function"},{"doc":"Host = atom() Node = atom() Result = {ok, NodeName} | {error, Reason, NodeName} Reason = not_started | not_connected | stop_timeout NodeName = atom() Stops the running Erlang node with name Node on host Host .","ref":"ct_slave.html#stop/2","title":"ct_slave.stop/2","type":"function"},{"doc":"Common Test user interface module for the SNMP application. The purpose of this module is to simplify SNMP configuration for the test case writer. Many test cases can use default values for common operations and then no SNMP configuration files need to be supplied. When it is necessary to change particular configuration parameters, a subset of the relevant SNMP configuration files can be passed to ct_snmp by Common Test configuration files. For more specialized configuration parameters, a simple SNMP configuration file can be placed in the test suite data directory. To simplify the test suite, Common Test keeps track of some of the SNMP manager information. This way the test suite does not have to handle as many input parameters as if it had to interface wthe OTP SNMP manager directly. Configurable SNMP Manager and Agent Parameters: Manager configuration: [{start_manager, boolean()} Optional. Default is true . {users, [{user_name(), [call_back_module(), user_data()]}]} Optional. {usm_users, [{usm_user_name(), [usm_config()]}]} Optional. SNMPv3 only. {managed_agents,[{agent_name(), [user_name(), agent_ip(), agent_port(), [agent_config()]]}]} managed_agents is optional. {max_msg_size, integer()} Optional. Default is 484 . {mgr_port, integer()} Optional. Default is 5000 . {engine _id, string()} Optional. Default is &quot;mgrEngine&quot; . Agent configuration: {start_agent, boolean()} Optional. Default is false . {agent_sysname, string()} Optional. Default is &quot;ct_test&quot; . {agent_manager_ip, manager_ip()} Optional. Default is localhost . {agent_vsns, list()} Optional. Default is [v2] . {agent_trap_udp, integer()} Optional. Default is 5000 . {agent_udp, integer()} Optional. Default is 4000 . {agent_notify_type, atom()} Optional. Default is trap . {agent_sec_type, sec_type()} Optional. Default is none . {agent_passwd, string()} Optional. Default is &quot;&quot; . {agent_engine_id, string()} Optional. Default is &quot;agentEngine&quot; . {agent_max_msg_size, string()} Optional. Default is 484 . The following parameters represents the SNMP configuration files context.conf , standard.conf , community.conf , vacm.conf , usm.conf , notify.conf , target_addr.conf , and target_params.conf . Notice that all values in agent.conf can be modified by the parameters listed above. All these configuration files have default values set by the SNMP application. These values can be overridden by suppling a list of valid configuration values or a file located in the test suites data directory, which can produce a list of valid configuration values if you apply function file:consult/1 to the file. {agent_contexts, [term()] | {data_dir_file, rel_path()}} Optional. {agent_community, [term()] | {data_dir_file, rel_path()}} Optional. {agent_sysinfo, [term()] | {data_dir_file, rel_path()}} Optional. {agent_vacm, [term()] | {data_dir_file, rel_path()}} Optional. {agent_usm, [term()] | {data_dir_file, rel_path()}} Optional. {agent_notify_def, [term()] | {data_dir_file, rel_path()}} Optional. {agent_target_address_def, [term()] | {data_dir_file, rel_path()}} Optional. {agent_target_param_def, [term()] | {data_dir_file, rel_path()}} Optional. Parameter MgrAgentConfName in the functions is to be a name you allocate in your test suite using a require statement. Example (where MgrAgentConfName = snmp_mgr_agent ): suite ( ) -&gt; [ { require , snmp_mgr_agent , snmp } ] . or ct : require ( snmp_mgr_agent , snmp ) . Notice that USM users are needed for SNMPv3 configuration and are not to be confused with users. SNMP traps, inform, and report messages are handled by the user callback module. For details, see the SNMP application. It is recommended to use the .hrl files created by the Erlang/OTP MIB compiler to define the Object Identifiers (OIDs). For example, to get the Erlang node name from erlNodeTable in the OTP-MIB: Oid = ? erlNodeEntry ++ [ ? erlNodeName , 1 ] Furthermore, values can be set for SNMP application configuration parameters, config , server , net_if , and so on (for a list of valid parameters and types, see the User's Guide for the SNMP application ). This is done by defining a configuration data variable on the following form: { snmp_app , [ { manager , [ snmp_app_manager_params ( ) ] } , { agent , [ snmp_app_agent_params ( ) ] } ] } . A name for the data must be allocated in the suite using require (see the example above). Pass this name as argument SnmpAppConfName to ct_snmp:start/3 . ct_snmp specifies default values for some SNMP application configuration parameters (such as {verbosity,trace} for parameter config ). This set of defaults is merged with the parameters specified by the user. The user values override ct_snmp defaults.","ref":"ct_snmp.html","title":"ct_snmp","type":"module"},{"doc":"Agent = agent_name() Oids = oids() MgrAgentConfName = atom() SnmpReply = snmpreply() Issues a synchronous SNMP get next request.","ref":"ct_snmp.html#get_next_values/3","title":"ct_snmp.get_next_values/3","type":"function"},{"doc":"Agent = agent_name() Oids = oids() MgrAgentConfName = atom() SnmpReply = snmpreply() Issues a synchronous SNMP get request.","ref":"ct_snmp.html#get_values/3","title":"ct_snmp.get_values/3","type":"function"},{"doc":"Mibs = [MibName] MibName = string() Reason = term() Loads the MIBs into agent snmp_master_agent .","ref":"ct_snmp.html#load_mibs/1","title":"ct_snmp.load_mibs/1","type":"function"},{"doc":"MgrAgentConfName = atom() ManagedAgents = [agent()] Reason = term() Explicitly instructs the manager to handle this agent. Corresponds to making an entry in agents.conf . This function tries to register the specified managed agents, without checking if any of them exist. To change a registered managed agent, the agent must first be unregistered.","ref":"ct_snmp.html#register_agents/2","title":"ct_snmp.register_agents/2","type":"function"},{"doc":"MgrAgentConfName = atom() Users = [user()] Reason = term() Registers the manager entity (=user) responsible for specific agent(s). Corresponds to making an entry in users.conf . This function tries to register the specified users, without checking if any of them exist. To change a registered user, the user must first be unregistered.","ref":"ct_snmp.html#register_users/2","title":"ct_snmp.register_users/2","type":"function"},{"doc":"MgrAgentConfName = atom() UsmUsers = [usm_user()] Reason = term() Explicitly instructs the manager to handle this USM user. Corresponds to making an entry in usm.conf . This function tries to register the specified users, without checking if any of them exist. To change a registered user, the user must first be unregistered.","ref":"ct_snmp.html#register_usm_users/2","title":"ct_snmp.register_usm_users/2","type":"function"},{"doc":"Config = [{Key, Value}] Agent = agent_name() OldVarsAndVals = varsandvals() NewVarsAndVals = varsandvals() Returns a list of all successful set requests performed in the test case in reverse order. The list contains the involved user and agent, the value before set , and the new value. This is intended to simplify the cleanup in function end_per_testcase , that is, the undoing of the set requests and their possible side-effects.","ref":"ct_snmp.html#set_info/1","title":"ct_snmp.set_info/1","type":"function"},{"doc":"Agent = agent_name() Oids = oids() MgrAgentConfName = atom() Config = [{Key, Value}] SnmpReply = snmpreply() Issues a synchronous SNMP set request.","ref":"ct_snmp.html#set_values/4","title":"ct_snmp.set_values/4","type":"function"},{"doc":"Equivalent to ct_snmp:start(Config, MgrAgentConfName, undefined) .","ref":"ct_snmp.html#start/2","title":"ct_snmp.start/2","type":"function"},{"doc":"Config = [{Key, Value}] Key = atom() Value = term() MgrAgentConfName = atom() SnmpConfName = atom() Starts an SNMP manager and/or agent. In the manager case, registrations of users and agents, as specified by the configuration MgrAgentConfName , are performed. When using SNMPv3, called USM users are also registered. Users, usm_users , and managed agents can also be registered later using ct_snmp:register_users/2 , ct_snmp:register_agents/2 , and ct_snmp:register_usm_users/2 . The agent started is called snmp_master_agent . Use ct_snmp:load_mibs/1 to load MIBs into the agent. With SnmpAppConfName SNMP applications can be configured with parameters config , mibs , net_if , and so on. The values are merged with (and possibly override) default values set by ct_snmp .","ref":"ct_snmp.html#start/3","title":"ct_snmp.start/3","type":"function"},{"doc":"Config = [{Key, Value}] Key = atom() Value = term() Stops the SNMP manager and/or agent, and removes all files created.","ref":"ct_snmp.html#stop/1","title":"ct_snmp.stop/1","type":"function"},{"doc":"Mibs = [MibName] MibName = string() Reason = term() Unloads the MIBs from agent snmp_master_agent .","ref":"ct_snmp.html#unload_mibs/1","title":"ct_snmp.unload_mibs/1","type":"function"},{"doc":"MgrAgentConfName = atom() Reason = term() Unregisters all managed agents.","ref":"ct_snmp.html#unregister_agents/1","title":"ct_snmp.unregister_agents/1","type":"function"},{"doc":"MgrAgentConfName = atom() ManagedAgents = [agent_name()] Reason = term() Unregisters the specified managed agents.","ref":"ct_snmp.html#unregister_agents/2","title":"ct_snmp.unregister_agents/2","type":"function"},{"doc":"MgrAgentConfName = atom() Reason = term() Unregisters all users.","ref":"ct_snmp.html#unregister_users/1","title":"ct_snmp.unregister_users/1","type":"function"},{"doc":"MgrAgentConfName = atom() Users = [user_name()] Reason = term() Unregisters the specified users.","ref":"ct_snmp.html#unregister_users/2","title":"ct_snmp.unregister_users/2","type":"function"},{"doc":"MgrAgentConfName = atom() Reason = term() Unregisters all USM users.","ref":"ct_snmp.html#unregister_usm_users/1","title":"ct_snmp.unregister_usm_users/1","type":"function"},{"doc":"MgrAgentConfName = atom() UsmUsers = [usm_user_name()] Reason = term() Unregisters the specified USM users.","ref":"ct_snmp.html#unregister_usm_users/2","title":"ct_snmp.unregister_usm_users/2","type":"function"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:agent_config/0","title":"ct_snmp.agent_config/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:agent_ip/0","title":"ct_snmp.agent_ip/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:agent_name/0","title":"ct_snmp.agent_name/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:agent_port/0","title":"ct_snmp.agent_port/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:call_back_module/0","title":"ct_snmp.call_back_module/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:error_index/0","title":"ct_snmp.error_index/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:error_status/0","title":"ct_snmp.error_status/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:ip/0","title":"ct_snmp.ip/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:manager_ip/0","title":"ct_snmp.manager_ip/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:oid/0","title":"ct_snmp.oid/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:oids/0","title":"ct_snmp.oids/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:rel_path/0","title":"ct_snmp.rel_path/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:sec_type/0","title":"ct_snmp.sec_type/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:snmp_app_agent_params/0","title":"ct_snmp.snmp_app_agent_params/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:snmp_app_manager_params/0","title":"ct_snmp.snmp_app_manager_params/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:snmpreply/0","title":"ct_snmp.snmpreply/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:user_data/0","title":"ct_snmp.user_data/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:user_name/0","title":"ct_snmp.user_name/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:usm_config/0","title":"ct_snmp.usm_config/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:usm_user_name/0","title":"ct_snmp.usm_user_name/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:value_type/0","title":"ct_snmp.value_type/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:var_and_val/0","title":"ct_snmp.var_and_val/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:varbind/0","title":"ct_snmp.varbind/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:varbinds/0","title":"ct_snmp.varbinds/0","type":"type"},{"doc":"These data types are described in the documentation for the SNMP application.","ref":"ct_snmp.html#t:varsandvals/0","title":"ct_snmp.varsandvals/0","type":"type"},{"doc":"SSH/SFTP client module. This module uses application SSH , which provides detailed information about, for example, functions, types, and options. Argument Server in the SFTP functions is only to be used for SFTP sessions that have been started on existing SSH connections (that is, when the original connection type is ssh ). Whenever the connection type is sftp , use the SSH connection reference only. The following options are valid for specifying an SSH/SFTP connection (that is, can be used as configuration elements): [ { ConnType , Addr } , { port , Port } , { user , UserName } { password , Pwd } { user_dir , String } { public_key_alg , PubKeyAlg } { connect_timeout , Timeout } { key_cb , KeyCallbackMod } ] ConnType = ssh | sftp . For other types, see ssh(3) . All time-out parameters in ct_ssh functions are values in milliseconds.","ref":"ct_ssh.html","title":"ct_ssh","type":"module"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#apread/4","title":"ct_ssh.apread/4","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#apread/5","title":"ct_ssh.apread/5","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#apwrite/4","title":"ct_ssh.apwrite/4","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#apwrite/5","title":"ct_ssh.apwrite/5","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#aread/3","title":"ct_ssh.aread/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#aread/4","title":"ct_ssh.aread/4","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#awrite/3","title":"ct_ssh.awrite/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#awrite/4","title":"ct_ssh.awrite/4","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#close/2","title":"ct_ssh.close/2","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#close/3","title":"ct_ssh.close/3","type":"function"},{"doc":"Equivalent to ct_ssh:connect(KeyOrName, host, []) .","ref":"ct_ssh.html#connect/1","title":"ct_ssh.connect/1","type":"function"},{"doc":"Equivalent to ct_ssh:connect(KeyOrName, ConnType, []) .","ref":"ct_ssh.html#connect/2","title":"ct_ssh.connect/2","type":"function"},{"doc":"KeyOrName = Key | Name Key = atom() Name = target_name() ConnType = ssh | sftp | host ExtraOpts = ssh_connect_options() Handle = handle() Reason = term() Opens an SSH or SFTP connection using the information associated with KeyOrName . If Name (an alias name for Key ) is used to identify the connection, this name can be used as connection reference for subsequent calls. Only one open connection at a time associated with Name is possible. If Key is used, the returned handle must be used for subsequent calls (multiple connections can be opened using the configuration data specified by Key ). For information on how to create a new Name , see ct:require/2 . For target_name , see module ct . ConnType always overrides the type specified in the address tuple in the configuration data (and in ExtraOpts ). So it is possible to, for example, open an SFTP connection directly using data originally specifying an SSH connection. Value host means that the connection type specified by the host option (either in the configuration data or in ExtraOpts ) is used. ExtraOpts (optional) are extra SSH options to be added to the configuration data for KeyOrName . The extra options override any existing options with the same key in the configuration data. For details on valid SSH options, see application SSH .","ref":"ct_ssh.html#connect/3","title":"ct_ssh.connect/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#del_dir/2","title":"ct_ssh.del_dir/2","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#del_dir/3","title":"ct_ssh.del_dir/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#delete/2","title":"ct_ssh.delete/2","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#delete/3","title":"ct_ssh.delete/3","type":"function"},{"doc":"SSH = connection() Reason = term() Closes an SSH/SFTP connection.","ref":"ct_ssh.html#disconnect/1","title":"ct_ssh.disconnect/1","type":"function"},{"doc":"Equivalent to ct_ssh:exec(SSH, Command, DefaultTimeout) .","ref":"ct_ssh.html#exec/2","title":"ct_ssh.exec/2","type":"function"},{"doc":"SSH = connection() Command = string() Timeout = integer() Data = list() Reason = term() Requests server to perform Command . A session channel is opened automatically for the request. Data is received from the server as a result of the command.","ref":"ct_ssh.html#exec/3","title":"ct_ssh.exec/3","type":"function"},{"doc":"SSH = connection() ChannelId = integer() Command = string() Timeout = integer() Data = list() Reason = term() Requests server to perform Command . A previously opened session channel is used for the request. Data is received from the server as a result of the command.","ref":"ct_ssh.html#exec/4","title":"ct_ssh.exec/4","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#get_file_info/2","title":"ct_ssh.get_file_info/2","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#get_file_info/3","title":"ct_ssh.get_file_info/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#list_dir/2","title":"ct_ssh.list_dir/2","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#list_dir/3","title":"ct_ssh.list_dir/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#make_dir/2","title":"ct_ssh.make_dir/2","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#make_dir/3","title":"ct_ssh.make_dir/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#make_symlink/3","title":"ct_ssh.make_symlink/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#make_symlink/4","title":"ct_ssh.make_symlink/4","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#open/3","title":"ct_ssh.open/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#open/4","title":"ct_ssh.open/4","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#opendir/2","title":"ct_ssh.opendir/2","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#opendir/3","title":"ct_ssh.opendir/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#position/3","title":"ct_ssh.position/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#position/4","title":"ct_ssh.position/4","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#pread/4","title":"ct_ssh.pread/4","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#pread/5","title":"ct_ssh.pread/5","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#pwrite/4","title":"ct_ssh.pwrite/4","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#pwrite/5","title":"ct_ssh.pwrite/5","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#read/3","title":"ct_ssh.read/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#read/4","title":"ct_ssh.read/4","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#read_file/2","title":"ct_ssh.read_file/2","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#read_file/3","title":"ct_ssh.read_file/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#read_file_info/2","title":"ct_ssh.read_file_info/2","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#read_file_info/3","title":"ct_ssh.read_file_info/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#read_link/2","title":"ct_ssh.read_link/2","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#read_link/3","title":"ct_ssh.read_link/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#read_link_info/2","title":"ct_ssh.read_link_info/2","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#read_link_info/3","title":"ct_ssh.read_link_info/3","type":"function"},{"doc":"Equivalent to ct_ssh:receive_response(SSH, ChannelId, close) .","ref":"ct_ssh.html#receive_response/2","title":"ct_ssh.receive_response/2","type":"function"},{"doc":"Equivalent to ct_ssh:receive_response(SSH, ChannelId, End, DefaultTimeout) .","ref":"ct_ssh.html#receive_response/3","title":"ct_ssh.receive_response/3","type":"function"},{"doc":"SSH = connection() ChannelId = integer() End = Fun | close | timeout Timeout = integer() Data = list() Reason = term() Receives expected data from server on the specified session channel. If End == close , data is returned to the caller when the channel is closed by the server. If a time-out occurs before this happens, the function returns {timeout,Data} (where Data is the data received so far). If End == timeout , a time-out is expected and {ok,Data} is returned both in the case of a time-out and when the channel is closed. If End is a fun, this fun is called with one argument, the data value in a received ssh_cm message (see ssh_connection(3) . The fun is to return either true to end the receiving operation (and have the so far collected data returned) or false to wait for more data from the server. Even if a fun is supplied, the function returns immediately if the server closes the channel).","ref":"ct_ssh.html#receive_response/4","title":"ct_ssh.receive_response/4","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#rename/3","title":"ct_ssh.rename/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#rename/4","title":"ct_ssh.rename/4","type":"function"},{"doc":"Equivalent to ct_ssh:send(SSH, ChannelId, 0, Data, DefaultTimeout) .","ref":"ct_ssh.html#send/3","title":"ct_ssh.send/3","type":"function"},{"doc":"Equivalent to ct_ssh:send(SSH, ChannelId, 0, Data, Timeout) .","ref":"ct_ssh.html#send/4","title":"ct_ssh.send/4","type":"function"},{"doc":"SSH = connection() ChannelId = integer() Type = integer() Data = list() Timeout = integer() Reason = term() Sends data to server on specified session channel.","ref":"ct_ssh.html#send/5","title":"ct_ssh.send/5","type":"function"},{"doc":"Equivalent to ct_ssh:send_and_receive(SSH, ChannelId, Data, close) .","ref":"ct_ssh.html#send_and_receive/3","title":"ct_ssh.send_and_receive/3","type":"function"},{"doc":"Equivalent to ct_ssh;send_and_receive(SSH, ChannelId, 0, Data, End, DefaultTimeout) .","ref":"ct_ssh.html#send_and_receive/4","title":"ct_ssh.send_and_receive/4","type":"function"},{"doc":"Equivalent to ct_ssh:send_and_receive(SSH, ChannelId, 0, Data, End, Timeout) .","ref":"ct_ssh.html#send_and_receive/5","title":"ct_ssh.send_and_receive/5","type":"function"},{"doc":"SSH = connection() ChannelId = integer() Type = integer() Data = list() End = Fun | close | timeout Timeout = integer() Reason = term() Sends data to server on specified session channel and waits to receive the server response. For details on argument End , see ct_ssh:receive_response/4 .","ref":"ct_ssh.html#send_and_receive/6","title":"ct_ssh.send_and_receive/6","type":"function"},{"doc":"SSH = connection() ChannelId = integer() Reason = term() Closes an SSH session channel.","ref":"ct_ssh.html#session_close/2","title":"ct_ssh.session_close/2","type":"function"},{"doc":"Equivalent to ct_ssh:session_open(SSH, DefaultTimeout) .","ref":"ct_ssh.html#session_open/1","title":"ct_ssh.session_open/1","type":"function"},{"doc":"SSH = connection() Timeout = integer() ChannelId = integer() Reason = term() Opens a channel for an SSH session.","ref":"ct_ssh.html#session_open/2","title":"ct_ssh.session_open/2","type":"function"},{"doc":"SSH = connection() Server = pid() Reason = term() Starts an SFTP session on an already existing SSH connection. Server identifies the new session and must be specified whenever SFTP requests are to be sent.","ref":"ct_ssh.html#sftp_connect/1","title":"ct_ssh.sftp_connect/1","type":"function"},{"doc":"Equivalent to ct_ssh:shell(SSH, ChannelId, DefaultTimeout) .","ref":"ct_ssh.html#shell/2","title":"ct_ssh.shell/2","type":"function"},{"doc":"SSH = connection() ChannelId = integer() Timeout = integer() Reason = term() Requests that the user default shell (typically defined in /etc/passwd in Unix systems) is executed at the server end.","ref":"ct_ssh.html#shell/3","title":"ct_ssh.shell/3","type":"function"},{"doc":"Equivalent to ct_ssh:subsystem(SSH, ChannelId, Subsystem, DefaultTimeout) .","ref":"ct_ssh.html#subsystem/3","title":"ct_ssh.subsystem/3","type":"function"},{"doc":"SSH = connection() ChannelId = integer() Subsystem = string() Timeout = integer() Status = success | failure Reason = term() Sends a request to execute a predefined subsystem.","ref":"ct_ssh.html#subsystem/4","title":"ct_ssh.subsystem/4","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#write/3","title":"ct_ssh.write/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#write/4","title":"ct_ssh.write/4","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#write_file/3","title":"ct_ssh.write_file/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#write_file/4","title":"ct_ssh.write_file/4","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#write_file_info/3","title":"ct_ssh.write_file_info/3","type":"function"},{"doc":"SSH = connection() Result = ssh_sftp_return() | {error, Reason} Reason = term() For information and other types, see ssh_sftp(3) .","ref":"ct_ssh.html#write_file_info/4","title":"ct_ssh.write_file_info/4","type":"function"},{"doc":"For target_name , see module ct .","ref":"ct_ssh.html#t:connection/0","title":"ct_ssh.connection/0","type":"type"},{"doc":"Handle for a specific SSH/SFTP connection, see module ct .","ref":"ct_ssh.html#t:handle/0","title":"ct_ssh.handle/0","type":"type"},{"doc":"Return value from an ssh_sftp function.","ref":"ct_ssh.html#t:ssh_sftp_return/0","title":"ct_ssh.ssh_sftp_return/0","type":"type"},{"doc":"Common Test specific layer on top of Telnet client ct_telnet_client.erl . Use this module to set up Telnet connections, send commands, and perform string matching on the result. For information about how to use ct_telnet and configure connections, specifically for UNIX hosts, see the unix_telnet manual page. Default values defined in ct_telnet : Connection timeout (time to wait for connection) = 10 seconds Command timeout (time to wait for a command to return) = 10 seconds Max number of reconnection attempts = 3 Reconnection interval (time to wait in between reconnection attempts) = 5 seconds Keep alive (sends NOP to the server every 8 sec if connection is idle) = true Polling limit (max number of times to poll to get a remaining string terminated) = 0 Polling interval (sleep time between polls) = 1 second The TCP_NODELAY option for the telnet socket is disabled (set to false ) per default These parameters can be modified by the user with the following configuration term: { telnet_settings , [ { connect_timeout , Millisec } , { command_timeout , Millisec } , { reconnection_attempts , N } , { reconnection_interval , Millisec } , { keep_alive , Bool } , { poll_limit , N } , { poll_interval , Millisec } , { tcp_nodelay , Bool } ] } . Millisec = integer(), N = integer() Enter the telnet_settings term in a configuration file included in the test and ct_telnet retrieves the information automatically. keep_alive can be specified per connection, if necessary. For details, see unix_telnet . Logging The default logging behavior of ct_telnet is to print information about performed operations, commands, and their corresponding results to the test case HTML log. The following is not printed to the HTML log: text strings sent from the Telnet server that are not explicitly received by a ct_telnet function, such as expect/3 . However, ct_telnet can be configured to use a special purpose event handler, implemented in ct_conn_log_h , for logging all Telnet traffic. To use this handler, install a Common Test hook named cth_conn_log . Example (using the test suite information function): suite ( ) -&gt; [ { ct_hooks , [ { cth_conn_log , [ { conn_mod ( ) , hook_options ( ) } ] } ] } ] . conn_mod() is the name of the Common Test module implementing the connection protocol, that is, ct_telnet . The cth_conn_log hook performs unformatted logging of Telnet data to a separate text file. All Telnet communication is captured and printed, including any data sent from the server. The link to this text file is located at the top of the test case HTML log. By default, data for all Telnet connections is logged in one common file (named default ), which can get messy, for example, if multiple Telnet sessions are running in parallel. Therefore a separate log file can be created for each connection. To configure this, use hook option hosts and list the names of the servers/connections to be used in the suite. The connections must be named for this to work (see ct_telnet:open/1,2,3,4 ). Hook option log_type can be used to change the cth_conn_log behavior. The default value of this option is raw , which results in the behavior described above. If the value is set to html , all Telnet communication is printed to the test case HTML log instead. All cth_conn_log hook options described can also be specified in a configuration file with configuration variable ct_conn_log . Example: { ct_conn_log , [ { ct_telnet , [ { log_type , raw } , { hosts , [ key_or_name ( ) ] } ] } ] } Hook options specified in a configuration file overwrite any hard-coded hook options in the test suite. Logging Example: The following ct_hooks statement causes printing of Telnet traffic to separate logs for the connections server1 and server2 . Traffic for any other connections is logged in the default Telnet log. suite ( ) -&gt; [ { ct_hooks , [ { cth_conn_log , [ { ct_telnet , [ { hosts , [ server1 , server2 ] } ] } ] } ] } ] . As previously explained, this specification can also be provided by an entry like the following in a configuration file: { ct_conn_log , [ { ct_telnet , [ { hosts , [ server1 , server2 ] } ] } ] } . In this case the ct_hooks statement in the test suite can look as follows: suite ( ) -&gt; [ { ct_hooks , [ { cth_conn_log , [ ] } ] } ] . See Also unix_telnet","ref":"ct_telnet.html","title":"ct_telnet","type":"module"},{"doc":"Connection = connection() Reason = term() Closes the Telnet connection and stops the process managing it. A connection can be associated with a target name and/or a handle. If Connection has no associated target name, it can only be closed with the handle value (see ct_telnet:open/4 ).","ref":"ct_telnet.html#close/1","title":"ct_telnet.close/1","type":"function"},{"doc":"Equivalent to ct_telnet:cmd(Connection, Cmd, []) .","ref":"ct_telnet.html#cmd/2","title":"ct_telnet.cmd/2","type":"function"},{"doc":"Connection = connection() Cmd = string() Opts = [Opt] Opt = {timeout, timeout()} | {newline, boolean() | string()} Data = [string()] Reason = term() Sends a command through Telnet and waits for prompt. By default, this function adds &quot;\\n&quot; to the end of the specified command. If this is not desired, use option {newline,false} . This is necessary, for example, when sending Telnet command sequences prefixed with character Interpret As Command (IAC). Option {newline,string()} can also be used if a different line end than &quot;\\n&quot; is required, for instance {newline,&quot;\\r\\n&quot;} , to add both carriage return and newline characters. Option timeout specifies how long the client must wait for prompt. If the time expires, the function returns {error,timeout} . For information about the default value for the command timeout, see the list of default values in the beginning of this module.","ref":"ct_telnet.html#cmd/3","title":"ct_telnet.cmd/3","type":"function"},{"doc":"Equivalent to ct_telnet:cmdf(Connection, CmdFormat, Args, []) .","ref":"ct_telnet.html#cmdf/3","title":"ct_telnet.cmdf/3","type":"function"},{"doc":"Connection = connection() CmdFormat = string() Args = list() Opts = [Opt] Opt = {timeout, timeout()} | {newline, boolean() | string()} Data = [string()] Reason = term() Sends a Telnet command and waits for prompt (uses a format string and a list of arguments to build the command). For details, see ct_telnet:cmd/3 .","ref":"ct_telnet.html#cmdf/4","title":"ct_telnet.cmdf/4","type":"function"},{"doc":"Equivalent to ct_telnet:expect(Connections, Patterns, []) .","ref":"ct_telnet.html#expect/2","title":"ct_telnet.expect/2","type":"function"},{"doc":"Connection = connection() Patterns = Pattern | [Pattern] Pattern = string() | {Tag, string()} | prompt | {prompt, Prompt} Prompt = string() Tag = term() Opts = [Opt] Opt = {idle_timeout, IdleTimeout} | {total_timeout, TotalTimeout} | repeat | {repeat, N} | sequence | {halt, HaltPatterns} | ignore_prompt | no_prompt_check | wait_for_prompt | {wait_for_prompt, Prompt} IdleTimeout = infinity | integer() TotalTimeout = infinity | integer() N = integer() HaltPatterns = Patterns MatchList = [Match] Match = RxMatch | {Tag, RxMatch} | {prompt, Prompt} RxMatch = [string()] HaltReason = done | Match Reason = timeout | {prompt, Prompt} Gets data from Telnet and waits for the expected pattern. Pattern can be a POSIX regular expression. The function returns when a pattern is successfully matched (at least one, in the case of multiple patterns). RxMatch is a list of matched strings. It looks as follows [FullMatch, SubMatch1, SubMatch2, ...] , where FullMatch is the string matched by the whole regular expression, and SubMatchN is the string that matched subexpression number N . Subexpressions are denoted with '(' ')' in the regular expression. If a Tag is specified, the returned Match also includes the matched Tag . Otherwise, only RxMatch is returned. Options: idle_timeout Indicates that the function must return if the Telnet client is idle (that is, if no data is received) for more than IdleTimeout milliseconds. Default time-out is 10 seconds. total_timeout Sets a time limit for the complete expect operation. After TotalTimeout milliseconds, {error,timeout} is returned. Default is infinity (that is, no time limit). ignore_prompt | no_prompt_check &gt;The function returns when a prompt is received, even if no pattern has yet been matched, and {error,{prompt,Prompt}} is returned. However, this behavior can be modified with option ignore_prompt or option no_prompt_check , which tells expect to return only when a match is found or after a time-out. ignore_prompt ct_telnet ignores any prompt found. This option is useful if data sent by the server can include a pattern matching prompt regexp (as returned by TargedMod:get_prompt_regexp/0 ), but is not to not cause the function to return. no_prompt_check ct_telnet does not search for a prompt at all. This is useful if, for example, Pattern itself matches the prompt. wait_for_prompt Forces ct_telnet to wait until the prompt string is received before returning (even if a pattern has already been matched). This is equal to calling expect(Conn, Patterns++[{prompt,Prompt}], [sequence|Opts]) . Notice that option idle_timeout and total_timeout can abort the operation of waiting for prompt. repeat | repeat, N The pattern(s) must be matched multiple times. If N is specified, the pattern(s) are matched N times, and the function returns HaltReason = done . This option can be interrupted by one or more HaltPatterns . MatchList is always returned, that is, a list of Match instead of only one Match . Also HaltReason is returned. sequence All patterns must be matched in a sequence. A match is not concluded until all patterns are matched. This option can be interrupted by one or more HaltPatterns . MatchList is always returned, that is, a list of Match instead of only one Match . Also HaltReason is returned. Example 1: expect ( Connection , [ { abc , &quot;ABC&quot; } , { xyz , &quot;XYZ&quot; } ] , [ sequence , { halt , [ { nnn , &quot;NNN&quot; } ] } ] ) First this tries to match &quot;ABC&quot; , and then &quot;XYZ&quot; , but if &quot;NNN&quot; appears, the function returns {error,{nnn,[&quot;NNN&quot;]}} . If both &quot;ABC&quot; and &quot;XYZ&quot; are matched, the function returns {ok,[AbcMatch,XyzMatch]} . Example 2: expect ( Connection , [ { abc , &quot;ABC&quot; } , { xyz , &quot;XYZ&quot; } ] , [ { repeat , 2 } , { halt , [ { nnn , &quot;NNN&quot; } ] } ] ) This tries to match &quot;ABC&quot; or &quot;XYZ&quot; twice. If &quot;NNN&quot; appears, the function returns HaltReason = {nnn,[&quot;NNN&quot;]} . Options repeat and sequence can be combined to match a sequence multiple times.","ref":"ct_telnet.html#expect/3","title":"ct_telnet.expect/3","type":"function"},{"doc":"Connection = connection() Data = [string()] Reason = term() Gets all data received by the Telnet client since the last command was sent. Only newline-terminated strings are returned. If the last received string has not yet been terminated, the connection can be polled automatically until the string is complete. The polling feature is controlled by the configuration values poll_limit and poll_interval and is by default disabled. This means that the function immediately returns all complete strings received and saves a remaining non-terminated string for a later get_data call.","ref":"ct_telnet.html#get_data/1","title":"ct_telnet.get_data/1","type":"function"},{"doc":"Equivalent to ct_telnet:open(Name, telnet) .","ref":"ct_telnet.html#open/1","title":"ct_telnet.open/1","type":"function"},{"doc":"Name = target_name() ConnType = connection_type() Handle = handle() Reason = term() Opens a Telnet connection to the specified target host.","ref":"ct_telnet.html#open/2","title":"ct_telnet.open/2","type":"function"},{"doc":"Equivalent to ct_telnet:ct_telnet:open(KeyOrName, ConnType, TargetMod, []) .","ref":"ct_telnet.html#open/3","title":"ct_telnet.open/3","type":"function"},{"doc":"KeyOrName = Key | Name Key = atom() Name = target_name() ConnType = connection_type() TargetMod = atom() Extra = term() Handle = handle() Reason = term() Opens a Telnet connection to the specified target host. The target data must exist in a configuration file. The connection can be associated with Name and/or the returned Handle . To allocate a name for the target, use one of the following alternatives: ct:require/2 in a test case A require statement in the suite information function ( suite/0 ) A require statement in a test case information function If you want the connection to be associated with Handle only (if you, for example, need to open multiple connections to a host), use Key , the configuration variable name, to specify the target. Notice that a connection without an associated target name can only be closed with the Handle value. TargetMod is a module that exports the functions connect(Ip, Port, KeepAlive, Extra) and get_prompt_regexp() for the specified TargetType (for example, unix_telnet ). For target_name() , see module ct . See also ct:require/2 .","ref":"ct_telnet.html#open/4","title":"ct_telnet.open/4","type":"function"},{"doc":"Equivalent to ct_telnet:send(Connection, Cmd, []) .","ref":"ct_telnet.html#send/2","title":"ct_telnet.send/2","type":"function"},{"doc":"Connection = connection() Cmd = string() Opts = [Opt] Opt = {newline, boolean() | string()} Reason = term() Sends a Telnet command and returns immediately. By default, this function adds &quot;\\n&quot; to the end of the specified command. If this is not desired, option {newline,false} can be used. This is necessary, for example, when sending Telnet command sequences prefixed with character Interpret As Command (IAC). Option {newline,string()} can also be used if a different line end than &quot;\\n&quot; is required, for instance {newline,&quot;\\r\\n&quot;} , to add both carriage return and newline characters. The resulting output from the command can be read with ct_telnet:get_data/2 or ct_telnet:expect/2,3 .","ref":"ct_telnet.html#send/3","title":"ct_telnet.send/3","type":"function"},{"doc":"Equivalent to ct_telnet:sendf(Connection, CmdFormat, Args, []) .","ref":"ct_telnet.html#sendf/3","title":"ct_telnet.sendf/3","type":"function"},{"doc":"Connection = connection() CmdFormat = string() Args = list() Opts = [Opt] Opt = {newline, boolean() | string()} Reason = term() Sends a Telnet command and returns immediately (uses a format string and a list of arguments to build the command). For details, see ct_telnet:send/3 .","ref":"ct_telnet.html#sendf/4","title":"ct_telnet.sendf/4","type":"function"},{"doc":"For target_name() , see module ct .","ref":"ct_telnet.html#t:connection/0","title":"ct_telnet.connection/0","type":"type"},{"doc":"","ref":"ct_telnet.html#t:connection_type/0","title":"ct_telnet.connection_type/0","type":"type"},{"doc":"Handle for a specific Telnet connection, see module ct .","ref":"ct_telnet.html#t:handle/0","title":"ct_telnet.handle/0","type":"type"},{"doc":"Regular expression matching all possible prompts for a specific target type. regexp must not have any groups, that is, when matching, re:run/3 (in STDLIB) must return a list with one single element.","ref":"ct_telnet.html#t:prompt_regexp/0","title":"ct_telnet.prompt_regexp/0","type":"type"},{"doc":"Parsing of test specifications for Common Test . This module exports help functions for parsing of test specifications.","ref":"ct_testspec.html","title":"ct_testspec","type":"module"},{"doc":"SpecsIn = [string()] | [[string()]] Specs = [string()] Test = [{Node,Run,Skip}] Node = atom() Run = {Dir,Suites,Cases} Skip = {Dir,Suites,Comment} | {Dir,Suites,Cases,Comment} Dir = string() Suites = atom | [atom()] | all Cases = atom | [atom()] | all Comment = string() Reason = term() Parse the given test specification files and return the tests to run and skip. If SpecsIn=[Spec1,Spec2,...] , separate tests will be created per specification. If SpecsIn=[[Spec1,Spec2,...]] , all specifications will be merge into one test. For each test, a {Specs,Tests} element is returned, where Specs is a list of all included test specifications, and Tests specifies actual tests to run/skip per node.","ref":"ct_testspec.html#get_tests/1","title":"ct_testspec.get_tests/1","type":"function"},{"doc":"Callback module for ct_telnet , for connecting to a Telnet server on a UNIX host. It requires the following entry in the configuration file: { unix , [ { telnet , HostNameOrIpAddress } , { port , PortNum } , % optional { username , UserName } , { password , Password } , { keep_alive , Bool } ] } . % optional To communicate through Telnet to the host specified by HostNameOrIpAddress , use the interface functions in ct_telnet , for example, open(Name) and cmd(Name,Cmd) . Name is the name you allocated to the Unix host in your require statement, for example: suite ( ) -&gt; [ { require , Name , { unix , [ telnet ] } } ] . or ct : require ( Name , { unix , [ telnet ] } ) . The &quot;keep alive&quot; activity (that is, that Common Test sends NOP to the server every 10 seconds if the connection is idle) can be enabled or disabled for one particular connection as described here. It can be disabled for all connections using telnet_settings (see ct_telnet ). The {port,PortNum} tuple is optional and if omitted, default Telnet port 23 is used. Also the keep_alive tuple is optional, and the value defauls to true (enabled). See Also ct , ct_telnet","ref":"unix_telnet.html","title":"unix_telnet","type":"module"},{"doc":"ConnName = target_name() Ip = string() | {integer(), integer(), integer(), integer()} Port = integer() Timeout = integer() KeepAlive = bool() TCPNoDelay = bool() Extra = target_name() | {Username, Password} Username = string() Password = string() Handle = handle() Reason = term() Callback for ct_telnet.erl . Setup Telnet connection to a Unix host. For target_name() , see ct . For handle() , see ct_telnet .","ref":"unix_telnet.html#connect/7","title":"unix_telnet.connect/7","type":"function"},{"doc":"PromptRegexp = prompt_regexp() Callback for ct_telnet.erl . Returns a suitable regexp string matching common prompts for users on Unix hosts. For prompt_regexp() , see ct_telnet .","ref":"unix_telnet.html#get_prompt_regexp/0","title":"unix_telnet.get_prompt_regexp/0","type":"function"}]